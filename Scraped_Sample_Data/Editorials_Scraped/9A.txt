Problem: 9A - Die Roll
Problem Link: https://codeforces.com/problemset/problem/9/A
Editorial Link: https://codeforces.com/blog/entry/283

================================================================================

A. Die Roll        If the maximum of Yakko's and Wakko's points is a, then Dot will win, if she has not less than a points. So the probability of her win is (6 - (a-1)) / 6. Since there are only 6 values for a, you can simply hardcode the answers. B. Running Student        It is simple to calculate the time ti that the Student will need, if he gets off the bus at the i-th stop: ti = bi + si, where bi = xi / vb is the time he will drive on the bus, and  is the time he will need to get from the i-th stop to the University. We need to choose indices with minimal possible ti, and among them - the index with minimal possible si, that is, with maximal bi, that is (since the coordinates of bus stops are already ordered) with maximal i.Note that due to precision issues, you should be careful when you compare ti: the condition ti = tj should be written in the form |ti - tj| < ε for some small ε.C. Hexadecimal's Numbers        Brute force solution, when you try each number from 1 to n, will not fit into the time limit.Note, however, that all good numbers have at most 10 digits, and each of the digits is 0 or 1. That is, there are at most 210 binary strings to check. Each of these strings is a number from 1 to 210 - 1 in binary representation. So the algorithm is the following: for each number from 1 to 210 - 1 write its binary  representation, read it as if it was decimal representation and compare the result to n.D. How many trees?        Denote by tnh the number of binary search trees on n nodes with height equal to h. We will derive a recurrent formula for tnh. For the base case note that t00 = 1 (empty tree), and ti0 = t0i = 0 if i>0.Now take any binary search tree on n nodes with height equal to h. Let m be the number written at its root, 1 <= m <= n. The left subtree is a binary search tree on m-1 nodes, and the right subtree is a binary search tree on n-m nodes. The maximal of their heights must be equal to h-1. Consider 2 subcases:1. The height of the left subtree is equal to h-1. There are tm - 1, h - 1 such trees. The right subtree can have any height from 0 to h-1, so there are  such trees. Since we can choose left and right subtrees independently, we have  variants in this case.2. The height of the left subtree is less than h-1. There are  such trees, and the right subtree must have height exactly h-1, which gives us totally  variants.So the recurrent formula is the following: .All the values tnh can be calculated by dynamic programming. The answer, then, is .E. Interesting graph and Apples        The funny ring consists of n vertices and n edges. If there is another edge except for these n, then the vertices it connects belong to more than one cycle. So, an interesting graph is just a funny ring. A graph is a funny ring if and only if the following conditions hold:A1. The degree of each vertex equals 2.A2. The graph is connected. Now let's figure out when a graph is not yet a funny ring, but can be transformed into a funny ring by adding edges. There are obvious necessary conditions:B1. m < n.B2. There are no cycles.B3. The degree of each vertex is not more than 2. Let's add edges so that these conditions were preserved, and the sequence of edges was lexicographically minimal. So, we add an edge (i,j) such that:1. The degrees of i and j are less than 2. (Otherwise we would break B3).2. i and j belong to different connected components. (Otherwise we would break B2).3. The pair (i,j) is lexicographically minimal. Let's see what we have when we can't add edges anymore. Since there are no cycles, each connected component is a tree, and therefore has at least one vertex with degree less than 2. If there are two connected components, then they could be connected by an edge without breaking B1-B3. So the graph is connected, has no cycles, and the degree of each vertex is not more than 2. This means that the obtained graph is just a walk and we can connect its end points to obtain a funny ring.  To summarize, the algorithm is the following: 1. Check if A1-A2 hold. If yes, output "YES" and 0. 2. Check if B1-B3 hold. If no, output "NO". 3. Output "YES" and n-m.  4. Add edges as described. When the edge (i,j) is added, output "i j". 5. Find the only vertices i and j with degree less than 2 (they can be equal if n=1). Output "i j".