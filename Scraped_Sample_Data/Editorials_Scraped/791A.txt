Problem: 791A - Bear and Big Brother
Problem Link: https://codeforces.com/problemset/problem/791/A
Editorial Link: https://codeforces.com/blog/entry/51068

================================================================================

791A - Bear and Big BrotherThis problem is simple: just multiply a by 3 and b by 2 until a > b. Output the number of operations. You will not need more than 6 iterations.Code: 25627790 771A - Bear and Friendship ConditionThe main observation is that you should print "YES" if the graph is a set of disjoint cliques (in each connected non-clique there is a triple of vertices X,Y,Z that X-Y and Y-Z but not X-Z). To check if each connected component is a clique, you can run dfs and count vertices and edges in the connected component - it's a clique if and only if .Code: 25627860 771B - Bear and Different NamesFirst generate n different names. If the i-th given string is "NO", make names i and i + k - 1 equal. Note that it doesn't affect other groups of k consecutive names.Code: 25627873. 771C - Bear and Tree JumpsIt's a known problem to count the sum of distances for all pairs of vertices. For each edge, we should add to the answer the number of times this edge appears in a path between some two vertices. If sv denotes the size of the subtree of the vertex v (we can first root the tree in 1), we should add sv·(n - sv) to the sum.In this problem, the answer is around , where S is the answer for the known problem described above. But for each path with length L, we should add  to the answer, where f(L, k) says how much we must add to L to get a number divisible by k (f(10, 3) = 2, f(11, 3) = 1, f(12, 3) = 0). We know the sum of  because it's  in total. What remains is to compute the sum of f(L, k). To achieve that, for each remainder modulo k, we want to know the number of paths with length that has this remainder. For example, if k = 3 and there are 200 paths with remainder 1, they all have f(L, k) = 2, so we should add 200·2 to the answer.Let's root the tree in any vertex and do bottom-up dp. For each subtree we compute the k values: for each remainder modulo k how many paths (starting from the root of this subtree) have this remainder. We can merge two subtrees in O(k2), so the total complexity is O(n·k2). See my code for details.Code: 25627885. 771D - Bear and CompanyLetters different than 'V' and 'K' are indistinguishable, so we can treat all of them as the same letter 'X'.We will try to build the final string from left to right Let dp[v][k][x] denote the number of moves needed to move first v letters 'V', first k letters 'K' and first x letters 'X' to the beginning of the string (those letters should become first v + k + x letters of the string). We should also remember the last used letter (to ensure that there is no 'K' just after 'V') so let's extend the state to dp[v][k][x][lastLetter] (or it can be dp[v][k][x][is_the_last_letter_V]).To move from a state, we should consider taking the next 'K' (i.e. the k + 1-th letter 'K' in the initial string), the next 'V' or the next 'X'. Of course, we can't take 'K' if the last used letter was 'V'.The last step is to see how we should add to the score when we add a new letter. It turns out that it isn't enough to just add the difference between indices (where the letter was and where it will be) and the third sample test ("VVKEVKK") showed that. Instead, we should notice that we know which letters are already moved to the beginning (first k letters 'K' and so on) so we know how exactly the string looks like currently.For example, let's consider the string "VVKXXVKVV" and moving from the state v = 4, k = 1, x = 1 by taking a new letter 'K'. We know that first 4 letters 'V', 1 letter 'K' and 1 letter 'X' are already moved to the beginning. To move the next letter 'K' (underlined in blue on the drawing below) to the left, we must swap it with all not-used letters that were initially on the left from this 'K'. Counting them in linear time gives the total complexity O(n4) but you can also think a bit and get O(n3) - it's quite easy but it wasn't required to get AC. On the drawing below, used letters are crossed out. There is only 1 not-crossed-out letter on the left from 'K' so we should increase the score by 1 (because we need 1 swap to move this 'K' to the x + k + v + 1-th position).  Code: 25627898. 771E - Bear and Rectangle StripsThere are three types of rectangles: in the top row, in the bottom row, and in both rows (with height 2). For each type, and for each starting index i we can quite easily find the first possible ending index - it's the first index on the right with the same prefix sum of numbers (it means that the difference of prefix sums is 0). We can iterate from right to left for each of three types, use store prefix sums in the set and for each type and each starting index we can remember the first possible ending index (or we will know that there is no such index). The complexity of this part is .Now, the naive square solution would be to create an array dp[n][n] and compute dp[i][j] as the maximum possible score, if we are allowed to use only first i cells in the first row and first j cells in the second row. Thanks to the precomputing above, we can move from a state in O(1), considering the following options:  increase i by 1 (without taking any rectangle)  increase j by 1  take the first possible rectangle in the first row (check what is the first possible ending index of a rectangle in the first row, starting at index i + 1)  take the first possible rectangle in the second row  if i = j, also consider taking first possible rectangle of height 2 (in both rows) Now let's improve this part to O(n). Let Ci denote the best score if we were allowed to use only first i cells in each row (Ci = dp[i][i]). It turns out that the following values for each i are enough to solve the problem:  Ci  If we were allowed to use only first i cells in the first row, how far we must go in the second row, in order to get the score Ci + 1. In other words, what is the smallest j such that dp[i][j] = Ci + 1  Similarly, the smallest j such that dp[j][i] = Ci + 1 Take a look at the drawings below. The value Ci is the maximum possible score for light-blue cells on the left drawing. The right drawing shows the third of situation listed above - we want to know what prefix of cells in the first row is needed, if we want to get the score Ci + 1.  To see that it works, we must prove that we don't have to care how far we must go in one row to get the score Ci + 2 or higher. The crucial observation that getting score at least Ci + 2 means that we took at least two rectangles that are at least partially on the right from index i (i.e. each of them contains at least one cell with index greater than i) - see the drawing below. So, instead of considering this situation now, we can first take some rectangle in the second row (or skip a few cells) because we can take that last rectangle in the first row later. In other words, when we are in the state dp[i][j] where i < j, it's enough to consider taking a rectangle in the first row or just increasing i without taking anything.  Code: 25627911. 771F - Bear and Isomorphic PointsIf p1 is collinear with some two other points, we should print 0. Now let's assume that no two points are collinear with p1.The naive solution is to iterate over O(n2) pairs of points. For each pair of points there is a line going through them both, and we know that the new placement of p1 should be on the same side (e.g. on the left) from the line - otherwise the sign of the cross product will change. In other words, the new placement must belong to some halfplane. What we're looking for is the intersection of those O(n2) halfplanes, what can be found in . We should also remember that the new placement must be inside the big square, what can be achieved by adding four halfplanes (each for one side of the square).It turns out that it's quite easy to improve the complexity of the naive solution. Let's first sort other n - 1 points by angle. One way to approach the problem is to think "we are interested in those new placements that don't affect the sorting of those n - 1 points" - this is almost enough to get the intended solution. If sorted (in the clockwise order) points are p2, p3, ..., pn, taking into account a halfplane that goes through points pi and pi + 1 ensures that pi + 1 is further in the clockwise order than pi (i.e. it is more "on the right" if we look from p1). Usually, pi + 2 is also more "on the right" than pi, and so on, till some point pj that is no longer "on the left" from pi (if we look from p1). For each i, let's find the first j that pj is "on the left" from pi (move indices i and j with two pointers) and then consider a halfplane that goes through pi and pj. To sum up, we consider n halfplanes determined by pairs (pi, pi + 1) and n halfplanes determined by pairs (pi, pj) where pi and pj are almost opposite to each other, with respect to p1. It turns out that this is already a working solution - no other halfplanes are needed. The answer is the intersection of found O(n) halfplanes. Let's prove the correctness.Let's assume that one of halfplanes (going through some pa and pb) wasn't considered, while it should be because it would affect the answer. And let's say that pb is more "on the right" than pa, and a < b. If |a - b| = 1, we surely considered that halfplane. Otherwise, if there is some other point with index  such that it is on the proper side of the line (pa, pb), i.e. on the same side as p1, halfplanes determined by pairs (a, m) and (m, b) completely cover that (a, b) halfplane. Here we must use induction: if each halfplane determined by a pair (a, b) for smaller value of b - a is either taken or covered by some other taken halfplanes, then also halfplanes with greater differences b - a will be considered (remember that we assumed that there is some other points with index  such that ...).The case analysed above is shown on the drawing below. Let R denote the red point. If halfplanes (pa, R) and (R, pb) are considered (or from induction they are covered by something else), we don't need considering (pa, pb).  What remains is the case when a + 1 ≠ b and each point with index in [a + 1, b - 1] is on the line (pa, pb) or on the wrong side (not the same as p1). It quite easily implies that our line is already covered everywhere except for the segment (pa, pb), see the drawing:  Now we should take a look at points pb + 1, pb + 2, .... If one of them pk is on the wrong side of the line (pa, pb) (i.e. on the side different than p1), the halfplane (pk - 1, pk) covers our segment (pa, pb) and we are done. Otherwise, all those points are on the proper side (the same as p1). Eventually one of them will be the last one that is "on the right" from pa and let's remember that we consider halfplanes determined by such pairs (earlier denoted as pi and pj). Since that point is on the proper side of the line (pa, pb), the segment is covered:  Code: 25627924.