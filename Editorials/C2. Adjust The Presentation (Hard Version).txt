TutorialTutorial is loading...

TutorialTutorial is loading...

TutorialTutorial is loading...

TutorialTutorial is loading...

TutorialTutorial is loading...

Greedy solutionConstruct the subset of leaves one by one. Keep choosing the leaf which will have the least contribution. To simulate this quickly, let h(i) be the highest ancestor of leaf i, such that leaf i is the leaf that minimizes the sum of values on the path from i to h(i). Initially, you must take the leaf i which has h(i) = the root of the tree. Sort the rest of the leaves in increasing order of the sum of values on the path from i to h(i), and add them to the subset in that order.

DP solutionLet dp[i][j] be the minimum sum of values of nodes when choosing j leaves in the subtree of i. If j=0, then dp[i][j]=0. Otherwise, dp[i][j]=val[i]+min(dp[left][x]+dp[right][j−x]), where 0≤x≤j, and left and right are the children of i in the KRT. To optimize this DP for E3, notice that the values of dp[i] are convex. dp[i][j]−dp[i][j−1]≤dp[i][j+1]−dp[i][j] holds. Doing the transformation c[j]=min(a[x]+b[j−x]) when arrays a and b are convex, can be done by merging the slopes of arrays a and b. (See this errorgorn blog, (max, +) convolution part).You can maintain the slopes of the dp in a sorted multiset, and merge the multisets of the left and right children into dp[node], and then insert val[node] into dp[node].

