README: Notice about solutionsAll editorial codes contain solutions wrapped in classes. I'll only paste the important part (namespace solution in C++, class Solution in Python 3) as plaintext in the solution code section (along with the corresponding AC submission link). You might want to see the code template here. C++ template#include <bits/stdc++.h>
using namespace std;

namespace solution {
    bool hasMultipleTests = true;

    void preprocess() {
        // something
    }

    void input(int testcase) {
        // something
    }

    void solve(int testcase) {
        // something
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    solution::preprocess();

    int t = 1;
    if (solution::hasMultipleTests) cin >> t;

    for (int testcase=1; testcase<=t; testcase++) {
        solution::input(testcase);
        solution::solve(testcase);
    }

    return 0;
} Python 3 templateimport sys
input = sys.stdin.readline


class Solution:
    hasMultipleTests = True

    @classmethod
    def preprocess(cls):
        pass

    @classmethod
    def input(cls, testcase):
        pass

    @classmethod
    def solve(cls, testcase):
        pass

# end Solution


if __name__ == '__main__':
    Solution.preprocess()

    t = int(input()) if Solution.hasMultipleTests else 1
    for testcase in range(1, t+1):
        Solution.input(testcase)
        Solution.solve(testcase)Also, per my own custom ever since 2019, solution codes will only be published after system testing, to ensure all codes used here guarantee AC. Thank you for your patience.

C++ template#include <bits/stdc++.h>
using namespace std;

namespace solution {
    bool hasMultipleTests = true;

    void preprocess() {
        // something
    }

    void input(int testcase) {
        // something
    }

    void solve(int testcase) {
        // something
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    solution::preprocess();

    int t = 1;
    if (solution::hasMultipleTests) cin >> t;

    for (int testcase=1; testcase<=t; testcase++) {
        solution::input(testcase);
        solution::solve(testcase);
    }

    return 0;
}

Python 3 templateimport sys
input = sys.stdin.readline


class Solution:
    hasMultipleTests = True

    @classmethod
    def preprocess(cls):
        pass

    @classmethod
    def input(cls, testcase):
        pass

    @classmethod
    def solve(cls, testcase):
        pass

# end Solution


if __name__ == '__main__':
    Solution.preprocess()

    t = int(input()) if Solution.hasMultipleTests else 1
    for testcase in range(1, t+1):
        Solution.input(testcase)
        Solution.solve(testcase)

Hint #1In which cases would a light be on?

Hint #2AImagine that you have xx white socks and yy black socks. What would you do to make the maximum pairs of matched socks?

Hint #2BImagine that you have xx white socks and yy black socks. What would you do to make the maximum pairs of unmatched socks?

Tutorial2032A - CircuitObserve that an even number of switch toggles on the same light will not change that light's status. In other words, a light is on if and only if exactly one of the two switches connecting to it is on.Let's denote cnt0 and cnt1 as the number of off switches and on switches in the circuit. We see that   The maximum number of on lights is min(cnt0,cnt1): we can't achieve more than this amount since any on light decreases both cnt0 and cnt1 by 1, and we can achieve this amount by matching min(cnt0,cnt1) pairs of one off switch and one on switch, and the rest can be matched arbitrarily.  The minimum number of on lights is cnt0mod2. Since cnt0+cnt1=2n, they have the same parity. Then, we can easily see that when both cnt0 and cnt1 are even, we can match n pairs of the same type of switches, so there are no on lights in this case. When both cnt0 and cnt1 are odd, we must match one on switch with one off switch to make cnt0 and cnt1 even, so there is one on light in this case. The calculation of cnt0 and cnt1 can be easily done by a simple iteration over the switches.Time complexity: O(n).

Solution (C++)Submission link: 289291089 Plaintextnamespace solution {
    bool hasMultipleTests = true;

    int n;
    vector<int> a;

    void preprocess() {

    }

    void input(int testcase) {
        cin >> n;
        a.clear();
        a.resize(n * 2);
        for (auto &z: a) cin >> z;
    }

    void solve(int testcase) {
        int cnt0 = 0;

        for (auto &z: a) {
            cnt0 += z;
        }

        cout << (cnt0 & 1) << " " << min(cnt0, n * 2 - cnt0) << endl;
    }
}

Plaintextnamespace solution {
    bool hasMultipleTests = true;

    int n;
    vector<int> a;

    void preprocess() {

    }

    void input(int testcase) {
        cin >> n;
        a.clear();
        a.resize(n * 2);
        for (auto &z: a) cin >> z;
    }

    void solve(int testcase) {
        int cnt0 = 0;

        for (auto &z: a) {
            cnt0 += z;
        }

        cout << (cnt0 & 1) << " " << min(cnt0, n * 2 - cnt0) << endl;
    }
}

Solution (Python 3)Submission link: 289291082 Plaintextclass Solution:
    hasMultipleTests = True

    n: int = None
    a: list = None

    @classmethod
    def preprocess(cls):
        pass

    @classmethod
    def input(cls, testcase):
        cls.n = int(input())
        cls.a = list(map(int, input().split()))

    @classmethod
    def solve(cls, testcase):
        cnt0 = sum(cls.a)
        
        print(cnt0 & 1, min(cnt0, cls.n*2 - cnt0))

# end Solution

Plaintextclass Solution:
    hasMultipleTests = True

    n: int = None
    a: list = None

    @classmethod
    def preprocess(cls):
        pass

    @classmethod
    def input(cls, testcase):
        cls.n = int(input())
        cls.a = list(map(int, input().split()))

    @classmethod
    def solve(cls, testcase):
        cnt0 = sum(cls.a)
        
        print(cnt0 & 1, min(cnt0, cls.n*2 - cnt0))

# end Solution

Feedback Didn't attempt 




2





 Great problem 

    


23



 Nice problem 

    


55



 OK problem 

    


114



 Bad problem 

    


5



 Terrible problem 

    


12



 

Hint #1There is always exactly one solution for n=1n=1. For n≥3n≥3, for which kk should there be no solution at all?

Hint #2ATry to find a solution with k=2k=2 and k=4k=4, assuming nn allows at least one solution to exist. Can you find a pattern and generalize it for all even kk?

Hint #2BTry to find a solution with k=3k=3 and k=5k=5, assuming nn allows at least one solution to exist. Can you find a pattern and generalize it for all odd kk?

Tutorial2032B - MediansFor n=1 (and k=1 as well), the obvious answer would be not partitioning anything, i.e., partition with 1 subarray being itself.For n>1, we see that k=1 and k=n cannot yield a satisfactory construction. Proof is as follows:  m=1 will yield ans=⌊n+12⌋, which will never be equal to 1 or n when n≥3.  If m>1, considering the case of k=1, we see that median(bi)=1 iff i≥2, and since the original array a is an increasingly-sorted permutation, we can conclude that median(b1)<1. This is not possible.  Similarly, k=n also doesn't work with m>1, as it'll require median(bm)>n. Apart from these cases, any other k can yield an answer with m=3  — a prefix subarray b1, a middle subarray b2 containing k (b2 will be centered at k, of course), and a suffix subarray b3. This way, the answer will be median(b2)=k.The length of b2 can be either 1 or 3, depending on the parity of k (so that b1 and b3 could have odd lengths). In detail: b2 will have length 1 (i.e., [k]) if k is an even integer, and length 3 (i.e., [k−1,k,k+1]) if k is an odd integer.Time complexity: O(1).

Solution (C++)Submission link: 289291698 Plaintextnamespace solution {
    bool hasMultipleTests = true;

    int n, k;

    void preprocess() {

    }

    void input(int testcase) {
        cin >> n >> k;
    }

    void solve(int testcase) {
        if (n == 1) {cout << "1\n1\n"; return;}

        if (k == 1 || k == n) {cout << "-1\n"; return;}

        int p2 = k - k % 2;
        int p3 = k + 1 + k % 2;
        cout << "3\n1 " << p2 << " " << p3 << endl;
    }
}

Plaintextnamespace solution {
    bool hasMultipleTests = true;

    int n, k;

    void preprocess() {

    }

    void input(int testcase) {
        cin >> n >> k;
    }

    void solve(int testcase) {
        if (n == 1) {cout << "1\n1\n"; return;}

        if (k == 1 || k == n) {cout << "-1\n"; return;}

        int p2 = k - k % 2;
        int p3 = k + 1 + k % 2;
        cout << "3\n1 " << p2 << " " << p3 << endl;
    }
}

Solution (Python 3)Submission link: 289291693 Plaintextclass Solution:
    hasMultipleTests = True

    n: int = None
    k: int = None

    @classmethod
    def preprocess(cls):
        pass

    @classmethod
    def input(cls, testcase):
        cls.n, cls.k = map(int, input().split())

    @classmethod
    def solve(cls, testcase):
        if cls.n == 1: return(print('1\n1'))

        if cls.k in {1, cls.n}: return(print(-1))

        p2, p3 = cls.k - cls.k % 2, cls.k + 1 + cls.k % 2
        print(f'3\n1 {p2} {p3}')

# end Solution

Plaintextclass Solution:
    hasMultipleTests = True

    n: int = None
    k: int = None

    @classmethod
    def preprocess(cls):
        pass

    @classmethod
    def input(cls, testcase):
        cls.n, cls.k = map(int, input().split())

    @classmethod
    def solve(cls, testcase):
        if cls.n == 1: return(print('1\n1'))

        if cls.k in {1, cls.n}: return(print(-1))

        p2, p3 = cls.k - cls.k % 2, cls.k + 1 + cls.k % 2
        print(f'3\n1 {p2} {p3}')

# end Solution

Feedback Didn't attempt 

    


0



 Great problem 

    


33



 Nice problem 

    


134



 OK problem 

    


19



 Bad problem 

    


7



 Terrible problem 

    


64



 

Hint #1Without loss of generality, you can rewrite the triangle inequality into a much more compacted form if the side lengths are properly ordered.

Hint #2AGiven four integers a≤b≤c≤da≤b≤c≤d, if (a,b,d)(a,b,d) are side lengths of a non-degenerate triangle, so does (a,b,c)(a,b,c).

Hint #2BGiven four integers a≤b≤c≤da≤b≤c≤d, if (a,b,d)(a,b,d) are side lengths of a non-degenerate triangle, so does (a,c,d)(a,c,d).

Hint #2CGiven four integers a≤b≤c≤da≤b≤c≤d, if (a,b,d)(a,b,d) are side lengths of a non-degenerate triangle, so does (b,c,d)(b,c,d).

Hint #3To make a sorted array [b1,b2,…,bm] (m≥3)[b1,b2,…,bm] (m≥3) satisfy the problem, we must ensure that b1+b2>bmb1+b2>bm.

Hint #4Fix the result array to have two minimas and one maxima at respectively axax, ayay and azaz. How many operations are required to do so?

Hint #5Is there a fast and optimal way to try all possible (ax,ay,az)(ax,ay,az) triplets?

Tutorial2032C - TrinityWithout loss of generality, we assume that every array mentioned below is sorted in non-descending order.An array bb of kk elements (k≥3k≥3) will satisfy the problem's criteria iff b1+b2>bkb1+b2>bk. The proof is that b1+b2b1+b2 is the minimum sum possible of any pair of distinct elements of array bb, and if it is larger than the largest element of bb, every pair of distinct elements of bb will be larger than any element of bb on its own.The upper bound for our answer is n−2n−2. This can be done as follows: we will turn every value from a2a2 to an−1an−1 to anan — this way, we only have two types of triangles: (a1,an,an)(a1,an,an) and (an,an,an)(an,an,an). Since a1≥1>0a1≥1>0, we have a1+an>ana1+an>an, which means the former type of triangles is non-degenerate. The latter is also trivially one, as it is a regular/equilateral triangle.Otherwise, we'll need a pair of indices (i,j)(i,j) (1≤i≤n−21≤i≤n−2, i+2≤j≤ni+2≤j≤n), so that in the final array after applying operations to aa, aiai and ai+1ai+1 will be respectively the smallest and second smallest element, and ajaj will be the largest element. Such indices must satisfy ai+ai+1>ajai+ai+1>aj.Let's consider a pair (i,j)(i,j) that satisfies the above condition, then we need to turn elements outside of it (i.e. those before ii or after jj) into some elements within the range [ai+1,aj][ai+1,aj], and indeed we can change them into ai+1ai+1 — this way, we have everything in place while keeping the relative rankings of aiai, ai+1ai+1 and ajaj as what they are initially. Therefore, for such a pair, the number of operations needed is n−(j−i+1)n−(j−i+1). This means that for every ii, we need to find the largest j>ij>i that satisfies the condition, which can easily be done using two pointers.Sorting complexity: O(nlogn)O(nlog⁡n).Two-pointer complexity: O(n)O(n).

Solution (C++)Submission link: 289292343 Plaintextnamespace solution {
    bool hasMultipleTests = true;

    int n;
    vector<int> a;

    void preprocess() {

    }

    void input(int testcase) {
        cin >> n;
        a.clear();
        a.resize(n);
        for (auto &z: a) cin >> z;
    }

    void solve(int testcase) {
        sort(a.begin(), a.end());

        int l = 0, ans = n - 2;
        for (int r = 2; r < n; r++) {
            while (r - l >= 2 && a[l] + a[l+1] <= a[r]) l++;
            ans = min(ans, n - (r - l + 1));
        }

        cout << ans << endl;
    }
}

Plaintextnamespace solution {
    bool hasMultipleTests = true;

    int n;
    vector<int> a;

    void preprocess() {

    }

    void input(int testcase) {
        cin >> n;
        a.clear();
        a.resize(n);
        for (auto &z: a) cin >> z;
    }

    void solve(int testcase) {
        sort(a.begin(), a.end());

        int l = 0, ans = n - 2;
        for (int r = 2; r < n; r++) {
            while (r - l >= 2 && a[l] + a[l+1] <= a[r]) l++;
            ans = min(ans, n - (r - l + 1));
        }

        cout << ans << endl;
    }
}

Solution (Python 3)Submission link: 289292338 Plaintextclass Solution:
    hasMultipleTests = True

    n: int = None
    a: list = None

    @classmethod
    def preprocess(cls):
        pass

    @classmethod
    def input(cls, testcase):
        cls.n = int(input())
        cls.a = list(map(int, input().split()))

    @classmethod
    def solve(cls, testcase):
        cls.a.sort()
        l, r, ans = 0, 2, cls.n - 2
        while r < cls.n:
            while r - l >= 2 and cls.a[l] + cls.a[l+1] <= cls.a[r]: l += 1
            ans = min(ans, cls.n - (r - l + 1))
            r += 1
        print(ans)

# end Solution

Plaintextclass Solution:
    hasMultipleTests = True

    n: int = None
    a: list = None

    @classmethod
    def preprocess(cls):
        pass

    @classmethod
    def input(cls, testcase):
        cls.n = int(input())
        cls.a = list(map(int, input().split()))

    @classmethod
    def solve(cls, testcase):
        cls.a.sort()
        l, r, ans = 0, 2, cls.n - 2
        while r < cls.n:
            while r - l >= 2 and cls.a[l] + cls.a[l+1] <= cls.a[r]: l += 1
            ans = min(ans, cls.n - (r - l + 1))
            r += 1
        print(ans)

# end Solution

Feedback Didn't attempt 

    


15



 Great problem 

    


78



 Nice problem 

    


205



 OK problem 

    


43



 Bad problem 

    


13



 Terrible problem 

    


46



 

Hint #1There are many specific constraints on the system tree.First, notice that 1≤x≤y≤n−11≤x≤y≤n−1 if and only if px≤pypx≤py. Draw a few trees with this constraint and start pointing your finger on the nodes from 00 to n−1n−1. Notice the pattern your finger is making.

Hint #2Incorporate hint #1 with the fact that the "tentacles" of the Genokraken are just paths. Try to draw more detailed conclusion about that pattern.

Hint #3AIs there a way to know how many tentacles there are?

Hint #3BWhat use could we make of the fact that node 11 has exactly two adjacent nodes?

Hint #4The query limit is very small. Is there a way to query that the information obtained in each query should (at least partially) determine a node?

Hint #5For each "tentacle", can we know when its path has ended? How many queries should it take?

Tutorial2032D - Genokraken  For simplicity, we'll use the term "tentacle" to call each path tree in the forest made by cutting off node 0. We also notice that in each tentacle, two nodes will never have the same distance from root node 0.The condition of px≤py iff x≤y leads to a crucial observation of the system: it is indexed in accordance to a BFS order of the tree. Hence, we now have two goals:  Determine m — the number of tentacles.  From node m+1 to n−1, assign every node to their respective tentacles. Due to the BFS order, at the moment of assignment, the previous tip of the tentacle is the parent of the current node, and the current node becomes the new tip of the tentacle. For the first objective, we see that node 1 is guaranteed to be connected with nodes 0 and m+1. Furthermore, m+1 is the first non-zero node where the path between it and 1 does not cross 0. Therefore, you can keep querying (1,j) for increasing j until you find a 0 to get m.For the second objective, we need to find the tentacle that each node i (m+2≤i≤n−1) belongs to; in other words, find the node 1≤i≤m so that query (i,j) yields a 0. Denote t(j) as the tentacle associated with node j, then note that:   If j−1 and j share the same distance from 0, then obviously t(j−1)<t(j), i.e., t(j) will be a tentacle at the forward direction from t(j−1) in the tentacle list.  If j−1 and j don't share the same distance from 0, then t(j) can be any tentacle in the list. So we can approach this objective like this: denote next(t(j−1)) as the next tentacle in the list after t(j−1) (or 1 if t(j−1) was at the end of the list), starting from i=t(j−1), we'll keep re-assigning i=next(i) until query (i,j) yields a 0.From hindsight, it looks like we'll need O(n2) query count order to finish this part, but there is another crucial observation: due to the nodes being indexed in BFS order, if any tentacle yields a 1 during probing, that tentacle will never be extended again — proof for this is pretty intuitive but a bit lengthy to express in words, so we'll leave it as an exercise for the reader — thus if you reach an i that has already been deactivated before, you ignore it and call next again, which wouldn't count towards the queries as it is your internal processing.Let's count the number of queries we used. Let m≤n−2 be the number of tentacles, then  If m=n−2, the second objective wouldn't be needed, so we end up with n−2≤2n−6 queries in total (as n≤4).  If m≤n−3, note that each time we process a query, either a node is appended to a tentacle, or a tentacle is removed. Since at most m−1 tentacles can be removed and there are n−m−2 nodes to be processed, the second phase uses at most n−3 queries, so in total we use n+m−3≤2n−6 queries. To process the list of tentacles, there are a few options:  Naively mark the tentacles as active/inactive to know when to stop by for queries and when to skip. Time complexity will be O(n2), and though it can still pass (in fact one such solution from the author passed nicely), it is not recommended.  Maintain the list of tentacles in a set, if a node is known to be inactive, remove it. Time complexity will be O(nlogn).  Maintain the list of tentacles in a similar manner as above, but using a doubly linked list this time. Time complexity will be O(n). 

Solution (C++)Submission link: 289292866 Plaintextnamespace datastruct {
    // A doubly-linked list that only supports modify and (pseudo) deletion at pointer
    class DeleteOnly_DLL {
    public:
        vector<int> values;
        vector<int> prev;
        vector<int> next;
        int pointer;
        
        DeleteOnly_DLL(int size) {
            values.resize(size);
            prev.resize(size);
            next.resize(size);
            
            for (int i = 0; i < size; i++) {
                prev[i] = (i + size - 1) % size;
                next[i] = (i +        1) % size;
            }
            
            pointer = 0;
        }
        
        int current() {
            return values[pointer];
        }
        
        // Set value at pointer and move pointer to next
        void set_and_move(int val) {
            values[pointer] = val;
            pointer = next[pointer];
        }
        
        // "Delete" node and move pointer to next
        void erase() {
            if (prev[pointer] != -1) {
                next[prev[pointer]] = next[pointer];
            }
            if (next[pointer] != -1) {
                prev[next[pointer]] = prev[pointer];
            }
            
            int next_id = next[pointer];
            prev[pointer] = next[pointer] = -1;
            pointer = next_id;
        }
    };
}

namespace solution {
    bool hasMultipleTests = true;

    int n;
    
    int ask(int a, int b) {
        cout << "? " << a << " " << b << endl;
        cout.flush();
        
        int res; cin >> res;
        return res;
    }
    
    void answer(vector<int> &p) {
        cout << "!";
        for (int i=1; i<n; i++) {
            cout << " " << p[i];
        }
        cout << endl;
        cout.flush();
    }

    void preprocess() {

    }

    void input(int testcase) {
        cin >> n;
    }

    void solve(int testcase) {
        vector<int> p(n, -1);
        p[1] = 0;
        
        int r = 2;
        while (true) {
            int response = ask(1, r);
            if (response == -1) exit(2226);
            
            if (response == 1) {
                p[r] = 0;
                r++;
            }
            else break;
        }
        
        int tentacle_count = r - 1;
        
        datastruct::DeleteOnly_DLL tentacles = datastruct::DeleteOnly_DLL(tentacle_count);
        for (int i = 0; i < tentacle_count; i++) {
            tentacles.set_and_move(i + 1);
        }

        p[r] = tentacles.current();
        tentacles.set_and_move(r);
        r++;
        
        while (r < n) {
            int response = ask(tentacles.current(), r);
            if (response == -1) exit(2226);
            
            if (response == 1) {
                tentacles.erase();
            }
            else {
                p[r] = tentacles.current();
                tentacles.set_and_move(r);
                r++;
            }
        }
        
        answer(p);
    }
}

Plaintextnamespace datastruct {
    // A doubly-linked list that only supports modify and (pseudo) deletion at pointer
    class DeleteOnly_DLL {
    public:
        vector<int> values;
        vector<int> prev;
        vector<int> next;
        int pointer;
        
        DeleteOnly_DLL(int size) {
            values.resize(size);
            prev.resize(size);
            next.resize(size);
            
            for (int i = 0; i < size; i++) {
                prev[i] = (i + size - 1) % size;
                next[i] = (i +        1) % size;
            }
            
            pointer = 0;
        }
        
        int current() {
            return values[pointer];
        }
        
        // Set value at pointer and move pointer to next
        void set_and_move(int val) {
            values[pointer] = val;
            pointer = next[pointer];
        }
        
        // "Delete" node and move pointer to next
        void erase() {
            if (prev[pointer] != -1) {
                next[prev[pointer]] = next[pointer];
            }
            if (next[pointer] != -1) {
                prev[next[pointer]] = prev[pointer];
            }
            
            int next_id = next[pointer];
            prev[pointer] = next[pointer] = -1;
            pointer = next_id;
        }
    };
}

namespace solution {
    bool hasMultipleTests = true;

    int n;
    
    int ask(int a, int b) {
        cout << "? " << a << " " << b << endl;
        cout.flush();
        
        int res; cin >> res;
        return res;
    }
    
    void answer(vector<int> &p) {
        cout << "!";
        for (int i=1; i<n; i++) {
            cout << " " << p[i];
        }
        cout << endl;
        cout.flush();
    }

    void preprocess() {

    }

    void input(int testcase) {
        cin >> n;
    }

    void solve(int testcase) {
        vector<int> p(n, -1);
        p[1] = 0;
        
        int r = 2;
        while (true) {
            int response = ask(1, r);
            if (response == -1) exit(2226);
            
            if (response == 1) {
                p[r] = 0;
                r++;
            }
            else break;
        }
        
        int tentacle_count = r - 1;
        
        datastruct::DeleteOnly_DLL tentacles = datastruct::DeleteOnly_DLL(tentacle_count);
        for (int i = 0; i < tentacle_count; i++) {
            tentacles.set_and_move(i + 1);
        }

        p[r] = tentacles.current();
        tentacles.set_and_move(r);
        r++;
        
        while (r < n) {
            int response = ask(tentacles.current(), r);
            if (response == -1) exit(2226);
            
            if (response == 1) {
                tentacles.erase();
            }
            else {
                p[r] = tentacles.current();
                tentacles.set_and_move(r);
                r++;
            }
        }
        
        answer(p);
    }
}

Solution (Python 3)Submission link: 289292865 Plaintextclass DeleteOnly_DLL:
    def __init__(self, size: int):
        self.values = [None for _ in range(size)]
        self.prev = [(i + size - 1) % size for i in range(size)]
        self.next = [(i +        1) % size for i in range(size)]
        self.pointer = 0
    
    def current(self):
        return self.values[self.pointer]
    
    # Set value at pointer and move pointer to next
    def set_and_move(self, val):
        self.values[self.pointer] = val
        self.pointer = self.next[self.pointer]
        
    # "Delete" node and move pointer to next
    def erase(self):
        if self.prev[self.pointer] != -1:
            self.next[self.prev[self.pointer]] = self.next[self.pointer]
        if self.next[self.pointer] != -1:
            self.prev[self.next[self.pointer]] = self.prev[self.pointer]
        
        next_id = self.next[self.pointer]
        self.prev[self.pointer] = self.next[self.pointer] = -1
        self.pointer = next_id
    
# end DeleteOnly_DLL


class Solution:
    hasMultipleTests = True

    n: int = None
    
    @classmethod
    def ask(cls, a: int, b: int):
        print(f'? {a} {b}', flush=True)
        return int(input())
    
    @classmethod
    def answer(cls, p: list):
        print(f'! {" ".join(map(str, p[1:]))}', flush=True)

    @classmethod
    def preprocess(cls):
        pass

    @classmethod
    def input(cls, testcase):
        cls.n = int(input())

    @classmethod
    def solve(cls, testcase):
        p = [-1 for _ in range(cls.n)]
        p[1] = 0
        
        r = 2
        while True:
            response = cls.ask(1, r)
            if response == -1: exit(2226)
            
            if response == 1:
                p[r] = 0
                r += 1
            else: break
        
        tentacle_count = r - 1
        
        tentacles = DeleteOnly_DLL(size = tentacle_count)
        for i in range(tentacle_count):
            tentacles.set_and_move(i + 1)

        p[r] = tentacles.current()
        tentacles.set_and_move(r)
        r += 1
        
        while r < cls.n:
            response = cls.ask(tentacles.current(), r)
            if response == -1: exit(2226)
            
            if response == 1:
                tentacles.erase()
            else:
                p[r] = tentacles.current()
                tentacles.set_and_move(r)
                r += 1
        
        cls.answer(p)

# end Solution

Plaintextclass DeleteOnly_DLL:
    def __init__(self, size: int):
        self.values = [None for _ in range(size)]
        self.prev = [(i + size - 1) % size for i in range(size)]
        self.next = [(i +        1) % size for i in range(size)]
        self.pointer = 0
    
    def current(self):
        return self.values[self.pointer]
    
    # Set value at pointer and move pointer to next
    def set_and_move(self, val):
        self.values[self.pointer] = val
        self.pointer = self.next[self.pointer]
        
    # "Delete" node and move pointer to next
    def erase(self):
        if self.prev[self.pointer] != -1:
            self.next[self.prev[self.pointer]] = self.next[self.pointer]
        if self.next[self.pointer] != -1:
            self.prev[self.next[self.pointer]] = self.prev[self.pointer]
        
        next_id = self.next[self.pointer]
        self.prev[self.pointer] = self.next[self.pointer] = -1
        self.pointer = next_id
    
# end DeleteOnly_DLL


class Solution:
    hasMultipleTests = True

    n: int = None
    
    @classmethod
    def ask(cls, a: int, b: int):
        print(f'? {a} {b}', flush=True)
        return int(input())
    
    @classmethod
    def answer(cls, p: list):
        print(f'! {" ".join(map(str, p[1:]))}', flush=True)

    @classmethod
    def preprocess(cls):
        pass

    @classmethod
    def input(cls, testcase):
        cls.n = int(input())

    @classmethod
    def solve(cls, testcase):
        p = [-1 for _ in range(cls.n)]
        p[1] = 0
        
        r = 2
        while True:
            response = cls.ask(1, r)
            if response == -1: exit(2226)
            
            if response == 1:
                p[r] = 0
                r += 1
            else: break
        
        tentacle_count = r - 1
        
        tentacles = DeleteOnly_DLL(size = tentacle_count)
        for i in range(tentacle_count):
            tentacles.set_and_move(i + 1)

        p[r] = tentacles.current()
        tentacles.set_and_move(r)
        r += 1
        
        while r < cls.n:
            response = cls.ask(tentacles.current(), r)
            if response == -1: exit(2226)
            
            if response == 1:
                tentacles.erase()
            else:
                p[r] = tentacles.current()
                tentacles.set_and_move(r)
                r += 1
        
        cls.answer(p)

# end Solution

Feedback Didn't attempt 

    


13



 Great problem 

    


136



 Nice problem 

    


25



 OK problem 

    


26



 Bad problem 

    


7



 Terrible problem 

    


18



 

Hint #1Why is nn odd? Does it imply anything of the availability of a solution?

Hint #2n=1n=1 is trivial. Try to solve this problem if n=3n=3 and a1=a3a1=a3.

Hint #3Try to solve this problem for any array with n=3n=3. Is there any way to solve this without going pass a state of a1=a3a1=a3 (or a1=a2a1=a2 or a2=a3a2=a3)?

Hint #4Assume that n=5n=5, a1=a5a1=a5 and a2=a3=a4a2=a3=a4. Now refer to hint #2, can you see any similarity in the solution?

Hint #5Refer to hint #4. What would happen if we apply an operation to index 22 and another to index 44?

Hint #6For any array with n=5n=5, how would you convert it into the form stated in hint #4?

Hint #7Refer to hint #6. How would you make a1=a5a1=a5 and a2=a4a2=a4? Does the fact that nn is odd help in any way?

Hint #8Can you draw a generalized conclusion?

Tutorial2032E - BalancedTo simplify this problem a little bit before starting, we will temporarily allow "negative" operation: choose an index 1≤i≤n and increase ai−1 by −1, ai by −2, and ai+1 by −1. This is counted as −1 operation on index i. Should we get negative elements in array v in the end, we can normalize it just fine by subtracting all vi with minvi so that the final array v is valid — it's trivial to prove that applying the same amount of operations in all indices does not change the relative difference between any two values in the array.Imagine we have n=3 and array a=[a1,a2,a3] where a1≥a2≤a3; i.e., a trench. This array always has at least one solution: try to balance a1 and a3 by adding an amount of operation on either side based on their difference — here we have something we'll denote as a "balanced trench", then add another amount of operations on index 2 to balance them three, and due to the cyclic nature of a.In fact, every array with n=3, without regards to value intensity, can be thought of this form — if a2 is higher than both a1 and a3, the act of "raising" a2 is actually applying a negative amount of operations to index 2.How to make a "balanced trench" for n>3?At least, we can balance a1 and an in the same fashion as we did for n=3. Can we balance a2 and an−1 without breaking the balance we achieved between a1 and an?Assuming we have an array [0,x,y,x+1,0].By logic, we want to increase the value of index 2.Applying an operation to index 1 won't do, as the new array would be [2,x+1,y,x+1,1]. We are balancing the inner elements by sacrificing the outer ones.Applying an operation to index 3 also won't do as it increases both sides.Applying an operation to index 2 will make the array become [1,x+2,y+1,x+1,0]. By applying another operation to index 5, we'll reach our desired goal with array [2,x+2,y+1,x+2,2].In fact, a series of operations in "consecutive" indices of the same parity would have this effect, regardless of how long that series is.To be precise, without loss of generality, a series of operations in indices 2,4,…,i, with i≤n−1, will increase a1 and ai+1 by 1, and all values with indices in range [2,i] by 2.The catch here is that we mitigate 1 unit of difference between sides with each operation series by adding just 1 unit to the higher side, while the corresponding other 1 would be further beyond the lower side.If we aim to balance the sides from outwards to inwards, that exceeding 1 will either fall into a deeper-inwards layer, or the center of the array (since n is odd), which will not harm whatever we have achieved at first.Take an example with array [48,18,26,57,39].  First, we'll balance index 1 and index 5. We can simply apply 9 operations to index 5. The new array would be [57,18,26,66,57].  Then, we'll balance index 2 and index 4. From index 2, we'll move to the left until it reaches index 5, and apply 48 operations for every 2 steps. In other words, apply 48 operations to index 2 and 48 operations to index 5. This array is now a balanced trench: [153,114,64,114,153]. Now, achieving the desired array (we'll call it a "plateau") from a balanced trench is easy: starting from the rightmost element of the left side before the center going leftwards, compare the value to its adjacent element to the right, and apply a corresponding amount of operations.Now, take the balanced trench we just acquired.  First, we'll check index 2. Clearly, we want to rise index 3 to close the 50 unit gap, thus we'll apply 50 operations to index 3. The new array will become [153,164,164,164,153].  Then, we'll check index 1. Our objective is to decrease 11 for all elements with indices in range [2,4]. Using the similar operation series as discussed earlier, this can be done like this: apply −11 operations to index 2, then apply −11 operations to index 4. The final array will be [142,142,142,142,142].  That operation series can be used here because the range of elements changing by 2 units per series has an odd size, and since we're growing the plateau from the center point outwards, its size is always odd as well. With this, the non-normalized array v will be [0,46,50,−11,57].Implementing this method can be separated into two separate steps:  Step 1 (creating the balanced trench): for each pair of indices (i,n+1−i) with difference an+1−i−ai=d, apply d operations for each index of the cyclic range [n+3−i,i] with step 2.  Step 2 (creating the plateau): for each pair of indices (i,i+1) with difference ai−ai+1=d, apply d operations for each index of the range [i+1,n−i] with step 2. Some extra notes:  Each step requires an independent prefix-sum structure to quickly maintain the operation updates. Notice that the prefix sum here takes account of parity, since only the other index in a range is updated, not every one of them.  Remember that after each index considered, its value will alter based on the amount of operations just applied on it, so keep track of it properly.  To avoid confusion, it's advised to apply the operations of step 1 directly into array a before proceeding with step 2.  Remember to normalize array v before outputting to get rid of negative values.  Refer to the model solution for more details. Time complexity: O(n).

Solution (C++)Submission link: 289293300 Plaintextnamespace solution {
    bool hasMultipleTests = true;

    int n;
    vector<int> a;
    
    void apply_prefixes(vector<long long> &prefixes, vector<long long> &v) {
        for (int i = 2; i < n * 2; i++) {
            prefixes[i] += prefixes[i - 2];
        }
        
        for (int i = 0; i < n * 2; i++) {
            v[i % n] += prefixes[i];
        }
    }
    
    void construct_trench(vector<long long> &arr, vector<long long> &v) {
        vector<long long> prefixes(n * 2, 0LL);
        vector<long long> delta(n, 0LL);
        
        for (int i = 0; i < n / 2; i++) {
            long long diff = arr[n - 1 - i] - (arr[i] + delta[i]);
            
            delta[i] += 2 * diff;
            delta[i + 1] += diff;
            
            prefixes[n - i] += diff;
            prefixes[n + i + 2] -= diff;
        }
        
        apply_prefixes(prefixes, v);
        
        for (int i = 0; i < n; i++) {
            arr[i] += v[i] * 2;
            arr[(i + 1) % n] += v[i];
            arr[(i + n - 1) % n] += v[i];
        }
    }
    
    void construct_plateau(vector<long long> &arr, vector<long long> &v) {
        vector<long long> prefixes(n * 2, 0LL);
        vector<long long> delta(n, 0LL);
        
        for (int i = n / 2 - 1; i >= 0; i--) {
            long long diff = arr[i] - (arr[i + 1] + delta[i + 1]);
            
            delta[i] += diff;
            
            prefixes[i + 1] += diff;
            prefixes[n - i] -= diff;
        }
        
        apply_prefixes(prefixes, v);
    }

    void preprocess() {
        
    }

    void input(int testcase) {
        cin >> n;
        a.clear();
        a.resize(n);
        for (auto &z: a) cin >> z;
    }

    void solve(int testcase) {
        if (n == 1) {
            cout << "0\n";
            return;
        }
        
        vector<long long> v(n, 0LL);
        vector<long long> arr(n);
        for (int i = 0; i < n; i++) {
            arr[i] = 1LL * a[i];
        }
        
        construct_trench(arr, v);
        construct_plateau(arr, v);
        
        long long offset = *ranges::min_element(v);
        
        for (auto &z: v) cout << z - offset << " ";
        cout << endl;
    }
}

Plaintextnamespace solution {
    bool hasMultipleTests = true;

    int n;
    vector<int> a;
    
    void apply_prefixes(vector<long long> &prefixes, vector<long long> &v) {
        for (int i = 2; i < n * 2; i++) {
            prefixes[i] += prefixes[i - 2];
        }
        
        for (int i = 0; i < n * 2; i++) {
            v[i % n] += prefixes[i];
        }
    }
    
    void construct_trench(vector<long long> &arr, vector<long long> &v) {
        vector<long long> prefixes(n * 2, 0LL);
        vector<long long> delta(n, 0LL);
        
        for (int i = 0; i < n / 2; i++) {
            long long diff = arr[n - 1 - i] - (arr[i] + delta[i]);
            
            delta[i] += 2 * diff;
            delta[i + 1] += diff;
            
            prefixes[n - i] += diff;
            prefixes[n + i + 2] -= diff;
        }
        
        apply_prefixes(prefixes, v);
        
        for (int i = 0; i < n; i++) {
            arr[i] += v[i] * 2;
            arr[(i + 1) % n] += v[i];
            arr[(i + n - 1) % n] += v[i];
        }
    }
    
    void construct_plateau(vector<long long> &arr, vector<long long> &v) {
        vector<long long> prefixes(n * 2, 0LL);
        vector<long long> delta(n, 0LL);
        
        for (int i = n / 2 - 1; i >= 0; i--) {
            long long diff = arr[i] - (arr[i + 1] + delta[i + 1]);
            
            delta[i] += diff;
            
            prefixes[i + 1] += diff;
            prefixes[n - i] -= diff;
        }
        
        apply_prefixes(prefixes, v);
    }

    void preprocess() {
        
    }

    void input(int testcase) {
        cin >> n;
        a.clear();
        a.resize(n);
        for (auto &z: a) cin >> z;
    }

    void solve(int testcase) {
        if (n == 1) {
            cout << "0\n";
            return;
        }
        
        vector<long long> v(n, 0LL);
        vector<long long> arr(n);
        for (int i = 0; i < n; i++) {
            arr[i] = 1LL * a[i];
        }
        
        construct_trench(arr, v);
        construct_plateau(arr, v);
        
        long long offset = *ranges::min_element(v);
        
        for (auto &z: v) cout << z - offset << " ";
        cout << endl;
    }
}

Solution (Python 3)Submission link: 289293299 Plaintextclass Solution:
    hasMultipleTests = True

    n: int = None
    a: list = None

    @classmethod
    def apply_prefixes(cls, prefixes, v):
        for i in range(2, cls.n*2):
            prefixes[i] += prefixes[i - 2]
        
        for i in range(cls.n*2):
            v[i % cls.n] += prefixes[i]

    @classmethod
    def construct_trench(cls, arr, v):
        prefixes = [0 for _ in range(cls.n * 2)]
        delta = [0 for _ in range(cls.n)]
        
        for i in range(cls.n // 2):
            diff = arr[cls.n - 1 - i] - (arr[i] + delta[i])
            
            delta[i] += 2 * diff
            delta[i + 1] += diff
            
            prefixes[cls.n - i] += diff
            prefixes[cls.n + i + 2] -= diff
        
        cls.apply_prefixes(prefixes, v)
        
        for i in range(cls.n):
            arr[i] += v[i] * 2
            arr[(i + 1) % cls.n] += v[i]
            arr[(i + cls.n - 1) % cls.n] += v[i]

    @classmethod
    def construct_plateau(cls, arr, v):
        prefixes = [0 for _ in range(cls.n * 2)]
        delta = [0 for _ in range(cls.n)]
        
        for i in range(cls.n // 2 - 1, -1, -1):
            diff = arr[i] - (arr[i + 1] + delta[i + 1])
            
            delta[i] += diff
            
            prefixes[i + 1] += diff
            prefixes[cls.n - i] -= diff
        
        cls.apply_prefixes(prefixes, v)

    @classmethod
    def preprocess(cls):
        pass

    @classmethod
    def input(cls, testcase):
        cls.n = int(input())
        cls.a = list(map(int, input().split()))

    @classmethod
    def solve(cls, testcase):
        if cls.n == 1:
            return(print(0))
        
        v = [0 for _ in range(cls.n)]
        
        cls.construct_trench(cls.a, v)
        cls.construct_plateau(cls.a, v)
        
        offset = min(v)
        v = list(map(lambda x: x - offset, v))
        
        print(*v)

# end Solution

Plaintextclass Solution:
    hasMultipleTests = True

    n: int = None
    a: list = None

    @classmethod
    def apply_prefixes(cls, prefixes, v):
        for i in range(2, cls.n*2):
            prefixes[i] += prefixes[i - 2]
        
        for i in range(cls.n*2):
            v[i % cls.n] += prefixes[i]

    @classmethod
    def construct_trench(cls, arr, v):
        prefixes = [0 for _ in range(cls.n * 2)]
        delta = [0 for _ in range(cls.n)]
        
        for i in range(cls.n // 2):
            diff = arr[cls.n - 1 - i] - (arr[i] + delta[i])
            
            delta[i] += 2 * diff
            delta[i + 1] += diff
            
            prefixes[cls.n - i] += diff
            prefixes[cls.n + i + 2] -= diff
        
        cls.apply_prefixes(prefixes, v)
        
        for i in range(cls.n):
            arr[i] += v[i] * 2
            arr[(i + 1) % cls.n] += v[i]
            arr[(i + cls.n - 1) % cls.n] += v[i]

    @classmethod
    def construct_plateau(cls, arr, v):
        prefixes = [0 for _ in range(cls.n * 2)]
        delta = [0 for _ in range(cls.n)]
        
        for i in range(cls.n // 2 - 1, -1, -1):
            diff = arr[i] - (arr[i + 1] + delta[i + 1])
            
            delta[i] += diff
            
            prefixes[i + 1] += diff
            prefixes[cls.n - i] -= diff
        
        cls.apply_prefixes(prefixes, v)

    @classmethod
    def preprocess(cls):
        pass

    @classmethod
    def input(cls, testcase):
        cls.n = int(input())
        cls.a = list(map(int, input().split()))

    @classmethod
    def solve(cls, testcase):
        if cls.n == 1:
            return(print(0))
        
        v = [0 for _ in range(cls.n)]
        
        cls.construct_trench(cls.a, v)
        cls.construct_plateau(cls.a, v)
        
        offset = min(v)
        v = list(map(lambda x: x - offset, v))
        
        print(*v)

# end Solution

Alternative tutorial (Kuroni, rephrased by AkiLotus)We have some observations here. Our only allowed operation is [1,2,1][1,2,1], but by stacking it in the right way (and normalizing the differences) we could obtain simpler operations. In details:  We can apply operation [−1,−1][−1,−1] to index ii (decrease values at index ii and i+1i+1 by 11) by applying operation [1,2,1][1,2,1] to index i+2i+2, i+4i+4, and so on until i−1i−1 (please treat these addition/subtraction of indices in a cyclic array context). Doing so will increase every index's value by 22, except ii and i+1i+1 only get increase by 11, so relatively, indices ii and i+1i+1 got their values lowered by 11 compared to the rest. We can apply operation [1][1] to index ii (increase value at index ii by 11) by applying operation [−1,−1][−1,−1] to index i+1i+1, i+3i+3, and so on until i−1i−1. Proof for this is trivial. 

Feedback Didn't attempt 

    


13



 Great problem 

    


37



 Nice problem 

    


55



 OK problem 

    


8



 Bad problem 

    


4



 Terrible problem 

    


22



 

Hint #1Try to solve if all pockets are in the same box. Does the problem seem familiar?

Hint #2There's one kind of cases for a box that its game has a fixed move sequence, and thus a fixed outcome. What is it?

Hint #3Let's take the cases found in hint #2 out of the equation from here on. Is there any way for a player to win in two consecutive boxes?

Hint #4If a player can win a box if both play optimally to win, can they also lose it if both play optimally to lose?

Tutorial2032F - Peanuts  Let's get the trivial case out of the way: If the peanut pockets always contain 1 nut each, then partitioning the pockets doesn't affect the game's outcome at all:  Alice will always win if n is odd, and there are 2n−1 ways to partition n pockets.  Jack will always win if n is even. Proof for the trivial case is, indeed, trivial.For the main problem, we see that this is a derivative of a game of Nim. To be exact, each box is a vanilla Nim game. To determine the winner of a vanilla Nim game when both players play optimally is trivial — if not for you, I strongly suggest reading about the game and the Sprague-Grundy theorem before continuing.In short, the Nim-sum of a Nim game is the xor sum of all values presented, and if that value is at least 1, the first player will win if they play optimally.The original game of this problem is a series of consecutive Nim games, with the loser of the previous game becoming the first player of the next game. Clearly, trying to win all the boxes isn't a correct approach — one of the simplest counterexamples is a partition with two boxes, both with the first player winning if played optimally, so of course if the first player "wins" the first box, they immediately lose the second one and thus lose the whole game.In short, sometimes, tactically "losing" some boxes might be required. But how to know which player would lose if they both aimed for it?Now, introducing the "mirrored" version of a Nim game — a Misère Nim game, where the winning condition is the original Nim game's losing condition.If the peanut pockets always contain 1 nut each, then the winner of a Misère Nim game can be easily declared by the parity of n. Otherwise, the winner of a Misère Nim game can be decided using the same nimber used in a regular Nim game: if the nimber is not 0, the first player wins both the original and the Misère version; otherwise, the second player wins — the optimal strategies to acquire such outcome have the exact mirror intents of those in a regular Nim game.Also, surpassing the leading 1s in array a, both Alice and Jack have the rights to tactically lose. Thus, any of them would win the game if and only if they could win the first box containing non-trivial pockets (here defined as pockets with more than 1 nut, we'll call a box having at least one non-trivial pocket a non-trivial box) if both play optimally until there — as proven above, if they could theoretically win it, they could also tactically lose it, thus they would have full control of the game, and they could make a decision in accordance with whatever partition coming next in the remaining pockets.We'll denote l as the number of trivial pockets (i.e. pockets with 1 nut each) standing at the left side of array a, i.e., the (l+1)th pocket will be the leftmost one to have more than 1 nut. We'll consider all possible options for first boxes containing non-trivial pockets, and thus we'll iterate r in range [l+1,n]:  First, we denote P(r) as the xor sum of all elements of the prefix of array a up until the rth element. This value will determine how much control Alice would have.  If P(r)=0, Alice will lose in all cases with the first non-trivial box ending at r. Proof is simple: if this box has an even amount of 1s before it, obviously Alice will be the starting player of a game with nimber of 0 and thus cannot control it to her will; and if the amount of preceding 1s is odd, then the first non-trivial box is a game with nimber of 1 and Jack as first player, thus Jack retains full control.  If P(r)=1, Alice will win in all cases with the first non-trivial box ending at r. Proof is literally the reverse of the above case.  If P(r)>1, both Alice and Jack have full control to win it, thus Alice will win if and only if she is the starting player of the game at the first non-trivial box. So we have the detailed winning condition. Now, towards the maths.  First, whatever pockets after the first non-trivial box doesn't matter. Thus, for each r, there exists 2max(0,n−r−1) different partitions of the pockets following the rth one.  We don't consider cases with P(r)=0, obviously.  If P(r)=1, all partitions involving only the first l pockets are allowed. In fact, there are l+1 items here: l trivial pockets, and the first non-trivial blob always coming last, thus the number of different partitions of the pockets preceding the rth one in this case is 2l.  If P(r)>1, we'll consider all even l0 in range [0,l], with l0 denoting the number of 1s not within the first non-trivial box. Clearly, for each l0, the number of different partitions would be 2max(0,l0−1). And since l is fixed and this process has no relation with r, this value could be pre-calculated. In more details, denoting that value as M, we have M=∑⌊l02⌋i=02max(0,2i−1).  All powers of 2 could be pre-calculated as well, saving a considerable amount of runtime. All pre-calculations have time complexity in linear order of the maximum size of array a. Time complexity: O(n).

Solution (C++)Submission link: 289293663 Plaintextnamespace solution {
    bool hasMultipleTests = true;

    int n;
    vector<int> a;
    
    const int MAXN = 1000000;
    const int MOD  = 998244353;
    int pow2[MAXN];

    void preprocess() {
        pow2[0] = 1;
        for (int i = 1; i < MAXN; i++) {
            pow2[i] = (2LL * pow2[i-1]) % MOD;
        }
    }

    void input(int testcase) {
        cin >> n;
        a.clear();
        a.resize(n);
        for (auto &z: a) cin >> z;
    }

    void solve(int testcase) {
        if (*ranges::max_element(a) == 1) {
            cout << (n & 1 ? pow2[n-1] : 0) << endl;
            return;
        }
        
        int ans = 0;
        
        // The critical layer (assuming prefix Grundy > 1) can only fall into Alice's control
        // if and only if before it is an even amount of pockets
        int alice_at_critical = 1;
        int prefix_1 = 0;
        while (a[prefix_1] == 1) {
            prefix_1++;
            if (prefix_1 % 2 == 0) {
                alice_at_critical = (alice_at_critical + pow2[prefix_1 - 1]) % MOD;
            }
        }
        
        int grundy = (prefix_1 & 1);
        for (int r = prefix_1; r < n; r++) {
            grundy ^= a[r];
            
            if (!grundy) continue;
            
            int post_critical = (r < n - 1 ? pow2[n - 2 - r] : 1);
            int pre_critical = (grundy == 1 ? pow2[prefix_1] : alice_at_critical);
            
            ans += (1LL * pre_critical * post_critical) % MOD;
            ans %= MOD;
        }
        
        cout << ans << endl;
    }
}

Plaintextnamespace solution {
    bool hasMultipleTests = true;

    int n;
    vector<int> a;
    
    const int MAXN = 1000000;
    const int MOD  = 998244353;
    int pow2[MAXN];

    void preprocess() {
        pow2[0] = 1;
        for (int i = 1; i < MAXN; i++) {
            pow2[i] = (2LL * pow2[i-1]) % MOD;
        }
    }

    void input(int testcase) {
        cin >> n;
        a.clear();
        a.resize(n);
        for (auto &z: a) cin >> z;
    }

    void solve(int testcase) {
        if (*ranges::max_element(a) == 1) {
            cout << (n & 1 ? pow2[n-1] : 0) << endl;
            return;
        }
        
        int ans = 0;
        
        // The critical layer (assuming prefix Grundy > 1) can only fall into Alice's control
        // if and only if before it is an even amount of pockets
        int alice_at_critical = 1;
        int prefix_1 = 0;
        while (a[prefix_1] == 1) {
            prefix_1++;
            if (prefix_1 % 2 == 0) {
                alice_at_critical = (alice_at_critical + pow2[prefix_1 - 1]) % MOD;
            }
        }
        
        int grundy = (prefix_1 & 1);
        for (int r = prefix_1; r < n; r++) {
            grundy ^= a[r];
            
            if (!grundy) continue;
            
            int post_critical = (r < n - 1 ? pow2[n - 2 - r] : 1);
            int pre_critical = (grundy == 1 ? pow2[prefix_1] : alice_at_critical);
            
            ans += (1LL * pre_critical * post_critical) % MOD;
            ans %= MOD;
        }
        
        cout << ans << endl;
    }
}

Solution (Python 3)Submission link: 289293585 Plaintextclass Solution:
    hasMultipleTests = True

    n: int = None
    a: list = None
    
    MAXN: int = 1000000
    MOD: int = 998244353
    pow2: list = None

    @classmethod
    def preprocess(cls):
        cls.pow2 = [None for _ in range(cls.MAXN)]
        for i in range(cls.MAXN):
            cls.pow2[i] = 1 if i == 0 else (2 * cls.pow2[i-1]) % cls.MOD

    @classmethod
    def input(cls, testcase):
        cls.n = int(input())
        cls.a = list(map(int, input().split()))

    @classmethod
    def solve(cls, testcase):
        if max(cls.a) == 1:
            return(print(cls.pow2[cls.n-1] if cls.n & 1 else 0))
        
        ans = 0

        # The critical layer (assuming prefix Grundy > 1) can only fall into Alice's control
        # if and only if before it is an even amount of pockets
        alice_at_critical = 1
        prefix_1 = 0
        while cls.a[prefix_1] == 1:
            prefix_1 += 1
            
            if prefix_1 % 2 == 0:
                alice_at_critical = (alice_at_critical + cls.pow2[prefix_1 - 1]) % cls.MOD
                
        grundy = prefix_1 & 1
        for r in range(prefix_1, cls.n):
            grundy ^= cls.a[r]
            
            if grundy == 0: continue
        
            post_critical = cls.pow2[cls.n - 2 - r] if r < cls.n - 1 else 1
            pre_critical = cls.pow2[prefix_1] if grundy == 1 else alice_at_critical
            
            ans = (ans + pre_critical * post_critical) % cls.MOD
            
        print(ans)

# end Solution

Plaintextclass Solution:
    hasMultipleTests = True

    n: int = None
    a: list = None
    
    MAXN: int = 1000000
    MOD: int = 998244353
    pow2: list = None

    @classmethod
    def preprocess(cls):
        cls.pow2 = [None for _ in range(cls.MAXN)]
        for i in range(cls.MAXN):
            cls.pow2[i] = 1 if i == 0 else (2 * cls.pow2[i-1]) % cls.MOD

    @classmethod
    def input(cls, testcase):
        cls.n = int(input())
        cls.a = list(map(int, input().split()))

    @classmethod
    def solve(cls, testcase):
        if max(cls.a) == 1:
            return(print(cls.pow2[cls.n-1] if cls.n & 1 else 0))
        
        ans = 0

        # The critical layer (assuming prefix Grundy > 1) can only fall into Alice's control
        # if and only if before it is an even amount of pockets
        alice_at_critical = 1
        prefix_1 = 0
        while cls.a[prefix_1] == 1:
            prefix_1 += 1
            
            if prefix_1 % 2 == 0:
                alice_at_critical = (alice_at_critical + cls.pow2[prefix_1 - 1]) % cls.MOD
                
        grundy = prefix_1 & 1
        for r in range(prefix_1, cls.n):
            grundy ^= cls.a[r]
            
            if grundy == 0: continue
        
            post_critical = cls.pow2[cls.n - 2 - r] if r < cls.n - 1 else 1
            pre_critical = cls.pow2[prefix_1] if grundy == 1 else alice_at_critical
            
            ans = (ans + pre_critical * post_critical) % cls.MOD
            
        print(ans)

# end Solution

Feedback Didn't attempt 

    


22



 Great problem 

    


14



 Nice problem 

    


1



 OK problem 

    


6



 Bad problem 

    


0



 Terrible problem 

    


9



 

SpoilerDoes your solution for the second test case really have m=1m=1?

AnswerOutput should be 11. SpoilerIt's not always the best idea to keep the largest element as you have done.

SpoilerIt's not always the best idea to keep the largest element as you have done.

