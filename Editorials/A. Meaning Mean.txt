Tutorial2021A - Meaning MeanFor now, let's ignore the floor operation, so an operation is merging two elements aiai and ajaj into one element ai+aj2ai+aj2.Consider the end result. Each initial element in aa must contribute a fractional coefficient to the final result. It turns out that the sum of the coefficients is fixed (it must be 11). That means we can greedily give the biggest values in aa the biggest coefficients.One way to do this is by sorting aa in ascending order. We merge a1a1 and a2a2, then merge that result with a3a3, then merge that result with a4a4, and so on until anan. If we do this, anan contributes 1212 times, an−1an−1 contributes 1414 times, an−2an−2 contributes 1818 times, and so on. This is the optimal way to get the maximum final result.It turns out that the strategy above is also the optimal strategy for the original version of the problem. So we can simulate that process to get the answer.Time complexity for each test case: O(nlogn)O(nlog⁡n)

Tutorial2021B - Maximize MexFor the MEXMEX to be at least kk, then each non-negative integer from 00 to k−1k−1 must appear at least once in the array.First, notice that since there are only nn elements in the array, there are at most nn different values, so the MEXMEX can only be at most nn. And since we can only increase an element's value, that means every element with values bigger than nn can be ignored.We construct a frequency array freqfreq such that freq[k]freq[k] is the number of elements in aa with value kk.Notice that the values just need to appear at least once to contribute to the MEXMEX, so two or more elements with the same value should be split into different values to yield a potentially better result. To find the maximum possible MEXMEX, we iterate each index kk in the array freqfreq from 00 to nn. In each iteration of kk, if we find freq[k]>0freq[k]>0, that means it's possible to have the MEXMEX be bigger than kk, so we can iterate kk to the next value. Before we iterate to the next value, if we find freq[k]>1freq[k]>1, that indicates duplicates, so we should do an operation to all except one of those values to change them into k+xk+x, which increases freq[k+x]freq[k+x] by freq[k]−1freq[k]−1 and changes freq[k]freq[k] into 11. In each iteration of kk, if we find freq[k]=0freq[k]=0, that means, kk is the maximum MEXMEX we can get, and we should end the process.Time complexity for each test case: O(n)O(n)

Tutorial2021C2 - Adjust The Presentation (Hard Version)Firstly, let's relabel the nn members such that member number ii is the ii-th member in the initial line configuration in array aa. We also adjust the values in bb (and the future updates) accordingly.For now, let's solve the problem if there are no updates to the array bb. Consider the first member who presents. Notice that member 11 must be the first one presenting since he/she is at the very front of the line, which means b1=1b1=1 must hold. After this, we insert him/her into any position in the line. However, instead of determining the target position immediately, we make member 11 a "pending member" and we will only determine his/her position later on when we need him/her again.To generalize, we can form an algorithm to check whether achieving bb is possible or not. We iterate each element bibi for each ii from 11 to mm. While iterating, we maintain a set of pending members which is initially empty, and we maintain who is the next member in the line. When iterating a value of bibi, there are three cases:   If bibi is equal to the next member in the line, then we can make that member present. And then he/she will become a pending member for the next iterations.  Else, if bibi is one of the pending members, then we can always set a precise target position when moving that member in the past such that he/she will be at the very front of the line at this very moment. And then, that member will be a pending member again.  Else, then it's impossible to make member bibi present at this time. To solve the problem with updates, let's observe some special properties of bb if bb is valid. Notice that once a member becomes a pending member, he/she will be a pending member forever. And a member xx becomes a pending member during the first occurence of value xx bb. Since the order of members becoming pending must follow the order of the members in the line, that means the first occurence for each value xx in bb must be in chronological order from 11 to nn. More formally, let's define first[x]first[x] as follows:   If the value xx appears at least once in bb, then first[x]first[x] is the smallest index ii such that bi=xbi=x.  If the value xx doesn't appear in bb, then first[x]=m+1first[x]=m+1. Then, for bb to be valid, it must hold that first[1]≤first[2]≤…≤first[n]first[1]≤first[2]≤…≤first[n].To handle the updates, we must maintain the array firstfirst. In order to do that, for each value xx from 11 to nn, we maintain a set of indices for every occurence of xx in bb. The value of firstfirst is just the minimum value in the set, or m+1m+1 if the set is empty. An update to an element in bb corresponds to two updates among the sets, which corresponds to two updates in array firstfirst.To maintain the status on whether array firstfirst is non-decreasing or not, we maintain a value cc which represents the number of pairs of adjacent indices (x,x+1)(x,x+1) (for all 1≤x≤n−11≤x≤n−1) such that first[x]≤first[x+1]first[x]≤first[x+1]. The array is non-decreasing if and only if c=n−1c=n−1. For an update to an index xx in firstfirst, we only need to check how pairs (x−1,x)(x−1,x) and (x,x+1)(x,x+1) affect the value of cc.Time complexity for each test case: O((n+m+q)log(n+m))O((n+m+q)log⁡(n+m))

Tutorial2021D - Boss, ThirstyWe can see it as a grid of square tiles, consisting of nn rows and mm columns. Consider a single row. Instead of looking at the mm tiles, we can look at the m+1m+1 edges between tiles, including the leftmost edge and the rightmost edge. We number the edges from 00 to mm such that tile jj (1≤j≤m1≤j≤m) is the tile between edge j−1j−1 and edge jj.For a single row ii, choosing a segment of tiles is equivalent to choosing two different edges ll and rr (0≤l<r≤m0≤l<r≤m) as the endpoints of the segment, which denotes choosing the tiles from l+1l+1 to rr. For each edge jj, we can precompute a prefix sum pref[j]=Ai,1+Ai,2+…+Ai,jpref[j]=Ai,1+Ai,2+…+Ai,j. That means, choosing edges ll and rr yields a profit of pref[r]−pref[l]pref[r]−pref[l].Let's say we've chosen edges l′l′ and r′r′ for row i−1i−1 and we want to choose two edges ll and rr for row ii that satisfies the problem requirement. We want to choose a continuous segment that includes at least one chosen tile and at least one unchosen tile from the previous row. A chosen tile that is adjacent to an unchosen tile only appears at the endpoints of the previous segment. That means, to satisfy the requirement, the new segment must strictly contain at least one endpoint of the previous segment. More formally, at least one of the following conditions must be satisfied:   l<l′<rl<l′<r  l<r′<rl<r′<r Knowing that, we can see that when going from one row to the next, we only need the information for one of the two endpoints, not both.We can solve this with dynamic programming from row 11 to row nn. For each row, we find the optimal profit for each ll and the optimal profit for each rr. We do those two things separately. For each row ii, define the following things:  dpL[i][l]dpL[i][l]: the optimal profit for the first ii rows if the left endpoint of the last segment is ll.  dpR[i][r]dpR[i][r]: the optimal profit for the first ii rows if the right endpoint of the last segment is rr. Let's say we've calculated all values of dpLdpL and dpRdpR for row i−1i−1 and we want to calculate for row ii. Let ll and rr be the left and right endpoints of the new segment respectively. Let pp be one of the endpoints of the previous segment. Then it must hold that l<p<rl<p<r, which yields a maximum profit of −pref[l]+max(dpL[i−1][p],dpR[i−1][p])+pref[r]−pref[l]+max(dpL[i−1][p],dpR[i−1][p])+pref[r].Let's calculate all values of dpRdpR first for row ii. For each rr, we want to consider all corresponding triples (l,p,r)(l,p,r) and find the maximum profit among them. In order to do that, we do three steps:  Make a prefix maximum of −pref[l]−pref[l].  Then, for each pp, we add max(dpL[i-1][p],dpR[i−1][p])max(dpL[i-1][p],dpR[i−1][p]) with the maximum value of −pref[l]−pref[l] for all 0≤l<j0≤l<j. And then we make a prefix maximum of those values.  Then, for each rr, the value of dpR[i][r]dpR[i][r] is pref[r]pref[r] added by the maximum value for the previous calculation for each pp from 00 to r−1r−1. We do the same thing for dpLdpL but we use suffix maxmiums instead.After doing all that for every row from 11 to nn, we find the maximum value of dpLdpL and dpRdpR in the last row to get the answer.Time complexity of each test case: O(nm)O(nm)

Tutorial2021E3 - Digital Village (Extreme Version)Since the cost of a path uses the maximum edge weight in the path, we can use a Kruskal-like algorithm that is similar to finding the MST (Minimum Spanning Tree). Initially, the graph has no edges, and we add each edge one by one starting from the smallest values of wiwi, while maintaining the connected components in the graph using DSU (Disjoint Set Union).While doing the MST algorithm, we simultaneously construct the reachability tree of the graph, whose structure represents the sequence of mergings of connected components in the algorithm. Each vertex in the reachability tree corresponds to some connected component at some point in time in the algorithm. Each non-leaf vertex in the reachability tree always has two children, which are the two connected components that are merged to form the connected component represented by that vertex, so every time two connected components merge in the algorithm, we make a new vertex in the reachability tree that is connected to its two corresponding children.After doing all that, we've constructed a reachability tree that is a rooted binary tree with 2n−12n−1 vertices, nn of which are leaves. For each non-leaf vertex xx, we write down weight[x]weight[x] which is the weight of the edge that forms its connected component. For each leaf, we mark it as special if and only if it corresponds to a house that needs internet. Then, for each vertex xx, we calculate cnt[x]cnt[x], which is the number of special leaves in the subtree of xx. These values will be used later.Consider a non-leaf xx in the reachability tree. It can be obtained that two vertices in the original graph corresponding to any two leaves in the subtree of xx can have a path between them in the original graph with a weight of at most weight[x]weight[x].Let's solve for some value of kk. For each special vertex xx, we want to choose a target vertex yy that's an ancestor of xx. Then, we choose a set of kk leaves for the houses with installed servers. We want it such that each chosen target has at least one leaf in its subtree that is a member of the set. The total path cost of this is the sum of weight[y]weight[y] for all chosen targets yy.Let's say we've fixed the set of kk leaves. Then, we mark every ancestor of these leaves. If we only consider the marked vertices with the edges between them, we have a reduced tree. For each special leaf, we want to choose its nearest ancestor that is in the reduced tree for its target to get the one with the smallest weight.Knowing this, we can solve the problem in another point of view. Initially, we have the original reachability tree. We want to reduce it into a reduced tree with kk leaves. We want to do it while maintaining the chosen targets of the special leaves and their costs. Initially, for each special leaf, we choose itself as its target. In one operation, we can do the following:   Choose a vertex that's currently a leaf.  Move every target that's currently in that leaf to its parent.  Remove that leaf and the edge connecting it to its parent. We want to do that until the reduced tree has kk leaves.For each edge connecting a vertex xx to its parent yy in the reachability tree, calculate (weight[y]−weight[x])×cnt[x](weight[y]−weight[x])×cnt[x]. That is the cost to move every target in vertex xx to vertex yy. Define that as the edge's length.We want to do operations with the minimum cost so that the reduced tree has kk leaves. We want to minimize the sum of lengths of the deleted edges. If we look at it in a different way, we want to choose edges to be in the reduced tree with the maximum sum of lengths.For some value of kk, the edges of the reduced tree can be decomposed into kk paths from some vertex to its descendant. We want the total sum of lengths of these paths to be as big as possible. But how do we solve it for every kk from 11 to nn?Let's say k=1k=1. We can choose the path from the root to its furthest leaf. How do we solve for k=2k=2 onwards? It turns out that we can use the optimal solution for some value of kk to make the optimal solution for k+1k+1, by just adding the longest possible available path. That means, for each kk from 11 to nn, we just find the current longest available path and add it to our reduced tree.What if at some point. there are more than one possible longest paths? It can be proven that we can choose any of these paths and the optimal solutions for the next values of kk will still be optimal.The proof for this greedy strategy involves the convexity of the total length as kk goes from 11 to nn. However, we won't explain it in detail here.So to solve the problem, we do DFS in the reachability tree to calculate for each vertex xx, the furthest leaf and the second furthest leaf in its subtree. For each kk from 11 to nn, we add the current longest available path using this precalculation.Time complexity: O(nlogn+mlogm)O(nlog⁡n+mlog⁡m)

Greedy solutionConstruct the subset of leaves one by one. Keep choosing the leaf which will have the least contribution. To simulate this quickly, let h(i)h(i) be the highest ancestor of leaf ii, such that leaf ii is the leaf that minimizes the sum of values on the path from ii to h(i)h(i). Initially, you must take the leaf ii which has h(i)h(i) = the root of the tree. Sort the rest of the leaves in increasing order of the sum of values on the path from ii to h(i)h(i), and add them to the subset in that order.

DP solutionLet dp[i][j]dp[i][j] be the minimum sum of values of nodes when choosing jj leaves in the subtree of ii. If j=0j=0, then dp[i][j]=0dp[i][j]=0. Otherwise, dp[i][j]=val[i]+min(dp[left][x]+dp[right][j−x])dp[i][j]=val[i]+min(dp[left][x]+dp[right][j−x]), where 0≤x≤j0≤x≤j, and leftleft and rightright are the children of ii in the KRT. To optimize this DP for E3, notice that the values of dp[i]dp[i] are convex. dp[i][j]−dp[i][j−1]≤dp[i][j+1]−dp[i][j]dp[i][j]−dp[i][j−1]≤dp[i][j+1]−dp[i][j] holds. Doing the transformation c[j]=min(a[x]+b[j−x])c[j]=min(a[x]+b[j−x]) when arrays aa and bb are convex, can be done by merging the slopes of arrays aa and bb. (See this errorgorn blog, (max, +) convolution part).You can maintain the slopes of the dp in a sorted multiset, and merge the multisets of the left and right children into dp[node]dp[node], and then insert val[node]val[node] into dp[node]dp[node].

