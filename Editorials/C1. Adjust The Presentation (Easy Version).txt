Tutorial2021A - Meaning MeanFor now, let's ignore the floor operation, so an operation is merging two elements $$$a_i$$$ and $$$a_j$$$ into one element $$$\frac{a_i+a_j}{2}$$$.Consider the end result. Each initial element in $$$a$$$ must contribute a fractional coefficient to the final result. It turns out that the sum of the coefficients is fixed (it must be $$$1$$$). That means we can greedily give the biggest values in $$$a$$$ the biggest coefficients.One way to do this is by sorting $$$a$$$ in ascending order. We merge $$$a_1$$$ and $$$a_2$$$, then merge that result with $$$a_3$$$, then merge that result with $$$a_4$$$, and so on until $$$a_n$$$. If we do this, $$$a_n$$$ contributes $$$\frac{1}{2}$$$ times, $$$a_{n-1}$$$ contributes $$$\frac{1}{4}$$$ times, $$$a_{n-2}$$$ contributes $$$\frac{1}{8}$$$ times, and so on. This is the optimal way to get the maximum final result.It turns out that the strategy above is also the optimal strategy for the original version of the problem. So we can simulate that process to get the answer.Time complexity for each test case: $$$O(n\log n)$$$

Tutorial2021B - Maximize MexFor the $$$\operatorname{MEX}$$$ to be at least $$$k$$$, then each non-negative integer from $$$0$$$ to $$$k-1$$$ must appear at least once in the array.First, notice that since there are only $$$n$$$ elements in the array, there are at most $$$n$$$ different values, so the $$$\operatorname{MEX}$$$ can only be at most $$$n$$$. And since we can only increase an element's value, that means every element with values bigger than $$$n$$$ can be ignored.We construct a frequency array $$$\text{freq}$$$ such that $$$\text{freq}[k]$$$ is the number of elements in $$$a$$$ with value $$$k$$$.Notice that the values just need to appear at least once to contribute to the $$$\operatorname{MEX}$$$, so two or more elements with the same value should be split into different values to yield a potentially better result. To find the maximum possible $$$\operatorname{MEX}$$$, we iterate each index $$$k$$$ in the array $$$\text{freq}$$$ from $$$0$$$ to $$$n$$$. In each iteration of $$$k$$$, if we find $$$\text{freq[k]}>0$$$, that means it's possible to have the $$$\operatorname{MEX}$$$ be bigger than $$$k$$$, so we can iterate $$$k$$$ to the next value. Before we iterate to the next value, if we find $$$\text{freq}[k]>1$$$, that indicates duplicates, so we should do an operation to all except one of those values to change them into $$$k+x$$$, which increases $$$\text{freq}[k+x]$$$ by $$$\text{freq}[k]-1$$$ and changes $$$\text{freq}[k]$$$ into $$$1$$$. In each iteration of $$$k$$$, if we find $$$\text{freq}[k]=0$$$, that means, $$$k$$$ is the maximum $$$\operatorname{MEX}$$$ we can get, and we should end the process.Time complexity for each test case: $$$O(n)$$$

Tutorial2021C2 - Adjust The Presentation (Hard Version)Firstly, let's relabel the $$$n$$$ members such that member number $$$i$$$ is the $$$i$$$-th member in the initial line configuration in array $$$a$$$. We also adjust the values in $$$b$$$ (and the future updates) accordingly.For now, let's solve the problem if there are no updates to the array $$$b$$$. Consider the first member who presents. Notice that member $$$1$$$ must be the first one presenting since he/she is at the very front of the line, which means $$$b_1=1$$$ must hold. After this, we insert him/her into any position in the line. However, instead of determining the target position immediately, we make member $$$1$$$ a "pending member" and we will only determine his/her position later on when we need him/her again.To generalize, we can form an algorithm to check whether achieving $$$b$$$ is possible or not. We iterate each element $$$b_i$$$ for each $$$i$$$ from $$$1$$$ to $$$m$$$. While iterating, we maintain a set of pending members which is initially empty, and we maintain who is the next member in the line. When iterating a value of $$$b_i$$$, there are three cases:   If $$$b_i$$$ is equal to the next member in the line, then we can make that member present. And then he/she will become a pending member for the next iterations.  Else, if $$$b_i$$$ is one of the pending members, then we can always set a precise target position when moving that member in the past such that he/she will be at the very front of the line at this very moment. And then, that member will be a pending member again.  Else, then it's impossible to make member $$$b_i$$$ present at this time. To solve the problem with updates, let's observe some special properties of $$$b$$$ if $$$b$$$ is valid. Notice that once a member becomes a pending member, he/she will be a pending member forever. And a member $$$x$$$ becomes a pending member during the first occurence of value $$$x$$$ $$$b$$$. Since the order of members becoming pending must follow the order of the members in the line, that means the first occurence for each value $$$x$$$ in $$$b$$$ must be in chronological order from $$$1$$$ to $$$n$$$. More formally, let's define $$$\text{first}[x]$$$ as follows:   If the value $$$x$$$ appears at least once in $$$b$$$, then $$$\text{first}[x]$$$ is the smallest index $$$i$$$ such that $$$b_i=x$$$.  If the value $$$x$$$ doesn't appear in $$$b$$$, then $$$\text{first}[x]=m+1$$$. Then, for $$$b$$$ to be valid, it must hold that $$$\text{first}[1]\leq\text{first}[2]\leq\ldots\leq\text{first}[n]$$$.To handle the updates, we must maintain the array $$$\text{first}$$$. In order to do that, for each value $$$x$$$ from $$$1$$$ to $$$n$$$, we maintain a set of indices for every occurence of $$$x$$$ in $$$b$$$. The value of $$$\text{first}$$$ is just the minimum value in the set, or $$$m+1$$$ if the set is empty. An update to an element in $$$b$$$ corresponds to two updates among the sets, which corresponds to two updates in array $$$\text{first}$$$.To maintain the status on whether array $$$\text{first}$$$ is non-decreasing or not, we maintain a value $$$c$$$ which represents the number of pairs of adjacent indices $$$(x,x+1)$$$ (for all $$$1\leq x\leq n-1$$$) such that $$$\text{first}[x]\leq\text{first}[x+1]$$$. The array is non-decreasing if and only if $$$c=n-1$$$. For an update to an index $$$x$$$ in $$$\text{first}$$$, we only need to check how pairs $$$(x-1,x)$$$ and $$$(x,x+1)$$$ affect the value of $$$c$$$.Time complexity for each test case: $$$O((n+m+q)\log (n+m))$$$

Tutorial2021D - Boss, ThirstyWe can see it as a grid of square tiles, consisting of $$$n$$$ rows and $$$m$$$ columns. Consider a single row. Instead of looking at the $$$m$$$ tiles, we can look at the $$$m+1$$$ edges between tiles, including the leftmost edge and the rightmost edge. We number the edges from $$$0$$$ to $$$m$$$ such that tile $$$j$$$ ($$$1\leq j\leq m$$$) is the tile between edge $$$j-1$$$ and edge $$$j$$$.For a single row $$$i$$$, choosing a segment of tiles is equivalent to choosing two different edges $$$l$$$ and $$$r$$$ ($$$0\leq l<r\leq m$$$) as the endpoints of the segment, which denotes choosing the tiles from $$$l+1$$$ to $$$r$$$. For each edge $$$j$$$, we can precompute a prefix sum $$$\text{pref}[j]=A_{i,1}+A_{i,2}+\ldots+A_{i,j}$$$. That means, choosing edges $$$l$$$ and $$$r$$$ yields a profit of $$$\text{pref}[r]-\text{pref}[l]$$$.Let's say we've chosen edges $$$l'$$$ and $$$r'$$$ for row $$$i-1$$$ and we want to choose two edges $$$l$$$ and $$$r$$$ for row $$$i$$$ that satisfies the problem requirement. We want to choose a continuous segment that includes at least one chosen tile and at least one unchosen tile from the previous row. A chosen tile that is adjacent to an unchosen tile only appears at the endpoints of the previous segment. That means, to satisfy the requirement, the new segment must strictly contain at least one endpoint of the previous segment. More formally, at least one of the following conditions must be satisfied:   $$$l<l'<r$$$  $$$l<r'<r$$$ Knowing that, we can see that when going from one row to the next, we only need the information for one of the two endpoints, not both.We can solve this with dynamic programming from row $$$1$$$ to row $$$n$$$. For each row, we find the optimal profit for each $$$l$$$ and the optimal profit for each $$$r$$$. We do those two things separately. For each row $$$i$$$, define the following things:  $$$\text{dpL}[i][l]$$$: the optimal profit for the first $$$i$$$ rows if the left endpoint of the last segment is $$$l$$$.  $$$\text{dpR}[i][r]$$$: the optimal profit for the first $$$i$$$ rows if the right endpoint of the last segment is $$$r$$$. Let's say we've calculated all values of $$$\text{dpL}$$$ and $$$\text{dpR}$$$ for row $$$i-1$$$ and we want to calculate for row $$$i$$$. Let $$$l$$$ and $$$r$$$ be the left and right endpoints of the new segment respectively. Let $$$p$$$ be one of the endpoints of the previous segment. Then it must hold that $$$l<p<r$$$, which yields a maximum profit of $$$-\text{pref}[l]+\max(\text{dpL}[i-1][p],\text{dpR}[i-1][p])+\text{pref}[r]$$$.Let's calculate all values of $$$\text{dpR}$$$ first for row $$$i$$$. For each $$$r$$$, we want to consider all corresponding triples $$$(l,p,r)$$$ and find the maximum profit among them. In order to do that, we do three steps:  Make a prefix maximum of $$$-\text{pref}[l]$$$.  Then, for each $$$p$$$, we add $$$\max(\text{dpL[i-1][p]},\text{dpR}[i-1][p])$$$ with the maximum value of $$$-\text{pref}[l]$$$ for all $$$0\leq l<j$$$. And then we make a prefix maximum of those values.  Then, for each $$$r$$$, the value of $$$\text{dpR}[i][r]$$$ is $$$\text{pref}[r]$$$ added by the maximum value for the previous calculation for each $$$p$$$ from $$$0$$$ to $$$r-1$$$. We do the same thing for $$$\text{dpL}$$$ but we use suffix maxmiums instead.After doing all that for every row from $$$1$$$ to $$$n$$$, we find the maximum value of $$$\text{dpL}$$$ and $$$\text{dpR}$$$ in the last row to get the answer.Time complexity of each test case: $$$O(nm)$$$

Tutorial2021E3 - Digital Village (Extreme Version)Since the cost of a path uses the maximum edge weight in the path, we can use a Kruskal-like algorithm that is similar to finding the MST (Minimum Spanning Tree). Initially, the graph has no edges, and we add each edge one by one starting from the smallest values of $$$w_i$$$, while maintaining the connected components in the graph using DSU (Disjoint Set Union).While doing the MST algorithm, we simultaneously construct the reachability tree of the graph, whose structure represents the sequence of mergings of connected components in the algorithm. Each vertex in the reachability tree corresponds to some connected component at some point in time in the algorithm. Each non-leaf vertex in the reachability tree always has two children, which are the two connected components that are merged to form the connected component represented by that vertex, so every time two connected components merge in the algorithm, we make a new vertex in the reachability tree that is connected to its two corresponding children.After doing all that, we've constructed a reachability tree that is a rooted binary tree with $$$2n-1$$$ vertices, $$$n$$$ of which are leaves. For each non-leaf vertex $$$x$$$, we write down $$$\text{weight}[x]$$$ which is the weight of the edge that forms its connected component. For each leaf, we mark it as special if and only if it corresponds to a house that needs internet. Then, for each vertex $$$x$$$, we calculate $$$\text{cnt}[x]$$$, which is the number of special leaves in the subtree of $$$x$$$. These values will be used later.Consider a non-leaf $$$x$$$ in the reachability tree. It can be obtained that two vertices in the original graph corresponding to any two leaves in the subtree of $$$x$$$ can have a path between them in the original graph with a weight of at most $$$\text{weight}[x]$$$.Let's solve for some value of $$$k$$$. For each special vertex $$$x$$$, we want to choose a target vertex $$$y$$$ that's an ancestor of $$$x$$$. Then, we choose a set of $$$k$$$ leaves for the houses with installed servers. We want it such that each chosen target has at least one leaf in its subtree that is a member of the set. The total path cost of this is the sum of $$$\text{weight}[y]$$$ for all chosen targets $$$y$$$.Let's say we've fixed the set of $$$k$$$ leaves. Then, we mark every ancestor of these leaves. If we only consider the marked vertices with the edges between them, we have a reduced tree. For each special leaf, we want to choose its nearest ancestor that is in the reduced tree for its target to get the one with the smallest weight.Knowing this, we can solve the problem in another point of view. Initially, we have the original reachability tree. We want to reduce it into a reduced tree with $$$k$$$ leaves. We want to do it while maintaining the chosen targets of the special leaves and their costs. Initially, for each special leaf, we choose itself as its target. In one operation, we can do the following:   Choose a vertex that's currently a leaf.  Move every target that's currently in that leaf to its parent.  Remove that leaf and the edge connecting it to its parent. We want to do that until the reduced tree has $$$k$$$ leaves.For each edge connecting a vertex $$$x$$$ to its parent $$$y$$$ in the reachability tree, calculate $$$(\text{weight}[y]-\text{weight}[x])\times\text{cnt}[x]$$$. That is the cost to move every target in vertex $$$x$$$ to vertex $$$y$$$. Define that as the edge's length.We want to do operations with the minimum cost so that the reduced tree has $$$k$$$ leaves. We want to minimize the sum of lengths of the deleted edges. If we look at it in a different way, we want to choose edges to be in the reduced tree with the maximum sum of lengths.For some value of $$$k$$$, the edges of the reduced tree can be decomposed into $$$k$$$ paths from some vertex to its descendant. We want the total sum of lengths of these paths to be as big as possible. But how do we solve it for every $$$k$$$ from $$$1$$$ to $$$n$$$?Let's say $$$k=1$$$. We can choose the path from the root to its furthest leaf. How do we solve for $$$k=2$$$ onwards? It turns out that we can use the optimal solution for some value of $$$k$$$ to make the optimal solution for $$$k+1$$$, by just adding the longest possible available path. That means, for each $$$k$$$ from $$$1$$$ to $$$n$$$, we just find the current longest available path and add it to our reduced tree.What if at some point. there are more than one possible longest paths? It can be proven that we can choose any of these paths and the optimal solutions for the next values of $$$k$$$ will still be optimal.The proof for this greedy strategy involves the convexity of the total length as $$$k$$$ goes from $$$1$$$ to $$$n$$$. However, we won't explain it in detail here.So to solve the problem, we do DFS in the reachability tree to calculate for each vertex $$$x$$$, the furthest leaf and the second furthest leaf in its subtree. For each $$$k$$$ from $$$1$$$ to $$$n$$$, we add the current longest available path using this precalculation.Time complexity: $$$O(n\log n+m\log m)$$$

Greedy solutionConstruct the subset of leaves one by one. Keep choosing the leaf which will have the least contribution. To simulate this quickly, let h(i) be the highest ancestor of leaf i, such that leaf i is the leaf that minimizes the sum of values on the path from i to h(i). Initially, you must take the leaf i which has h(i) = the root of the tree. Sort the rest of the leaves in increasing order of the sum of values on the path from i to h(i), and add them to the subset in that order.

DP solutionLet dp[i][j] be the minimum sum of values of nodes when choosing j leaves in the subtree of i. If j=0, then dp[i][j]=0. Otherwise, dp[i][j]=val[i]+min(dp[left][x]+dp[right][j−x]), where 0≤x≤j, and left and right are the children of i in the KRT. To optimize this DP for E3, notice that the values of dp[i] are convex. dp[i][j]−dp[i][j−1]≤dp[i][j+1]−dp[i][j] holds. Doing the transformation c[j]=min(a[x]+b[j−x]) when arrays a and b are convex, can be done by merging the slopes of arrays a and b. (See this errorgorn blog, (max, +) convolution part).You can maintain the slopes of the dp in a sorted multiset, and merge the multisets of the left and right children into dp[node], and then insert val[node] into dp[node].

