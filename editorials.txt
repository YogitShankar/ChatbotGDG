Problem ID: 2057H
Editorial Content:
2057H - Coffee Break
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>

using namespace std;
using vi = vector<int>;
using ll = long long;

vector<ll> a, lhs, rhs;
vector<int> st;

vector<ll> get_right_out(const vector<ll>& a, vector<ll>& res) {
    const int n = a.size();
    st.clear();
    res.assign(n+1, 0);

    for (int i = 0; i < n; ++i) {
        ll x = a[i] + res[i];
        st.push_back(i);

        while (x != 0) {
            if (st.empty()) {
                const int len = i + 1;
                const ll cnt = x / (len + 1);
                res[i+1] += cnt * len;
                x -= cnt * (len + 1);

                if (x != 0) {
                    res[i+1] += x;
                    st.push_back(x-1);
                    x = 0;
                }
            } else {
                const int j = st.back();
                if (x > i - j) {
                    res[i+1] += i - j;
                    st.pop_back();
                    x -= i - j + 1;
                } else {
                    res[i+1] += x;
                    st.back() += x;
                    x = 0;
                }
            }
        }
    }

    return res;
}

vector<ll> get_left_out(vector<ll>& a, vector<ll>& b) {
    reverse(a.begin(), a.end());
    get_right_out(a, b);
    reverse(b.begin(), b.end());
    reverse(a.begin(), a.end());
    return b;
}

void solve() {
    int n; cin >> n;
    
    a.resize(n);
    for (ll& x : a) cin >> x;

    get_right_out(a, lhs);
    get_left_out(a, rhs);

    ll ans = 0;
    for (int i = 0; i < n; ++i)
        cout << lhs[i] + a[i] + rhs[i+1] << ' ';
    cout << '\n';
}

int main() {
    ios::sync_with_stdio(0); cin.tie(0);

    int t = 1;
    cin >> t;
    while (t--) solve();
}
--------------------------------------------------
Problem ID: 2057G
Editorial Content:
2057G - Secret Message
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>

using namespace std;
using pi = pair<int, int>;

void solve() {
    int n, m; cin >> n >> m;
    vector<string> v(n);
    for (auto& w : v) cin >> w;

    auto col = [](int x, int y) {
        int c = (x+2*y)%5;
        if (c < 0) c += 5;
        return c;
    };
    auto cell = [&](int x, int y) {
        if (x < 0 || y < 0 || x >= n || y >= m) return false;
        return v[x][y] == '#';
    };

    array<vector<pi>, 5> colorings;
    for (int i = 0; i < n; ++i)
    for (int j = 0; j < m; ++j) {
        if (!cell(i, j)) continue;
        colorings[col(i, j)].emplace_back(i, j);

        for (int di = -1; di <= 1; ++di)
        for (int dj = -1; dj <= 1; ++dj) {
            if (abs(di) + abs(dj) != 1) continue;
            if (!cell(i+di, j+dj)) {
                colorings[col(i+di, j+dj)].emplace_back(i, j);
            }
        }
    }

    auto coloring = colorings[0];
    for (const auto& w : colorings)
        if (w.size() < coloring.size()) coloring = w;
    for (auto [x, y] : coloring) v[x][y] = 'S';
    for (auto line : v) cout << line << '\n';
}

int main() {
    ios::sync_with_stdio(0); cin.tie(0);

    int t; cin >> t;
    while (t--)
        solve();
}
--------------------------------------------------
Problem ID: 2057F
Editorial Content:
2057F - Formation
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
 
using i64 = long long;
 
void solve() {
    int n, q;
    std::cin >> n >> q;
    std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
    }
    constexpr int LG = 30;
    std::vector<std::array<i64, 4>> events;
    for (int i = 0; i < n; i++) {
        i64 pow = 1, sum = 0;
        i64 dop = 0;
        for (int j = 0; j < LG; j++) {
            if (i - j < 0) {
                break;
            }
            sum += a[i - j];
            i64 L = dop, R;
            if (i - j == 0) {
                R = 2E18;
            } else {
                i64 x = (pow * 4 - 2) * a[i - j - 1] - sum;
                R = x;
                dop = x;
            }
            pow *= 2;
            events.push_back({L, -1, j, sum});
            events.push_back({R, 1, j, sum});
        }
    }
    for (int i = 0; i < q; i++) {
        int x;
        std::cin >> x;
        events.push_back({x, 0, i, 0});
    }
    std::sort(events.begin(), events.end());
    std::vector<int> ans(q); 
    std::vector<std::multiset<i64>> st(LG);
    for (auto item : events) {
        int h = item[0];
        int o = item[1];
        if (o == -1) {
            int j = item[2];
            i64 sum = item[3];
            st[j].insert(sum);
        } else if (o == 1) {
            int j = item[2];
            i64 sum = item[3];
            st[j].erase(st[j].find(sum));
        } else {
            int i = item[2];
            int low = 0, high = 2E9 + 1;
            while (high - low > 1) {
                int mid = (0LL + low + high) / 2;
                int cur = mid;
                i64 pos = 0;
                bool ok = false;
                for (int cnt = 0; cnt < LG; cnt++) {
                    if (st[cnt].empty()) {
                        continue;
                    }
                    i64 neg = *st[cnt].rbegin();
                    pos += cur;
                    cur = (cur + 1) / 2;
                    if (pos - neg <= h) {
                        ok = true;
                        break;
                    }
                }
                if (ok) {
                    low = mid;
                } else {
                    high = mid;
                }
            }
            ans[i] = low;
        }
    }
    for (int i = 0; i < q; i++) {
        std::cout << ans[i] << " \n"[i == q - 1];
    }
}
 
signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
 
    int t = 1;
    std::cin >> t;
 
    while (t--) {
        solve();
    }
}
Alternative solution
// Parallel binary search technique optimizes log^3 => log^2
// SegmentTree might be faster then std::multiset
// sl[i] should equals max(a) at the begining cause IDK how to explain but it's obviously important
 
#include <bits/stdc++.h>
#include <algorithm>
 
using namespace std;
using ll = long long;
 
constexpr int W = 31;
constexpr int C = 1'000'000'000;
 
struct Event {
    int x;
    int ind;
    ll s;
 
    bool operator<(const Event& rhs) const { return x < rhs.x; }
};
 
struct SegmentTree {
    int n;
    vector<ll> sgt;
 
    SegmentTree(int n) : n(n), sgt(2 * n, -1) {}
 
    void Change(int i, ll x) {
        for (sgt[i += n] = x; i != 1; i >>= 1) {
            sgt[i >> 1] = max(sgt[i], sgt[i ^ 1]);
        }
    }
 
    int GlobalMax() const { return sgt[1]; }
};
 
vector<int> solve(const vector<int>& a, const vector<int>& q) {
    const int n = a.size(), m = q.size();
 
    vector<ll> ps(n + 1);
    for (int i = 0; i < n; ++i)
        ps[i + 1] = ps[i] + a[i];
 
    vector<ll> min_x(n, 0);
    vector<vector<pair<int, ll>>> change_sum(W);
 
    vector<Event> events;
    events.reserve(2 * n);
    for (int j = 1; j <= W && j <= n; ++j) {
        events.clear();
 
        for (int i = j - 1; i < n; ++i) {
            min_x[i] = max(min_x[i], 1 + ((a[i - j + 1] - 1ll) << (j - 1)));
            ll max_x = i == j - 1 ? 2ll * C : ((ll)a[i - j] << j);
            max_x = min<ll>(max_x, a[i] + C);
 
            if (min_x[i] > max_x) {
                continue;
            }
            const ll xsum = ps[i + 1] - ps[i + 1 - j];
            events.push_back(Event{(int)min_x[i], i, xsum});
            events.push_back(Event{(int)max_x + 1, i, -1});
        }
        sort(events.begin(), events.end());
 
        SegmentTree sgt(n);
        const int k = events.size();
        ll was_max = -1;
 
        for (int i = 0; i < k;) {
            int s = i;
            while (i < k && events[i].x == events[s].x) {
                sgt.Change(events[i].ind, events[i].s);
                ++i;
            }
            ll cur_max = sgt.GlobalMax();
            if (cur_max != was_max) {
                change_sum[j - 1].emplace_back(events[s].x, cur_max);
                was_max = cur_max;
            }
        }
    }
 
    vector<int> sl(m, *max_element(a.begin(), a.end())), sr(m, 2 * C + 1);
 
    vector<int> ord_to_check(m);
    iota(ord_to_check.begin(), ord_to_check.end(), 0);
    for (int iter = 32; iter--;) {
        vector<int> sm(m);
        for (int i = 0; i < m; ++i) {
            sm[i] = sl[i] + (sr[i] - sl[i]) / 2;
        }
        sort(ord_to_check.begin(), ord_to_check.end(), [&](int lhs, int rhs) {
            return sm[lhs] < sm[rhs];
        });
 
        vector<int> ptr(W);
        vector<ll> actual_sum(W, -1);
        for (int i : ord_to_check) {
            const int x = sm[i];
 
 
            ll upper_sum = 0;
            bool nice = false;
            for (int w = 0; w < W; ++w) {
                int& j = ptr[w];
                while (j < change_sum[w].size() && change_sum[w][j].first <= x) {
                    actual_sum[w] = change_sum[w][j++].second;
                }
                upper_sum += 1 + ((x - 1) >> w);
                if (upper_sum - actual_sum[w] <= q[i]) {
                    nice = true;
                }
            }
 
            if (nice) {
                sl[i] = sm[i];
            } else {
                sr[i] = sm[i];
            }
        }
    }
 
    return sl;
}
 
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
 
    int t = 1;
    cin >> t;
    while (t--) {
        int n, q;
        cin >> n >> q;
        vector<int> a(n), k(q);
        for (int& x : a)
            cin >> x;
        for (int& x : k)
            cin >> x;
 
        auto ans = solve(a, k);
        for (int x : ans)
            cout << x << ' ';
        cout << '\n';
    }
}
--------------------------------------------------
Problem ID: 2057E2
Editorial Content:
2057E2 - Another Exercise on Graphs (hard version)
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>

using i64 = long long;

struct DSU {
    std::vector<int> p, sz, h;
    
    DSU(int n = 0) : p(n), sz(n, 1), h(n) { 
        std::iota(p.begin(), p.end(), 0); 
    }

    int leader(int x) {
        if (x == p[x]) {
            return x;
        }
        return leader(p[x]);
    }

    bool same(int x, int y) {
        return leader(x) == leader(y);
    }

    bool merge(int x, int y) {
        x = leader(x);
        y = leader(y);
        if (x == y) return false;
        if (h[x] < h[y]) {
            std::swap(x, y);
        }
        if (h[x] == h[y]) {
            ++h[x];
        }
        sz[x] += sz[y];
        p[y] = x;
        return true;
    }

    int size(int x) { 
        return sz[leader(x)]; 
    }
};

void solve() {
    int n, m, q;
    std::cin >> n >> m >> q;
    std::vector<std::array<int, 3>> edges(m);
    for (int i = 0; i < m; i++) {
        int v, u, w;
        std::cin >> v >> u >> w;
        v--, u--;
        edges[i] = {v, u, w};
    }
    std::sort(edges.begin(), edges.end(), [&](const std::array<int, 3> &a, const std::array<int, 3> &b) {
        return a[2] < b[2];
    });
    constexpr int INF = 1e9;
    std::vector<int> value(n);
    std::vector<std::vector<std::vector<int>>> dis(n, std::vector<std::vector<int>>(n, std::vector<int>(n, INF)));
    for (int i = 0; i < n; i++) {
        dis[0][i][i] = 0;
    }
    for (auto edge : edges) {
        int v = edge[0], u = edge[1];
        dis[0][v][u] = dis[0][u][v] = 1;
    }
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dis[0][i][j] = std::min(dis[0][i][j], dis[0][i][k] + dis[0][k][j]);
            }
        }
    }
    int p = 1;
    DSU dsu(n);
    for (auto edge : edges) {
        int v = edge[0], u = edge[1], w = edge[2];
        if (dsu.merge(v, u)) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    dis[p][i][j] = std::min({dis[p - 1][i][j], dis[p - 1][i][v] + dis[p - 1][u][j], dis[p - 1][i][u] + dis[p - 1][v][j]});
                }
            }
            value[p++] = w;
        }
    }
    for (int i = 0; i < q; i++) {
        int v, u, k;
        std::cin >> v >> u >> k;
        v--, u--;
        int low = 0, high = n - 1;
        while (high - low > 1) {
            int mid = (low + high) / 2;
            if (dis[mid][v][u] < k) {
                high = mid;
            } else {
                low = mid;
            }
        }
        std::cout << value[high] << " \n"[i == q - 1];
    }
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int t = 1;
    std::cin >> t;

    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 2057E1
Editorial Content:
2057E1 - Another Exercise on Graphs (Easy Version)
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
 
using i64 = long long;
 
void solve() {
    int n, m, q;
    std::cin >> n >> m >> q;
    std::vector<std::array<int, 3>> edges(m);
    for (int i = 0; i < m; i++) {
        int v, u, w;
        std::cin >> v >> u >> w;
        v--, u--;
        edges[i] = {v, u, w};
    }
    std::sort(edges.begin(), edges.end(), [&](const std::array<int, 3> &a, const std::array<int, 3> &b) {
        return a[2] < b[2];
    });
    constexpr int INF = 1e9;
    std::vector<int> value(m + 1);
    std::vector<std::vector<std::vector<int>>> dis(m + 1, std::vector<std::vector<int>>(n, std::vector<int>(n, INF)));
    for (int i = 0; i < n; i++) {
        dis[0][i][i] = 0;
    }
    for (auto edge : edges) {
        int v = edge[0], u = edge[1];
        dis[0][v][u] = dis[0][u][v] = 1;
    }
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dis[0][i][j] = std::min(dis[0][i][j], dis[0][i][k] + dis[0][k][j]);
            }
        }
    }
    int p = 1;
    for (auto edge : edges) {
        int v = edge[0], u = edge[1], w = edge[2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dis[p][i][j] = std::min({dis[p - 1][i][j], dis[p - 1][i][v] + dis[p - 1][u][j], dis[p - 1][i][u] + dis[p - 1][v][j]});
            }
        }
        value[p++] = w;
    }
    for (int i = 0; i < q; i++) {
        int v, u, k;
        std::cin >> v >> u >> k;
        v--, u--;
        int low = 0, high = m;
        while (high - low > 1) {
            int mid = (low + high) / 2;
            if (dis[mid][v][u] < k) {
                high = mid;
            } else {
                low = mid;
            }
        }
        std::cout << value[high] << " \n"[i == q - 1];
    }
}
 
signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
 
    int t = 1;
    std::cin >> t;
 
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 2057D
Editorial Content:
2057D - Gifts Order
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>

using i64 = long long;

template<class Info>
struct SegmentTree {
    int n;
    std::vector<Info> info;

    SegmentTree() : n(0) {}

    SegmentTree(int n_, Info v_ = Info()) {
        init(n_, v_);
    }

    template<class T>
    SegmentTree(std::vector<T> init_) {
        init(init_);
    }

    void init(int n_, Info v_ = Info()) {
        init(std::vector<Info>(n_, v_));
    }

    template<class T>
    void init(std::vector<T> init_) {
        n = init_.size();
        int sz = (1 << (std::__lg(n - 1) + 1));
        info.assign(sz * 2, Info());
        std::function<void(int, int, int)> build = [&](int v, int l, int r) {
            if (l == r) {
                info[v] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(v + v, l, m);
            build(v + v + 1, m + 1, r);
            info[v] = info[v + v] + info[v + v + 1];
        };
        build(1, 0, n - 1);
    }

    Info rangeQuery(int v, int l, int r, int tl, int tr) {
        if (r < tl || l > tr) {
            return Info();
        }
        if (l >= tl && r <= tr) {
            return info[v];
        }
        int m = (l + r) / 2;
        return rangeQuery(v + v, l, m, tl, tr) + rangeQuery(v + v + 1, m + 1, r, tl, tr);
    }

    Info rangeQuery(int l, int r) {
        return rangeQuery(1, 0, n - 1, l, r);
    }

    void modify(int v, int l, int r, int i, const Info &x) {
        if (l == r) {
            info[v] = x;
            return;
        }
        int m = (l + r) / 2;
        if (i <= m) {
            modify(v + v, l, m, i, x);
        } else {
            modify(v + v + 1, m + 1, r, i, x);
        }
        info[v] = info[v + v] + info[v + v + 1];
    }

    void modify(int i, const Info &x) {
        modify(1, 0, n - 1, i, x);
    }

    Info query(int v, int l, int r, int i) {
        if (l == r) {
            return info[v];
        }
        int m = (l + r) / 2;
        if (i <= m) {
            return query(v + v, l, m, i);
        } else {
            return query(v + v + 1, m + 1, r, i);
        }
    }

    Info query(int i) {
        return query(1, 0, n - 1, i);
    }
};

const int INF = 1E9;

struct Info {
    int min1, min2, max1, max2, ans1, ans2;

    Info() : min1(INF), min2(INF), max1(-INF), max2(-INF), ans1(0), ans2(0) {}

    Info(std::pair<int, int> x) : min1(x.first), min2(x.second), max1(x.first), max2(x.second), ans1(0), ans2(0) {}
};

Info operator+(const Info &a, const Info &b) {
    Info res;
    res.min1 = std::min(a.min1, b.min1);
    res.min2 = std::min(a.min2, b.min2);
    res.max1 = std::max(a.max1, b.max1);
    res.max2 = std::max(a.max2, b.max2);
    res.ans1 = std::max({a.ans1, b.ans1, b.max1 - a.min1});
    res.ans2 = std::max({a.ans2, b.ans2, a.max2 - b.min2});
    return res;
}

void solve() {
    int n, q;
    std::cin >> n >> q;
    std::vector<int> a(n);
    std::vector<std::pair<int, int>> t(n);
    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
        t[i] = {a[i] - i, a[i] + i - n + 1};
    }
    SegmentTree<Info> st(t);
    auto query = [&]() {
        return std::max(st.info[1].ans1, st.info[1].ans2);
    };
    std::cout << query() << "\n";
    for (int i = 0; i < q; i++) {
        int p, x;
        std::cin >> p >> x;
        p--;
        t[p] = {x - p, x + p - n + 1};
        st.modify(p, t[p]);
        std::cout << query() << "\n";
    }
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int t;
    std::cin >> t;

    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 2057C
Editorial Content:
2057C - Trip to the Olympiad
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
 
using i64 = long long;
 
void solve() {
    int l, r;
    std::cin >> l >> r;
    int k = 31 - __builtin_clz(l ^ r);
    int a = l | ((1 << k) - 1), b = a + 1, c = (a == l ? r : l);
    std::cout << a << " " << b << " " << c << "\n";
}
 
signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
 
    int t = 1;
    std::cin >> t;
 
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 2057B
Editorial Content:
2057B - Gorilla and the Exam
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>

using i64 = long long;

void solve() {
    int n, k;
    std::cin >> n >> k;
    std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
    }
    std::sort(a.begin(), a.end());
    std::vector<int> cnt = {1};
    for (int i = 1; i < n; i++) {
        if (a[i] == a[i - 1]) {
            cnt.back()++;
        } else {
            cnt.emplace_back(1);
        }
    }
    std::sort(cnt.begin(), cnt.end());
    int m = cnt.size();
    for (int i = 0; i < m - 1; i++) {
        if (cnt[i] > k) {
            std::cout << m - i << "\n";
            return;
        }
        k -= cnt[i];
    }
    std::cout << 1 << "\n";
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int t = 1;
    std::cin >> t;

    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 2057A
Editorial Content:
2057A - MEX Table
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
 
using i64 = long long;
 
void solve() {
    int n, m;
    std::cin >> n >> m;
    std::cout << std::max(n, m) + 1 << "\n";
}
 
signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
 
    int t = 1;
    std::cin >> t;
    
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 2056F2
Editorial Content:
2056F2 - Xor of Median (Hard Version)
Hints
Hint 1
The order of the sequence doesn't matter. What if we fix the sequence $$$\text{cnt}$$$ and then calculate its contribution to the answer?
Hint 2
By Lucas's theorem the contribution is odd iff for each set bit in $$$n$$$ there is exactly one $$$i$$$ such that $$$\text{cnt}_i$$$ has this bit set, and $$$\sum\limits_{i = 0}^{m - 1} \text{cnt}_i = n$$$. In other words, $$$\text{cnt}$$$ has to partition all set bits in $$$n$$$. For a fixed $$$\text{cnt}$$$ with an odd contribution, what will be the median?
Hint 3
There is a very big element in $$$\text{cnt}$$$.
Hint 4
Since $$$\text{cnt}$$$ partitions the bits of $$$n$$$, there will be $$$i$$$ which has it's most significant bit. This means that $$$2\text{cnt}_i > n$$$, so $$$i$$$ will always be the median.
Hint 5
Suppose there are $$$p$$$ non-zero elements in $$$\text{cnt}$$$. We can partition all set bits of $$$n$$$ into $$$p$$$ non-empty subsequences and then choose which of the $$$m$$$ numbers will occur. How can we calculate the answer now?
Hint 6
The only time we use the value of $$$n$$$ is when we partition all of it's set bits into subsequences. That means that the answer only depends on the number of set bits in $$$n$$$, not on $$$n$$$ itself. This allows us to solve the easy version by fixing the value of $$$p$$$ and the value of the median.
Hint 7
To solve the hard version use Lucas's theorem again and do digit dp or SOS-dp.
Hint 1
The order of the sequence doesn't matter. What if we fix the sequence $$$\text{cnt}$$$ and then calculate its contribution to the answer?
Hint 2
By Lucas's theorem the contribution is odd iff for each set bit in $$$n$$$ there is exactly one $$$i$$$ such that $$$\text{cnt}_i$$$ has this bit set, and $$$\sum\limits_{i = 0}^{m - 1} \text{cnt}_i = n$$$. In other words, $$$\text{cnt}$$$ has to partition all set bits in $$$n$$$. For a fixed $$$\text{cnt}$$$ with an odd contribution, what will be the median?
Hint 3
There is a very big element in $$$\text{cnt}$$$.
Hint 4
Since $$$\text{cnt}$$$ partitions the bits of $$$n$$$, there will be $$$i$$$ which has it's most significant bit. This means that $$$2\text{cnt}_i > n$$$, so $$$i$$$ will always be the median.
Hint 5
Suppose there are $$$p$$$ non-zero elements in $$$\text{cnt}$$$. We can partition all set bits of $$$n$$$ into $$$p$$$ non-empty subsequences and then choose which of the $$$m$$$ numbers will occur. How can we calculate the answer now?
Hint 6
The only time we use the value of $$$n$$$ is when we partition all of it's set bits into subsequences. That means that the answer only depends on the number of set bits in $$$n$$$, not on $$$n$$$ itself. This allows us to solve the easy version by fixing the value of $$$p$$$ and the value of the median.
Hint 7
To solve the hard version use Lucas's theorem again and do digit dp or SOS-dp.
Solution
The order of the sequence doesn't matter, so let's fix the sequence $$$\text{cnt}$$$ and calculate its contribution to the answer.
For a fixed $$$\text{cnt}$$$, the number of ways to order $$$a$$$ is $$$\binom{n}{\text{cnt}_0, \text{cnt}_1, \ldots, \text{cnt}_{m - 1}}$$$. By Lucas's theorem the contribution is odd iff for each set bit in $$$n$$$ there is exactly one $$$i$$$ such that $$$\text{cnt}_i$$$ has this bit set, and $$$\sum\limits_{i = 0}^{m - 1} \text{cnt}_i = n$$$. In other words, $$$\text{cnt}$$$ has to partition all set bits in $$$n$$$.
Since $$$\text{cnt}$$$ partitions the bits of $$$n$$$, there will be $$$i$$$ which has it's most significant bit. This means that $$$2\text{cnt}_i > n$$$, so $$$i$$$ will always be the median.
Suppose there are $$$p$$$ non-zero elements in $$$\text{cnt}$$$. We can partition all set bits of $$$n$$$ into $$$p$$$ non-empty subsequences and then choose which of the $$$m$$$ numbers will occur.
The only time we use the value of $$$n$$$ is when we partition all of it's set bits into subsequences. That means that the answer only depends on the number of set bits in $$$n$$$, not on $$$n$$$ itself.
So let's fix $$$p$$$ as the number of non-zero elements in $$$\text{cnt}$$$ and $$$x$$$ as the median. Denote $$$b$$$ as the number of set bits in $$$n$$$. There are $$$S(b, p)$$$ ways to partition the bits into $$$p$$$ non-empty subsequences, where $$$S$$$ denotes Stirling number of the second kind. There are $$$\binom{x}{p - 1}$$$ ways to choose which other elements will have non-zero $$$\text{cnt}$$$, because the median will always have the largest value and non-zero $$$\text{cnt}_i$$$ must be non-decreasing.
The answer is then $$$\oplus_{p = 1}^b \oplus_{x = 0}^{m - 1} \left(S(b, p) \bmod 2\right) \cdot \left(\binom{x}{p - 1} \bmod 2\right) \cdot x$$$, which we can calculate in $$$O(km)$$$, which solves the easy version.
To solve the hard version we can use Lucas's theorem again to get that the contribution of $$$x$$$ to the answer is the XOR of $$$S(b, p + 1) \bmod 2$$$ over all submasks $$$p$$$ of $$$x$$$. We can limit $$$p$$$ to be between $$$0$$$ and $$$b - 1$$$.
That means that only $$$L = \lceil \log_2 b \rceil$$$ last bits of $$$x$$$ determine whether $$$x$$$ contributes something to the answer. We can find which of $$$2^L$$$ of them will have an odd contribution by setting $$$dp_p = S(b, p + 1) \bmod 2$$$, and calculating it's SOS-dp. Then for fixed $$$L$$$ last bits it is easy to find the XOR of all $$$x < m$$$ with those bits.
Note that $$$S(n, k)$$$ is odd iff $$$(n - k) \text{&} \frac{k - 1}{2} = 0$$$, which we can derive from the recurrence, combinatorics, google or OEIS.
This solves the problem in $$$O(b \log b) = O(k \log k)$$$.
F1 code
#include <bits/stdc++.h>
 
using namespace std;
 
int C(int n, int k) {
    return (n & k) == k;
}
 
int S(int n, int k) {
    return !(n - k & (k - 1 >> 1));
}
 
int brute_partition(int n, int m) {
    vector<int> cnt;
    int ans = 0;
    for(int k = 1; k <= n; k++) {
        if(!S(n, k)) continue;
        for(int median = 1; median < m; median++) {
            if(C(median, k - 1)) ans ^= median;
        }
    }
    return ans;
}
 
void solve() {
    int k, m;
    string s;
    cin >> k >> m >> s;
    int n = 0;
    for(auto &i : s) n += i & 1;
    int ans = brute_partition(n, m);
    cout << ans << '\n';
}
 
signed main() {
    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int ttt = 1;
    cin >> ttt;
    while(ttt--) {
        solve();
    }
}
F2 code
#include <bits/stdc++.h>

using namespace std;

int S(int n, int k) {
    return !(n - k & (k - 1 >> 1));
}

int get(int n, int m) {
    int L = __lg(n) + 1;
    int up = 1 << L;
    vector<int> dp(up);
    for(int i = 0; i < n; i++) dp[i] = S(n, i + 1);
    for(int j = 0; j < L; j++) {
        for(int i = 0; i < up; i++) {
            if(i >> j & 1) dp[i] ^= dp[i ^ (1 << j)];
        }
    }
    int ans = 0;
    for(int lst = 0; lst < up && lst < m; lst++) {
        if(!dp[lst]) continue;
        int cnt = m - 1 - lst >> L;
        if(cnt & 1 ^ 1) ans ^= lst;
        if(cnt % 4 == 0) ans ^= cnt << L;
        else if(cnt % 4 == 1) ans ^= 1ll << L;
        else if(cnt % 4 == 2) ans ^= cnt + 1 << L;
        else ans ^= 0;
    }
    return ans;
}

void solve() {
    int k, m;
    string s;
    cin >> k >> m >> s;
    int n = 0;
    for(auto &i : s) n += i & 1;
    int ans = get(n, m);
    cout << ans << '\n';
}

signed main() {
    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int ttt = 1;
    cin >> ttt;
    while(ttt--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 2056F1
Editorial Content:
2056F1 - Xor of Median (Easy Version)
--------------------------------------------------
Problem ID: 2056E
Editorial Content:
2056E - Nested Segments
Hints
Hint 1
Forget about counting. What is the maximum size of $$$T$$$ if $$$m = 0$$$?
Hint 2
It is $$$2n - 1$$$. What if $$$m$$$ isn't $$$0$$$?
Hint 3
It is still $$$2n - 1$$$. To prove this represent a
good
set as a forest.
Hint 4
We can always add $$$[1, n]$$$ and $$$[i, i]$$$ for all $$$1 \le i \le n$$$ to $$$S$$$. Now the tree of $$$S$$$ has exactly $$$n$$$ leaves. What if a vertex has more than $$$2$$$ children?
Hint 5
What is the number of solutions when $$$m = 0$$$?
Hint 6
It is the number of full binary trees with $$$n$$$ leaves, which is $$$C_{n - 1}$$$, where $$$C$$$ denotes the Catalan's sequence. Extend this idea to count the number of solutions for a general tree of $$$S$$$.
Hint 1
Forget about counting. What is the maximum size of $$$T$$$ if $$$m = 0$$$?
Hint 2
It is $$$2n - 1$$$. What if $$$m$$$ isn't $$$0$$$?
Hint 3
It is still $$$2n - 1$$$. To prove this represent a
good
set as a forest.
Hint 4
We can always add $$$[1, n]$$$ and $$$[i, i]$$$ for all $$$1 \le i \le n$$$ to $$$S$$$. Now the tree of $$$S$$$ has exactly $$$n$$$ leaves. What if a vertex has more than $$$2$$$ children?
Hint 5
What is the number of solutions when $$$m = 0$$$?
Hint 6
It is the number of full binary trees with $$$n$$$ leaves, which is $$$C_{n - 1}$$$, where $$$C$$$ denotes the Catalan's sequence. Extend this idea to count the number of solutions for a general tree of $$$S$$$.
Solution
Any
good
set has a tree-like structure.
Specifically, represent $$$S$$$ as a forest the following way: segment $$$[l, r]$$$ has a parent $$$[L, R]$$$ iff $$$[l, r] \in [L, R]$$$ and $$$R - L + 1$$$ is minimized (its parent is the shortest interval in which it lies). This segment is unique (or does not exist), because there can't be two segments with minimum length that cover $$$[l, r]$$$, as they would partially intersect otherwise.
Notice that we can always add $$$[1, n]$$$ and $$$[i, i]$$$ for all $$$1 \le i \le n$$$ if they aren't in $$$S$$$ yet. Now the forest of $$$S$$$ is a tree with exactly $$$n$$$ leaves.
Suppose $$$[L, R]$$$ has $$$k$$$ children $$$[l_1, r_1], [l_2, r_2], \ldots, [l_k, r_k]$$$. If $$$k > 2$$$, we can always add $$$[l_1, r_2]$$$ to $$$S$$$, which decreases the number of children of $$$[L, R]$$$ by $$$1$$$ and increases the size of $$$S$$$ by $$$1$$$.
Therefore, in the optimal solution each segment has at most $$$2$$$ children. Having exactly one child is impossible, as we have added all $$$[i, i]$$$, so every index of $$$[L, R]$$$ is covered by its children.
This means that we have a tree where each vertex has either $$$0$$$ or $$$2$$$ children, which is a full binary tree.
We have $$$n$$$ leaves, and every full binary tree with $$$n$$$ leaves has exactly $$$2n - 1$$$ vertices, so this is always the optimal size of $$$T$$$ regardless of $$$S$$$.
To count the number of $$$T$$$, notice that when $$$m = 0$$$ the answer is the number of full binary trees with $$$n$$$ leaves, which is $$$C_{n - 1}$$$, where $$$C$$$ denotes the Catalan's sequence.
To extend this to a general tree, we can add $$$[1, n]$$$ and $$$[i, i]$$$ for all $$$1 \le i \le n$$$ to $$$S$$$.
Now suppose $$$[L, R]$$$ has $$$k \ge 2$$$ children $$$[l_1, r_1], [l_2, r_2], \ldots, [l_k, r_k]$$$. We need to merge some children. We can treat $$$[l_1, r_1]$$$ as $$$[1, 1]$$$, $$$[l_2, r_2]$$$ as $$$[2, 2]$$$, etc. This is now the same case as $$$m = 0$$$, so there are $$$C_{k - 1}$$$ ways to merge children of $$$[L, R]$$$.
Each vertex is independent of each other, so the answer is $$$\prod C_{c_v - 1}$$$ over all non-leaves $$$v$$$, where $$$c_v$$$ is the number of children of $$$v$$$.
We can construct the tree in $$$O(n \log n)$$$ by definition or in $$$O(n)$$$ using a stack.
Code
#include <bits/stdc++.h>

using namespace std;

const int mod = 998244353;
const int MAX = 4e5 + 42;

int fact[MAX], inv[MAX], inv_fact[MAX];

int C(int n, int k) {
    if(n < k || k < 0) return 0;
    return (long long) fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod;
}

int Cat(int n) {
    return (long long) C(2 * n, n) * inv[n + 1] % mod;
}

int binpow(int x, int n) {
    int ans = 1;
    while(n) {
        if(n & 1) ans = (long long) ans * x % mod;
        n >>= 1;
        x = (long long) x * x % mod;
    }
    return ans;
}

void solve() {
    int n, m;
    cin >> n >> m;
    int initial_m = m;
    vector<pair<int, int>> a(m);
    for(auto &[l, r] : a) {
        cin >> l >> r;
    }
    bool was_full = 0;
    vector<int> was_single(n + 1);
    for(auto [l, r] : a) was_full |= (r - l + 1 == n);
    for(auto [l, r] : a) {
        if(l == r) was_single[l] = 1;
    }
    if(!was_full) {
        a.push_back({1, n});
        m++;
    }
    for(int i = 1; i <= n; i++) {
        if(!was_single[i] && n != 1) {
            a.push_back({i, i});
            m++;
        }
    }
    for(auto &[l, r] : a) r = -r;
    sort(a.begin(), a.end());
    vector<int> deg(m);
    for(int i = 0; i < m; i++) {
        int j = i + 1;
        while(j < m) {
            if(-a[i].second < a[j].first) break;
            deg[i]++;
            j = upper_bound(a.begin(), a.end(), make_pair(-a[j].second, 1)) - a.begin();
        }
    }
    for(auto &[l, r] : a) r = -r;
    int ans = 1;
    for(int i = 0; i < m; i++) {
        if(deg[i] > 0) {
            assert(deg[i] >= 2);
            ans = (long long) ans * Cat(deg[i] - 1) % mod;
        }
    }
    cout << ans << '\n';
}

signed main() {
    fact[0] = 1;
    for(int i = 1; i < MAX; i++) fact[i] = (long long) fact[i - 1] * i % mod;
    inv_fact[MAX - 1] = binpow(fact[MAX - 1], mod - 2);
    for(int i = MAX - 1; i; i--) inv_fact[i - 1] = (long long) inv_fact[i] * i % mod;
    assert(inv_fact[0] == 1);
    for(int i = 1; i < MAX; i++) inv[i] = (long long) inv_fact[i] * fact[i - 1] % mod;
    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int ttt = 1;
    cin >> ttt;
    while(ttt--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 2056D
Editorial Content:
2056D - Unique Median
Hints
Hint 1
Solve the problem when $$$a_i \le 2$$$.
Hint 2
Assign $$$b_i = 1$$$ if $$$a_i = 2$$$ and $$$b_i = -1$$$ if $$$a_i = 1$$$ and calculate the number of bad subarrays.
Hint 3
Extend this solution for $$$a_i \le 10$$$, however, you need to take overcounting into account.
Hint 1
Solve the problem when $$$a_i \le 2$$$.
Hint 2
Assign $$$b_i = 1$$$ if $$$a_i = 2$$$ and $$$b_i = -1$$$ if $$$a_i = 1$$$ and calculate the number of bad subarrays.
Hint 3
Extend this solution for $$$a_i \le 10$$$, however, you need to take overcounting into account.
Solution
When is a subarray $$$a[l, r]$$$ not good?
If $$$r - l + 1$$$ is odd, $$$a[l, r]$$$ can't be bad. Otherwise, suppose the median of $$$a[l, r]$$$ is $$$x$$$. Then there need to be exactly $$$\frac{r - l + 1}{2}$$$ elements in $$$a[l, r]$$$ that are $$$\le x$$$ and exactly $$$\frac{r - l + 1}{2}$$$ that are $$$> x$$$.
This gives us an idea to calculate the number of bad subarrays with a median of $$$x$$$.
Create another array $$$b$$$ of size $$$n$$$, where $$$b_i = -1$$$ if $$$a_i \le x$$$ and $$$b_i = 1$$$ otherwise.
$$$a[l, r]$$$, which has a median of $$$x$$$, is bad if and only if $$$\sum\limits_{i = l}^r b_i = 0$$$ and $$$r - l + 1$$$ is even.
Notice that the second condition is not needed, as the sum of an odd length subarray of $$$b$$$ is always odd, so it can't be zero.
Therefore, $$$a[l, r]$$$ with a median of $$$x$$$ is bad iff $$$\sum\limits_{i = l}^r b_i = 0$$$.
If there is no $$$x$$$ in $$$[l, r]$$$, then the median of $$$a[l, r]$$$ trivially can't be equal to $$$x$$$.
If there is an occurrence of $$$x$$$ in $$$a[l, r]$$$ and $$$\sum\limits_{i = l}^r b_i = 0$$$, notice that the median of $$$a[l, r]$$$ will always be exactly $$$x$$$. This is true because $$$\frac{r - l + 1}{2}$$$ smallest elements of $$$a[l, r]$$$ are all $$$\le x$$$, and there is an occurrence of $$$x$$$, so $$$\frac{r - l + 1}{2}$$$-th smallest element must be $$$x$$$.
This allows us to simply count the number of subarrays of $$$b$$$ with a sum of $$$0$$$ and with an occurrence of $$$x$$$ to count the number of bad subarrays with median $$$x$$$.
We can subtract that value from $$$\frac{n(n + 1)}{2}$$$ for all $$$x$$$ between $$$1$$$ and $$$A = 10$$$ to solve the problem in $$$O(nA)$$$.
Code
#include <bits/stdc++.h>

using namespace std;

const int MAX = 11;

int main() {
    int tests;
    cin >> tests;
    for(int test = 0; test < tests; test++) {
        int n;
        cin >> n;
        vector<int> a(n);
        for(auto &i : a) {
            cin >> i;
        }
        long long ans = 0;
        for(int x = 1; x < MAX; x++) {
            vector<int> b(n);
            for(int i = 0; i < n; i++) {
                b[i] = (a[i] > x? 1 : -1);
            }
            int sum = n;
            vector<int> pref(n);
            for(int i = 0; i < n; i++) {
                pref[i] = sum;
                sum += b[i];
            }
            vector<int> cnt(2 * n + 1);
            sum = n;
            int j = 0;
            for(int i = 0; i < n; i++) {
                if(a[i] == x) {
                    while(j <= i) {
                        cnt[pref[j]]++;
                        j++;
                    }
                }
                sum += b[i];
                ans += cnt[sum];
            }
        }
        ans = 1ll * n * (n + 1) / 2 - ans;
        cout << ans << '\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2056C
Editorial Content:
2056C - Palindromic Subsequences
Hints
Hint 1
Analyze the example with $$$n = 6$$$.
Hint 2
If $$$[a_1, a_2, \ldots, a_k, a_{n - k + 1}, a_{n - k + 2}, \ldots, a_n]$$$ is a palindrome, then $$$[a_1, a_2, \ldots, a_k, a_i, a_{n - k + 1}, a_{n - k + 2}, \ldots, a_n]$$$ is also a palindrome for all $$$k < i < n - k + 1$$$.
Hint 1
Analyze the example with $$$n = 6$$$.
Hint 2
If $$$[a_1, a_2, \ldots, a_k, a_{n - k + 1}, a_{n - k + 2}, \ldots, a_n]$$$ is a palindrome, then $$$[a_1, a_2, \ldots, a_k, a_i, a_{n - k + 1}, a_{n - k + 2}, \ldots, a_n]$$$ is also a palindrome for all $$$k < i < n - k + 1$$$.
Solution
If $$$[a_1, a_2, \ldots, a_k, a_{n - k + 1}, a_{n - k + 2}, \ldots, a_n]$$$ is a palindrome, then $$$[a_1, a_2, \ldots, a_k, a_i, a_{n - k + 1}, a_{n - k + 2}, \ldots, a_n]$$$ is also a palindrome for all $$$k < i < n - k + 1$$$, because we make it's length odd and add $$$a_i$$$ to the middle.
We can use this to create a sequence with a big value of $$$g$$$. However, we shouldn't create a palindrome of a greater length than $$$2k + 1$$$ by using the fact above.
That make us try something like $$$a = [1, 2, 3, \ldots, n - 2, 1, 2]$$$. $$$f(a) = 3$$$ here, and any of $$$[a_1, a_i, a_{n - 1}]$$$ for $$$1 < i < n - 1$$$ and $$$[a_2, a_i, a_n]$$$ for $$$2 < i < n$$$ are palindromes, which means that $$$g(a) = 2(n - 3) = 2n - 6$$$.
This construction works for $$$n \ge 7$$$, so we have to handle $$$n = 6$$$ separately.
We can also use the construction from the example with $$$n = 6$$$ directly: $$$a = [1, 1, 2, 3, 4, \ldots, n - 3, 1, 2]$$$, which has $$$g(a) = 3n - 11$$$.
Code
#include <bits/stdc++.h>

using namespace std;

void solve() {
    int n;
    cin >> n;
    if (n == 6) {
        cout << "1 1 2 3 1 2\n";
    }
    else if(n == 9) {
        cout << "7 3 3 7 5 3 7 7 3\n";
    }
    else if(n == 15) {
        cout << "15 8 8 8 15 5 8 1 15 5 8 15 15 15 8\n";
    }
    else {
        for(int i = 1; i <= n - 2; i++) cout << i << " "; cout << "1 2\n";
    }
}


signed main() {
    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int ttt = 1;
    cin >> ttt;
    while(ttt--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 2056B
Editorial Content:
2056B - Find the Permutation
Hints
Hint 1
"It can be proven that permutation $$$p$$$ can be uniquely determined"
Hint 2
This means that there is an order of elements. How to determine whether $$$x$$$ should be earlier in that order than $$$y$$$?
Hint 1
"It can be proven that permutation $$$p$$$ can be uniquely determined"
Hint 2
This means that there is an order of elements. How to determine whether $$$x$$$ should be earlier in that order than $$$y$$$?
Solution
Consider two elements $$$x < y$$$. Suppose their positions in $$$p$$$ are $$$i$$$ and $$$j$$$ correspondigly.
How can we determine if $$$i < j$$$? If $$$i < j$$$ and $$$x < y$$$, we will have $$$g_{x, y} = g_{y, x} = 1$$$. Otherwise, $$$i > j$$$ and $$$x < y$$$, so $$$g_{x, y} = g_{y, x} = 0$$$.
So if $$$g_{x, y} = 1$$$, we know that $$$i < j$$$, otherwise $$$i > j$$$.
That way we can determine for each pair of elements which one of them should appear earlier in the permutation. Notice that this is just a definition of a comparator, which proves that the permutation is indeed unique. We can find it by sorting $$$p = [1, 2, \ldots, n]$$$ with that comparator.
Code
#include <bits/stdc++.h>
 
using namespace std;
 
void solve() {
    int n;
    cin >> n;
    vector<string> g(n);
    for(auto &i : g) {
        cin >> i;
    }
    vector<int> p(n);
    iota(p.begin(), p.end(), 0);
    sort(p.begin(), p.end(),
    [&](int x, int y) {
        if(g[x][y] == '1') return x < y;
        else return x > y;
    });
    for(auto i : p) cout << i + 1 << " "; cout << '\n';
}
 
signed main() {
    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int ttt = 1;
    cin >> ttt;
    while(ttt--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 2056A
Editorial Content:
2056A - Shape Perimeter
Hints
Hint 1
Look at the picture. I mean,
look
at the picture.
Hint 2
Consider coordinates $$$x$$$ and $$$y$$$ separately.
Hint 1
Look at the picture. I mean,
look
at the picture.
Hint 2
Consider coordinates $$$x$$$ and $$$y$$$ separately.
Solution
Consider coordinates $$$x$$$ and $$$y$$$ separately. Since $$$1 \le x_i, y_i \le m - 1$$$, after each step both coordinates increase and remain connected with the previous square.
From the picture we can see that each coordinate spans from the bottom-left corner of the first square to the top-right corner of the last square.
To calculate the perimeter we can add the length of that interval for both coordinates and multiply it by $$$2$$$, as it is counted in the perimeter twice, going in both directions:
The coordinates of the bottom-left corner of the first square are $$$(x_1, y_1)$$$ and of the top-right corner of the last square are $$$(m + \sum\limits_{i = 1}^n x_i, m + \sum\limits_{i = 1}^n y_i)$$$.
The lengths of the intervals are $$$m + \sum\limits_{i = 2}^n x_i$$$ and $$$m + \sum\limits_{i = 2}^n y_i$$$.
Therefore, the answer is $$$2(2m + \sum\limits_{i = 2}^n (x_i + y_i))$$$.
Code
#include <bits/stdc++.h>

using namespace std;

void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> x(n), y(n);
    for(int i = 0; i < n; i++) {
        cin >> x[i] >> y[i];
    }
    int ans = 2 * (accumulate(x.begin(), x.end(), 0) + m - x[0] + accumulate(y.begin(), y.end(), 0) + m - y[0]);
    cout << ans << '\n';
}

signed main() {
    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int ttt = 1;
    cin >> ttt;
    while(ttt--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 2055F
Editorial Content:
2055F - Cosmic Divide
Hint 1
The results of the partition must be convex. Can you see why?
Hint 2
The easier cases are when the polyomino must be cut vertically or horizontally. Let's discard those for now, and consider the "diagonal cuts". I.e. let one polyomino start from the top row, and another starting from some row $$$c$$$. WLOG the one starting on row $$$c$$$ is on the left side, we will check the other side by just duplicating the rest of the solution.
Hint 3
Both sub-polyominoes are fixed if you choose $$$c$$$. But, it takes $$$O(n)$$$ time to check each one.
Hint 4
Can you get rid of most $$$c$$$ with a quick check?
Hint 5
Look at perimeters shapes, or area. Both will work.
Solution
Assume there exists a valid partition of the polyomino. Note that the resulting congruent polyominoes must be convex, as it is not possible to join two non-overlapping non-convex polyominoes to create a convex one.
Then, there are two cases: either the two resulting polyominoes are separated by a perfectly vertical or horizontal cut, or they share some rows. The first case is easy to check in linear time. The remainder of the solution will focus on the second case.
Consider the structure of a valid partition. We will focus on the perimeter:
Notice that the cut separating the two polyominoes must only ever move down and right, or up and right, as otherwise one of the formed polyominoes will not be convex. Without loss of generality, say it only goes down and right.
In order for our cut to be valid, it must partition the perimeter into six segments as shown, such that the marked segments are congruent in the indicated orientations ($$$a$$$ with $$$a$$$, $$$b$$$ with $$$b$$$, $$$c$$$ with $$$c$$$.) If we label the horizontal lines of the grid to be $$$0, \dots, n$$$ where line $$$i$$$ is located after row $$$i$$$, we notice that the division points along the left side of the original polyomino are located at lines $$$0, k, 2k$$$ for some $$$1 \leq k \leq n/2$$$.
Notice that if we were to fix a given $$$k$$$, we can uniquely determine the lower polyomino from the first few rows of the upper polyomino. Indeed, if $$$a_i = r_i - \ell_i + 1$$$ denotes the width of the $$$i$$$-th row of the original polyomino, we can show that the resulting polyomino for a particular choice of $$$k$$$ has
$$$b_i = a_i - a_{i-k} + a_{i-2k} - \dots$$$
cells in its $$$i$$$-th row, for $$$1 \leq i \leq n - k$$$. Therefore, iterating over all possible $$$k$$$ and checking them individually gives an $$$O(n^2)$$$ solution.
To speed this up, we will develop a constant-time check that will prune ``most'' choices of $$$k$$$. Indeed, we may use prefix sums and hashing to verify the perimeter properties outlined above, so that we can find all $$$k$$$ that pass this check in $$$O(n)$$$ time. If there are at most $$$f(n)$$$ choices of $$$k$$$ afterwards, we can check them all for a solution in $$$O(n \cdot (f(n) + \text{hashing errors}))$$$.
It can actually be shown that for our hashing protocol, $$$f(n) \leq 9$$$, so that this algorithm has linear time complexity. While the proof is not difficult, it is rather long and will be left as an exercise. Instead, we will give a simpler argument to bound $$$f(n)$$$. Fix some choice of $$$k$$$, and consider the generating functions
$$$A(x) = a_0 + a_1 x + \dots + a_n x^n,$$$
$$$B(x) = b_0 + b_1 x + \dots + b_{n-k} x^{n-k}.$$$
The perimeter conditions imply that $$$(1 + x^k) B(x) = A(x)$$$. In other words, $$$k$$$ may only be valid if $$$(1 + x^k)$$$ divides $$$A(x)$$$. Therefore, we can use
cyclotomic polynomials
for $$$1 + x^k \mid x^{2k} - 1$$$ to determine that
$$$f(n) \leq \text{maximum number of cyclotomic polynomials that can divide a degree}\ n\ \text{polynomial}.$$$
As the degree of the $$$k$$$-th cyclotomic polynomial is $$$\phi(k)$$$ for the Euler totient function $$$\phi$$$, we can see that $$$f(n)$$$ is also at most the maximum number of $$$k_i \leq n$$$ we can select with $$$\sum_i \phi(k_i) \leq n$$$. Since $$$\phi(n) \geq \frac{n}{\log \log n}$$$, this tells us that
$$$f(n) = O(\sqrt n \cdot \log \log n)$$$
and this looser bound already yields a time complexity of at most $$$O(n \sqrt n \cdot \log \log n).$$$
While this concludes the official solution,
there exist many other heuristics with different $$$f(n)$$$ that also work.
It is in the spirit of the problem to admit many alternate heuristics that give small enough $$$f(n)$$$ ``in practice'', as the official solution uses hashing. One such heuristic found by testers is as follows:
We take as our pruning criteria that the area of the subdivided polyomino $$$\sum_{i=1}^{n-k} b_i$$$ is exactly half of the area of the original polyomino, which is $$$\sum_{i=1}^n a_i$$$. Algebraically manipulating $$$\sum_{i=1}^{n-k} b_i$$$ to be a linear function of $$$a_i$$$ shows it to be equal to
$$$(a_1 + \dots + a_k) - (a_{k+1} + \dots + a_{2k}) + \dots.$$$
The calculation of all these sums may be sped up with prefix sums, and therefore pruning of $$$k$$$, can be done in amortized $$$O(n \log n)$$$ time since any fixed choice of $$$k$$$ has $$$\frac nk$$$ segments.
However, for this choice of pruning, it can actually be shown that $$$f(n) \geq \Omega(d(n))$$$, where $$$d(n)$$$ is the number of divisors of $$$n$$$. This lower bound is obtained at an even-sized diamond polyomino, e.g.
$$$(a_1, \dots, a_n) = (2, 4, \dots, n, n, \dots, 4, 2).$$$
Despite our efforts, we could not find an upper bound on $$$f(n)$$$ in this case, though we suspect that if it were not for the integrality and bounding constraints $$$a_i \in {1, \dots, 10^9}$$$, then $$$f(n) = \Theta(n)$$$, with suitable choices of $$$a_i$$$ being found using linear programs. Nevertheless, the solution passes our tests, and we suspect that no countertest exists (though hacking attempts on such solutions would be interesting to see!).
Implementation
#include <bits/stdc++.h>

#define f first
#define s second

typedef long long int ll;
typedef unsigned long long int ull;
using namespace std;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;

void print_set(vector<int> x) {
    for (auto i : x) {
        cout << i << " ";
    }
    cout << endl;
}

void print_set(vector<ll> x) {
    for (auto i : x) {
        cout << i << " ";
    }
    cout << endl;
}

bool connected(vector<ll> &U, vector<ll> &D) {
    if (U[0] > D[0]) return 0;
    for (int i = 1; i < U.size(); i++) {
        if (U[i] > D[i]) return 0;
        if (D[i] < U[i-1]) return 0;
        if (U[i] > D[i-1]) return 0;
    }
    return 1;
}

bool compare(vector<ll> &U1, vector<ll> &D1, vector<ll> &U2, vector<ll> &D2) {
    if (U1.size() != U2.size()) return 0;
    if (!connected(U1, D1)) return 0;
    for (int i = 0; i < U1.size(); i++) {
        if (U1[i] - D1[i] != U2[i] - D2[i]) return 0;
        if (U1[i] - U1[0] != U2[i] - U2[0]) return 0;
    }
    return 1;
}

bool horizontal_check(vector<ll>& U, vector<ll>& D) {
    if (U.size() % 2) return 0;
    int N = U.size() / 2;
    auto U1 = vector<ll>(U.begin(), U.begin() + N);
    auto D1 = vector<ll>(D.begin(), D.begin() + N);
    auto U2 = vector<ll>(U.begin() + N, U.end());
    auto D2 = vector<ll>(D.begin() + N, D.end());
    return compare(U1, D1, U2, D2);
}

bool vertical_check(vector<ll>& U, vector<ll>& D) {
    vector<ll> M1, M2;
    for (int i = 0; i < U.size(); i++) {
        if ((U[i] + D[i]) % 2 == 0) return 0;
        M1.push_back((U[i] + D[i]) / 2);
        M2.push_back((U[i] + D[i]) / 2 + 1);
    }
    return compare(U, M1, M2, D);
}

ll base = 2;
ll inv = 1000000006;
ll mod = 2000000011;

vector<ll> base_pows;
vector<ll> inv_pows;
void precompute_powers() {
    base_pows.push_back(1);
    inv_pows.push_back(1);
    for (int i = 1; i <= 300000; i++) {
        base_pows.push_back(base_pows.back() * base % mod);
        inv_pows.push_back(inv_pows.back() * inv % mod);
    }
}

ll sub(vector<ll> &hash_prefix, int a1, int b1) {
    return ((mod + hash_prefix[b1] - hash_prefix[a1]) * inv_pows[a1]) % mod;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    precompute_powers();

    int T; cin >> T;
    while (T--) {
        int N; cin >> N;
        vector<ll> U(N), D(N), H(N);
        vector<pii> col_UL(N), col_DR(N+1);
        vector<ll> hash_prefix_U(N), hash_prefix_D(N);
        for (int i = 0; i < N; i++) {
            cin >> U[i] >> D[i];
            H[i] = D[i] - U[i] + 1;
            col_UL[i] = {i,U[i]};
            col_DR[i] = {i+1,D[i]+1};
        }

        // hashing
        for (int i = 1; i < N; i++) {
            hash_prefix_U[i] = (((mod + U[i] - U[i-1]) * base_pows[i-1])
                                + hash_prefix_U[i-1]) % mod;
        }

        for (int i = 1; i < N; i++) {
            hash_prefix_D[i] = (((mod + D[i] - D[i-1]) * base_pows[i-1])
                                + hash_prefix_D[i-1]) % mod;
        }

        // horizontal split
        if (horizontal_check(U, D)) {
            cout << "YES" << endl;
            goto next;
        }

        // vertical split
        if (vertical_check(U, D)) {
            cout << "YES" << endl;
            goto next;
        }

        for (int _ = 0; _ < 2; _++) {
            // down-right split
            for (int c = 1; c <= N/2; c++) {
                // check upper portion
                if (sub(hash_prefix_U, 0, c-1) != sub(hash_prefix_U, c, 2*c-1)) continue;
                if (H[0] - U[2*c] + U[2*c-1] != U[c-1] - U[c]) continue;

                // check lower portion
                if (sub(hash_prefix_D, N-c, N-1) != sub(hash_prefix_D, N-2*c, N-c-1)) continue;
                if (H[N-1] + D[N-2*c-1] - D[N-2*c] != D[N-c-1] - D[N-c]) continue;

                // check main portion
                if (sub(hash_prefix_U, 2*c, N-1) != sub(hash_prefix_D, 0, N-2*c-1)) continue;

                // brute force section
                // polynomial division
                bool ok = 1;
                vector<ll> H_copy(H.begin(), H.end());
                vector<ll> quotient(N);

                // calculate quotient
                for (int i = 0; i < N-c; i++) {
                    quotient[i] = H_copy[i];
                    H_copy[i+c] -= H_copy[i];
                    if (quotient[i] < 0) ok = 0;
                }

                // check for no remainder
                for (int i = N-c; i < N; i++) if (H_copy[i]) ok = 0;
                if (!ok) continue;

                // construct subdivision
                vector<ll> U1, D1, U2, D2;
                for (int i = c; i < N; i++) {
                    int ref_height = quotient[i-c];
                    U1.push_back(D[i-c] - ref_height + 1);
                    D1.push_back(D[i-c]);
                    U2.push_back(U[i]);
                    D2.push_back(U[i] + ref_height - 1);
                }

                if (compare(U1, D1, U2, D2)) {
                    cout << "YES" << endl;
                    goto next;
                }
            }

            // flip and go again!
            swap(hash_prefix_U, hash_prefix_D);
            swap(U, D);
            for (int i = 0; i < N; i++) {
                U[i] = -U[i];
                D[i] = -D[i];
            }
        }
        cout << "NO" << endl;
        next:;
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2055E
Editorial Content:
2055E - Haystacks
Hint 1
Let's say you have to empty the haystacks in a fixed order. What's the best way to do it?
Hint 2
Write the expression for the number of moves for a given order.
Hint 3
In an optimal ordering, you should not gain anything by swapping two entries of the order. Using this, describe the optimal order.
Hint 4
The constraint only limits what you can empty last. How can you efficiently compute the expression in Hint 2?
Solution
Let's say we fixed some permutation $$$\sigma$$$ of $$$1, \dots, n$$$ such that we empty haystacks in the order $$$\sigma_1, \dots, \sigma_n$$$. Notice that a choice of $$$\sigma$$$ is possible if and only if the final stack $$$\sigma_n$$$ can be cleared, which is equivalent to the constraint
$$$a_{\sigma_1} + \dots + a_{\sigma_n} \leq b_{\sigma_1} + \dots + b_{\sigma_{n-1}}.$$$
With this added constraint, the optimal sequence of moves is as follows:
Iterate $$$i$$$ through $$$1, \dots, n-1$$$. For each $$$i$$$, try to move its haybales to haystacks $$$1, \dots, i-1$$$, and if they are all full then move haybales to haystack $$$n$$$. Once this process terminates, move all haystacks from $$$n$$$ back onto arbitrary haystacks $$$1, \dots, n-1$$$, being careful to not overflow the height limits.
The key observation is that the number of extra haybales that must be moved onto haystack $$$n$$$ is
$$$\max_{1 \leq i \leq n-1} \left\{\sum_{j=1}^i a_{\sigma_j} - \sum_{j=1}^{i-1} b_{\sigma_j}\right\}.$$$
To show this, consider the last time $$$i$$$ that a haybale is moved onto haystack $$$n$$$. At this time, all haybales from haystacks $$$1, \dots, i$$$ have found a home, either on the height limited haystacks $$$1, \dots, i-1$$$ or on haystack $$$n$$$, from which the identity immediately follows. Now, every haystack that wasn't moved onto haystack $$$n$$$ will get moved once, and every haystack that did gets moved twice. Therefore, our task becomes the following: Compute
$$$\sum_{i=1}^{n} a_i + \min_{\sigma} \max_{1 \leq i \leq n-1} \left\{\sum_{j=1}^i a_{\sigma_j} - \sum_{j=1}^{i-1} b_{\sigma_j}\right\}$$$
for $$$\sigma$$$ satisfying
$$$a_{\sigma_1} + \dots + a_{\sigma_n} \leq b_{\sigma_1} + \dots + b_{\sigma_{n-1}}.$$$
Notice that the $$$\sum_{i=1}^n a_i$$$ term is constant, and we will omit it for the rest of this tutorial. We will first solve the task with no restriction on $$$\sigma$$$ to gain some intuition. Denote $$$<_{\sigma}$$$ the ordering of pairs $$$(a, b)$$$ corresponding to $$$\sigma$$$.
Consider adjacent pairs $$$(a_i, b_i) <_{\sigma} (a_j, b_j)$$$. Then, if the choice of $$$\sigma$$$ is optimal, it must not be better to swap their ordering, i.e.
$$$\begin{align*} \overbrace{(a_i, b_i) <_{\sigma} (a_j, b_j)}^{\text{optimal}} \implies& \max(a_i, a_i + a_j - b_i) \leq \max(a_j, a_i + a_j - b_j) \\ \iff& \max(-a_j, -b_i) \leq \max(-a_i, -b_j)\\ \iff& \min(a_j, b_i) \geq \min(a_i, b_j). \end{align*}$$$
As a corollary, there exists an optimal $$$\sigma$$$ satisfying the following properties:
Claim [Optimality conditions of $\sigma$].
All pairs with $$$a_i < b_i$$$ come first. Then, all pairs with $$$a_i = b_i$$$ come next. Then, all pairs with $$$a_i > b_i$$$.
The pairs with $$$a_i < b_i$$$ are in ascending order of $$$a_i$$$.
The pairs with $$$a_i > b_i$$$ are in descending order of $$$b_i$$$.
It is not hard to show that all such $$$\sigma$$$ satisfying these properties are optimal by following similar logic as above. We leave it as an exercise for the reader.
Now, we add in the constraint on the final term $$$\sigma_n$$$ of the ordering. We will perform casework on this final haystack. Notice that for any fixed $$$a_n, b_n$$$, if
$$$\max_{1 \leq i \leq n-1} \left\{\sum_{j=1}^i a_{\sigma_j} - \sum_{j=1}^{i-1} b_{\sigma_j}\right\}$$$
is maximized, then so is
$$$\max_{1 \leq i \leq n} \left\{\sum_{j=1}^i a_{\sigma_j} - \sum_{j=1}^{i-1} b_{\sigma_j}\right\}.$$$
So, if we were to fix any last haystack $$$\sigma_n$$$, the optimality conditions tell us that we should still order the remaining $$$n-1$$$ haystacks as before. Now, we may iterate over all valid $$$\sigma_n$$$ and compute the answer efficiently as follows: maintain a segment tree with leaves representing pairs $$$(a_i, b_i)$$$ and range queries for
$$$\max_{1 \leq i \leq n} \left\{\sum_{j=1}^i a_{\sigma_j} - \sum_{j=1}^{i-1} b_{\sigma_j}\right\}.$$$
This gives an $$$O(n \log n)$$$ solution.
Note that it is possible to implement this final step using prefix and suffix sums to yield an $$$O(n)$$$ solution, but it is not necessary to do so.
Implementation
#include <bits/stdc++.h>

#define f first
#define s second
#define pb push_back

typedef long long int ll;
typedef unsigned long long int ull;
using namespace std;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;

template<typename T> int die(T x) { cout << x << endl; return 0; }

#define LNF 1e15

int N;
vector<pll> segtree;

pll f(pll a, pll b) {
    return {max(a.first, a.second + b.first), a.second + b.second};
}

void pull(int t) {
    segtree[t] = f(segtree[2*t], segtree[2*t+1]);
}

void point_set(int idx, pll val, int L = 1, int R = N, int t = 1) {
    if (L == R) segtree[t] = val;
    else {
        int M = (L + R) / 2;
        if (idx <= M) point_set(idx, val, L, M, 2*t);
        else point_set(idx, val, M+1, R, 2*t+1);
        pull(t);
    }
}

pll range_add(int left, int right, int L = 1, int R = N, int t = 1) {
    if (left <= L && R <= right) return segtree[t];
    else {
        int M = (L + R) / 2;
        pll ret = {0, 0};
        if (left <= M) ret = f(ret, range_add(left, right, L, M, 2*t));
        if (right > M) ret = f(ret, range_add(left, right, M+1, R, 2*t+1));
        return ret;
    }
}

void build(vector<pll>& arr, int L = 1, int R = N, int t = 1) {
    if (L == R) segtree[t] = arr[L-1];
    else {
        int M = (L + R) / 2;
        build(arr, L, M, 2*t);
        build(arr, M+1, R, 2*t+1);
        pull(t);
    }
}

vector<int> theoretical(const vector<pii>& arr) {
    vector<int> idx(arr.size());
    for (int i = 0; i < arr.size(); ++i) {
        idx[i] = i;
    }

    vector<int> ut, eq, lt;
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i].first < arr[i].second) {
            ut.push_back(i);
        } else if (arr[i].first == arr[i].second) {
            eq.push_back(i);
        } else {
            lt.push_back(i);
        }
    }

    sort(ut.begin(), ut.end(), [&arr](int i, int j) {
        return arr[i].first < arr[j].first;
    });

    sort(eq.begin(), eq.end(), [&arr](int i, int j) {
        return arr[i].first > arr[j].first;
    });

    sort(lt.begin(), lt.end(), [&arr](int i, int j) {
        return arr[i].second > arr[j].second;
    });

    vector<int> result;
    result.insert(result.end(), ut.begin(), ut.end());
    result.insert(result.end(), eq.begin(), eq.end());
    result.insert(result.end(), lt.begin(), lt.end());

    return result;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int T = 1; cin >> T;
    while (T--) {
        cin >> N;
        vector<pll> data(N);
        ll sum_a = 0;
        ll sum_b = 0;
        for (int i = 0; i < N; i++) {
            cin >> data[i].f >> data[i].s;
            sum_a += data[i].f;
            sum_b += data[i].s;
        }
        vector<int> order = theoretical(vector<pii>(data.begin(), data.end()));

        vector<pll> data_sorted;
        for (int i : order) data_sorted.push_back({data[i].first, data[i].first - data[i].second});
        data_sorted.push_back({0, 0});

        ++N;

        segtree = vector<pll>(4*N);
        build(data_sorted);

        ll ans = LNF;
        for (int i = 0; i < N-1; i++) {
            if (sum_b - (data_sorted[i].first - data_sorted[i].second) >= sum_a) {
                point_set(i+1, data_sorted[N-1]);
                point_set(N, data_sorted[i]);

                ans = min(ans, range_add(1, N).first);

                point_set(i+1, data_sorted[i]);
                point_set(N, data_sorted[N-1]);
            }
        }
        if (ans == LNF) cout << -1 << endl;
        else cout << ans + sum_a << endl;
    }
}
--------------------------------------------------
Problem ID: 2055D
Editorial Content:
2055D - Scarecrow
Hint 1
Should you ever change the order of scarecrows?
Hint 2
What's the first thing that the leftmost scarecrow should do?
Hint 3
What's the only way to save time? Think in terms of distances and not times.
Hint 4
Look at the points where the crow "switches over" between scarecrows.
Hint 5
Greedy.
Solution
We make a few preliminary observations:
(1) The order of scarecrows should never change, i.e no two scarecrows should cross each other while moving along the interval.
(2) Scarecrow $$$1$$$ should spend the first $$$a_1$$$ seconds moving to position zero, as this move is required for the crow to make any progress and there is no point in delaying it.
(3) Let's say that a scarecrow at position $$$p$$$ `has' the crow if the crow is at position $$$p + k$$$, and there are no other scarecrows in the interval $$$[p, p+k]$$$. A scarecrow that has the crow should always move to the right; in other words, all scarecrows that find themselves located to the left of the crow should spend all their remaining time moving to the right, as it is the only way they will be useful.
(4) Let there be a scenario where at time $$$T$$$, scarecrow $$$i$$$ has the crow and is at position $$$x$$$, and another scenario at time $$$T$$$ where scarecrow $$$i$$$ also has the crow, but is at position $$$y \geq x$$$. Then, the latter scenario is at least as good as the former scenario, assuming scarecrows numbered higher than $$$i$$$ are not fixed.
(5) The only way to save time is to maximize the distance $$$d$$$ teleported by the crow.
The second and fifth observations imply that the time spent to move the crow across the interval is $$$a_1 + \ell - d$$$.
Now, for each scarecrow $$$i$$$, define $$$b_i$$$ to be the position along the interval at which it begins to have the crow, i.e. the crow is transferred from scarecrow $$$i-1$$$ to $$$i$$$. For instance, in the second sample case the values of $$$b_i$$$ are
$$$(b_1, b_2, b_3) = (0, 2.5, 4.5)$$$
The second observation above implies that $$$b_1 = 0$$$, and the first observation implies that $$$b_1 \leq \dots \leq b_n$$$. Notice that we may express the distance teleported as
$$$d = \sum_{i=1}^{n} \min(k, b_{i+1} - b_i)$$$
with the extra definition that $$$b_{n+1} = \ell$$$. For instance, in the second sample case the distance teleported is
$$$d = \min(k, b_2 - b_1) + \min(k, b_3 - b_2) + \min(k, \ell - b_3) = 2 + 2 + 0.5 = 4.5$$$
and the total time is $$$a_1 + \ell - d = 2 + 5 - 4.5 = 2.5$$$.
Now, suppose that $$$b_1, \dots, b_{i-1}$$$ have been selected for some $$$2 \leq i \leq n$$$, and that time $$$T$$$ has elapsed upon scarecrow $$$i-1$$$ receiving the crow. We will argue the optimal choice of $$$b_i$$$.
At time $$$T$$$ when scarecrow $$$i-1$$$ first receives the crow, scarecrow $$$i$$$ may be at any position in the interval $$$[a_i - T, \min(a_i + T, \ell)]$$$. Now, we have three cases.
Case 1. $$$b_{i-1} + k \leq a_i - T.$$$
In this case, scarecrow $$$i$$$ will need to move some nonnegative amount to the left in order to meet with scarecrow $$$i-1$$$. They will meet at the midpoint of the crow position $$$b_{i-1} + k$$$ and the leftmost possible position $$$a_i - T$$$ of scarecrow $$$i$$$ at time $$$T$$$. This gives
$$$b_i := \frac{a_i - T + b_{i-1} + k}{2}.$$$
Case 2. $$$a_i - T \leq b_{i-1} + k \leq a_i + T.$$$
Notice that if our choice of $$$b_i$$$ has $$$b_i < b_{i-1} + k$$$, it benefits us to increase our choice of $$$b_i$$$ (if possible) as a consequence of our fourth observation, since all such $$$b_i$$$ will cause an immediate transfer of the crow to scarecrow $$$i$$$ at time $$$T$$$. However, if we choose $$$b_i > b_{i-1} + k$$$, lowering our choice of $$$b_i$$$ is now better as it loses less potential teleported distance $$$\min(k, b_i - b_{i-1})$$$, while leaving more space for teleported distance after position $$$b_i$$$. Therefore, we will choose $$$b_i := b_{i-1} + k$$$ in this case.
Case 3. $$$a_i + T \leq b_{i-1} + k.$$$
In this case, regardless of how we choose $$$b_i$$$, the crow will immediately transfer to scarecrow $$$i$$$ from scarecrow $$$i-1$$$ at time $$$T$$$. We might as well pick $$$b_i := a_i + T$$$.
Therefore, the optimal selection of $$$b_i$$$ may be calculated iteratively as
$$$b_i := \min\left(\ell, \overbrace{a_i + T}^{\text{case 3}}, \max\left(\overbrace{b_{i-1} + k}^{\text{case 2}}, \overbrace{\frac{a_i - T + b_{i-1} + k}{2}}^{\text{case 1}}\right)\right).$$$
It is now easy to implement the above approach to yield an $$$O(n)$$$ solution. Note that the constraints for $$$k, \ell$$$ were deliberately set to $$$10^8$$$ instead of $$$10^9$$$ to make two times the maximum answer $$$4 \cdot \ell$$$ fit within $$$32$$$-bit integer types. It is not difficult to show that the values of $$$b_i$$$ as well as the answer are always integers or half-integers.
Implementation
#include <bits/stdc++.h>

#define f first
#define s second
#define pb push_back

typedef long long int ll;
typedef unsigned long long int ull;
using namespace std;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    int T; cin >> T;
    while (T--) {
        int N, k, l;
        cin >> N >> k >> l;
        double K = k;
        double L = l;
        vector<int> A(N);
        for (int i = 0; i < N; i++) cin >> A[i];
        double T = A[0];
        double last_pt = 0;
        double S = 0;
        for (int i = 1; i < N; i++) {
            double this_pt = min(L, min(A[i] + T,
                                max(last_pt + K,
                                    (A[i] - T + last_pt + K)/2.0)));
            T += max(0.0, this_pt - last_pt - K);
            S += min(K, this_pt - last_pt);
            last_pt = this_pt;
        }
        S += min(K, L - last_pt);
        cout << (int)round(2*(L - S + A[0])) << endl;
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2055C
Editorial Content:
2055C - The Trail
Hint 1
Pick $$$x$$$, and find the sum of the whole grid. What does this tell you?
Hint 2
Once you know $$$x$$$, the top left cell is fixed.
Hint 3
What about the next cell on the trail?
Solution
The naive solution of writing out a linear system and solving them will take $$$O((n + m)^3)$$$ time, which is too slow, so we will need a faster algorithm.
We begin by selecting a target sum $$$S$$$ for each row and column. If we calculate the sum of all numbers in the completed grid, summing over rows gives a total of $$$S \cdot n$$$ while summing over columns gives a total of $$$S \cdot m$$$. Therefore, in order for our choice of $$$S$$$ to be possible, we require $$$S \cdot n = S \cdot m$$$, and since it is possible for $$$n \neq m$$$, we will pick $$$S = 0$$$ for our choice to be possible in all cases of $$$n, m$$$.
Notice that all choices $$$S \neq 0$$$ will fail on $$$n \neq m$$$, as the condition $$$S \cdot n = S \cdot m$$$ no longer holds. As such, $$$S = 0$$$ is the only one that will work in all cases.
Now, we aim to make each row and column sum to $$$S$$$. The crux of the problem is the following observation:
Denote $$$x_1, x_2, \dots, x_{n+m-1}$$$ to be the variables along the path. Let's say variables $$$x_1, \dots, x_{i-1}$$$ have their values set for some $$$1 \leq i < n+m-1$$$. Then, either the row or column corresponding to variable $$$x_i$$$ has all of its values set besides $$$x_i$$$, and therefore we may determine exactly one possible value of $$$x_i$$$ to make its row or column sum to $$$0$$$.
The proof of this claim is simple. At variable $$$x_i$$$, we look at the corresponding path move $$$s_i$$$. If $$$s_i = \tt{R}$$$, then the path will never revisit the column of variable $$$x_i$$$, and its column will have no remaining unset variables since $$$x_1, \dots, x_{i-1}$$$ are already set. Likewise, if $$$s_i = \tt{D}$$$, then the path will never revisit the row of variable $$$x_i$$$, which can then be used to determine the value of $$$x_i$$$.
Repeating this process will cause every row and column except for row $$$n$$$ and column $$$m$$$ to have a sum of zero, with $$$x_{n+m-1}$$$ being the final variable. However, we will show that we can use either the row or column to determine it, and it will give a sum of zero for both row $$$n$$$ and column $$$m$$$. WLOG we use row $$$n$$$. Indeed, if the sum of all rows and columns except for column $$$m$$$ are zero, we know that the sum of all entries of the grid is zero by summing over rows. However, we may then subtract all columns except column $$$m$$$ from this total to arrive at the conclusion that column $$$m$$$ also has zero sum. Therefore, we may determine the value of $$$x_{n+m-1}$$$ using either its row or column to finish our construction, giving a solution in $$$O(n \cdot m)$$$.
Implementation
#include <bits/stdc++.h>

#define f first
#define s second
#define pb push_back

typedef long long int ll;
typedef unsigned long long int ull;
using namespace std;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;

template<typename T> int die(T x) { cout << x << endl; return 0; }

#define mod 1000000007
#define INF 1000000000
#define LNF 1e15
#define LOL 12345678912345719ll

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    int T; cin >> T;
    while (T--) {
        int N, M; cin >> N >> M;
        string S; cin >> S;
        vector<vector<ll>> A;
        for (int i = 0; i < N; i++) {
            A.push_back(vector<ll>(M));
            for (int j = 0; j < M; j++) {
                cin >> A[i][j];
            }
        }
        int x = 0, y = 0;
        for (char c : S) {
            if (c == 'D') {
                long long su = 0;
                for (int i = 0; i < M; i++) {
                    su += A[x][i];
                }
                A[x][y] = -su;
                ++x;
            } else {
                long long su = 0;
                for (int i = 0; i < N; i++) {
                    su += A[i][y];
                }
                A[x][y] = -su;
                ++y;
            }
        }
        long long su = 0;
        for (int i = 0; i < M; i++) {
            su += A[N-1][i];
        }
        A[N-1][M-1] = -su;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                cout << A[i][j] << " ";
            }
            cout << endl;
        }

    }
    return 0;
}
--------------------------------------------------
Problem ID: 2055B
Editorial Content:
2055B - Crafting
Hint 1
The order of the moves is pretty much irrelevant. What happens if we try to make two different materials?
Solution
The key observation is that we will never use the operation to craft two different types of materials $$$i, j$$$. This is because if we were to combine the net change in resources from these two operations, we would lose two units each of every material $$$k \neq i, j$$$, and receive a net zero change in our amounts of materials $$$i, j$$$. Therefore, we will only ever use the operation on one type of material $$$i$$$.
An immediate corollary of this observation is that we can only be deficient in at most one type of material, i.e. at most one index $$$i$$$ at which $$$a_i < b_i$$$. If no such index exists, the material is craftable using our starting resources. Otherwise, applying the operation $$$x$$$ times transforms our array to
$$$a_j := \begin{cases} a_j + x & \text{if}\ i = j \\ a_j - x & \text{if}\ i \neq j \end{cases}$$$
i.e. increasing element $$$a_i$$$ by $$$x$$$ and decreasing all other elements by $$$x$$$. We must have $$$x \geq b_i - a_i$$$ to satisfy the requirement on material type $$$i$$$. However, there is also no point in making $$$x$$$ any larger, as by then we already have enough of type $$$i$$$, and further operations cause us to start losing materials from other types that we could potentially need to craft the artifact. Therefore, our condition in this case is just to check that
$$$b_i - a_i \leq \min_{j \neq i} a_j - b_j,$$$
i.e. we are deficient in type $$$i$$$ by at most as many units as our smallest surplus in all other material types $$$j \neq i$$$. This gives an $$$O(n)$$$ solution.
Implementation
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// typedef tree<int, null_type, std::less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

#include <bits/stdc++.h>

#define f first
#define s second
#define pb push_back

typedef long long int ll;
typedef unsigned long long int ull;
using namespace std;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;

template<typename T> int die(T x) { cout << x << endl; return 0; }

#define mod_fft 998244353
#define mod_nfft 1000000007
#define INF 100000000000000
#define LNF 1e15
#define LOL 12345678912345719ll

struct LL {

    static const ll m = mod_fft;
    long long int val;

    LL(ll v) {val=reduce(v);};
    LL() {val=0;};
    ~LL(){};
    LL(const LL& l) {val=l.val;};
    LL& operator=(int l) {val=l; return *this;}
    LL& operator=(ll l) {val=l; return *this;}
    LL& operator=(LL l) {val=l.val; return *this;}

    static long long int reduce(ll x, ll md = m) {
        x %= md;
        while (x >= md) x-=md;
        while (x < 0) x+=md;
        return x;
    }

    bool operator<(const LL& b) { return val<b.val; }
    bool operator<=(const LL& b) { return val<=b.val; }
    bool operator==(const LL& b) { return val==b.val; }
    bool operator>=(const LL& b) { return val>=b.val; }
    bool operator>(const LL& b) { return val>b.val; }

    LL operator+(const LL& b) { return LL(val+b.val); }
    LL operator+(const ll& b) { return (*this+LL(b)); }
    LL& operator+=(const LL& b) { return (*this=*this+b); }
    LL& operator+=(const ll& b) { return (*this=*this+b); }

    LL operator-(const LL& b) { return LL(val-b.val); }
    LL operator-(const ll& b) { return (*this-LL(b)); }
    LL& operator-=(const LL& b) { return (*this=*this-b); }
    LL& operator-=(const ll& b) { return (*this=*this-b); }

    LL operator*(const LL& b) { return LL(val*b.val); }
    LL operator*(const ll& b) { return (*this*LL(b)); }
    LL& operator*=(const LL& b) { return (*this=*this*b); }
    LL& operator*=(const ll& b) { return (*this=*this*b); }

    static LL exp(const LL& x, const ll& y){
        ll z = y;
        z = reduce(z,m-1);
        LL ret = 1;
        LL w = x;
        while (z) {
            if (z&1) ret *= w;
            z >>= 1; w *= w;
        }
        return ret;
    }
    LL& operator^=(ll y) { return (*this=LL(val^y)); }

    LL operator/(const LL& b) { return ((*this)*exp(b,-1)); }
    LL operator/(const ll& b) { return (*this/LL(b)); }
    LL operator/=(const LL& b) { return ((*this)*=exp(b,-1)); }
    LL& operator/=(const ll& b) { return (*this=*this/LL(b)); }

}; ostream& operator<<(ostream& os, const LL& obj) { return os << obj.val; }

int N;
vector<ll> segtree;

void pull(int t) {
    segtree[t] = max(segtree[2*t], segtree[2*t+1]);
}

void point_set(int idx, ll val, int L = 1, int R = N, int t = 1) {
    if (L == R)  segtree[t] = val;
    else {
        int M = (L + R) / 2;
        if (idx <= M) point_set(idx, val, L, M, 2*t);
        else point_set(idx, val, M+1, R, 2*t+1);
        pull(t);
    }
}

ll range_add(int left, int right, int L = 1, int R = N, int t = 1) {
    if (left <= L && R <= right) return segtree[t];
    else {
        int M = (L + R) / 2;
        ll ret = 0;
        if (left <= M) ret = max(ret, range_add(left, right, L, M, 2*t));
        if (right > M) ret = max(ret, range_add(left, right, M+1, R, 2*t+1));
        return ret;
    }
}

void build(vector<ll>& arr, int L = 1, int R = N, int t = 1) {
    if (L == R)  segtree[t] = arr[L-1];
    else {
        int M = (L + R) / 2;
        build(arr, L, M, 2*t);
        build(arr, M+1, R, 2*t+1);
        pull(t);
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int T = 1; cin >> T;
    while (T--) {
        int N; cin >> N;
        vector<int> A(N), B(N);
        for (int i = 0; i < N; i++) cin >> A[i];
        int bad = -1, margin = 1e9, need = 0;
        bool reject = 0;
        for (int i = 0; i < N; i++) {
            cin >> B[i];
            if (A[i] < B[i]) {
                if (bad != -1) reject = 1;
                bad = i;
                need = B[i] - A[i];
            } else {
                margin = min(margin, A[i] - B[i]);
            }
        }
        if (reject) {
            cout << "NO" << endl;
            continue;
        } else {
            cout << ((margin >= need) ? "YES" : "NO") << endl;
        }
    }
}
--------------------------------------------------
Problem ID: 2055A
Editorial Content:
2055A - Two Frogs
Hint 1
Look at the distance between the frogs.
Solution
Notice that regardless of how the players move, the difference between the numbers of the lilypads the two players are standing on always alternates even and odd, depending on the starting configuration. Then, the key observation is that exactly one player has the following winning strategy:
Walk towards the other player, and do not stop until they are forced onto lilypad $$$1$$$ or $$$n$$$.
For instance, if Alice and Bob start on lilypads with the same parity, Bob cannot stop Alice from advancing towards him. This is because at the start of Alice's turn, she will always be able to move towards Bob due to their distance being even and therefore at least $$$2$$$, implying that there is a free lilypad for her to jump to. This eventually forces Bob into one of the lilypads $$$1, n$$$, causing him to lose.
In the case that they start on lilypads with different parity, analogous logic shows that Bob wins. Therefore, for each case, we only need to check the parity of the lilypads for a constant time solution.
Implementation
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    int T; cin >> T;
    while (T--) {
        int N, A, B; cin >> N >> A >> B;
        if ((A ^ B) & 1) cout << "NO\n";
        else cout << "YES\n";
    }
    cout.flush();
    return 0;
}
--------------------------------------------------
Problem ID: 2053I2
Editorial Content:
2053I2 - Affectionate Arrays (Hard Version)
Hint 1
Try insert numbers into spaces between the elements of $$$a$$$ (including the beginning and the end). Note that an array be can be formed in multiple ways (for example, you can insert a number $$$x$$$ to the left or right of the original number $$$x$$$ in array $$$a$$$). What's the number of different ways?
Answer
It's actually the "value", that is, the number of occurrances of $$$a$$$. Use the fact that "only one number can be inserted into each space" to prove.
Answer
It's actually the "value", that is, the number of occurrances of $$$a$$$. Use the fact that "only one number can be inserted into each space" to prove.
Solution
Read the editorial for I1 and the hints first.
According to the hint, you can count the number of ways to insert the new numbers into the space, so the dp and transitions are similar to those in problem I1.
We can add an additional dp array, $$$g_{i, j}$$$ representing the number of different ways when everything meets the description of $$$f_{i, j}$$$. Let's see from which values it can be transferred:
If $$$f_{i, j} = v_i$$$, then $$$f_{i, j}$$$ can only be transferred from $$$f_{i-1, j-a_i}$$$. That is, $$$g_{i, j} = g_{i-1, j-a_i}$$$.
If $$$f_{i, j} = v_i + 1$$$, then $$$f_{i, j} = \sum_{k \in L_i, f_{i-1, k} = f_{i, j} - 1} g_{i-1, k}$$$.
We can use some tags and a Deque to maintain the whole process, so the amortized time complexity is $$$\mathcal O(n)$$$.
Code (C++)
#include <bits/stdc++.h>
 
namespace FastIO {
	template <typename T> inline T read() { T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= (ch == '-'), ch = getchar(); while ('0' <= ch && ch <= '9') x = x * 10 + (ch ^ '0'), ch = getchar(); return w ? -x : x; }
	template <typename T> inline void write(T x) { if (!x) return; write<T>(x / 10), putchar((x % 10) ^ '0'); }
	template <typename T> inline void print(T x) { if (x > 0) write<T>(x); else if (x < 0) putchar('-'), write<T>(-x); else putchar('0'); }
	template <typename T> inline void print(T x, char en) { print<T>(x), putchar(en); }
}; using namespace FastIO;
 
const int MOD = 998244353;
namespace Modint {
	inline int add(int x, int y) { return (x += y) >= MOD ? x - MOD : x; }
	inline int sub(int x, int y) { return x < y ? x - y + MOD : x - y; }
	inline int mul(int x, int y) { return 1ll * x * y % MOD; }
	inline int pow(int x, int y) { int r = 1; for (; y; y >>= 1, x = mul(x, x)) if (y & 1) r = mul(r, x); return r; }
	inline int inv(int x) { return pow(x, MOD - 2); }
};
struct modint {
	int v;
	modint (int x = 0) : v(x) { /* for debug only. assert(0 <= x && x < MOD); */ }
	inline int get() { return v; }
	modint operator - () const { return v ? MOD - v : 0; }
	modint operator + (const modint &k) const { return Modint::add(v, k.v); }
	modint operator - (const modint &k) const { return Modint::sub(v, k.v); }
	modint operator * (const modint &k) const { return Modint::mul(v, k.v); }
	modint operator / (const modint &k) const { return Modint::mul(v, Modint::inv(k.v)); }
	modint pow(const modint &k) const { return Modint::pow(v, k.v); }
	modint inverse() const { return Modint::inv(v); }
	modint operator += (const modint &k) { (v += k.v) >= MOD && (v -= MOD); return *this; }
	modint operator -= (const modint &k) { (v -= k.v) < 0 && (v += MOD); return *this; }
	modint operator *= (const modint &k) { return v = Modint::mul(v, k.v); }
	modint operator /= (const modint &k) { return v = Modint::mul(v, Modint::inv(k.v)); }
};
 
struct Node {
	int f; modint g; long long len;
	Node () {}
	Node (int F, int G, long long L) : f(F), g(G), len(L) {}
	Node (int F, modint G, long long L) : f(F), g(G), len(L) {}
}; std::deque<Node> Q;
 
#define MAXN 3000001
int a[MAXN];
void solve() {
	int N = read<int>(); long long p = 0, l = 0, r = 0, v = 0;
	for (int i = 1; i <= N; ++i) p += (a[i] = read<int>());
	for (int i = 1; i <= N; ++i) assert (std::abs(a[i]) <= p);
	Q.clear(); Q.push_back(Node(0, 1, 1)), Q.push_back(Node(1, 1, p));
	modint gv = 1, gz = p % MOD, tv = 0, tz = 0;
	for (int i = 1; i <= N; ++i) if (a[i] >= 0) {
		for (long long ls = a[i]; ls > 0; ) {
			Node k = Q.back(); Q.pop_back();
			if (ls < k.len) Q.push_back(Node(k.f, k.g, k.len - ls)), k.len = ls;
			(k.f == v ? gv : gz) -= k.g * (k.len % MOD), ls -= k.len;
		}
		l += a[i], r = std::min(r + a[i], p);
		if (l > r) ++v, l = a[i], r = p, gv = gz, tv = tz, gz = tz = 0;
		gz += -tz * (a[i] >= MOD ? a[i] - MOD : a[i]);
        if (a[i] > 0) Q.push_front(Node(v + 1, -tz, a[i]));
        tz += gv + tv * ((r - l + 1) % MOD);
	} else if (a[i] < 0) {
		a[i] = -a[i];
		for (long long ls = a[i]; ls > 0; ) {
			Node k = Q.front(); Q.pop_front();
			if (ls < k.len) Q.push_front(Node(k.f, k.g, k.len - ls)), k.len = ls;
			(k.f == v ? gv : gz) -= k.g * (k.len % MOD), ls -= k.len;
		}
		r -= a[i], l = std::max(l - a[i], 0ll);
		if (l > r) ++v, l = 0, r = p - a[i], gv = gz, tv = tz, gz = tz = 0;
		gz += -tz * (a[i] >= MOD ? a[i] - MOD : a[i]), Q.push_back(Node(v + 1, -tz, a[i])), tz += gv + tv * ((r - l + 1) % MOD);
    }
	print<int>((Q.back().g + (r == p ? tv : tz)).get(), '\n');
}
int main() { int T = read<int>(); while (T--) solve(); return 0; }
Bonus
Try to solve the initial problem: count the number of valid array $$$b$$$ for $$$n\le 500$$$.
hint
Consider $$$f_{i,j,k}$$$: the number of ways to fill the first $$$i$$$ elements of $$$b$$$, which contains at most $$$j$$$ first elements from $$$a$$$ as a subsequence, and the sum of the first $$$i$$$ elements is $$$k$$$.
Try to optimize this from $$$O(n^2s^2)$$$ to $$$O(n^2s)$$$, and then $$$O(\rm{poly}(n))$$$, and then $$$O(n^3)$$$.
hint
Consider $$$f_{i,j,k}$$$: the number of ways to fill the first $$$i$$$ elements of $$$b$$$, which contains at most $$$j$$$ first elements from $$$a$$$ as a subsequence, and the sum of the first $$$i$$$ elements is $$$k$$$.
Try to optimize this from $$$O(n^2s^2)$$$ to $$$O(n^2s)$$$, and then $$$O(\rm{poly}(n))$$$, and then $$$O(n^3)$$$.
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2053I1
Editorial Content:
2053I1 - Affectionate Arrays (Easy Version)
Hint 1
What is the minimized LIS?
Hint 2
How do you prove that it is an achievable lower bound?
Hint 3
Go for a brute DP first.
Solution
We claim that the minimized LIS is $$$\sum a_i$$$. Let $$$p$$$ be $$$\sum a_i$$$.
Since it is required that $$$\operatorname{LIS}(b) = p$$$ while $$$\sum b_i = p$$$, we point out that it is equivalent to
each of the prefix sums of the sequence being between $$$[0, p]$$$
.
Sufficiency
: $$$\forall X \in [0, p], Y \in [0, p]$$$, $$$X - Y \leq p$$$. Also, we can pick $$$X = p, Y = 0$$$, so it can only be $$$= p$$$.
Necessity
: disproof. If a prefix sum is $$$< 0$$$, then choose the whole array except for this prefix; if a prefix sum is $$$> p$$$, then choose this prefix. Both derive a contradiction of the LIS being greater than $$$p$$$.
Consider dp. Let $$$f_{i,j}$$$ denote, after considering the first $$$i$$$ numbers, the minimum
extra
sequence length (i.e. the actual length minus $$$i$$$), when the current prefix sum is $$$j$$$. The initial states are $$$f_{0,j} = [j \neq 0]$$$. The transfer is simple too:
$$$f_{i,j} = \min\limits_{0 \leq k + a_i \leq p} (f_{i-1,k} + [k + a_i \neq j])$$$
It is possible to optimize the transfer to $$$\mathcal O(np)$$$, since for each $$$j$$$, the contribution from at most one $$$k$$$ is special ($$$+0$$$). We can calculate the prefix and suffix $$$\min$$$ for $$$f_{i-1}$$$ and it will be fast to get the dp array in the new row. Then, let's focus on optimizing it to $$$\mathcal O(n)$$$.
We call the set of $$$0 \leq k \leq p$$$ satisfying $$$0 \leq k + a_i \leq p$$$ as the legal interval of $$$i$$$ (denoted as $$$L_i$$$).
It is concluded that the range of $$$f_{i, 0\dots p}$$$ is at most $$$1$$$, and this can be proven by considering the transfer to each of the $$$j$$$ with the $$$k \in L_i$$$ which has the least $$$f_{i-1, k}$$$. Let $$$v_i = \min_{0 \leq j \leq p}(f_{i, j})$$$. We also have: for those $$$j$$$ with $$$f_{i,j} = v_i$$$, they form a consecutive segment in the integer field. Let the segment be covering $$$[l_i, r_i]$$$.
Inductive proof. The essence of the transfer is that it shifts all the DP values $$$= v_{i-1}$$$ by $$$a_i$$$ unit length, and all the other numbers will be updated to $$$v_{i-1} + 1$$$. Then truncates the $$$j \in ((-\inf, 0) \cup (p, +\inf))$$$ part. The consecutive segment remains consecutive. Specially, if $$$[l_{i-1}, r_{i-1}] \cap L_i = \varnothing$$$, then $$$\min_{k \in L_i}(f_{i-1, k}) = v_{i-1} + 1$$$, hence we need to set $$$v_i = v_{i-1} + 1$$$, and $$$l_i, r_i$$$ as the range of $$$j = k + a_i$$$ in which $$$k \in L_i$$$. Otherwise, $$$v_i = v_{i-1}$$$, and $$$l_i, r_i$$$ can be calculated by shifting $$$l_{i-1}, r_{i-1}$$$ by $$$a_i$$$ unit length.
In fact, we only need to maintain three variables $$$l, r, v$$$ to represent the current consecutive segment and the current value field. Therefore, this problem can be easily solved in $$$\mathcal O(n)$$$.
Code (C++)
#include <bits/stdc++.h>
 
namespace FastIO {
	template <typename T> inline T read() { T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= (ch == '-'), ch = getchar(); while ('0' <= ch && ch <= '9') x = x * 10 + (ch ^ '0'), ch = getchar(); return w ? -x : x; }
	template <typename T> inline void write(T x) { if (!x) return; write<T>(x / 10), putchar((x % 10) ^ '0'); }
	template <typename T> inline void print(T x) { if (x > 0) write<T>(x); else if (x < 0) putchar('-'), write<T>(-x); else putchar('0'); }
	template <typename T> inline void print(T x, char en) { print<T>(x), putchar(en); }
}; using namespace FastIO;
 
#define MAXN 3000001
int a[MAXN];
void solve() {
	int N = read<int>(); long long p = 0, l = 0, r = 0, v = 0;
	for (int i = 1; i <= N; ++i) p += (a[i] = read<int>());
	for (int i = 1; i <= N; ++i) if (a[i] >= 0) {
		l += a[i], r = std::min(r + a[i], p);
		if (l > r) ++v, l = a[i], r = p;
	} else {
		a[i] = -a[i];
		r -= a[i], l = std::max(l - a[i], 0ll);
		if (l > r) ++v, l = 0, r = p - a[i];
	}
	print<int>(v + N + (int)(r != p), '\n');
}
int main() { int T = read<int>(); while (T--) solve(); return 0; }
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2053H
Editorial Content:
2053H - Delicate Anti-monotonous Operations
Hint 1
What if $$$w = 2$$$? Is it optimal to increase $$$\sum\limits_{i=0}^n [a_i \neq a_{i+1}]$$$ (suppose $$$a_0 = a_{n+1} = 2$$$)?
Hint 2
If $$$w \geq 3$$$, what's the answer to the first question?
Hint 3
If $$$a_i = a_{i+1}$$$, after the operation we can obtain $$$a_{i-1} = a_i$$$ or $$$a_{i+1} = a_{i+2}$$$ (and possibly, both).
Hint 4
Try to think of the whole process reversedly. If $$$w \geq 3$$$, $$$1 \leq a_i \leq w - 1$$$, can you solve the problem?
Hint 5
How many extra operations are required for each $$$1 \leq i \leq n$$$ if $$$a_i = w$$$, in the above scheme you use for $$$a_i \leq w - 1$$$?
Solution
Read the Hints.
$$$w = 2$$$
After any operation, $$$k = \sum\limits_{i=0}^n [a_i \neq a_{i+1}]$$$ won't decrease (suppose $$$a_0 = a_{n+1} = 2$$$). For a fixed $$$k$$$, the maximal $$$\sum a_i = 2n - \frac{1}{2}k$$$ and can be reached by each time turning a $$$[2, 1, 1]$$$ into $$$[2, 2, 1]$$$ (or symmetrically, $$$[1, 1, 2] \rightarrow [1, 2, 2]$$$.
$$$w \geq 3$$$
No initial operations can be conducted, or $$$\min(a_i) = w$$$
This case is trivial.
$$$w \geq 3$$$
Some initial operations can be conducted
We claim that the answer to the first question is $$$nw - 1$$$. For the second question, let's study some rather easier cases below.
$$$w \geq 3$$$
Some initial operations can be conducted
$$$a_i \neq w$$$
We pretend that the final sequence is $$$[w, w, \dots, w, (w-1), w, w, \dots, w]$$$, then since $$$(a_i, a_{i+1})$$$ must be different after the operation, the last operation can only occur on $$$[w, (w-1)]$$$ (or $$$[(w-1), w]$$$). And since initially $$$a_i \neq w$$$, each position must have been operated on at least once.
This gives us states such as $$$[w, \dots, w, x, x, w, \dots, w]$$$, $$$[w, \dots, w, y, y, x, w, \dots, w]$$$, etc. To the leftmost positions, we get $$$a_1 = a_2$$$ (essentially based on Hint 3). Also, we get ...... $$$a_{n-1} = a_n$$$? This is if and only if the initial $$$[w, (w - 1)]$$$ is neither at the beginning nor at the end. If the initial $$$[w, (w - 1)]$$$ is at the beginning, we only need $$$a_{n-1} = a_n$$$ to achieve the goal, and symmetrically the same. Less is more. Obviously, we only need to satisfy either $$$a_1 = a_2$$$ or $$$a_{n-1} = a_n$$$, and then use $$$n - 1$$$ more operations to reach the target situation.
How do we get to $$$a_1 = a_2$$$ (symmetrically the same)? Based on Hint 3, we find the smallest $$$x$$$ that satisfies $$$a_x = a_{x+1}$$$, and then follow the example above, again using $$$x - 1$$$ operations to conduct the equality sign to $$$a_1 = a_2$$$.
Why is it optimal?
Lemma 1
: We can never choose an index $$$a_i = w$$$, fix it (i.e. avoid changing $$$a_i$$$ in the following operations), and then use some operations to reach $$$\sum a_i = nw - 1$$$ unless $$$[a_1, \ldots, a_i] = [w, \ldots, w]$$$ or $$$[a_i, \ldots, a_n] = [w, \ldots, w]$$$.
Proof
: If not so, the array is split into two parts: $$$[a_1, \ldots, a_{i-1}]$$$ and $$$[a_{i+1}, \ldots, a_n]$$$. We have: after some operations, the maximum $$$\sum a_i$$$ we can get for each part are respectively $$$(i-1)w - 1, (n-i)w - 1$$$, and add them up and we get $$$nw - 2$$$, which is less than $$$nw - 1$$$, so it's never optimal.
Lemma 2
: Look at the final array $$$a$$$, consisting of $$$n - 1$$$ element $$$w$$$ and $$$1$$$ element $$$(w - 1)$$$. Obtain an array $$$a'$$$ by keeping the elements with the value of $$$w$$$. Denote $$$t_i$$$ as the last round in which $$${a'}_i$$$ was changed to $$$w$$$ (and then become fixed). Then, there exists some $$$k$$$ such that $$$t_1 < t_2 < \dots < t_k > t_{k+1} > \dots > t_{n-1}$$$.
Proof
: This follows from
Lemma 1
.
According to
Lemma 2
, we can see the pattern that we used above is optimal.
$$$w \geq 3$$$
Some initial operations can be conducted
$$$a_1 \neq w, a_n \neq w$$$
Basically, the idea remains to reach $$$a_1 = a_2$$$ in the same way first (symmetrically the same), and then to extend to all positions. However, at this point, in the second stage, some problems may arise as follows:
$$$[\dots \underline{a_k}\ a_{k+1}\ w\ a_{k+3} \dots]$$$
$$$[\dots \underline{\color{red}{a_{k+1}}\ a_{k+1}}\ w\ a_{k+3} \dots]$$$
$$$[\dots \color{red}s\ \underline{\color{red}w\ w}\ a_{k+3} \dots]$$$
$$$[\dots \color{red}{\underline{s\ s}}\ t\ a_{k+3} \dots]$$$
$$$[\dots \color{red}w\ \underline{\color{red}t\ t}\ a_{k+3} \dots]$$$
$$$[\dots \color{red}{w\ w}\ \underline{\color{red}{a_{k+3}}\ a_{k+3}} \dots]$$$
In which $$$s, t, w$$$ are three distinct integers in the range $$$[1, w]$$$ (This also explains why we need to specially deal with the $$$w = 2$$$ case). Since we cannot fix $$$a_{k+2} = w$$$ at the beginning (refer to the "Why is it optimal?" spoiler above), we have to first change $$$a_{k+2}$$$ into something not equal to $$$w$$$, and that cost at least $$$2$$$ extra operations, which is shown here.
Do we always need $$$2$$$ extra operations?
One may note that if $$$a_i = a_{i+1} = w$$$, in which the two elements are both in the way of expansion, we can only use $$$1$$$ operation to vanish their existence. Formally, if there is a maximum continuous subsegment of $$$w$$$ in the way of expansion, let its length be $$$L$$$, then we will spend $$$\lceil \frac{L}{2} \rceil + [L = 1]$$$ extra operations.
What is 'in the way of expansion'?
Suppose in the first stage, we pick $$$a_x = a_{x+1}$$$ and keep operating on it until $$$a_1 = a_2$$$. Then after it, $$$\forall 3 \leq k \leq x + 1$$$, $$$a_k$$$ can be an arbitrary number which is different from the initial $$$a_{k-1}$$$, thus we can always force it to be $$$\neq w$$$.
In the above case, only elements $$$[a_{x+2}, \ldots, a_n]$$$ are considered 'in the way of expansion', and symmetrically the same.
$$$w \geq 3$$$
Some initial operations can be conducted
No additional constraints
It may come to you that if $$$a_1 = w$$$, we can ignore $$$a_1$$$; if $$$a_1 = a_2 = w$$$, we can ignore $$$a_2$$$. Symmetrically the same. And so on... Then we boil the problem down to the case above.
It is correct unless in some rare cases when we ignore all the prefixes and suffixes, there will be no remaining $$$a_i = a_{i+1}$$$; or if we pick any pair $$$a_i = a_{i+1}$$$ as the starting pair in the remaining array, it is not optimal compared to picking an $$$a_k = a_{k+1} = w (a_{k+2} \neq w)$$$ (symmetrically the same). So, we have to special handle the deleted prefix and suffix, once it has a length greater than $$$2$$$.
In summary, the problem can be solved in $$$\mathcal O(n)$$$.
Why is it optimal?
Lemma 1
: We can never choose an index $$$a_i = w$$$, fix it (i.e. avoid changing $$$a_i$$$ in the following operations), and then use some operations to reach $$$\sum a_i = nw - 1$$$ unless $$$[a_1, \ldots, a_i] = [w, \ldots, w]$$$ or $$$[a_i, \ldots, a_n] = [w, \ldots, w]$$$.
Proof
: If not so, the array is split into two parts: $$$[a_1, \ldots, a_{i-1}]$$$ and $$$[a_{i+1}, \ldots, a_n]$$$. We have: after some operations, the maximum $$$\sum a_i$$$ we can get for each part are respectively $$$(i-1)w - 1, (n-i)w - 1$$$, and add them up and we get $$$nw - 2$$$, which is less than $$$nw - 1$$$, so it's never optimal.
Lemma 2
: Look at the final array $$$a$$$, consisting of $$$n - 1$$$ element $$$w$$$ and $$$1$$$ element $$$(w - 1)$$$. Obtain an array $$$a'$$$ by keeping the elements with the value of $$$w$$$. Denote $$$t_i$$$ as the last round in which $$${a'}_i$$$ was changed to $$$w$$$ (and then become fixed). Then, there exists some $$$k$$$ such that $$$t_1 < t_2 < \dots < t_k > t_{k+1} > \dots > t_{n-1}$$$.
Proof
: This follows from
Lemma 1
.
According to
Lemma 2
, we can see the pattern that we used above is optimal.
What is 'in the way of expansion'?
Suppose in the first stage, we pick $$$a_x = a_{x+1}$$$ and keep operating on it until $$$a_1 = a_2$$$. Then after it, $$$\forall 3 \leq k \leq x + 1$$$, $$$a_k$$$ can be an arbitrary number which is different from the initial $$$a_{k-1}$$$, thus we can always force it to be $$$\neq w$$$.
In the above case, only elements $$$[a_{x+2}, \ldots, a_n]$$$ are considered 'in the way of expansion', and symmetrically the same.
Code (C++)
#include <bits/stdc++.h>

#define MAXN 200005
int a[MAXN];

void solve() {
	int N, w; scanf("%d%d", &N, &w);
	for (int i = 1; i <= N; ++i) scanf("%d", a + i);
	if (N == 1) return (void)printf("%d 0\n", a[1]);
	if (*std::min_element(a + 1, a + N + 1) == w)
		return (void)printf("%lld 0\n", 1ll * w * N);
	if (w == 2) {
		int ans = N * 2, pans = 0;
		for (int i = 1, j = 1; i <= N; i = ++j) if (a[i] == 1) {
			--ans; while (j < N && a[j + 1] == 1) ++j; pans += j - i;
		}
		return (void)printf("%d %d\n", ans, pans);
	}
	bool flag = true;
	for (int i = 1; i < N; ++i) if (a[i] == a[i + 1]) flag = false;
	if (flag) return (void)printf("%lld 0\n", std::accumulate(a + 1, a + N + 1, 0ll));
	printf("%lld ", 1ll * w * N - 1);
	if (std::accumulate(a + 1, a + N + 1, 0ll) == 1ll * w * N - 1) return (void)puts("0");
	int ans = 0x3f3f3f3f, l = (a[1] == w ? 2 : 1), r = (a[N] == w ? N - 1 : N);
	if ((a[1] == w && a[2] == w) || (a[N] == w && a[N - 1] == w)) {
		int Lw = 0, Rw = N + 1;
		while (a[Lw + 1] == w) ++Lw; while (a[Rw - 1] == w) --Rw;
		int pans = Rw - Lw;
		for (int i = Lw + 1, j = i; i < Rw; i = ++j) if (a[i] == w) {
			while (j + 1 < Rw && a[j + 1] == w) ++j;
			pans += (i == j ? 2 : ((j - i) >> 1) + 1);
		}
		ans = pans, l = Lw + 1, r = Rw - 1;
	}
	for (int d = 0; d < 2; std::reverse(a + l, a + r + 1), ++d) 
		for (int i = l - 1, pre = 0, len = 0; i + 2 <= r; ) {
			if (a[i + 1] == a[i + 2]) 
				ans = std::min(r - (i + 1) + r - l - 1 + pre - ((len == 1) && i + 2 < r && a[i + 3] != w ? 1 : 0), ans);
			++i; if (a[i] == w) ++len, pre += (len == 1 ? 2 : len == 2 ? -1 : (len & 1)); else len = 0;
	}
	printf("%d\n", ans);
}

int main() { int T; scanf("%d", &T); while (T--) solve(); return 0; }
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2053G
Editorial Content:
2053G - Naive String Splits
Hint 1
(If we do not have to be deterministic) We do not need any hard string algorithm.
Hint 2
In what cases won't greed work? Why?
Hint 3
Is your brute forces actually faster (maybe you can explain it by harmonic series)?
Solution
Let's call the prefix $$$s_1$$$ the short string and the suffix $$$s_2$$$ the long string. If $$$\lvert s_1\rvert\gt \lvert s_2\rvert$$$, swapping the order doesn't affect the answer.
Consider a greedy approach. We first match a few short strings until we can't match anymore. If we can't match, we try discarding a few short strings and placing one long string. We enumerate how many short strings to discard.
Find the first position where we can place a long string.
We call this placing once a "matching process." The starting position of each "matching process" is the next position after the previous "matching process."
However, this approach has a flaw. Below, I will explain the situation where this flaw occurs.
Why it has a flaw
It's not difficult to view the long string as several short strings concatenated with a "tail" at the end.
Why only find the first position? Why wouldn't it be better to backtrack and discard a few more $$$s_1$$$'s before placing the long string?
The diagram above is an example. The red line indicates the cutoff position for matching $$$s_1$$$. The three orange boxes represent the possible choices for attempting to match the long string.
The last one is invalid, so skip it. Replace it with the "The first valid position to place the long string." box. This box is correct.
The difference between choosing the second box and the first box is that when we end the matching and proceed to the next round, the content we need to match is that a suffix of $$$s_1$$$ has been moved to the beginning of $s_1$。
As shown in the diagram.
The alignment results in the following diagram.
In the diagram, the case where $$$\lvert pre\rvert \gt \lvert suf\rvert$$$ is shown. The other case follows similarly.
$$$pre+suf=suf+pre$$$, and as can be seen from the diagram, here $$$pre+suf$$$ needs to be "misaligned but equal." This means that $$$s_1$$$ must have a periodic cycle, and the "tail" must also be able to be formed through this cycle. Additionally, the $$$\lvert s_1 \rvert$$$ characters at the beginning of $$$s_2$$$ must still be able to be formed by the periodic cycle.
In summary, it is equivalent to $$$s_1$$$ and $$$s_2$$$ having a
common periodic cycle
.
In other words,
backtracking twice can lead to a solution, but backtracking once may not always work
. It is necessary for $$$s_1$$$ and $$$s_2$$$ to have a common periodic cycle.
Having a common periodic cycle is too specific. First, the common periodic cycle of these two strings must indeed be the periodic cycle of string $$$s$$$. By finding this cycle in advance, it essentially becomes a problem of solving an equation. Let $$$a=\lvert s_1\rvert $$$ and $$$b=\lvert s_2\rvert$$$, and we need to check whether there are non-negative integer solutions $$$x$$$ and $$$y$$$ that satisfy the equation $$$xa+yb=\lvert s \rvert$$$.
This equation-solving part is just for show. We enumerate $$$y$$$, and for each value of $$$y$$$, we compute the enumeration $$$\mathcal O\left(\frac{m}{n}\right)$$$ times. At most, we do this $$$n$$$ times, so the overall complexity is $$$\mathcal O(m)$$$.
If we directly implement this, the worst-case complexity is related to the harmonic series. Consider a case like $$$s_1 = \texttt{a}, s_2 = \texttt{aaaaaaaab}$$$, and $$$t = \texttt{aaaaaaaaaaaaaaaaaaaaaaaaab}$$$. In this case, we would need to attempt $$$\mathcal O\left(\frac{m}{\lvert s_1\rvert }\right)$$$ steps to finish matching the short string. Each time we backtrack, it requires at most $$$\mathcal O\left(\frac{m}{\lvert s_2\rvert }\right)$$$ steps, and each of those takes $$$\mathcal O\left(\frac{\lvert s_2\rvert }{\lvert s_1\rvert }\right)$$$.
Why it has a flaw
It's not difficult to view the long string as several short strings concatenated with a "tail" at the end.
Why only find the first position? Why wouldn't it be better to backtrack and discard a few more $$$s_1$$$'s before placing the long string?
The diagram above is an example. The red line indicates the cutoff position for matching $$$s_1$$$. The three orange boxes represent the possible choices for attempting to match the long string.
The last one is invalid, so skip it. Replace it with the "The first valid position to place the long string." box. This box is correct.
The difference between choosing the second box and the first box is that when we end the matching and proceed to the next round, the content we need to match is that a suffix of $$$s_1$$$ has been moved to the beginning of $s_1$。
As shown in the diagram.
The alignment results in the following diagram.
In the diagram, the case where $$$\lvert pre\rvert \gt \lvert suf\rvert$$$ is shown. The other case follows similarly.
$$$pre+suf=suf+pre$$$, and as can be seen from the diagram, here $$$pre+suf$$$ needs to be "misaligned but equal." This means that $$$s_1$$$ must have a periodic cycle, and the "tail" must also be able to be formed through this cycle. Additionally, the $$$\lvert s_1 \rvert$$$ characters at the beginning of $$$s_2$$$ must still be able to be formed by the periodic cycle.
Optimization to Linear
Thanks to
o
rzdevinwang
and
crazy_sea
for pointing out it!
Yes, this problem can indeed be solved in linear time.
First, let the prefix of the long string contain $$$c$$$ short strings. Then, the first "valid position to place the long string" we backtrack to can only be obtained by either backtracking $$$c$$$ short strings or $$$c+1$$$ short strings.
This is easy to understand. Backtracking $$$c$$$ short strings means considering the prefix of the long string, then adding the "tail" of the long string. Backtracking $$$c + 1$$$ short strings only happens when the "tail" part of the long string is a prefix of the short string. For example, the hack in the CF comment section:
https://codeforces.com/blog/entry/136455?#comment-1234262
1
8 8
abaabaab
abaababa
The correct output should be:
0010000
When $$$k = 3$$$, $$$s_1 = \texttt{aba}$$$, $$$s_2 = \texttt{abaab}$$$, we first filled in 2 short strings, but if we backtrack $$$c = 1$$$ short string, it will be judged as unsolvable. This is how the error in std occurs. This situation only arises when the "tail" part of $$$s_2$$$ is a prefix of $$$s_1$$$.
So, each time we calculate, we first use binary search to find this $$$c$$$, and the complexity is $$$\mathcal O\left(\sum\limits_{i=1}^n\log(\frac n i)\right)=\mathcal O(n)$$$. After that, backtracking only requires two checks. The backtracking process becomes linear.
Next, let's accelerate the process of filling in short strings. The hack for brute-force filling has already been given above. If we directly use the method that everyone initially thought was correct, which is the "binary search for the number of short string occurrences" method, Then it can be accelerated by this set of hacks to achieve a $$$\log$$$ complexity.
1
2 5000000
ab
abababab....abababab
crazy_sea
points out an alternative solution.
Similar to block division, let $$$B = \frac{n}{\lvert s_1\rvert}$$$. We first try to match $$$B$$$ occurrences of $$$s_1$$$, meaning that each match can move forward by $$$n$$$ positions. After that, the remaining part will not exceed $$$B$$$ occurrences, and we binary search to find how many are left. For the part where we moved forward by $$$B$$$ occurrences, we can backtrack at most once, and then the binary search will take $$$\mathcal O(\log B)$$$. Each time, we can at least fill in $$$\lvert s_2\rvert $$$ occurrences. The time complexity for calculating the answer becomes $$$\mathcal O\left(\frac{m}{\lvert s_2\rvert }\log B\right)$$$, and the total complexity, due to $$$\mathcal O\left(\sum\limits_{i=1}^n \log(\frac{n}{i})\right) = \mathcal O(n)$$$, is $$$\mathcal O(m)$$$.
Thus, the problem is solved in linear time.
...wtf?
During testing, we found that
j
qdai0815
's solution is actually more violent than we thought (We have also received something similar in contest).
He specially handled the case in which $$$X$$$ and $$$T$$$ share a common shortest period, and for the rest $$$i$$$, he just used two queues to optimize the BFS progress (actually changing it to
std::priority_queue<int>
or similar also works), and it passed just seeming to have a larger constant time complexity.
I'm curious if anybody can (hack it or) prove that it is correct. Thanks in advance!
Code (log, C++)
This is written by
Caylex
.
#include <bits/stdc++.h>
using namespace std;
template <int P>
class mod_int
{
    using Z = mod_int;

private:
    static int mo(int x) { return x < 0 ? x + P : x; }

public:
    int x;
    int val() const { return x; }
    mod_int() : x(0) {}
    template <class T>
    mod_int(const T &x_) : x(x_ >= 0 && x_ < P ? static_cast<int>(x_) : mo(static_cast<int>(x_ % P))) {}
    bool operator==(const Z &rhs) const { return x == rhs.x; }
    bool operator!=(const Z &rhs) const { return x != rhs.x; }
    Z operator-() const { return Z(x ? P - x : 0); }
    Z pow(long long k) const
    {
        Z res = 1, t = *this;
        while (k)
        {
            if (k & 1)
                res *= t;
            if (k >>= 1)
                t *= t;
        }
        return res;
    }
    Z &operator++()
    {
        x < P - 1 ? ++x : x = 0;
        return *this;
    }
    Z &operator--()
    {
        x ? --x : x = P - 1;
        return *this;
    }
    Z operator++(int)
    {
        Z ret = x;
        x < P - 1 ? ++x : x = 0;
        return ret;
    }
    Z operator--(int)
    {
        Z ret = x;
        x ? --x : x = P - 1;
        return ret;
    }
    Z inv() const { return pow(P - 2); }
    Z &operator+=(const Z &rhs)
    {
        (x += rhs.x) >= P && (x -= P);
        return *this;
    }
    Z &operator-=(const Z &rhs)
    {
        (x -= rhs.x) < 0 && (x += P);
        return *this;
    }
    Z operator-() { return -x; }
    Z &operator*=(const Z &rhs)
    {
        x = 1ULL * x * rhs.x % P;
        return *this;
    }
    Z &operator/=(const Z &rhs) { return *this *= rhs.inv(); }
#define setO(T, o)                                  \
    friend T operator o(const Z &lhs, const Z &rhs) \
    {                                               \
        Z res = lhs;                                \
        return res o## = rhs;                       \
    }
    setO(Z, +) setO(Z, -) setO(Z, *) setO(Z, /)
#undef setO
        friend istream &
        operator>>(istream &is, mod_int &x)
    {
        long long tmp;
        is >> tmp;
        x = tmp;
        return is;
    }
    friend ostream &operator<<(ostream &os, const mod_int &x)
    {
        os << x.val();
        return os;
    }
};
typedef long long ll;
typedef unsigned long long ull;
mt19937 rnd(chrono::system_clock::now().time_since_epoch().count());
constexpr int p = 993244853;
using Hash = mod_int<p>;
// using Hash = ull;
const Hash base = rnd() % 20091119 + 30;
string s, t;
Hash st;
int mnlen;
Hash S[5000020];
Hash T[5000020];
Hash pw[5000020];
inline Hash SUM(const int l, const int r, const Hash *s) { return s[r] - s[l - 1] * pw[r - l + 1]; }
int n, m;
inline bool check(const int l, const int r, const Hash x, const int len, const Hash *S) { return r - l + 1 >= len && SUM(l, l + len - 1, S) == x && SUM(l, r - len, S) == SUM(l + len, r, S); }
inline bool calc(const int L1, const int R1, const int L2, const int R2, const int l1, const int l2)
{
    if (mnlen && check(L1, R1, st, mnlen, S) && check(L2, R2, st, mnlen, S))
    {
        if (check(1, m, st, mnlen, T))
        {
            for (int i = 0; i <= m; i += l2)
            {
                if (!((m - i) % l1))
                    return 1;
            }
            return 0;
        }
    }
    const Hash s1 = SUM(L1, R1, S);
    const Hash s2 = SUM(L2, R2, S);
    // int l = 1, r = l2 / l1, okcnt = 0;
    // while (l <= r)
    // {
    //     int mid = l + r >> 1;
    //     if (check(L2, L2 + mid * l1 - 1, s1, l1, S))
    //         l = (okcnt = mid) + 1;
    //     else
    //         r = mid - 1;
    // }
    int ed = 0;
    while (ed <= m)
    {
        int L = 1, R = (m - ed) / l1, cnt = 0;
        while (L <= R)
        {
            int mid = L + R >> 1;
            if (check(ed + 1, ed + mid * l1, s1, l1, T))
                L = (cnt = mid) + 1;
            else
                R = mid - 1;
        }
        if (ed + cnt * l1 + 1 > m)
            return 1;
        // bool found = 0;
        // int st = ed + (cnt - okcnt) * l1 + 1;
        // if (st > ed && st + l2 - 1 <= m && SUM(st, st + l2 - 1, T) == s2)
        // {
        //     ed = st + l2 - 1;
        //     found = 1;
        // }
        // if (!found)
        //     return 0;
        bool found = 0;
        for (int st = ed + cnt * l1 + 1; st > ed; st -= l1)
        {
            if (st + l2 - 1 <= m && SUM(st, st + l2 - 1, T) == s2)
            {
                ed = st + l2 - 1;
                found = 1;
                break;
            }
        }
        if (!found)
            return 0;
    }
    return 1;
}
void solve()
{
    // build();
    mnlen = 0;
    cin >> n >> m >> s >> t;
    s = ' ' + s;
    t = ' ' + t;
    for (int i = 1; i <= n; i++)
        S[i] = S[i - 1] * base + Hash(s[i] - 'a' + 1);
    for (int i = 1; i <= m; i++)
        T[i] = T[i - 1] * base + Hash(t[i] - 'a' + 1);
    for (int i = 1; i <= n; i++)
    {
        if (n % i == 0 && check(1, n, S[i], i, S))
        {
            st = S[i];
            mnlen = i;
            break;
        }
    }
    for (int i = 1; i < n; i++)
        putchar('0' ^ (i <= n - i ? calc(1, i, i + 1, n, i, n - i) : calc(i + 1, n, 1, i, n - i, i)));
    putchar('\n');
}
int main()
{
    pw[0] = Hash(1);
    for (int i = 1; i <= 5'000'000; i++)
        pw[i] = pw[i - 1] * base;
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int t;
    cin >> t;
    while (t--)
        solve();
    return 0;
}
Code (linear, C++)
This is written by
Caylex
.
#include <bits/stdc++.h>
using namespace std;
template <int P>
class mod_int
{
    using Z = mod_int;

private:
    static int mo(int x) { return x < 0 ? x + P : x; }

public:
    int x;
    int val() const { return x; }
    mod_int() : x(0) {}
    template <class T>
    mod_int(const T &x_) : x(x_ >= 0 && x_ < P ? static_cast<int>(x_) : mo(static_cast<int>(x_ % P))) {}
    bool operator==(const Z &rhs) const { return x == rhs.x; }
    bool operator!=(const Z &rhs) const { return x != rhs.x; }
    Z operator-() const { return Z(x ? P - x : 0); }
    Z pow(long long k) const
    {
        Z res = 1, t = *this;
        while (k)
        {
            if (k & 1)
                res *= t;
            if (k >>= 1)
                t *= t;
        }
        return res;
    }
    Z &operator++()
    {
        x < P - 1 ? ++x : x = 0;
        return *this;
    }
    Z &operator--()
    {
        x ? --x : x = P - 1;
        return *this;
    }
    Z operator++(int)
    {
        Z ret = x;
        x < P - 1 ? ++x : x = 0;
        return ret;
    }
    Z operator--(int)
    {
        Z ret = x;
        x ? --x : x = P - 1;
        return ret;
    }
    Z inv() const { return pow(P - 2); }
    Z &operator+=(const Z &rhs)
    {
        (x += rhs.x) >= P && (x -= P);
        return *this;
    }
    Z &operator-=(const Z &rhs)
    {
        (x -= rhs.x) < 0 && (x += P);
        return *this;
    }
    Z operator-() { return -x; }
    Z &operator*=(const Z &rhs)
    {
        x = 1ULL * x * rhs.x % P;
        return *this;
    }
    Z &operator/=(const Z &rhs) { return *this *= rhs.inv(); }
#define setO(T, o)                                  \
    friend T operator o(const Z &lhs, const Z &rhs) \
    {                                               \
        Z res = lhs;                                \
        return res o## = rhs;                       \
    }
    setO(Z, +) setO(Z, -) setO(Z, *) setO(Z, /)
#undef setO
        friend istream &
        operator>>(istream &is, mod_int &x)
    {
        long long tmp;
        is >> tmp;
        x = tmp;
        return is;
    }
    friend ostream &operator<<(ostream &os, const mod_int &x)
    {
        os << x.val();
        return os;
    }
};
typedef long long ll;
typedef unsigned long long ull;
mt19937 rnd(chrono::system_clock::now().time_since_epoch().count());
constexpr int p = 993244853;
using Hash = mod_int<p>;
// using Hash = ull;
const Hash base = rnd() % 20091119 + 30;
string s, t;
Hash st;
int mnlen;
Hash S[5000020];
Hash T[5000020];
Hash pw[5000020];
// int doit;
inline Hash SUM(const int l, const int r, const Hash *s) { return s[r] - s[l - 1] * pw[r - l + 1]; }
int n, m;
inline bool check(const int l, const int r, const Hash x, const int len, const Hash *S)
{
    // doit++;
    return r - l + 1 >= len && SUM(l, l + len - 1, S) == x && SUM(l, r - len, S) == SUM(l + len, r, S);
}
inline bool calc(const int L1, const int R1, const int L2, const int R2, const int l1, const int l2)
{
    if (mnlen && check(L1, R1, st, mnlen, S) && check(L2, R2, st, mnlen, S))
    {
        if (check(1, m, st, mnlen, T))
        {
            for (int i = 0; i <= m; i += l2)
            {
                if (!((m - i) % l1))
                    return 1;
            }
            return 0;
        }
    }
    const Hash s1 = SUM(L1, R1, S);
    const Hash s2 = SUM(L2, R2, S);
    int l = 1, r = l2 / l1, okcnt = 0;
    while (l <= r)
    {
        int mid = l + r >> 1;
        if (check(L2, L2 + mid * l1 - 1, s1, l1, S))
            l = (okcnt = mid) + 1;
        else
            r = mid - 1;
    }
    const int tt = (n / l1);
    int ed = 0;
    while (ed <= m)
    {
        int L = 1, R = (m - ed) / l1, cnt = 0;
        int tcnt = 0;
        while (tcnt + tt <= R && check(ed + 1, ed + (tcnt + tt) * l1, s1, l1, T))
            tcnt += tt;
        L = max(L, tcnt);
        R = min(R, tcnt + tt - 1);
        // cerr << ed << ' ' << L << ' ' << R << '\n';
        while (L <= R)
        {
            int mid = L + R >> 1;
            if (check(ed + 1, ed + mid * l1, s1, l1, T))
                L = (cnt = mid) + 1;
            else
                R = mid - 1;
        }
        if (ed + cnt * l1 + 1 > m)
            return 1;
        // int st = ed + (cnt - okcnt) * l1 + 1;
        // if (st > ed && st + l2 - 1 <= m && SUM(st, st + l2 - 1, T) == s2)
        // {
        //     ed = st + l2 - 1;
        //     continue;
        // }
        // return 0;
        bool found = 0;
        for (int st = ed + (cnt - okcnt) * l1 + 1, cnt = 1; cnt <= 2 && st > ed; st -= l1, cnt++)
        {
            if (st + l2 - 1 <= m && SUM(st, st + l2 - 1, T) == s2)
            {
                ed = st + l2 - 1;
                found = 1;
                break;
            }
        }
        if (!found)
            return 0;
    }
    return 1;
}
void solve()
{
    // build();
    mnlen = 0;
    cin >> n >> m >> s >> t;
    s = ' ' + s;
    t = ' ' + t;
    for (int i = 1; i <= n; i++)
        S[i] = S[i - 1] * base + Hash(s[i] - 'a' + 1);
    for (int i = 1; i <= m; i++)
        T[i] = T[i - 1] * base + Hash(t[i] - 'a' + 1);
    for (int i = 1; i <= n; i++)
    {
        if (n % i == 0 && check(1, n, S[i], i, S))
        {
            st = S[i];
            mnlen = i;
            break;
        }
    }
    for (int i = 1; i < n; i++)
        putchar('0' ^ (i <= n - i ? calc(1, i, i + 1, n, i, n - i) : calc(i + 1, n, 1, i, n - i, i)));
    putchar('\n');
    // cerr << doit << '\n';
}
int main()
{
    // freopen("out.txt", "r", stdin);
    pw[0] = Hash(1);
    for (int i = 1; i <= 5'000'000; i++)
        pw[i] = pw[i - 1] * base;
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int t;
    cin >> t;
    while (t--)
        solve();
    // cerr << fixed << setprecision(10) << 1.0 * clock() / CLOCKS_PER_SEC << '\n';
    return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2053F
Editorial Content:
2053F - Earnest Matrix Complement
Hint 1
What are we going to fill into the matrix? In other words, is there any relationship between the filed numbers?
Hint 2
Try to come up with a naive DP solution that works in large time complexity, such as $$$\mathcal O(nk^2)$$$.
Hint 3
For many different numbers between two consecutive rows, however, the transition is almost the same.
Hint 4
If $$$x' = \max(a, x + b)$$$ and $$$x'' = \max(c, x' + d)$$$, then $$$x'' = \max(\max(a + d, c), x + b + d)$$$.
Solution
Conclusion
: For each row, an optimal solution exists, such that the newly filled-in numbers are the same.
Proof
: Consider fixing the rows $$$i - 1$$$ and $$$i + 1$$$, and observe all the newly filled-in numbers at row $$$i$$$. Then a new number $$$u$$$ brings a contribution of $$$c_{u, i-1} + c_{u, i+1}$$$, and it is clear that there exists a scheme that takes the maximum value such that all the $$$u$$$ filled in are equal. Adjusting for each row leads to the above conclusion.
Consider dp. Let $$$f_{i,j}$$$ denote the maximum contribution that can be achieved between the first $$$i$$$ rows
(ignoring the initial contribution)
when the empty elements in the $$$i$$$-th row are filled with $$$j$$$. Let $$$c_i$$$ be the number of $$$-1$$$ numbers in the $$$i$$$-th row, and $$$d_{i,j}$$$ denote the number of elements $$$j$$$ in the $$$i$$$-th row initially.
The transfer should be as follows:
$$$f_{i, j} = \max(\max\limits_{1 \leq w \leq k}(f_{i-1, w} + c_i \cdot d_{i-1, w} + c_{i-1} \cdot d_{i-1, j}), f_{i-1, j} + (d_{i, j} + c_i) \cdot (d_{i-1, j} + c_{i-1}) - d_{i, j}d_{i-1, j}).$$$
In addition to being able to optimize the above transition to $$$\mathcal O(nk)$$$, the present problem in a matrix has a good property. Specifically, for the same $$$i$$$, there are only $$$\mathcal O(m)$$$ values of $$$j$$$ such that $$$d_{i,j} \neq 0$$$!
If $$$d_{i,j} = 0$$$ and $$$d_{i-1, j} = 0$$$, the original transfer can be viewed as
$$$f_{i,j} = \max(\max\limits_{1 \leq w \leq k}(f_{i-1, w}), f_{i-1, j} + c_i \cdot c_{i-1}).$$$
This can be seen as a global modification in the form of $$$x \gets \max(a, x + b)$$$. The tags are composable in $$$\mathcal O(1)$$$; Otherwise, we can brutely update the new $$$dp_j$$$ for $$$\mathcal O(m)$$$ positions.
Therefore, this problem is solved in $$$\mathcal O(nm)$$$. We decided to let every segment tree solution pass comfortably, so that we set small constraints and large TL.
Bonus Hint for implementation: always use $$$\max(a, dp_j + b)$$$ to get the real value.
Code (C++)
#include <bits/stdc++.h>
 
namespace FastIO {
	char buf[1 << 21], *p1 = buf, *p2 = buf;
#define getchar() (p1 == p2 && (p1 = buf, p2 = (p1 + fread(buf, 1, 1 << 21, stdin))) == p1 ? EOF : *p1++)
	template <typename T> inline T read() { T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= (ch == '-'), ch = getchar(); while ('0' <= ch && ch <= '9') x = x * 10 + (ch ^ '0'), ch = getchar(); return w ? -x : x; }
	template <typename T> inline void write(T x) { if (!x) return; write<T>(x / 10), putchar((x % 10) ^ '0'); }
	template <typename T> inline void print(T x) { if (x > 0) write<T>(x); else if (x < 0) putchar('-'), write<T>(-x); else putchar('0'); }
	template <typename T> inline void print(T x, char en) { print<T>(x), putchar(en); }
#undef getchar
}; using namespace FastIO;
 
using ll = long long;
void solve() {
	int n = read<int>(), m = read<int>(), k = read<int>(); ll cntP = 0, cntQ = 0;
	std::vector<int> vep(m), veq(m), cntp(k + 1), cntq(k + 1), vis(k + 1);
	std::vector<ll> dp(k + 1); ll a = 0, b = 0, v = 0, ext = 0; // max(a, x + b).
	cntp[0] = cntq[0] = m;
	auto get = [&](int x) -> int { return (~x) ? x : 0; };
	auto read_q = [&]() -> void {
		for (int i = 0; i < m; ++i) --cntq[get(veq[i])];
		for (int i = 0; i < m; ++i) ++cntq[get(veq[i] = read<int>())];
		cntQ = cntq[0];
	};
	auto roll = [&]() -> void { std::swap(vep, veq), std::swap(cntp, cntq), std::swap(cntP, cntQ); };
	auto chkmax = [&](ll &a, ll b) -> void { a = std::max(a, b); };
	read_q(), roll();
	for (int i = 2; i <= n; ++i) {
		read_q();
		ll max_dp = std::max(a, v + b);
		for (int k : vep) if (~k) chkmax(max_dp, std::max(a, dp[k] + b) + cntP * cntq[k]);
		for (int k : veq) if (~k) chkmax(max_dp, std::max(a, dp[k] + b) + cntP * cntq[k]);
		for (int k : vep) if ((~k) && vis[k] != i) {
			vis[k] = i, ext += 1ll * cntp[k] * cntq[k];
			dp[k] = std::max(a, dp[k] + b) + cntP * cntq[k] + cntQ * cntp[k] - b;
			chkmax(dp[k], max_dp + cntp[k] * cntQ - b - cntP * cntQ);
			chkmax(v, dp[k]);
		} for (int k : veq) if ((~k) && vis[k] != i) {
			vis[k] = i;
			dp[k] = std::max(a, dp[k] + b) + cntP * cntq[k] + cntQ * cntp[k] - b;
			chkmax(dp[k], max_dp + cntp[k] * cntQ - b - cntP * cntQ);
			chkmax(v, dp[k]);
		} a = std::max(max_dp, a + cntP * cntQ), b += cntP * cntQ;
		roll();
	} print<ll>(std::max(a, v + b) + ext, '\n');
}
 
int main() { int T = read<int>(); while (T--) solve(); return 0; }
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2053E
Editorial Content:
2053E - Resourceful Caterpillar Sequence
Hint 1
Suppose somebody wins. In which round does he or she win?
Hint 2
A player can always undo what his opponent did in the previous turn.
Hint 3
Can you find the necessary and sufficient condition for $$$(p, q)$$$ to be a caterpillar that makes Aron win?
Solution
Denote Nora's first move as round $$$1$$$, Aron's first move as round $$$2$$$, and so on. Suppose a player does not have a winning strategy in the $$$k$$$-th round, but he or she has a winning strategy in the $$$(k + 2)$$$-th round — it can be shown impossible because the other player can always withdraw the last move of another player so that the status is the same as it was before the $$$k$$$-th round.
Therefore: if a player wins in the $$$k$$$-th round, we claim that $$$k \leq 2$$$.
Given $$$p, q$$$, let's determine who will eventually win the game.
If both $$$p$$$ and $$$q$$$ are leaves, the result is a tie.
If $$$p$$$ is a leaf while $$$q$$$ is not, Nora wins.
If $$$q$$$ is a leaf while $$$p$$$ is not, Aron wins.
If neither $$$p$$$ nor $$$q$$$ is a leaf:
Can $$$k = 1$$$? Nora wins if and only if $$$p$$$ is adjacent to a leaf.
Can $$$k = 2$$$? Aron wins if and only if $$$p$$$ is not adjacent to a leaf, and $$$f(p, q)$$$ is adjacent to a leaf.
Otherwise, the result is a tie.
The counting part can also be solved easily in $$$\mathcal O(n)$$$. Denote $$$c$$$ as the number of leaves. The initial answer would be $$$c \cdot (n - c)$$$, considering the third case. For the fourth case, we can enumerate $$$m = f(p, q)$$$, which is adjacent to at least one leaf. Given $$$m$$$, $$$q$$$ must be a non-leaf neighbor of $$$m$$$, and let the number of different $$$q$$$ be $$$k$$$. For each of the potential $$$p$$$, which is a non-leaf node whose neighbors are all non-leaf nodes too, it is computed exactly $$$k - 1$$$ times for all the $$$k$$$ candidates of $$$q$$$ (since $$$m$$$ must be on the simple path from $$$p$$$ to $$$q$$$), so the extra contributions are easy to calculate. (If you do not think that much, you can use some simple DP, which I will not elaborate here.)
Code (C++)
#include <bits/stdc++.h>

#define MAXN 200001
std::vector<int> g[MAXN];
inline int deg(int u) { return g[u].size(); }

int d[MAXN];
void solve() {
	int n; std::cin >> n; long long ans = 0;
	for (int i = 1, u, v; i < n; ++i) {
		std::cin >> u >> v;
		g[u].push_back(v), g[v].push_back(u);
	}
	int c1 = 0, c2 = 0;
	for (int i = 1; i <= n; ++i) c1 += (deg(i) == 1);
	ans += 1ll * c1 * (n - c1);
	for (int i = 1; i <= n; ++i) if (deg(i) > 1) {
		for (int v : g[i]) d[i] += (deg(v) > 1);
		c2 += (d[i] == deg(i));
	}
	for (int m = 1; m <= n; ++m) if (deg(m) > 1 && d[m] != deg(m)) 
		ans += 1ll * c2 * (d[m] - 1);
	std::cout << ans << '\n';
	for (int i = 1; i <= n; ++i) 
		(std::vector<int>()).swap(g[i]), d[i] = 0;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr), std::cout.tie(nullptr);
	int t; std::cin >> t; while (t--) solve(); return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2053D
Editorial Content:
2053D - Refined Product Optimality
Hint 1
What if $$$q = 0$$$?
Hint 2
How do you keep the array sorted?
Solution
The problem makes no difference when both $$$a$$$ and $$$b$$$ can be rearranged. Let the rearranged arrays of $$$a$$$ and $$$b$$$ be $$$c$$$ and $$$d$$$ respectively.
If $$$q = 0$$$, we can write $$$c$$$ as $$$\operatorname{SORTED}(a_1, a_2 \ldots, a_n)$$$ and $$$d$$$ as $$$\operatorname{SORTED}(b_1, b_2 \ldots, b_n)$$$. It can be proved that this reaches the maximum value: if not so, then
There must be some pair $$$(i, j)$$$ such that $$$c_i < c_j, d_i > d_j$$$.
Since $$$\min(c_i, d_i) \cdot \min(c_j, d_j) = c_i \cdot \min(c_j, d_j) \leq c_i \cdot \min(c_j, d_i) = \min(c_i, d_j) \cdot \min(c_j, d_i)$$$, we can swap $$$d_i$$$ and $$$d_j$$$, and the product does not decrease.
Consider the modification, which is a single element increment by $$$1$$$. Without loss of generality, let $$$c_x$$$ be increased by $$$1$$$ (and the processing method for $$$d$$$ is the same). If $$$c_x < c_{x+1}$$$, then after the modification $$$c_x \leq c_{x+1}$$$, which would be fine. Otherwise, we can modify the array $$$c$$$ in the form of a single round of "Insertion Sort": We continuously swap $$$c_x$$$ and $$$c_{x+1}$$$, $$$x \gets x + 1$$$, until $$$c_x < c_{x+1}$$$ (or $$$x = n$$$), and thus the array remains sorted after the increment.
In fact, the swap operation does nothing in the above process: in these cases, $$$c_x = c_{x+1}$$$ holds! So we can just set $$$x'$$$ as the maximum $$$k$$$ such that $$$c_k = c_x$$$, and then increase $$$c_{x'}$$$ by $$$1$$$, after which $$$c$$$ is still sorted. The $$$k$$$ can be found with a naive binary search, so the problem is solved in $$$\mathcal O(n\log n + q(\log p + \log n))$$$ per test case.
Code (C++)
#include <bits/stdc++.h>
 
constexpr int MOD = 998244353;
int qpow(int a, int x = MOD - 2) {
	int res = 1;
	for (; x; x >>= 1, a = 1ll * a * a % MOD) if (x & 1) res = 1ll * res * a % MOD;
	return res;
}
 
#define MAXN 200001
int a[MAXN], b[MAXN], c[MAXN], d[MAXN];
void solve() {
	int n, q, res = 1; std::cin >> n >> q;
	for (int i = 1; i <= n; ++i) std::cin >> a[i], c[i] = a[i];
	for (int i = 1; i <= n; ++i) std::cin >> b[i], d[i] = b[i];
	std::sort(c + 1, c + n + 1), std::sort(d + 1, d + n + 1);
	for (int i = 1; i <= n; ++i) res = 1ll * res * std::min(c[i], d[i]) % MOD;
	std::cout << res << " \n"[q == 0];
	for (int i = 1, op, x; i <= q; ++i) {
		std::cin >> op >> x;
		if (op == 1) {
			int p = std::upper_bound(c + 1, c + n + 1, a[x]) - c - 1;
			if (c[p] < d[p]) res = 1ll * res * qpow(c[p]) % MOD * (c[p] + 1) % MOD;
			++a[x], ++c[p];
		} else {
			int p = std::upper_bound(d + 1, d + n + 1, b[x]) - d - 1;
			if (d[p] < c[p]) res = 1ll * res * qpow(d[p]) % MOD * (d[p] + 1) % MOD;
			++b[x], ++d[p];
		}
		std::cout << res << " \n"[i == q];
	}
}
 
int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr), std::cout.tie(nullptr);
	int t; std::cin >> t; while (t--) solve(); return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2053C
Editorial Content:
2053C - Bewitching Stargazer
Hint 1
Process many segments simultaneously. What kind of segments do we process at a time?
Hint 2
The length.
Solution
The point that must be noted is: that if we call the process of splitting a large segment into two smaller segments a round, then all segments are of the same length when the $$$i$$$-th round of the observation is conducted; and, the number of rounds does not exceed $$$\mathcal O(\log n)$$$. The $$$k$$$ restriction is equivalent to specifying that only a certain prefix of rounds is computed.
Here are some different approaches:
(Most succinctly) Note that the distribution of segments after round 1 is centrally symmetric; Also, $$$x$$$ and $$$y$$$ being centrally symmetric implies that $$$x + y = n + 1$$$, so it is simple to calculate by simulating the number of segments and the length directly.
If a segment $$$[l, r]$$$ is split into $$$[l, m - 1]$$$ and $$$[m + 1, r]$$$, its left endpoint sum changes from $$$l$$$ to $$$2l + \frac{r - l}{2} + 1$$$, and since $$$(r - l)$$$ is fixed, the sum of the left endpoints of all segments can be maintained similarly.
The following recursive method also works: the answer to $$$n$$$ can be recovered by the answer to $$$\lfloor \frac{n}{2} \rfloor$$$. The time complexity is $$$\mathcal O(t\log n)$$$.
Code (C++)
This is written by
_TernaryTree_
.
#include <bits/stdc++.h>
#define int long long
 
using namespace std;
 
int T;
int n, k;
 
signed main() {
	cin >> T;
	while (T--) {
		cin >> n >> k;
		int mul = n + 1, sum = 0, cur = 1;
		while (n >= k) {
			if (n & 1) sum += cur;
			n >>= 1;
			cur <<= 1;
		}
		cout << mul * sum / 2 << endl;
	}
	return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2053B
Editorial Content:
2053B - Outstanding Impressionist
Hint 1
What if for all $$$1 \leq i \leq n$$$, $$$l_i \ne r_i$$$ holds? How do you prove it?
Hint 2
Use prefix sums or similar to optimize your solution.
Solution
For each $$$1 \leq i \leq n$$$, for each $$$l_i \leq x \leq r_i$$$, we want to check if it is okay for impression $$$i$$$ being
unique
at the value of $$$x$$$. Note that: for each $$$j \neq i$$$, we can always switch $$$w_j$$$ to a value different from $$$x$$$ if $$$l_j \neq r_j$$$, since there are at least two options. Therefore, it is impossible if and only if there exists a $$$1 \leq j \leq n$$$ with $$$j \neq i$$$ such that $$$l_j = r_j = x$$$.
Let's record $$$a_i$$$ as the number of different $$$k$$$ satisfying $$$1 \leq k \leq n$$$ and $$$l_k = r_k = i$$$. If $$$l_i \neq r_i$$$, then we say impression $$$i$$$
cannot
be made
unique
if and only if for all $$$l_i \leq k \leq r_i$$$, $$$a_k \geq 1$$$; otherwise ($$$l_i = r_i$$$), it cannot be
unique
if and only if $$$a_{l_i} \geq 2$$$.
This can all be checked quickly within a prefix sum, so the overall time complexity is $$$\mathcal O(\sum n)$$$.
Code (C++)
#include <bits/stdc++.h>
 
#define MAXN 400001
int l[MAXN], r[MAXN], sum[MAXN], cnt[MAXN];
void solve() {
	int n; std::cin >> n;
	for (int i = 1; i <= 2 * n; ++i) sum[i] = cnt[i] = 0;
	for (int i = 1; i <= n; ++i) {
		std::cin >> l[i] >> r[i];
		if (l[i] == r[i]) sum[l[i]] = 1, ++cnt[l[i]];
	}
	for (int i = 2; i <= 2 * n; ++i) sum[i] += sum[i - 1];
	for (int i = 1; i <= n; ++i) 
		std::cout << ((l[i] == r[i] ? cnt[l[i]] <= 1 : sum[r[i]] - sum[l[i] - 1] < r[i] - l[i] + 1) ? "1" : "0");
	std::cout << '\n';
}
int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr), std::cout.tie(nullptr);
	int t; std::cin >> t; while (t--) solve(); return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2053A
Editorial Content:
2053A - Tender Carpenter
Hint 1
Can you find a partition that is always valid?
Hint 2
Suppose you are given a set $$$S$$$. How do you judge whether $$$S$$$ is
stable
in $$$\mathcal O(\lvert S\rvert)$$$?
Hint 3
Are sets that are very large really necessary?
Solution
Note that: we always have a partition like $$$[a_1], [a_2], \dots, [a_n]$$$, since $$$(x, x, x)$$$ always forms a non-degenerate (equilateral) triangle.
We focus on the second partition scheme in which not all continuous subsegments have a length of $$$1$$$. One can also note that if a set $$$S$$$ is
stable
then for all $$$T \subsetneq S$$$ ($$$T \neq \varnothing$$$), $$$T$$$ is also
stable
.
Short proof: If $$$\exists u, v, w \in T$$$ such that $$$(u, v, w)$$$ doesn't form a non-degenerate triangle, therefore $$$u, v, w \in S$$$ so it is concluded that $$$S$$$ is not
stable
. Contradiction!
If such a partition exists, we can always split long continuous subsegments into shorter parts, while the partition remains valid. Therefore, it's enough to check the case in which there is one subsegment of length $$$2$$$ and the rest of length $$$1$$$. So, we should output
NO
if and only if for all $$$1 \leq i < n$$$, $$$2\min(a_i, a_{i+1}) \leq \max(a_i, a_{i+1})$$$.
Code (C++)
#include <bits/stdc++.h>
 
#define MAXN 1001
int a[MAXN];
void solve() {
	int n; std::cin >> n;
	for (int i = 1; i <= n; ++i) std::cin >> a[i];
	for (int i = 1; i < n; ++i) if (2 * std::min(a[i], a[i + 1]) > std::max(a[i], a[i + 1])) 
		{ std::cout << "YES\n"; return; }
	std::cout << "NO\n";
}
 
int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr), std::cout.tie(nullptr);
	int t; std::cin >> t; while (t--) solve(); return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2052M
Editorial data not available.
--------------------------------------------------
Problem ID: 2052L
Editorial data not available.
--------------------------------------------------
Problem ID: 2052K
Editorial data not available.
--------------------------------------------------
Problem ID: 2052J
Editorial data not available.
--------------------------------------------------
Problem ID: 2052I
Editorial data not available.
--------------------------------------------------
Problem ID: 2052H
Editorial data not available.
--------------------------------------------------
Problem ID: 2052G
Editorial data not available.
--------------------------------------------------
Problem ID: 2052F
Editorial data not available.
--------------------------------------------------
Problem ID: 2052E
Editorial data not available.
--------------------------------------------------
Problem ID: 2052D
Editorial data not available.
--------------------------------------------------
Problem ID: 2052C
Editorial data not available.
--------------------------------------------------
Problem ID: 2052B
Editorial data not available.
--------------------------------------------------
Problem ID: 2052A
Editorial data not available.
--------------------------------------------------
Problem ID: 2051G
Editorial Content:
2051G - Snakes
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>

using namespace std;

#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define sz(a) int((a).size())

const int INF = int(1e9);

int n, q;
vector<int> id, ch;

bool read() {
    if (!(cin >> n >> q))
        return false;
    id.resize(q);
    ch.resize(q);
    fore (i, 0, q) {
        char c;
        cin >> id[i] >> c;
        id[i]--;
        ch[i] = c == '+' ? 1 : -1;
    }
    return true;
}

int getDist(int s, int t) {
    int pSum = 0, cMin = 0;
    fore (e, 0, q) {
        if (id[e] == t)
            pSum += ch[e] < 0;
        if (id[e] == s)
            pSum -= ch[e] > 0;
        cMin = min(cMin, pSum);
    }
    return -cMin + 1;
}

inline void solve() {
    vector<vector<int>> minDist(n, vector<int>(n, INF));

    fore (i, 0, n) fore (j, 0, n)
        minDist[i][j] = getDist(i, j);

    vector<int> len(n, 0);
    fore (e, 0, q)
        len[id[e]] += ch[e] > 0;
    
    vector< vector<int> > d(1 << n, vector<int>(n, INF));
    fore (i, 0, n)
        d[1 << i][i] = 1;
    
    fore (mask, 1, 1 << n) fore (lst, 0, n) {
        if (d[mask][lst] == INF)
            continue;
        fore (nxt, 0, n) {
            if ((mask >> nxt) & 1)
                continue;
            int nmask = mask | (1 << nxt);
            d[nmask][nxt] = min(d[nmask][nxt], d[mask][lst] + minDist[lst][nxt]);
        }
    }
    int ans = INF;
    fore (lst, 0, n)
        ans = min(ans, d[(1 << n) - 1][lst] + len[lst]);
    cout << ans << endl;
}

int main() {
#ifdef _DEBUG
    freopen("input.txt", "r", stdin);
    int tt = clock();
#endif
    ios_base::sync_with_stdio(false);

    if(read()) {
        solve();
        
#ifdef _DEBUG
        cerr << "TIME = " << clock() - tt << endl;
        tt = clock();
#endif
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2051F
Editorial Content:
2051F - Joker
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n, m, q;
    cin >> n >> m >> q;
    vector<pair<int, int>> segs({{1, -q}, {m, m}, {n + q + 1, n}});
    while (q--) {
      int x;
      cin >> x;
      bool ins = false;
      for (auto& [l, r] : segs) {
        if (x < l) l = max(1, l - 1);
        else if (x > r) r = min(n, r + 1);
        else {
          ins = true;
          if (l == r) l = n + q, r = -q;
        }
      }
      if (ins) {
        segs[0] = {1, max(segs[0].second, 1)};
        segs[2] = {min(segs[2].first, n), n};
      }
      int lf = 0, rg = -1, ans = 0;
      for (auto [l, r] : segs) {
        if (l > r) continue;
        if (l > rg) {
          ans += max(0, rg - lf + 1);
          lf = l; rg = r;
        }
        rg = max(rg, r);
      }
      ans += max(0, rg - lf + 1);
      cout << ans << ' ';
     }
     cout << '\n';
  }
}
--------------------------------------------------
Problem ID: 2051E
Editorial Content:
2051E - Best Price
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    int n, k;
    cin >> n >> k;
    vector<int> a(n), b(n);
    for (auto &x : a) cin >> x;
    for (auto &x : b) cin >> x;
    vector<pair<int, int>> ev;
    for (int i = 0; i < n; ++i) {
      ev.emplace_back(a[i], 1);
      ev.emplace_back(b[i], 2);
    }
    sort(ev.begin(), ev.end());
    long long ans = 0;
    int cnt = n, bad = 0;
    for (int i = 0; i < 2 * n;) {
      auto [x, y] = ev[i];
      if (bad <= k) ans = max(ans, x * 1LL * cnt);
      while (i < 2 * n && ev[i].first == x) {
        bad += (ev[i].second == 1);
        bad -= (ev[i].second == 2);
        cnt -= (ev[i].second == 2);
        ++i;
      }
    }
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 2051D
Editorial Content:
2051D - Counting Pairs
Tutorial
Tutorial is loading...
Solution (BledDest)
def calcLessThanX(a, x):
    n = len(a)
    s = sum(a)
    j = 0
    ans = 0

    for i in range(n-1, -1, -1):
        while j < n and s - a[i] - a[j] >= x:
            j += 1
        ans += (n - j)

    for i in range(n):
        if s - a[i] - a[i] < x:
            ans -= 1
    
    return ans // 2

for _ in range(int(input())):
    n, x, y = map(int, input().split())
    a = list(map(int, input().split()))
    
    a = sorted(a)
    print(calcLessThanX(a, y+1) - calcLessThanX(a, x))
--------------------------------------------------
Problem ID: 2051C
Editorial Content:
2051C - Preparing for the Exam
Tutorial
Tutorial is loading...
Solution (BledDest)
for _ in range(int(input())):
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))
    q = list(map(int, input().split()))
    used = [False for i in range(n + 1)]
    for i in q:
        used[i] = True
    l = len(q)
    for i in range(m):
        if l == n or (l == n-1 and not used[a[i]]):
            print(1, end='')
        else:
            print(0, end='')
    print()
--------------------------------------------------
Problem ID: 2051B
Editorial Content:
2051B - Journey
Tutorial
Tutorial is loading...
Solution (BledDest)
t = int(input())
for i in range(t):
    n, a, b, c = map(int, input().split())
    sum = a + b + c
    d = n // sum * 3
    if n % sum == 0:
        print(d)
    elif n % sum <= a:
        print(d + 1)
    elif n % sum <= a + b:
        print(d + 2)
    else:
        print(d + 3)
--------------------------------------------------
Problem ID: 2051A
Editorial Content:
2051A - Preparing for the Olympiad
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<int> a(n), b(n);
    for (auto &x : a) cin >> x;
    for (auto &x : b) cin >> x;
    int ans = a[n - 1];
    for (int i = 0; i < n - 1; ++i)
      ans += max(0, a[i] - b[i + 1]);
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 2050G
Editorial Content:
2050G - Tree Destruction
Решение
Tutorial is loading...
Код
#include <bits/stdc++.h>

#define int long long
#define x first
#define y second

using namespace std;

void dfs(int v, int p, vector<vector<int>> &sl, vector<pair<int, int>> &dp){
    dp[v].x = sl[v].size();
    int m1 = -1, m2 = -1;
    for(int u: sl[v]){
        if(u == p){
            continue;
        }
        dfs(u, v, sl, dp);
        dp[v].x = max(dp[v].x, dp[u].x + (int)sl[v].size() - 2);
        m2 = max(m2, dp[u].x);
        if(m1 < m2) swap(m1, m2);
    }
    dp[v].y = dp[v].x;
    if(m2 != -1){
        dp[v].y = m1 + m2 + sl[v].size() - 4;
    }
}

void solve(int tc){
    int n;
    cin >> n;
    vector<vector<int>> sl(n);
    for(int i = 1; i < n; ++i){
        int u, v;
        cin >> u >> v;
        sl[--u].emplace_back(--v);
        sl[v].emplace_back(u);
    }
    vector<pair<int, int>> dp(n);
    dfs(0, 0, sl, dp);
    int ans = 0;
    for(int i = 0; i < n; ++i){
        ans = max(ans, max(dp[i].x, dp[i].y));
    }
    cout << ans;
}

bool multi = true;

signed main() {
    int t = 1;
    if (multi)cin >> t;
    for (int i = 1; i <= t; ++i) {
        solve(i);
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2050F
Editorial Content:
2050F - Maximum modulo equality
Решение
Tutorial is loading...
Код
#include <bits/stdc++.h>

using namespace std;

const int LOGN = 20;

vector<vector<int>> stGCD;

int get_gcd(int l, int r) {
    int k = __lg(r - l + 1);
    return __gcd(stGCD[k][l], stGCD[k][r - (1 << k) + 1]);
}

void solve() {
    stGCD.clear();
    int n, q; cin >> n >> q;
    vector<int> a(n);
    for (int &x : a) cin >> x;

    vector<int> b;
    for (int i = 1; i < n; i++)
        b.push_back(abs(a[i - 1] - a[i]));

    stGCD.resize(LOGN, vector<int>(b.size(), 1));
    for (int i = 0; i < b.size(); i++)
        stGCD[0][i] = b[i];
    for (int i = 1; i < LOGN; i++)
        for (int j = 0; j + (1 << (i - 1)) < b.size(); j++)
            stGCD[i][j] = __gcd(stGCD[i - 1][j], stGCD[i - 1][j + (1 << (i - 1))]);

    while (q--) {
        int l, r; cin >> l >> r;
        if (l == r) {
            cout << 0 << " ";
            continue;
        }
        l--; r -= 2;
        int gcd = get_gcd(l, r);
        cout << gcd << " ";
    }
}

int main() {
    int TESTS = 1; cin >> TESTS;
    while (TESTS --> 0) {
        solve();
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2050E
Editorial Content:
2050E - Three Strings
Решение
Tutorial is loading...
Код
#include <iostream>
#include <algorithm>

static const int inf = 1e9;

void solve() {
    std::string a, b, res;
    std::cin >> a >> b >> res;
    int n = (int) a.size(), m = (int) b.size();
    int dp[n + 1][m + 1];
    std::fill(&dp[0][0], &dp[0][0] + (n + 1) * (m + 1), inf);
    dp[0][0] = 0;
    for (int i = 0; i < n; i++) {
        dp[i + 1][0] = dp[i][0] + (a[i] != res[i]);
    }
    for (int j = 0; j < m; j++) {
        dp[0][j + 1] = dp[0][j] + (b[j] != res[j]);
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            dp[i][j] = std::min(dp[i - 1][j] + (a[i - 1] != res[i + j - 1]),
                                dp[i][j - 1] + (b[j - 1] != res[i + j - 1]));
        }
    }
    std::cout << dp[n][m] << std::endl;
}

int main() {
    int tests;
    std::cin >> tests;
    while (tests--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 2050D
Editorial Content:
2050D - Digital string maximization
Решение
Tutorial is loading...
Код
#include <bits/stdc++.h>

using namespace std;

void solve() {
    string s; cin >> s;
    for (int i = 0; i < s.size(); i++) {
        int best = s[i] - '0', pos = i;
        for (int j = i; j < min(i + 10, (int) s.size()); j++) {
            if (s[j] - '0' - (j - i) > best) {
                best = s[j] - '0' - (j - i);
                pos = j;
            }
        }
        while (pos > i) {
            swap(s[pos], s[pos - 1]);
            pos--;
        }
        s[i] = char(best + '0');
    }
    cout << s;
}

int main() {
    int TESTS = 1; cin >> TESTS;
    while (TESTS --> 0) {
        solve();
        cout << '\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2050C
Editorial Content:
2050C - Uninteresting Number
Решение
Tutorial is loading...
Код
def solve():
    s = [int(x) for x in list(input())]

    sm = sum(s)
    twos = s.count(2)
    threes = s.count(3)

    for i in range(min(10, twos + 1)):
        for j in range(min(10, threes + 1)):
            if (sm + i * 2 + j * 6) % 9 == 0:
                print('YES')
                return
    print('NO')


t = int(input())
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 2050B
Editorial Content:
2050B - Transfusion
Решение
Tutorial is loading...
Код
#include <bits/stdc++.h>

using namespace std;

void solve() {
    int n; cin >> n;
    vector<int> a(n);
    for (int &x : a) cin >> x;
    
    long long ods = 0, evs = 0;
    for (int i = 0; i < n; i++) {
        if (i & 1) ods += a[i];
        else evs += a[i];
    }
    int odc = n / 2, evc = n / 2;
    if (n & 1) evc++;

    if (ods % odc != 0 || evs % evc != 0 || ods / odc != evs / evc) {
        cout << "NO";
        return;
    }
    cout << "YES";
}

int main() {
    int TESTS; cin >> TESTS;
    while (TESTS --> 0) {
        solve();
        cout << '\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2050A
Editorial Content:
2050A - Line Breaks
Решение
Tutorial is loading...
Код
def solve():
    n, m = [int(i) for i in input().split()]

    ans = 0
    for i in range(n):
        l = input()
        if len(l) <= m:
            m -= len(l)
            ans += 1
        else:
            for i in range(i + 1, n):
                input()
            break

    print(ans)


t = int(input())
for i in range(t):
    solve()
--------------------------------------------------
Problem ID: 2049F
Editorial Content:
2049F - MEX OR Mania
Tutorial
2049F - MEX OR Mania
Let's figure out when a sequence is good. Let $$$m$$$ be the maximum element of the sequence. Notice that the bitwise OR of the sequence is at least $$$m$$$ and as MEX $$$-$$$ OR $$$=1$$$, that means MEX has to be at least $$$m + 1$$$. Which means all elements from $$$0$$$ to $$$m$$$ has to be present in the sequence. As MEX can't be greater than $$$m + 1$$$, the MEX has to be exactly $$$m + 1$$$.
Now we need to check for which $$$m$$$ the bitwise OR of the elements from $$$0$$$ to $$$m$$$ is exactly $$$m$$$. It's not hard to see that this is true for $$$m = 2^k - 1$$$ for some integer $$$k \geq 0$$$. The reason is that all bits from $$$0$$$ to $$$k - 1$$$ have to be set in $$$m$$$ for the OR to be $$$m$$$ and it's only possible if $$$m$$$ is of the form $$$2^k - 1$$$.
So, a sequence is good if the maximum element is $$$m = 2^k - 1$$$ for some integer $$$k$$$ and all elements from $$$0$$$ to $$$m$$$ are present in the sequence.
Now, let's see how to answer the queries without any updates. To find the longest good subarray, we can use a two-pointers approach. But a better way to do this is to fix the power $$$k (0 \leq k \leq \log_2 n)$$$ and find the longest good subarray with maximum element $$$2^k - 1$$$. To do this, ignore the elements greater than $$$2^k - 1$$$ and then split the array into segments of consecutive numbers where each segment has elements from $$$0$$$ to $$$2^k - 1$$$. To check if a segment is good, we can track the number of distinct elements in the segment. If the number of distinct elements is $$$2^k$$$, then the segment is good.
So to sum it up, for each power $$$k$$$, we will track some segments/components and the number of distinct elements in them and also the lengths of the segments to get the longest one during queries.
Now regarding the updates, it is hard to track everything if we do the updates normally. But its's easier if we look at them in reverse order!
Then each update will be decreasing the value of $$$a_i$$$ by $$$x$$$. Then for each power $$$k$$$, we will have to add a new element to a component or merge two components. For tracking distinct elements, we can use a map or unordered map and to merge we can use DSU with small to large merging. And that's pretty much it.
Please check my code for more details.
Overall complexity is $$$O((n + q) \log^2 n)$$$ or $$$O((n + q) \log^3 n)$$$ depending on if you use an unordered map or a map.
2049F - MEX OR Mania
Solution
#include<bits/stdc++.h>
using namespace std;
 
const int N = 1e5 + 9, Q = 3e5 + 9;
using ll = long long;
 
struct GoodSet { // insert, erase and track distinct and total elements
  map<int, int> mp;
  int size;
  int k;
  GoodSet() {}
  GoodSet(int _k): k(_k), size(0) { };
  void insert(int x, int c = 1) {
    mp[x] += c;
    size += c;
  }
  void erase(int x) {
    if (mp[x] == 1) {
      mp.erase(x);
    }
    else {
      mp[x]--;
    }
    size -= 1;
  }
  void merge(GoodSet oth) {
    for (auto [x, c]: oth.mp) {
      insert(x, c);
    }
  }
  bool is_good() { // check if all elements from 0 to 2^k - 1 exists in the set
    return (int) mp.size() == (1 << k);
  }
  int get_value() {
    if (is_good()) return size;
    return 0;
  }
};
 
struct MaxSet { // insert, erase and track max element
  map<int, int> mp;
  MaxSet() {}
  void insert(int x) {
    mp[x]++;
  }
  void erase(int x) {
    mp[x]--;
    if (mp[x] == 0) mp.erase(x);
  }
  int get_max() {
    return mp.rbegin() -> first;
  }
};
 
struct DSU { // DSU for each power of 2
  int n;
  int k;
  vector<int> par;
  vector<GoodSet> comp;
  MaxSet good_lengths;
  DSU() {}
  DSU(int _n, int _k): n(_n), k(_k) {
    par.resize(n + 1);
    comp.resize(n + 1);
    for (int i = 1; i <= n; i++) {
      par[i] = i;
      comp[i] = GoodSet(k);
      good_lengths.insert(comp[i].get_value());
    }
  }
  int find(int u) {
    return par[u] = (par[u] == u ? u : find(par[u]));
  }
  void merge(int u, int v) {
    u = find(u); v = find(v);
    if (u == v) return;
    good_lengths.erase(comp[u].get_value());
    good_lengths.erase(comp[v].get_value());
 
    // small to large merging
    if (comp[u].mp.size() < comp[v].mp.size()) {
      comp[u].mp.swap(comp[v].mp);
      swap(comp[u].size, comp[v].size);
    }
    comp[u].merge(comp[v]);
    comp[v].mp.clear(); // clear to save up memory
 
    good_lengths.insert(comp[u].get_value());
    par[v] = u;
  }
  // insert or erase an element from the component that u belongs to
  void update_in_component(int u, int x, bool insert = true) {
    u = find(u);
    good_lengths.erase(comp[u].get_value());
    if (insert) comp[u].insert(x);
    else comp[u].erase(x);
    good_lengths.insert(comp[u].get_value());
  }
};
DSU f[18];
ll a[N]; // make it long long as total sum can be huge
int id[Q], x[Q], ans[Q];
void solve() {
  int n, q; cin >> n >> q;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  for (int i = 1; i <= q; i++) {
    cin >> id[i] >> x[i];
    a[id[i]] += x[i];
  }
  MaxSet se;
  for (int k = 0; (1 << k) <= n; k++) {
    f[k] = DSU(n, k);
    for (int i = 1; i <= n; i++) {
      if (a[i] < (1 << k)) {
        f[k].update_in_component(i, a[i], true);
      }
    }
    for (int i = 2; i <= n; i++) {
      if (a[i] < (1 << k) and a[i - 1] < (1 << k)) {
        f[k].merge(i - 1, i);
      }
    }
    se.insert(f[k].good_lengths.get_max());
  }
  for (int qid = q; qid >= 1; qid--) {
    ans[qid] = se.get_max();
    int i = id[qid], sub = x[qid];
    for (int k = 0; (1 << k) <= n; k++) {
      se.erase(f[k].good_lengths.get_max());
 
      if (a[i] < (1 << k)) f[k].update_in_component(i, a[i], false);
      if (a[i] - sub < (1 << k)) f[k].update_in_component(i, a[i] - sub, true);
 
      if (a[i] >= (1 << k) and a[i] - sub < (1 << k)) {
        if (i > 1 and a[i - 1] < (1 << k)) {
          f[k].merge(i - 1, i);
        }
        if (i + 1 <= n and a[i + 1] < (1 << k)) {
          f[k].merge(i, i + 1);
        }
      }
 
      se.insert(f[k].good_lengths.get_max());
    }
    a[i] -= sub;
  }
 
  for (int i = 1; i <= q; i++) {
    cout << ans[i] << '\n';
  }
}
 
int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}
--------------------------------------------------
Problem ID: 2049E
Editorial Content:
2049E - Broken Queries
Tutorial
2049E - Broken Queries
Make 2 queries $$$[1, n/4]$$$ and $$$[n/4+1, n/2]$$$. This tells us which half the 1 is in: it is in $$$[1, n / 2]$$$ if the query results are different and $$$[n / 2 + 1, n]$$$ otherwise.
Make 1 query: query $$$[1, n/2]$$$ if the 1 is in it or $$$[n/2+1, n]$$$ otherwise. This tells us that $$$k < n / 2$$$ if the result is $$$1$$$ and $$$k \ge n / 2$$$ otherwise.
Without loss of generality, assume that the 1 is in $$$[1, n / 2]$$$. Now we can binary search for $$$k$$$ in $$$[1, n / 2]$$$ or $$$[n / 2 + 1, n]$$$. Let $$$k'$$$ be our guess.
If $$$k < n / 2$$$, query $$$[n / 2 + 1, n / 2 + k']$$$. The result is $$$1$$$ if $$$k' \ge k$$$ and $$$0$$$ otherwise.
If $$$k \ge n / 2$$$, query $$$[1, k']$$$. The result is $$$0$$$ if $$$k' \ge k$$$ and $$$1$$$ otherwise.
In both cases, the binary search takes $$$\log n - 1 \le 29$$$ queries. Overall, this takes at most $$$2 + 1 + 29 = 32$$$ queries.
The limit of $$$33$$$ queries (instead of $$$32$$$) is to allow less optimized solutions and other solutions. For example, one can instead do 3 queries in the beginning $$$[1, n / 4]$$$, $$$[n / 4 + 1, n / 2]$$$, $$$[n / 2 + 1, 3n / 4]$$$ to determine which quarter the 1 is in.
2049E - Broken Queries
Solution
#include <bits/stdc++.h>
using namespace std;

int qry(int l, int r, bool rev = 0, int n = 0) {
    if (rev) {
        int t = n - l;
        l = n - r;
        r = t;
    }
    cout << "? " << l + 1 << ' ' << r << endl;
    cin >> r;
    return r;
}

void solve() {
    int n;
    cin >> n;
    int a = qry(0, n / 4);
    int b = qry(n / 4, n / 2);
    bool kSmall = 1;
    bool firstHalf = 1;
    if (a == b) firstHalf = 0;
    int bs = 0;
    if (qry(0, n / 2, firstHalf, n) == 0) kSmall = 0;
    if (kSmall) {
        for (int k = n / 4; k; k /= 2)
            if (qry(0, bs + k, firstHalf, n) == 0) bs += k;
    } else {
        bs = n / 2 - 1;
        for (int k = n / 4; k; k /= 2)
            if (qry(0, bs + k, 1-firstHalf, n) == 1) bs += k;
    }
    cout << "! " << bs + 1 << endl;
}

int main() {
    int T = 1;
    cin >> T;
    while (T--) solve();
    return 0;
}
--------------------------------------------------
Problem ID: 2049D
Editorial Content:
2049D - Shift + Esc
Tutorial
2049D - Shift + Esc
Let $$$f(i,j)$$$ be the minimum cost to move to cell $$$(i,j)$$$ after shifting and $$$g(i,j,x)$$$ be the minimum cost to move to $$$(i,j)$$$ assuming row $$$i$$$ is shifted to the left by $$$x$$$.
For simplicity sake, we will add a row with all zeros above the first row. Also note that the operations with states denoting columns are all under modulo $$$m$$$, I am omitting the notation to avoid clutter.
The transitions are as follows:
Base cases:
$$$\begin{align} f(0,j) &= 0 \quad (0 \leq j < m) \\ g(0,j,x) &= kx \quad (0 \leq j,x < m) \end{align}$$$
From row $$$i$$$ to row $$$i+1$$$:
$$$\begin{align} g(i,j,x) &= \min(f(i-1,j)+kx,g(i,j-1,x)) + a(i,j+x) \quad (*)\\ f(i,j) &= \displaystyle\min_{x}g(i,j,x) \end{align}$$$
In $$$(*)$$$, the $$$f(i-1,j)$$$ term is from the case where you move from $$$(i-1,j)$$$ to $$$(i,j)$$$. Similarly the $$$g(i,j-1,x)$$$ term is from the case where you move from $$$(i,j-1)$$$ to $$$(i,j)$$$.
The final answer is $$$f(n,m-1)$$$. The overall complexity is $$$O(nm^2)$$$.
2049D - Shift + Esc
Solution
#include<bits/stdc++.h>
using namespace std;
typedef long long int ll;
ll dp[511][511],a[511][511];

void solve()
{
    int n,m,k;
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++){
        for(int j=0;j<m;j++)cin>>a[i][j];
    }
    for(int i=0;i<=n;i++){
        for(int j=0;j<m;j++)dp[i][j] = 1e18;
    }

    dp[0][0] = 0;
    for(int i=1;i<=n;i++){
        for(int shift = 0;shift<m;shift++){
            vector<ll>tmp(m,1e18);
            for(int j=0;j<m;j++)tmp[j] = dp[i-1][j] + a[i][(j+shift)%m] + k*1LL*shift;

            for(int j=0;j<m;j++)tmp[j] = min(tmp[j],tmp[(j+m-1)%m] + a[i][(j+shift)%m]);
            for(int j=0;j<m;j++)tmp[j] = min(tmp[j],tmp[(j+m-1)%m] + a[i][(j+shift)%m]);
            for(int j=0;j<m;j++)dp[i][j] = min(dp[i][j],tmp[j]);
        }
        //for(int j=0;j<m;j++)cout<<dp[i][j]<<" ";
       // cout<<'\n';
    }
    cout<<dp[n][m-1]<<endl;
}

int main()
{
    int t; cin>>t;
    for (int i = 0; i < t; i++) solve();
}
--------------------------------------------------
Problem ID: 2049C
Editorial Content:
2049C - MEX Cycle
Tutorial
2049C - MEX Cycle
There are many possible solutions. The simplest one we can find (thanks to
Kaey
) is as follows:
Set $$$a_x = 0, a_{x+1} = 1, a_{x+2} = 0, \ldots$$$, alternating between 0 and 1, wrapping around accordingly. Formally, using 0-based indexing, set $$$a_{(x+i) \bmod n} = i \bmod 2$$$ for all $$$i$$$ ($$$0 \le i \le n - 1$$$).
If $$$n$$$ is odd or if $$$x - y$$$ is even, set $$$a_x = 2$$$.
Why this works:
If $$$n$$$ is even and $$$x - y$$$ is odd, all $$$0$$$'s are only friends with $$$1$$$'s and vice versa.
If $$$n$$$ is odd, $$$a_x$$$ will be adjacent to $$$0$$$ and $$$1$$$, so we set $$$a_x = 2$$$. Now $$$a$$$ is valid ignoring the extra friendship. Adding in the extra friendship, $$$a$$$ is still valid since $$$a_x = 2 > a_y$$$, so it will not affect $$$a_y$$$.
If $$$n$$$ is even and $$$x - y$$$ is even, the extra friendship connects two $$$0$$$ or two $$$1$$$. Setting $$$a_x = 2$$$ works because dragon $$$x$$$'s friends still have another neighbor to maintain their $$$\operatorname{MEX}$$$.
2049C - MEX Cycle
Solution
#include <iostream>
#include <vector>
using namespace std;

void solve() {
    int n, x, y;
    cin >> n >> x >> y;
    --x; --y;
    vector<int> ans(n);
    for (int i = 0; i < n; ++i) ans[(x + i) % n] = i % 2;
    if (n % 2 || (x - y) % 2 == 0)
        ans[x] = 2;
    for (auto x : ans)cout << x << ' ';
    cout << endl;
}

int main() {
    int T;
    cin >> T;
    while (T--) solve();
}
--------------------------------------------------
Problem ID: 2049B
Editorial Content:
2049B - pspspsps
Tutorial
2049B - pspspsps
Since the entire $$$p$$$ must be a permutation, if $$$s_1 =$$$
s
, we can set $$$s_1 = $$$
.
, and if $$$s_n =$$$
p
, we can set $$$s_n =$$$
.
.
After that, the answer is
YES
if and only if all non-dot characters in $$$s$$$ are all
p
or
s
.
If all non-dot characters are
p
, we can choose the permutation $$$p = [1, 2, \ldots, n]$$$. If all non-dot characters are
s
, we can choose $$$p = [n, n - 1, \ldots, 1]$$$.
Otherwise, there exists both a
p
and a
s
. Suppose for contradiction that there is a solution. Let $$$a$$$ and $$$b$$$ represent the subarrays represented by the
p
and
s
respectively. Without loss of generality, suppose $$$a$$$ is the shorter subarray.
Since $$$b$$$ is also a permutation, the elements of $$$a$$$ must be in $$$b$$$. Since $$$p$$$ is a permutation, $$$a$$$ must be a subarray of $$$b$$$.
However, $$$b$$$ cannot contain $$$a$$$: since $$$b$$$ is not the entire $$$p$$$, $$$b$$$ does not contain $$$p_1$$$. However, $$$a$$$ contains $$$p_1$$$. Contradiction.
2049B - pspspsps
Solution
#include <bits/stdc++.h>
using namespace std;

void solve()
{
    int n; cin >> n;
    string s; cin >> s;
    if (s[0] == 's') s[0] = '.';
    if (s.back() == 'p') s.back() = '.';
    bool found_p = false;
    bool found_s = false;
    for (const auto c : s)
    {
        switch (c)
        {
        case 'p':
            found_p = true;
            break;
        case 's':
            found_s = true;
            break;
        }
    }
    cout << (found_p && found_s ? "NO" : "YES") << '\n';
}

int main()
{
    int t; cin >> t;
    for (int i = 0; i < t; i++) solve();

    return 0;
}
--------------------------------------------------
Problem ID: 2049A
Editorial Content:
2049A - MEX Destruction
Tutorial
2049A - MEX Destruction
Case 1: All elements are $$$0$$$. Then the answer is $$$0$$$.
Case 2: Some element is non-zero, and all non-zero elements form a contiguous subarray. Then the answer is $$$1$$$ since we can choose that subarray and replace it with a $$$0$$$.
Case 3: Otherwise, the answer is $$$2$$$.
We can replace the entire array with a non-zero element (since $$$0$$$ is in the array), then replace the entire array again with a $$$0$$$ (since the only element left is non-zero).
$$$1$$$ operation is not enough. If we only use $$$1$$$ operation, the selected subarray must contain all non-zero elements. Since the non-zero elements do not form a subarray, the selected subarray must contain a $$$0$$$, thus the $$$\operatorname{MEX}$$$ will be non-zero.
2049A - MEX Destruction
Solution
#include <bits/stdc++.h>
using namespace std;

void solve()
{
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    while (!a.empty() && a.back() == 0)
        a.pop_back();

    reverse(a.begin(), a.end());
    while (!a.empty() && a.back() == 0)
        a.pop_back();
    reverse(a.begin(), a.end());

    if (a.empty())
    {
        cout << 0 << '\n';
        return;
    }

    bool hasZero = false;
    for (const auto x : a)
        hasZero |= x == 0;
    if (hasZero)
        cout << 2 << '\n';
    else
        cout << 1 << '\n';
}

int main()
{
    int t;
    cin >> t;
    for (int i = 0; i < t; i++)
        solve();

    return 0;
}
--------------------------------------------------
Problem ID: 2048I2
Editorial data not available.
--------------------------------------------------
Problem ID: 2048I1
Editorial data not available.
--------------------------------------------------
Problem ID: 2048H
Editorial data not available.
--------------------------------------------------
Problem ID: 2048G
Editorial data not available.
--------------------------------------------------
Problem ID: 2048F
Editorial data not available.
--------------------------------------------------
Problem ID: 2048E
Editorial data not available.
--------------------------------------------------
Problem ID: 2048D
Editorial data not available.
--------------------------------------------------
Problem ID: 2048C
Editorial data not available.
--------------------------------------------------
Problem ID: 2048B
Editorial data not available.
--------------------------------------------------
Problem ID: 2048A
Editorial data not available.
--------------------------------------------------
Problem ID: 2047B
Editorial Content:

--------------------------------------------------
Problem ID: 2047A
Editorial Content:

--------------------------------------------------
Problem ID: 2046F2
Editorial Content:

--------------------------------------------------
Problem ID: 2046F1
Editorial Content:

--------------------------------------------------
Problem ID: 2046E2
Editorial Content:

--------------------------------------------------
Problem ID: 2046E1
Editorial Content:

--------------------------------------------------
Problem ID: 2046D
Editorial Content:

--------------------------------------------------
Problem ID: 2046C
Editorial Content:

--------------------------------------------------
Problem ID: 2046B
Editorial Content:

--------------------------------------------------
Problem ID: 2046A
Editorial Content:

--------------------------------------------------
Problem ID: 2045M
Editorial data not available.
--------------------------------------------------
Problem ID: 2045L
Editorial data not available.
--------------------------------------------------
Problem ID: 2045K
Editorial data not available.
--------------------------------------------------
Problem ID: 2045J
Editorial data not available.
--------------------------------------------------
Problem ID: 2045I
Editorial data not available.
--------------------------------------------------
Problem ID: 2045H
Editorial data not available.
--------------------------------------------------
Problem ID: 2045G
Editorial data not available.
--------------------------------------------------
Problem ID: 2045F
Editorial data not available.
--------------------------------------------------
Problem ID: 2045E
Editorial data not available.
--------------------------------------------------
Problem ID: 2045D
Editorial data not available.
--------------------------------------------------
Problem ID: 2045C
Editorial data not available.
--------------------------------------------------
Problem ID: 2045B
Editorial data not available.
--------------------------------------------------
Problem ID: 2045A
Editorial data not available.
--------------------------------------------------
Problem ID: 2044H
Editorial Content:
2044H - Hard Demon Problem
Solution
Consider translating the sum back onto the matrix. For simplicity we discuss about querying the whole matrix.
The sum we would like to find is $$$\sum_i i\cdot A_i$$$. Here, $$$A_i$$$ corresponds to $$$M_{(x,y)}$$$, so we will translate this to $$$\sum_{x,y} i\cdot M_{(x,y)}$$$. The issue left is on the $$$i$$$ multiplied to it.
Remember that we index the entries in increasing order of $$$y$$$, and then increasing order of $$$x$$$. Assuming $$$y$$$ and $$$x$$$ were $$$0$$$-indexed, this will mean entry $$$(x,y)$$$ corresponds to $$$x\cdot n + y$$$ (also $$$0$$$-indexed). You can notice that this naturally corresponds to the order we had defined as well.
Then, what we want to find is $$$\sum_{x,y} (x \cdot n + y + 1)\cdot M_{(x,y)}$$$. Notice $$$x \cdot n$$$, $$$y$$$, $$$1$$$ are independent, and we can split them into sums $$$\sum_x x \cdot n \cdot M_{(x,y)}$$$, $$$\sum_y y \cdot M_{(x,y)}$$$, $$$\sum M_{(x,y)}$$$. Each of these three sums can be precomputed entry by entry, and a 2D prefix sum can solve the answer for the entire matrix.
The query for a submatrix is very similar. Formally, you have to care about:
That we have $$$y_2-y_1+1$$$ columns instead of $$$n$$$ now;
That the precomputed values might not start from $$$0$$$ on the first row/column of the query.
Still, these two issues can be fixed using the three sums we have precomputed. The time complexity becomes $$$\mathcal{O}(n^2+q)$$$.
Code (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using vll = vector <ll>;
using ii = pair <ll, ll>;
using vii = vector <ii>;

void tc () {
    ll n, Q;
    cin >> n >> Q;
    vector <vll> mat(n, vll(n));
    for (vll &ve : mat) {
        for (ll &i : ve) cin >> i;
    }
    vector <vll> psR(n, vll(n+1)), psRr(n, vll(n+1)), psRc(n+1, vll(n+1)), ps(n+1, vll(n+1)), psRrc(n+1, vll(n+1));
    for (ll i = 0; i < n; i++) {
        for (ll j = 0; j < n; j++) {
            psR[i][j+1] = psR[i][j] + mat[i][j];
        }
    }
    for (ll i = 0; i < n; i++) {
        for (ll j = 0; j < n; j++) {
            psRr[i][j+1] = psRr[i][j] + mat[i][j]*(j+1);
        }
    }
    for (ll i = 0; i < n; i++) {
        for (ll j = 0; j <= n; j++) {
            psRc[i+1][j] = psRc[i][j] + psR[i][j]*(i+1);
        }
    }
    for (ll i = 0; i < n; i++) {
        for (ll j = 0; j <= n; j++) {
            psRrc[i+1][j] = psRrc[i][j] + psRr[i][j];
        }
    }
    for (ll i = 0; i < n; i++) {
        for (ll j = 0; j <= n; j++) {
            ps[i+1][j] = ps[i][j] + psR[i][j];
        }
    }
    while (Q--) {
        ll x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        x1--; y1--; x2--; y2--;
        ll ans = 0;
        ans += -(ps[x2+1][y2+1]-ps[x2+1][y1]-ps[x1][y2+1]+ps[x1][y1])*x1*(y2-y1+1);
        ans += (psRc[x2+1][y2+1] - psRc[x1][y2+1] - (ps[x2+1][y2+1]-ps[x1][y2+1]))*(y2-y1+1);

        ans += (psRc[x2+1][y1] - psRc[x1][y1] - (ps[x2+1][y1]-ps[x1][y1]))*-(y2-y1+1);
        ans += (ps[x2+1][y2+1]-ps[x1][y2+1])*-y1;
        ans += (ps[x2+1][y1]-ps[x1][y1])*y1;

        ans += psRrc[x2+1][y2+1] - psRrc[x1][y2+1];
        ans +=-(psRrc[x2+1][y1] - psRrc[x1][y1]);
        cout << ans << ' ';
    }
    cout << '\n';
}

int main () {
    cin.tie(nullptr) -> sync_with_stdio(false);
    ll T; cin >> T; while (T--) { tc(); }
    return 0;
}
--------------------------------------------------
Problem ID: 2044G2
Editorial Content:
2044G2 - Medium Demon Problem (hard version)
Solution
Note that similarly to G1, once all plushies end up in the hands of spiders who are in a loop, the process becomes stable.
Let's model the input as a collection of rooted forests. For each spider $$$i$$$, if $$$i$$$ is part of a loop, then let's compress the loop into a single node and use that as the root of a tree. Otherwise, if spider $$$i$$$ gives a present to spider $$$r_i$$$, then let's draw an edge from $$$i$$$ to $$$r_i$$$. Now, let $$$i$$$ be any node that is not part of a loop. How long will it take until spider $$$i$$$ runs out of presents? We can see that it is the subtree size of $$$i$$$, as one present leaves the subtree each year.
Thus, our challenge now is to process the nodes in an efficient order such that we can find the subtree size of all nodes. This can be done with topological sorting, which gives us an order that processes all nodes starting from the leaf upwards. After the topological sort, we may do dynamic programming to find subtree sizes of all nodes. Let $$$dp[i]$$$ be the number of days until spider $$$i$$$ runs out of presents. Let's suppose that we already calculated $$$dp[i]$$$ (we initialize it to be $$$1$$$ for all nodes since each spider starts with a present). Then, we should add $$$dp[i]$$$ to $$$dp[r_i]$$$. Doing this and adding up all $$$dp$$$ values of nodes directly before a cycle will yield the answer.
Code (C++)
#include<bits/stdc++.h>
#define ll long long
using namespace std;


int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int tt;
    cin>>tt;
    while(tt--)
    {
        int n;
        cin>>n;
        vector<int> r(n+1),d(n+1),v(n+1,1);
        for(int i=1;i<=n;i++)
        {
            cin>>r[i];
            d[r[i]]++;
        }
        set<pair<int,int> > s;
        for(int i=1;i<=n;i++)
        {
            s.insert({d[i],i});
        }
        int ans=2;
        queue<int> q;
        while(!s.empty()&&(*s.begin()).first==0)
        {
            while(!s.empty()&&(*s.begin()).first==0)
            {
                int k=(*s.begin()).second;
                ans=max(ans,v[k]+2);v[r[k]]+=v[k];
                auto it=s.find({d[r[k]],r[k]});
                d[r[k]]--;
                if(it!=s.end())
                {
                    s.erase(it);
                    q.push(r[k]);
                }
                s.erase(s.begin());
            }
            while(!q.empty())
                s.insert({d[q.front()],q.front()}),q.pop();
        }
        cout<<ans<<'\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2044G1
Editorial Content:
2044G1 - Medium Demon Problem (easy version)
Solution
This problem deals with a specific subclass of graphs called "functional graphs", also known as "successor graphs". The key feature that they have is that each node only has one successor. Therefore, the graph in the problem will necessarily be split into $$$k \geq 1$$$ components, where each component necessarily contains one cycle, and each node will either be in the cycle, or it will be on a path leading towards the cycle.
Observe that if a node that is not on a cycle currently has a plushie, this plushie will cause the arrangement to be unstable until the plushie reaches the cycle. Proof: suppose node $$$u$$$ has the plushie on day $$$i$$$. On the next day, $$$u$$$ will no longer have this plushie, because they will have passed it down to $$$r_u$$$, therefore, the arrangement has changed. This continues inductively until the plushie reaches the cycle of its component.
From this, we know that the answer is at least the distance of any node to the cycle. Now, since every node in the cycle already has a plushie, we know that these plushies just get passed round and round, so actually, nodes within the cycle cannot change the answer. Therefore, we've already found the final answer.
Code (C++)
#include<bits/stdc++.h>
#define ll long long
using namespace std;


int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int tt;
    cin>>tt;
    while(tt--)
    {
        int n;
        cin>>n;
        vector<int> r(n+1),d(n+1);
        for(int i=1;i<=n;i++)
        {
            cin>>r[i];
            d[r[i]]++;
        }
        set<pair<int,int> > s;
        for(int i=1;i<=n;i++)
            s.insert({d[i],i});
        int ans=2;
        queue<int> q;
        while(!s.empty()&&(*s.begin()).first==0)
        {
            while(!s.empty()&&(*s.begin()).first==0)
            {
                int k=(*s.begin()).second;
                auto it=s.find({d[r[k]],r[k]});
                d[r[k]]--;
                if(it!=s.end())
                {
                    s.erase(it);
                    q.push(r[k]);
                }
                s.erase(s.begin());
            }
            while(!q.empty())
                s.insert({d[q.front()],q.front()}),q.pop();
            ans++;
        }
        cout<<ans<<'\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2044F
Editorial Content:
2044F - Easy Demon Problem
Are you a python user and failing test 12?
This is an anti-hash test for python sets and dictionaries. Before you call us evil, we saved you from getting hacked in open hack phase. Beware!
Solution
Let's denote the beauty of the matrix as $$$B$$$, and denote $$$\text{SumA}$$$ as the sum of all the elements in the array $$$a$$$, and $$$\text{SumB}$$$ as the sum of all the elements in the array $$$b$$$.
Before applying an operation, the beauty of the matrix can be expressed as:
$$$B = b_1 \cdot a_1 + b_1 \cdot a_2 + b_1 \cdot a_3 + b_2 \cdot a_1 + b_2 \cdot a_2 + \ldots$$$
After factoring, this simplifies to:
$$$ B = b_1 \cdot (a_1 + a_2 + a_3 + \ldots) + b_2 \cdot (a_1 + a_2 + a_3 + \ldots) + \ldots $$$
Further factoring gives:
$$$ B = (a_1 + a_2 + a_3 + a_4 + \ldots) \cdot (b_1 + b_2 + b_3 + \ldots) $$$
This can be written as:
$$$ B = \text{SumA} \cdot \text{SumB}$$$
Now, consider the effect of an operation on a column $$$C$$$. The beauty decreases by $$$A_c \cdot \text{SumB}$$$. Similarly, when an operation is done on a row $$$R$$$, the beauty decreases by $$$B_r \cdot \text{SumA}$$$.
An important observation is that the element at position $$$(r, c)$$$ is counted twice, so we must account for this in the formula.
After considering this, let the beauty after the operations be denoted as $$$X$$$. Using the observations above:
$$$X = B - (b_i \cdot \text{SumA} + a_j \cdot \text{SumB} - a_j \cdot b_i)$$$
Simplifying further:
$$$X = \text{SumA} \cdot \text{SumB} - b_i \cdot \text{SumA} - a_j \cdot \text{SumB} + a_j \cdot b_i$$$
Factoring terms, we obtain:
$$$X = \text{SumA} \cdot (\text{SumB} - b_i) - a_j \cdot (\text{SumB} - b_i)$$$
Finally:
$$$X = (\text{SumB} - b_i) \cdot (\text{SumA} - a_j)$$$
At this stage, it is sufficient to iterate over the divisors of $$$X$$$. For each ordered pair of divisors whose product is $$$X$$$, we check whether the required values of $$$\text{SumB} - b_i$$$ and $$$\text{SumA} - a_j$$$ can be achieved.
This can be implemented using a simple map or boolean vector for faster computation, although such optimization is not required for this problem.
Code (C++)
#include <bits/stdc++.h>
using namespace std;
#define FOR(i,a,b) for (int i = (a); i < (b); ++i)
#define F0R(i,a) FOR(i,0,a)
#define int long long
#define vt vector
#define endl "\n"

const int N = 4e5 + 5;
bool apos[N], aneg[N], bpos[N], bneg[N], posspos[N], possneg[N];

signed main() {
    ios_base::sync_with_stdio(false); 
    cin.tie(0);
    int n,m,q;
    cin >> n >> m >> q;
    vector<int> a(n), b(m);
    int asum = 0, bsum = 0;
    F0R(i, n) {
        cin >> a[i];
        asum += a[i];
    }
    F0R(i, m) {
        cin >> b[i];
        bsum += b[i];
    }
    F0R(i, n) {
        if(abs(asum-a[i]) < N) {
            if(asum-a[i]<0) aneg[a[i]-asum]=true;   
            else apos[asum-a[i]]=true;
        } 
    }
    F0R(i, m) {
        if(abs(bsum-b[i]) < N) {
            if(bsum-b[i]<0) bneg[b[i]-bsum]=true;   
            else bpos[bsum-b[i]]=true;
        } 
    }
    FOR(i, 1, N) {
        FOR(j, 1, N) {
            if(i * j > N) break;
            if(apos[i]&&bpos[j]) posspos[i*j]=true;
            if(apos[i]&&bneg[j]) possneg[i*j]=true;
            if(aneg[i]&&bpos[j]) possneg[i*j]=true;
            if(aneg[i]&&bneg[j]) posspos[i*j]=true;
        }
    }
    while(q--) {
        int x;
        cin >> x;
        if(x>0) {
            if(posspos[x]) {
                cout << "YES" << endl;
            } else {
                cout << "NO" << endl;
            }
        } else {
            if(possneg[-x]) {
                cout << "YES" << endl;
            } else {
                cout << "NO" << endl;
            }
        }
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2044E
Editorial Content:
2044E - Insane Problem
Solution 1 (Binary Search)
Clearly, trying to bruteforce over all possible values of $$$x$$$ or $$$y$$$ is too slow, because the bounds are $$$1 \leq l_1 \leq r_1 \leq 10^9$$$. However, there is another variable that you can actually bruteforce over — and that is $$$n$$$. This is because exponentiation famously makes numbers very big very quickly — and if we set $$$k$$$ as small as possible (i.e. $$$2$$$), we only need to check $$$1 \leq n \leq 32$$$. This is because $$$2^{32} > 10^9$$$, so there cannot possibly be any solutions for $$$n > 32$$$ for any $$$k$$$.
Now, let's rephrase the problem. We need to find pairs $$$(x, y)$$$ such that $$$x \cdot k^n = y$$$. Now, we can check every value of $$$n$$$ from $$$1$$$ to $$$32$$$, and for each, binary search to find the smallest $$$x$$$ such that $$$y$$$ fits the conditions, and the largest $$$x$$$. Now, we can subtract these two values and add this to the answer.
Solution 2 (Intervals)
Note that we do not need to care about more than $$$32$$$ different values of $$$k^n$$$, because obviously $$$k^{32} \ge 2^{32} > 10^9$$$. From here and on, we focus on solving for only one value of $$$k^n$$$.
When $$$k^n$$$ is fixed and you are given $$$\frac{y}{x}=k^n$$$, notice $$$y$$$ is fixed as $$$x k^n$$$. Therefore, if we count the values $$$x$$$ such that $$$y$$$ is in the given interval as well, we will be properly counting the ordered pairs.
Formally, this condition can be cleared out as:
$$$l_2 \le x k^n \le r_2$$$
$$$\frac{l_2}{k^n} \le x \le \frac{r_2}{k^n}$$$
Because $$$x$$$ is an integer, $$$\left \lceil {\frac{l_2}{k^n}} \right \rceil \le x \le \left \lfloor {\frac{r_2}{k^n}} \right \rfloor$$$
Thus, when we intersect the two intervals, we get the following interval at last.
$$$\max \left({l_1,\left \lceil {\frac{l_2}{k^n}} \right \rceil}\right) \le x \le \min \left({r_1,\left \lfloor {\frac{r_2}{k^n}} \right \rfloor}\right)$$$
Compute the size of this interval for all $$$k^n$$$ (at most $$$32$$$ values) and the answer can be found.
Do note the following details while implementing:
When $$$r < l$$$, the size of the interval is $$$0$$$, not negative.
Beware of overflows. Dealing with big integers can be helpful in avoiding this, but it may make your solution slow.
Do not round up a fraction using the
ceil
function; This has been a recurring issue in almost every Div.4!
Code (C++)
#include<bits/stdc++.h>
#define ll long long
using namespace std;


int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int tt;
    cin>>tt;
    while(tt--)
    {
        ll k,l1,r1,l2,r2;
        cin>>k>>l1>>r1>>l2>>r2;
        ll kn=1,ans=0;
        for(int n=0;r2/kn>=l1;n++)
        {
            ans+=max(0ll,min(r2/kn,r1)-max((l2-1)/kn+1,l1)+1ll);
            kn*=k;
        }
        cout<<ans<<'\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2044D
Editorial Content:
2044D - Harder Problem
Solution
Observe that if you have an array where all elements are unique, they will all have frequency $$$1$$$, therefore they can all be classified as the mode. Therefore, it follows that the strategy for the construction is to just construct an array where for each prefix, the last element of this prefix appears in the array at least once. An easy way of doing is this is such:
For each element $$$a_i$$$, if this value has appeared previously in the array (you can use a set to check this), set $$$b_i$$$ equal to some random integer that isn't used elsewhere in the list $$$a$$$, and keep going. Otherwise, set $$$b_i = a_i$$$.
Code (C++)
#include<bits/stdc++.h>
#define ll long long
using namespace std;


int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int tt;
    cin>>tt;
    while(tt--)
    {
        int n;
        cin>>n;
        vector<int> a(n+1),b(n);
        for(int i=0;i<n;i++)
        {
            int x;
            cin>>x;
            if(!a[x])
            {
                b[i]=x;
                a[x]=1;
            }
        }
        queue<int> q;
        for(int i=1;i<=n;i++)
            if(!a[i])
                q.push(i);
        for(int i=0;i<n;i++)
        {
            if(!b[i])
            {
                b[i]=q.front();
                q.pop();
            }
        }
        for(int i=0;i<n;i++)
            cout<<b[i]<<" \n"[i==n-1];
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2044C
Editorial Content:
2044C - Hard Problem
Solution
Let $$$A$$$, $$$B$$$, $$$C$$$ be three sets of monkeys, such that monkeys in $$$A$$$ can only sit in row $$$1$$$, $$$B$$$ in row $$$2$$$, and $$$C$$$ can sit anywhere. It is clear that if there is free space in row $$$1$$$, and there are monkeys left in set $$$A$$$, it is optimal to seat a monkey from set $$$A$$$ onto row $$$1$$$. This is because a monkey from set $$$C$$$ can be seated on either row, and there might be space left on the other row for that same monkey in set $$$C$$$ after you've already seated the monkey from set $$$A$$$. However, this is not the case if you start by seating the monkeys in set $$$C$$$ in the front row, since you might now leave empty seats at the back, but then have monkeys from set $$$A$$$ still left unseated.
Therefore, the strategy is as follows: seat as many monkeys from set $$$A$$$ as you can in the front row, then seat as many monkeys from set $$$B$$$ as you can in the back row, then seat as many monkeys from set $$$C$$$ as you can, and that yields the answer.
Code (C++)
#include<bits/stdc++.h>
#define ll long long
using namespace std;


int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int tt;
    cin>>tt;
    while(tt--)
    {
        int m,a,b,c;
        cin>>m>>a>>b>>c;
        int ans=0,rem=0;
        ans+=min(m,a);rem+=m-min(m,a);
        ans+=min(m,b);rem+=m-min(m,b);
        ans+=min(rem,c);
        cout<<ans<<'\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2044B
Editorial Content:
2044B - Normal Problem
Solution
The letters she reads that comprise string $$$b$$$ are just the letters that comprise string $$$a$$$, flipped left-to-right. This means that 'p' becomes 'q', 'q' becomes 'p', and 'w' stays 'w', since it is vertically symmetrical. The order in which the letters are read is also reversed, because what used to be the left side of string $$$a$$$ gets flipped over to the right side of string $$$b$$$, and vice versa.
We now have an algorithm for constructing string $$$b$$$, which is to iterate from right-to-left on string $$$a$$$, outputting 'p' when there is a 'q', 'q' when there is a 'p', and 'w' when there is a 'w'.
Code (C++)
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define pll pair<ll, ll>

int t;

int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin >> t;
	while (t--) {
		string s;
		cin >> s;
		reverse(s.begin(), s.end());
		for (char &c : s) if (c == 'q') c = 'p'; else if (c == 'p') c = 'q';
		cout << s << '\n';
	}
}
--------------------------------------------------
Problem ID: 2044A
Editorial Content:
2044A - Easy Problem
Solution
For any $$$n$$$, Cube can set $$$a$$$ = any integer between $$$1$$$ and $$$n-1$$$ inclusive, and set $$$b = n - a$$$. $$$a$$$ cannot be less than $$$1$$$, because then it would be non-positive, and $$$a$$$ cannot be greater than $$$n-1$$$, because then $$$b$$$ would be less than $$$1$$$, which would make it non-positive. Therefore the answer is just $$$n-1$$$ for all $$$n$$$.
Code (Python)
input = sys.stdin.readline
for _ in range(int(input())):
    print(int(input())-1)
--------------------------------------------------
Problem ID: 2043G
Editorial Content:
2043G - Problem with Queries
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 2043F
Editorial Content:
2043F - Nim
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
using namespace std;
 
#define forn(i, n) for(int i = 0; i < int(n); i++) 
 
const int MOD = 998244353;
 
int add(int a, int b){
	a += b;
	if (a >= MOD)
		a -= MOD;
	return a;
}
 
int mul(int a, int b){
	return a * 1ll * b % MOD;
}
 
struct state{
	int mx, cnt;
};
 
void merge(state &a, int mx, int cnt){
	if (a.mx > mx) return;
	if (a.mx < mx) a.mx = mx, a.cnt = 0;
	a.cnt = add(a.cnt, cnt);
}
 
state dp[52][64][2];
 
int main(){
	cin.tie(0);
	ios::sync_with_stdio(false);
	int n, q;
	cin >> n >> q;
	vector<int> a(n);
	forn(i, n) cin >> a[i];
	int mx = *max_element(a.begin(), a.end());
	vector<vector<int>> cnt(n + 1, vector<int>(mx + 1));
	forn(i, n){
		cnt[i + 1] = cnt[i];
		++cnt[i + 1][a[i]];
	}
	forn(_, q){
		int l, r;
		cin >> l >> r;
		--l;
		memset(dp, -1, sizeof(dp));
		dp[0][0][0] = {0, 1};
		forn(i, mx + 1){
			int c = cnt[r][i] - cnt[l][i];
			int c2 = c * 1ll * (c - 1) / 2 % MOD;
			forn(val, 64) forn(fl, 2) if (dp[i][val][fl].cnt >= 0){
				if (c > 0)
					merge(dp[i + 1][val ^ i][true], dp[i][val][fl].mx + c - 1, mul(dp[i][val][fl].cnt, c));
				if (c > 1)
					merge(dp[i + 1][val][true], dp[i][val][fl].mx + c - 2, mul(dp[i][val][fl].cnt, c2));
				merge(dp[i + 1][val][fl], dp[i][val][fl].mx + c, dp[i][val][fl].cnt);
			}
		}
		auto ans = dp[mx + 1][0][1];
		if (ans.cnt == -1)
			cout << -1 << '\n';
		else
			cout << ans.mx << ' ' << ans.cnt << '\n';
	}
}
--------------------------------------------------
Problem ID: 2043E
Editorial Content:
2043E - Matrix Transformation
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
struct graph
{
    int V;
    vector<vector<int>> g;
    vector<int> color;
 
    bool dfs(int v)
    {
        if(color[v] != 0) return false;
        color[v] = 1;
        bool res = false;
        for(auto y : g[v])
        {
            if(color[y] == 2) continue;
            else if(color[y] == 0)
                res |= dfs(y);
            else res = true;
        }
        color[v] = 2;
        return res;
    }
 
    void add_edge(int x, int y)
    {
        g[x].push_back(y);
    }
 
    graph(int V)
    {
        this->V = V;
        this->g.resize(V);
        this->color.resize(V);
    };
};
 
int get_bit(int x, int y)
{
    return (x >> y) & 1;
}
 
bool check(const vector<vector<int>>& a, const vector<vector<int>>& b, int k)
{
    int n = a.size();
    int m = a[0].size();
    vector<bool> must_row(n);
    vector<bool> must_col(m);
    auto G = graph(n + m);
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
        {
            if(get_bit(a[i][j], k) != get_bit(b[i][j], k))
            {
                if(get_bit(b[i][j], k) == 0) must_row[i] = true;
                else must_col[j] = true;
            }
            if(get_bit(b[i][j], k) == 0) G.add_edge(j + n, i);
            else G.add_edge(i, j + n);
        }                 
    for(int i = 0; i < n; i++)
        if(must_row[i] && G.dfs(i))
            return false;
    for(int j = 0; j < m; j++)
        if(must_col[j] && G.dfs(j + n))
            return false;
    return true;
}
 
void solve()
{
    int n, m;
    scanf("%d %d", &n, &m);
    vector<vector<int>> a(n, vector<int>(m));
    auto b = a;
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            scanf("%d", &a[i][j]);
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            scanf("%d", &b[i][j]);
    for(int i = 0; i < 30; i++)
    {
        if(!check(a, b, i))
        {
            puts("No");
            return;
        }
    }
    puts("Yes");
}
 
int main()
{                             
    int t;
    scanf("%d", &t);
    for(int i = 0; i < t; i++) solve();
}
--------------------------------------------------
Problem ID: 2043D
Editorial Content:
2043D - Problem about GCD
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
long long gcd(long long x, long long y)
{
    if(x == 0) return y;
    else return gcd(y % x, x);
}
 
void solve()
{
    long long l, r, g;
    scanf("%lld %lld %lld", &l, &r, &g);
    long long L = l + (l % g == 0 ? 0 : g - (l % g));
    long long R = r - r % g;
    for(int i = 0; i <= (R - L) / g; i++)
        for(int j = 0; j <= i; j++)
            if(gcd(L + j * g, R - (i - j) * g) == g)
            {
                printf("%lld %lld\n", L + j * g, R - (i - j) * g);
                return;
            }   
    puts("-1 -1");
}
 
int main()
{                             
    int t;
    scanf("%d", &t);
    for(int i = 0; i < t; i++) solve();
}
--------------------------------------------------
Problem ID: 2043C
Editorial Content:
2043C - Sums on Segments
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	n = int(input())
	a = list(map(int, input().split()))
	l1, r1 = 0, 0
	l2, r2 = 2*10**9, -2*10**9
	
	pr = 0
	mnl, mxl = 0, 0
	mnr, mxr = 2*10**9, -2*10**9
	for i in range(n):
		pr += a[i]
		if a[i] != -1 and a[i] != 1:
			mnr, mxr = mnl, mxl
			mnl, mxl = pr, pr
		l1 = min(l1, pr - mxl)
		r1 = max(r1, pr - mnl)
		l2 = min(l2, pr - mxr)
		r2 = max(r2, pr - mnr)
		mnl = min(mnl, pr)
		mxl = max(mxl, pr)
	res = []
	if l2 > r1:
		res = list(range(l1, r1 + 1)) + list(range(l2, r2 + 1))
	elif r2 < l1:
	    res = list(range(l2, r2 + 1)) + list(range(l1, r1 + 1))
	else:
		res = list(range(min(l1, l2), max(r1, r2) + 1))
	print(len(res))
	print(*res)
--------------------------------------------------
Problem ID: 2043B
Editorial Content:
2043B - Digits
Tutorial
Tutorial is loading...
Solution (BledDest)
import sys
 
sys.set_int_max_str_digits(6000)
 
def fact(x):
    if x == 0:
        return 1
    return x * fact(x - 1)
 
t = int(input())
for i in range(t):
    n, k = map(int, input().split())
    n = min(n, 7)
    s = int(str(k) * fact(n))
    for i in range(1, 10, 2):
        if s % i == 0:
            print(i, end = ' ')
    print()
--------------------------------------------------
Problem ID: 2043A
Editorial Content:
2043A - Coin Transformation
Tutorial
Tutorial is loading...
Solution (BledDest)
t = int(input())
for i in range(t):
    n = int(input())
    ans = 1
    while n > 3:
        n //= 4
        ans *= 2
    print(ans)
--------------------------------------------------
Problem ID: 2042F
Editorial Content:
2042F - Two Subarrays
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

#define forn(i, n) for (int i = 0; i < int(n); ++i)

const int N = 200 * 1000 + 13;
const int K = 5;

using li = long long;
using mat = array<array<li, K>, K>;

const li INF = 1e18;

int n, q;
li a[N], b[N];
mat t[4 * N];

mat init(li a, li b) {
  mat c;
  forn(i, K) forn(j, i + 1) c[j][i] = -INF;
  c[0][0] = c[2][2] = c[4][4] = 0;
  c[0][1] = c[2][3] = a + b;
  c[0][2] = c[2][4] = a + b + b;
  c[1][1] = c[3][3] = a;
  c[1][2] = c[3][4] = a + b;
  return c;
}

mat combine(mat a, mat b) {
  mat c = init(-INF, -INF);
  forn(i, K) forn(j, i + 1) forn(k, j + 1)
    c[k][i] = max(c[k][i], a[k][j] + b[j][i]);
  return c;
}

void build(int v, int l, int r) {
  if (l + 1 == r) {
    t[v] = init(a[l], b[l]);
    return;
  }
  int m = (l + r) / 2;
  build(v * 2 + 1, l, m);
  build(v * 2 + 2, m, r);
  t[v] = combine(t[v * 2 + 1], t[v * 2 + 2]);
}

void upd(int v, int l, int r, int p) {
  if (l + 1 == r) {
    t[v] = init(a[l], b[l]);
    return;
  }
  int m = (l + r) / 2;
  if (p < m) upd(v * 2 + 1, l, m, p);
  else upd(v * 2 + 2, m, r, p);
  t[v] = combine(t[v * 2 + 1], t[v * 2 + 2]);
}

mat get(int v, int l, int r, int L, int R) {
  if (L >= R) return init(-INF, -INF);
  if (l == L && r == R) return t[v];
  int m = (l + r) / 2;
  return combine(
    get(v * 2 + 1, l, m, L, min(m, R)),
    get(v * 2 + 2, m, r, max(m, L), R)
  );
}

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  cin >> n;
  forn(i, n) cin >> a[i];
  forn(i, n) cin >> b[i];
  build(0, 0, n);
  cin >> q;
  forn(_, q) {
    int t, x, y;
    cin >> t >> x >> y;
    --x;
    if (t == 1) {
      a[x] = y;
      upd(0, 0, n, x);
    } else if (t == 2) {
      b[x] = y;
      upd(0, 0, n, x);
    } else {
      auto res = get(0, 0, n, x, y);
      cout << res[0][4] << '\n';
    }
  }
}
--------------------------------------------------
Problem ID: 2042E
Editorial Content:
2042E - Vertex Pairs
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
using namespace std;
 
vector<vector<int>> g;
 
struct LCA {
	vector<vector<pair<int, int>>> st;
	vector<int> pw;
 
	void build(vector<pair<int, int>> a) {
		int n = a.size();
		int lg = 32 - __builtin_clz(n);
		st.resize(lg, vector<pair<int, int>>(n));
		st[0] = a;
		for (int j = 1; j < lg; ++j) {
			for (int i = 0; i < n; ++i) {
				st[j][i] = st[j - 1][i];
				if (i + (1 << (j - 1)) < n)
					st[j][i] = min(st[j][i], st[j - 1][i + (1 << (j - 1))]);
			}
		}
		pw.resize(n + 1);
		for (int i = 2; i <= n; ++i)
			pw[i] = pw[i / 2] + 1;
	}
 
	vector<int> d, fst, par;
	vector<pair<int, int>> ord;
 
	int lca(int v, int u) {
		int l = fst[v], r = fst[u];
		if (l > r) swap(l, r);
		++r;
		int len = pw[r - l];
		assert(len < int(st.size()));
		return min(st[len][l], st[len][r - (1 << len)]).second;
	}
 
	void init(int v, int p = -1) {
		if (fst[v] == -1) fst[v] = ord.size();
		ord.push_back({ d[v], v });
		for (int u : g[v]) if (u != p) {
			par[u] = v;
			d[u] = d[v] + 1;
			init(u, v);
			ord.push_back({ d[v], v });
		}
	}
 
	LCA(int r = 0) {
		int n = g.size();
		d.resize(n);
		fst.assign(n, -1);
		par.assign(n, -1);
		ord.clear();
		init(r);
 
		build(ord);
	}
};

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	int n;
	cin >> n;
	vector<int> a(2 * n);
	forn(i, 2 * n){
		cin >> a[i];
		--a[i];
	}
	g.resize(2 * n);
	forn(i, 2 * n - 1){
		int v, u;
		cin >> v >> u;
		--v, --u;
		g[v].push_back(u);
		g[u].push_back(v);
	}
	vector<int> l(n, -1), r(n, -1);
	forn(i, 2 * n){
		if (l[a[i]] == -1) l[a[i]] = i;
		else r[a[i]] = i;
	}
	vector<char> res(2 * n, 1);
	forn(rt, 2 * n) if (a[rt] == 0){
		LCA d(rt);
		vector<int> state(2 * n, 0);
		
		auto mark = [&](int v){
			while (v != -1 && state[v] != 1){
                state[v] = 1;
				v = d.par[v];
			}
		};
		auto markdel = [&](int v){
			queue<int> q;
			q.push(v);
			state[v] = -1;
			while (!q.empty()){
				int v = q.front();
				q.pop();
				mark(l[a[v]] ^ r[a[v]] ^ v);
				for (int u : g[v]) if (u != d.par[v] && state[u] == 0){
					state[u] = -1;
					q.push(u);
				}
			}
		};
		
		forn(i, n) mark(d.lca(l[i], r[i]));
		for (int i = 2 * n - 1; i >= 0; --i) if (state[i] == 0)
			markdel(i);
		vector<char> cur(2 * n, 0);
        for (int i = 0; i < 2 * n; ++i) if (state[i] == 1)
            cur[i] = 1;
        reverse(cur.begin(), cur.end());
		res = min(res, cur);
	}
	reverse(res.begin(), res.end());
	cout << count(res.begin(), res.end(), 1) << '\n';
	forn(i, 2 * n) if (res[i])
		cout << i + 1 << " ";
	cout << '\n';
	return 0;
}
--------------------------------------------------
Problem ID: 2042D
Editorial Content:
2042D - Recommendations
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>
using namespace std;

#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define sz(a) int((a).size())

struct Seg {
	int l, r;

	bool operator< (const Seg &oth) const {
		if (l != oth.l)
			return l < oth.l;
		return r < oth.r;
	};
};

void solve() {
	int n;
	cin >> n;
	vector<Seg> seg(n);
	for (int i = 0; i < n; i++)
		cin >> seg[i].l >> seg[i].r;
	
	vector<int> ans(n, 0);
	for (int k = 0; k < 2; k++) {
		vector<int> ord(n);
		iota(ord.begin(), ord.end(), 0);

		sort(ord.begin(), ord.end(), [&seg](int i, int j){
			if (seg[i].l != seg[j].l)
				return seg[i].l < seg[j].l;
			return seg[i].r > seg[j].r;
		});

		set<int> bounds;
		for (int i : ord) {
			auto it = bounds.lower_bound(seg[i].r);
			if (it != bounds.end())
				ans[i] += *it - seg[i].r;
			bounds.insert(seg[i].r);
		}

		for (auto &s : seg) {
			s.l = -s.l;
			s.r = -s.r;
			swap(s.l, s.r);
		}
	}

	map<Seg, int> cnt;
	for (auto s: seg)
		cnt[s]++;
	for (int i = 0; i < n; i++)
		if (cnt[seg[i]] > 1)
			ans[i] = 0;
	
	for (int a : ans)
		cout << a << '\n';
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	
	int t; cin >> t;
	while (t--)
		solve();
	return 0;
}
--------------------------------------------------
Problem ID: 2042C
Editorial Content:
2042C - Competitive Fishing
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n, k;
    string s;
    cin >> n >> k >> s;
    vector<int> vals;
    int sum = 0;
    for (int i = n - 1; i > 0; --i) {
      sum += (s[i] == '1' ? 1 : -1);
      if (sum > 0) vals.push_back(sum);
    }
    sort(vals.begin(), vals.end());
    int ans = 1;
    while (k > 0 && !vals.empty()) {
      k -= vals.back();
      vals.pop_back();
      ++ans;
    }
    cout << (k > 0 ? -1 : ans) << '\n';
  }
}
--------------------------------------------------
Problem ID: 2042B
Editorial Content:
2042B - Game with Colored Marbles
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

int main()
{
    int t;
    scanf("%d", &t);
    for(int _ = 0; _ < t; _++)
    {
        int n;
        scanf("%d", &n);
        vector<int> c(n);
        for(int i = 0; i < n; i++)
        {
            scanf("%d", &c[i]);
            --c[i];
        }
        vector<int> cnt(n);
        for(auto x : c) cnt[x]++;
        int exactly1 = 0, morethan1 = 0;
        for(auto x : cnt)
            if (x == 1)
                exactly1++;
            else if(x > 1)
                morethan1++;
        printf("%d\n", morethan1 + (exactly1 + 1) / 2 * 2);
    }
}
--------------------------------------------------
Problem ID: 2042A
Editorial Content:
2042A - Greedy Monocarp
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (auto& x : a) cin >> x;
    sort(a.begin(), a.end(), greater<int>());
    int sum = 0;
    for (auto& x : a) {
      if (sum + x <= k) sum += x;
      else break;
    }
    cout << k - sum << '\n';
  }
}
--------------------------------------------------
Problem ID: 2041N
Editorial data not available.
--------------------------------------------------
Problem ID: 2041M
Editorial data not available.
--------------------------------------------------
Problem ID: 2041L
Editorial data not available.
--------------------------------------------------
Problem ID: 2041K
Editorial data not available.
--------------------------------------------------
Problem ID: 2041J
Editorial data not available.
--------------------------------------------------
Problem ID: 2041I
Editorial data not available.
--------------------------------------------------
Problem ID: 2041H
Editorial data not available.
--------------------------------------------------
Problem ID: 2041G
Editorial data not available.
--------------------------------------------------
Problem ID: 2041F
Editorial data not available.
--------------------------------------------------
Problem ID: 2041E
Editorial data not available.
--------------------------------------------------
Problem ID: 2041D
Editorial data not available.
--------------------------------------------------
Problem ID: 2041C
Editorial data not available.
--------------------------------------------------
Problem ID: 2041B
Editorial data not available.
--------------------------------------------------
Problem ID: 2041A
Editorial data not available.
--------------------------------------------------
Problem ID: 2040F
Editorial Content:
2040F - Number of Cubes
Editorial
Tutorial is loading...
Solution Phi
#include <bits/stdc++.h>
#define int long long
 
using namespace std;
 
const int N = 3000010;
const int mod = 998244353;
int fact[N], ifact[N], phi[N];
 
int powmod(int a, int n) {
    int res = 1;
    while (n) {
        if (n % 2 == 0) {
            a = (a * a) % mod;
            n /= 2;
        }
        else {
            res = (res * a) % mod;
            n--;
        }
    }
    return res;
}
 
int inv(int a) {
    return powmod(a, mod - 2);
}
 
void prepare() {
    fact[0] = 1;
    for (int i = 1; i < N; i++) {
        fact[i] = (fact[i - 1] * i) % mod;
    }
    ifact[N - 1] = inv(fact[N - 1]);
    for (int i = N - 2; i >= 0; i--) {
        ifact[i] = (ifact[i + 1] * (i + 1)) % mod;
    }
 
    phi[0] = 0;
    phi[1] = 1;
    for (int i = 2; i < N; i++) {
        phi[i] = i - 1;
    }
    for (int i = 2; i < N; i++) {
        for (int j = i * 2; j < N; j += i) {
            phi[j] -= phi[i];
        }
    }
}
 
int C(int n, int k) {
    return ((fact[n] * ifact[k]) % mod * ifact[n - k]) % mod;
}
 
int MC(vector <int> &a) {
    int sum=0;
    for (int i : a) sum += i;
    int res = fact[sum];
    for (int i : a) {
        res = (res * ifact[i]) % mod;
    }
    return res;
}
 
int lcm(int a, int b) {
    return a / __gcd(a, b) * b;
}
 
vector <int> all_divs(int x) {
    vector <int> d;
    for (int i = 1; i * i <= x; i++) {
        if (x % i == 0) {
            d.push_back(i);
            if (i * i != x) {
                d.push_back(x / i);
            }
        }
    }
    return d;
}
 
void solve() {
    int a, b, c, k;
    cin >> a >> b >> c >> k;
    vector <int> v(k);
    for (int &i : v) cin >> i;
 
    int g = v[0];
    for (int i : v) g = __gcd(g, i);
 
    map <int, int> mp;
    for (int i : all_divs(a)) {
        for (int j : all_divs(b)) {
            for (int l : all_divs(c)) {
                int N = lcm(i, lcm(j, l));
                if (g % N == 0) {
                    mp[N] += phi[i] * phi[j] * phi[l];
                }
            }
        }
    }
 
    int sum = 0;
    for (pair <int, int> pr : mp) {
        int N = pr.first, cnt = pr.second;
        vector <int> u;
        for (int t : v) u.push_back(t / N);
        sum = (sum + (MC(u) * cnt) % mod) % mod;
    }
 
    sum = (sum * inv(a * b * c)) % mod;
 
    cout << sum << endl;
}
 
int32_t main() {
    prepare();
 
    int tt;
    cin >> tt;
    while (tt--) {
        solve();
    }
 
    return 0;
}
Solution DP
#include <bits/stdc++.h>
#define int long long
 
using namespace std;
 
const int N = 3000010;
const int mod = 998244353;
int fact[N], ifact[N];
int pos[N];
 
int powmod(int a, int n) {
    int res = 1;
    while (n) {
        if (n % 2 == 0) {
            a = (a * a) % mod;
            n /= 2;
        }
        else {
            res = (res * a) % mod;
            n--;
        }
    }
    return res;
}
 
int inv(int a) {
    return powmod(a, mod - 2);
}
 
void prepare() {
    fact[0] = 1;
    for (int i = 1;i < N; i++) {
        fact[i] = (fact[i - 1] * i) % mod;
    }
    ifact[N - 1] = inv(fact[N - 1]);
    for (int i = N - 2; i >= 0; i--) {
        ifact[i] = (ifact[i + 1] * (i + 1)) % mod;
    }
}
 
int C(int n, int k) {
    return ((fact[n] * ifact[k]) % mod * ifact[n - k]) % mod;
}
 
int MC(vector <int> &a) {
    int sum=0;
    for (int i : a) sum += i;
    int res = fact[sum];
    for (int i : a) {
        res = (res * ifact[i]) % mod;
    }
    return res;
}
 
int lcm(int a, int b) {
    return a / __gcd(a, b) * b;
}
 
vector <int> all_divs(int x) {
    vector <int> d1, d2;
    for (int i = 1; i * i <= x; i++) {
        if (x % i == 0) {
            d1.push_back(i);
            if (i * i != x) {
                d2.push_back(x / i);
            }
        }
    }
    reverse(d2.begin(), d2.end());
    for (int i : d2) d1.push_back(i);
    return d1;
}
 
void solve() {
    int a, b, c, k;
    cin >> a >> b >> c >> k;
    vector <int> v(k);
    for (int &i : v) cin >> i;
 
    int g = v[0];
    for (int i : v) g = __gcd(g, i);
    vector <int> divs_g = all_divs(g);
 
    set <int> divs;
    for (int i : all_divs(a)) divs.insert(i);
    for (int i : all_divs(b)) divs.insert(i);
    for (int i : all_divs(c)) divs.insert(i);
    for (int i : all_divs(g)) divs.insert(i);
    int D = divs.size();
    int i = 0;
    for (int j : divs) {
        pos[j] = i;
        i++;
    }
 
    int n = max({a, b, c}) + 1;
    vector < vector <int> > tmp(3, vector <int> (D));
    vector < vector <int> > cnt(3, vector <int> (D));
    for (int t = 0; t < 3; t++) {
        int x;
        if (t == 0) x = a;
        if (t == 1) x = b;
        if (t == 2) x = c;
        vector <int> divs_x = all_divs(x);
 
        for (int i = (int)divs_x.size() - 1; i >= 0; i--) {
            tmp[t][pos[divs_x[i]]] += x / divs_x[i];
            for (int j = 0; j < i; j++) {
                if (divs_x[i] % divs_x[j] == 0) {
                    tmp[t][pos[divs_x[j]]] -= tmp[t][pos[divs_x[i]]];
                }
            }
            cnt[t][pos[x / divs_x[i]]] = tmp[t][pos[divs_x[i]]];
        }
    }
        
    vector < vector <int> > dp(4, vector <int> (D));
    dp[0][0] = 1;
    for(int i = 0; i < 3; i++) {
        for (int t1 : divs_g) {
            for (int t2 : divs_g) {
                int new_pos = lcm(t1, t2);
                if (t2 < n) {
                    dp[i + 1][pos[new_pos]] = (dp[i + 1][pos[new_pos]] + dp[i][pos[t1]] * cnt[i][pos[t2]]) % mod;
                }
            }
        }
    }
 
    int sum = 0;
    i = 0;
    for (int j : divs) {
        if (g % j != 0) continue;
        int N = j, cnt = dp[3][pos[j]];
        vector <int> u;
        for (int t : v) u.push_back(t / N);
        sum = (sum + (MC(u) * cnt) % mod) % mod;
    }
 
    sum = (sum * inv(a * b * c)) % mod;
 
    cout << sum << endl;
}
 
int32_t main() {
    prepare();
 
    int tt;
    cin >> tt;
    while (tt--) {
        solve();
    }
 
    return 0;
}
--------------------------------------------------
Problem ID: 2040E
Editorial Content:
2040E - Control of Randomness
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
void solve() {
    int n, q;
    cin >> n >> q;
    
    vector < vector <int> > g(n);
    for (int i = 0; i < n - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    
    vector <int> depth(n);
    vector <int> d(n);
    vector <int> par(n);
 
    function <void(int, int)> dfs = [&](int v, int p) {
        if (depth[v] == 1) d[v] = 1;
        if (depth[v] > 1) d[v] = d[par[p]] + 2 * (int)g[p].size();
        par[v] = p;
        for(int to : g[v]) {
            if (to == p) continue;
            depth[to] = depth[v] + 1;
            dfs(to, v);
        }
    };
    
    dfs(0, 0);
    
    while (q--) {
        int v, p;
        cin >> v >> p;
        v--;
        int res = d[v];
        vector <int> cnt;
        while (v != 0 && par[v] != 0) {
            cnt.push_back((int)g[par[v]].size());
            v = par[par[v]];
        }
        sort(cnt.rbegin(), cnt.rend());
        for (int i = 0; i < min(p, (int)cnt.size()); i++) {
            res -= 2 * (cnt[i] - 1);
        }
        cout << res << '\n';
    }
}
 
int main() {
    int tt;
    cin >> tt;
    while (tt--) {
        solve();
    }
 
    return 0;
}
Solution (Notes)
#include <bits/stdc++.h>
 
using namespace std;
 
void solve() {
    int n, q;
    cin >> n >> q;
    
    vector < vector <int> > g(n);
    for (int i = 0; i < n - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    
    vector <int> depth(n);
    vector <int> d(n);
    vector < vector < pair <int,int> > > qrs(n); // <p, idx>
    vector <int> res(q);
    
    for (int i = 0; i < q; i++) {
        int v, p;
        cin >> v >> p;
        v--;
        qrs[v].push_back({p, i});
    }
    
    multiset <int> st[2]; // store negative number to be able to use usual foreach loop
    
    function <void(int, int, int)> dfs = [&](int v, int p, int pp) {
        if (depth[v] == 1) d[v] = 1;
        if (depth[v] > 1) d[v] = d[pp] + 2 * (int)g[p].size();
        
        for (pair <int, int> qr : qrs[v]) {
            int p = qr.first, idx = qr.second;
            int ans = d[v];
            for (int i : st[1 - depth[v] % 2]) {
                if (p == 0) break;
                ans -= (-i - 1) * 2;
                p--;
            }
            res[idx] = ans;
        }
        
        if (depth[v] != 0) st[depth[v] % 2].insert(-(int)g[v].size());
        
        for (int to : g[v]) {
            if (to == p) continue;
            depth[to] = depth[v] + 1;
            dfs(to, v, p);
        }
        
        if (depth[v] != 0) st[depth[v] % 2].erase(st[depth[v] % 2].find(-(int)g[v].size()));
    };
    
    dfs(0, 0, 0);
    
    for (int i = 0; i < q; i++)
        cout << res[i] << '\n';
}
 
int main() {
    int tt;
    cin >> tt;
    while (tt--) {
        solve();
    }
 
    return 0;
}
Notes
This problem originally had the following constraints:
$$$1 \le n, q \le 2 \cdot 10^5$$$
The sum of $$$p$$$ in all queries is not greater than $$$2 \cdot 10^5$$$
How to solve this problem?
Could you solve this problem without the second constraint?
Hint
However, it is not hard thanks to a recent
blog
.
Hint
However, it is not hard thanks to a recent
blog
.
--------------------------------------------------
Problem ID: 2040D
Editorial Content:
2040D - Non Prime Tree
Editorial
Tutorial is loading...
Solution 1
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int tt;
    cin >> tt;
    while (tt--) {
        int n;
        cin >> n;
        vector < vector <int> > g(n);
        for (int i = 0; i < n - 1; i++) {
            int a, b;
            cin >> a >> b;
            a--, b--;
            g[a].push_back(b);
            g[b].push_back(a);
        }
        
        vector <int> res(n);
        int lst = 1;
        res[0] = lst;
        
        function <void(int, int)> dfs = [&](int v, int p) {
            for (int to : g[v]) {
                if (to == p) continue;
                res[to] = lst + 1;
                while (res[to] != res[v] + 1 && 
                      (res[to] % 2 != res[v] % 2 || res[to] - res[v] == 2)) {
                    res[to]++;   
                }
                lst = res[to];
                dfs(to, v);
            }
        };
        
        dfs(0, 0);
        for (int i : res) cout << i << ' ';
        cout << endl;
    }
    
    return 0;
}
Solution 2 (zap4eg)
#include <bits/stdc++.h>
using namespace std;
 
using ll = long long;
 
void dfs(int v, vector<vector<int>>& g, vector<int>& h, int p) {
    h[v] = h[p] + 1;
    for (int u : g[v]) {
        if (u == p)
            continue;
        dfs(u, g, h, v);
    }
}
 
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    
    int tt;
    cin >> tt;
    while (tt--) {
        int n;
        cin >> n;
        vector<vector<int>> g(n);
        for (int i = 0; i < n - 1; i++) {
            int u, v;
            cin >> u >> v;
            u--, v--;
            g[u].push_back(v);
            g[v].push_back(u);
        }
        vector<int> h(n);
        dfs(0, g, h, 0);
        vector<vector<int>> hs(n + 1);
        for (int i = 0; i < n; i++)
            hs[h[i]].push_back(i);
        int l = 2, r = 2 * n;
        int cur = 0;
        vector<int> ans(n);
        for (int i = 1; i <= n; i++) {
           if (cur) {
               for (int v : hs[i]) {
                    ans[v] = r;
                    r -= 2;
               }
           } 
           else {
               for (int v : hs[i]) {
                    ans[v] = l;
                    l += 2;
               }
           }
           cur ^= 1;
        }
        bool found = false;
        for (int i = 0; i < n; i++) {
            for (int v : g[i]) {
                if (h[v] < h[i])
                    continue;
                if (abs(ans[v] - ans[i]) == 2) {
                    ans[v] = ans[i] - 1;
                    found = true;
                    break;
                }
            }
            if (found)
                break;
        }
        for (int i = 0; i < n; i++)
            cout << ans[i] << ' ';
        cout << '\n';
    }
    
    return 0;
}
Notes
There are many possible solutions to this problem, and almost all testers have implemented a unique solution. There are solutions that we could not prove correct, but we could not hack them either.
--------------------------------------------------
Problem ID: 2040C
Editorial Content:
2040C - Ordered Permutations
Editorial
Tutorial is loading...
Solution C++
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int tt;
    cin >> tt;
    while (tt--) {
        int n;
        long long k;
        cin >> n >> k;
        vector <int> a, b;
        
        if (n <= 60 && (1ll << (n - 1)) < k) {
            cout << -1 << endl;
            continue;
        }
        k--;
        vector <int> d;
        while (k) {
            d.push_back(k % 2);
            k /= 2;
        }
        while (d.size() < n - 1) d.push_back(0);
        
        for (int i = n - 2, j = 1; i >= 0; i--, j++) {
            if (d[i] == 0) a.push_back(j);
            else b.push_back(j);
        }
        
        reverse(b.begin(), b.end());
        for (int i : a) cout << i << ' ';
        cout << n << ' ';
        for (int i : b) cout << i << ' ';
        cout << endl;
    }
 
    return 0;
}
Solution Python
tt = int(input())
for _ in range(tt):
    n, k = map(int, input().split())
    a, b = [], []
 
    if n <= 60 and (1 << (n - 1)) < k:
        print(-1)
        continue
    k -= 1
    d = []
    while k:
        d.append(k % 2)
        k //= 2
    while len(d) < n - 1:
        d.append(0)
 
    a, b = [], []
    j = 1
    for i in range(n - 2, -1, -1):
        if d[i] == 0:
            a.append(j)
        else:
            b.append(j)
        j += 1
 
    b.reverse()
    print(*a, n, *b)
--------------------------------------------------
Problem ID: 2040B
Editorial Content:
2040B - Paint a Strip
Editorial
Tutorial is loading...
Solution C++
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int tt;
    cin >> tt;
    while (tt--) {
        int n;
        cin >> n;
        for (int ans = 1, cur = 1; ; ans++, cur = cur * 2 + 2) {
            if (cur >= n) {
                cout << ans << '\n';
                break;
            }
        }
    }
    
    return 0;
}
Solution Python
tt = int(input())
for _ in range(tt):
    n = int(input())
    ans = 1
    cur = 1
    while True:
        if cur >= n:
            print(ans)
            break
        ans += 1
        cur = cur * 2 + 2
Notes
At some point in the development of this problem, the following alternative statement appeared: we need to minimize the total number of operations of both types. How to solve this problem?
--------------------------------------------------
Problem ID: 2040A
Editorial Content:
2040A - Game of Division
Editorial
Tutorial is loading...
Solution C++
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int tt;
    cin >> tt;
    while (tt--) {
        int n, k;
        cin >> n >> k;
        vector < vector <int> > b(k);
        for (int i = 1; i <= n; i++) {
            int x;
            cin >> x;
            b[x % k].push_back(i);
        }
        int res = -1;
        for (int i = 0; i < k; i++) {
            if ((int)b[i].size() == 1) {
                res = b[i][0];
                break;
            }
        }
        if (res == -1) {
            cout << "NO" << endl;
        }
        else {
            cout << "YES" << endl << res << endl;
        }
    }
    
    return 0;
}
Solution Python
for _ in range(int(input())):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = [[] for _ in range(k)]
    for i in range(0, n):
        x = a[i]
        b[x % k].append(i + 1)
    res = -1
    for i in range(k):
        if len(b[i]) == 1:
            res = b[i][0]
            break
    if res == -1:
        print("NO")
    else:
        print("YES\n" + str(res))
--------------------------------------------------
Problem ID: 2039H2
Editorial Content:
2039H2 - Cool Swap Walk (Hard Version)
Tutorial
First, read the editorial of the easy version. We can see that the bottleneck lies in the fact that after every round of odd-even sorting, we need to perform a walk operation to ensure that $$$a_1 = mn$$$.
The following method can break through this bottleneck: for simplicity, let's assume $$$n$$$ is even. Define the numbers smaller than or equal to $$$\frac{n}{2}$$$ as $$$S$$$, and the numbers bigger than $$$\frac{n}{2}$$$ as $$$B$$$. If we have $$$a = [S, \ldots, S, B, \ldots, B]$$$, we can repeatedly perform key path operations to get the following sequence:
$$$[S, \ldots, S, B, \ldots, B] \to [S, \ldots, S, B, \ldots, B, S] \to [S, \ldots, S, B, \ldots, B, S, S] \to \ldots \to [B, \ldots, B, S, \ldots, S]$$$  In this process, we only perform odd-even sorting for the subarray $$$[B, \ldots, B]$$$.
$$$[B, \ldots, B, S, \ldots, S] \to [B, \ldots, B, S, \ldots, S, B] \to [B, \ldots, B, S, \ldots, B, B] \to \ldots \to [S, \ldots, S, B, \ldots, B]$$$  In this process, we only perform odd-even sorting for the subarray $$$[S, \ldots, S]$$$.
After that, the array is sorted.
Finally, the only remaining problem is how to arrange $$$a = [S, \ldots, S, B, \ldots, B]$$$.
Assume we have $$$k$$$ positions $$$p_1, p_2, \ldots, p_k$$$ such that $$$1 < p_1 < p_2 < \ldots < p_k \leq n$$$. Consider what the following operations are doing:
$$$(1, 1) \to (1, p_1)\to (2, p_1) \to (2, p_2)\to (3, p_2) \to \ldots \to (k, p_k)$$$
If we ignore the other numbers，these operations correspond to:
$$$\text{swap}(a_1, a_{p_1}), \text{swap}(a_2, a_{p_2}), \ldots$$$
Then, we can take any path from $$$(k, p_k)$$$ to $$$(n, n)$$$.
At first, we perform one operation to set $$$a_1 = n$$$, then choose $$$\frac{n}{2}$$$ positions $$$p_1, p_2, \ldots, p_{\frac{n}{2}}$$$ to obtain $$$a = [S, \ldots, S, B, \ldots, B]$$$.
For $$$n$$$ being odd, we need two additional operations for some little adjustments.
Overall, we obtained a sorted array using $$$n + 4$$$ walks.
Code
#include <map>
#include <set>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <bitset>
using namespace std;
typedef double db;
typedef long long ll;
typedef unsigned long long ull;
const int N=2010;
int T,n,tot;
int a[N];
vector<int> X[N],Y[N];

void path1(int num)  //(1,1)->(1,2)->(2,2)->(2,3)->(3,3)->...
{
	for(int i=1;i<=n;i++)
	{
		X[num].push_back(i),Y[num].push_back(i);
		if(i!=n)
		{
			X[num].push_back(i),Y[num].push_back(i+1);
			swap(a[i],a[i+1]);
		}
	}
}

void path2(int num) //(1,1)->(1,n)->(n,n)
{
	for(int i=1;i<=n;i++)
	{
		X[num].push_back(1),Y[num].push_back(i);
		swap(a[1],a[i]);
	}
	for(int i=2;i<=n;i++)
	{
		X[num].push_back(i),Y[num].push_back(n);
		swap(a[i],a[n]);
	}
}

void path3(int num,vector<int> p) //swap(1,p[0]),(2,p[1]),... note p[0]!=1
{
	for(int i=1;i<=p[0];i++)
	{
		X[num].push_back(1),Y[num].push_back(i);
		swap(a[1],a[i]);
	}
	for(int i=1;i<p.size();i++)
	{
		for(int j=p[i-1];j<=p[i];j++)
		{
			X[num].push_back(i+1),Y[num].push_back(j);
		    swap(a[i+1],a[j]);
		}
	}
	int x=p.size(),y=p.back();
	while(x!=n)
	{
	    x++;
	    X[num].push_back(x),Y[num].push_back(y);
		swap(a[x],a[y]);
	}
	while(y!=n)
	{
	    y++;
	    X[num].push_back(x),Y[num].push_back(y);
		swap(a[x],a[y]);
	}
}

void walk1(int j)
{
	X[tot].push_back(j-1),Y[tot].push_back(j);
	X[tot].push_back(j-1),Y[tot].push_back(j+1);
    X[tot].push_back(j),Y[tot].push_back(j+1);
	X[tot].push_back(j+1),Y[tot].push_back(j+1);
    swap(a[j-1],a[j+1]);
}

void walk2(int j)
{
	X[tot].push_back(j-1),Y[tot].push_back(j);
	X[tot].push_back(j),Y[tot].push_back(j);
	X[tot].push_back(j),Y[tot].push_back(j+1);
	X[tot].push_back(j+1),Y[tot].push_back(j+1);
	swap(a[j-1],a[j]);
	swap(a[j],a[j+1]);
}

void walk3(int j)
{
	X[tot].push_back(j-1),Y[tot].push_back(j);
	X[tot].push_back(j),Y[tot].push_back(j);
	swap(a[j-1],a[j]);
}

void init()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	tot=0;
	for(int i=1;i<=3*n;i++) X[i].clear(),Y[i].clear();
	vector<pair<int,int> > pr;
	for(int i=1;i<=n;i++) pr.push_back(make_pair(a[i],i));
	sort(pr.begin(),pr.end());
	for(int i=1;i<=n;i++) a[pr[i-1].second]=i;
}

void step1()
{
	int p1,pn;
	vector<int> p;
	for(int i=1;i<=n;i++) if(a[i]==1) p1=i;
	if(p1!=1)
	{
        p.push_back(p1);
        path3(++tot,p);
	}
	if(n==2) return ;
	tot++;
	X[tot].push_back(1),Y[tot].push_back(1);
	for(int j=2;j<=n;j+=2)
	{
	    if(j+1>n) walk3(j);
	    else if(a[j]==n) walk1(j);
		else walk2(j);
	}
	p1=n;
	for(int i=1;i<=n;i++) if(a[i]==n) pn=i;
    p.clear();
    p.push_back(pn);p.push_back(p1);
    path3(++tot,p);
    p.clear();
    for(int i=1;i<=n;i++) if(a[i]<=(n+1)/2) p.push_back(i);
    path3(++tot,p);
}

void step2()
{
	int head;
	if(n&1)
	{
	    for(int t=1;t<=2;t++)
		{
            head=n/2+2;
            for(int i=1;i<=n/2+(t==1);i++)
            {
                tot++;
                X[tot].push_back(1),Y[tot].push_back(1);
                for(int j=2;j<=n;j++)
                {
                    if(!(head<=j&&j<=head+n/2-1)) walk3(j);
                    else if(j==head&&(head&1)) walk3(j);
                    else
                    {
                        if(!(head<=j+1&&j+1<=head+n/2-1)) walk3(j);
                        else if(a[j]>a[j+1]) walk1(j),j++;
                        else walk2(j),j++;
                    }
                }
                head--;
            }
		}
	}
	else
	{
		for(int t=1;t<=2;t++)
		{
            head=n/2+1;
            for(int i=1;i<=n/2;i++)
            {
                tot++;
                X[tot].push_back(1),Y[tot].push_back(1);
                for(int j=2;j<=n;j++)
                {
                    if(!(head<=j&&j<=head+n/2-1)) walk3(j);
                    else if(j==head&&(head&1)) walk3(j);
                    else
                    {
                        if(!(head<=j+1&&j+1<=head+n/2-1)) walk3(j);
                        else if(a[j]>a[j+1]) walk1(j),j++;
                        else walk2(j),j++;
                    }
                }
                head--;
            }
		}
	}
}

void output()
{
	printf("%d\n",tot);
	for(int i=1;i<=tot;i++)
	{
		for(int j=1;j<2*n-1;j++)
		{
		    if(X[i][j]==X[i][j-1]) printf("R");
		    else printf("D");
		}
		printf("\n");
	}
}

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		init();
		step1();
		step2();
		output();
	}

	return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2039H1
Editorial Content:
2039H1 - Cool Swap Walk (Easy Version)
Tutorial
We can observe that this kind of path is imporatnt — when we are in $$$(x, x)$$$, we only perform one of the following two kind of moves:
Move 1
$$$ (x, x) \rightarrow (x, x+1) \rightarrow (x+1, x+1) $$$
This move transforms $$$[\ldots,a_x, a_{x+1},\ldots]$$$ into $$$[\ldots,a_{x+1}, a_{x},\ldots]$$$.
Move 2
$$$ (x, x) \rightarrow (x, x+1) \rightarrow (x, x+2) \rightarrow (x+1, x+2) \rightarrow (x+2, x+2) $$$
This move transforms $$$[\ldots,a_x, a_{x+1},a_{x+2},\ldots]$$$ into $$$[\ldots,a_{x+2}, a_{x+1},a_{x},\ldots]$$$.
Summary of the path:
Note the arrays before and after the path as $$$a$$$ and $$$a'$$$, respectively. We can see $$$a'_n=a_1$$$, and $$$[a'_1,\ldots,a'_{n-1}]$$$ can be obtained from $$$[a_2,\ldots,a_{n}]$$$ through the following transformation:
Swap any two adjacent numbers of $$$[a_2,\ldots,a_{n}]$$$, but each number can be swapped at most once.
This inspires us to use
Odd-Even Sort
algorithm.
Steps to Achieve the Sorted Array:
Step $$$1$$$:
Initialize $$$a_1 = mn$$$:
If $$$a_1 \neq mn$$$, where $$$mn$$$ is the minimum of the array, use the following path:
$$$ (1, 1) \rightarrow (1, p_1) \rightarrow (p_1, p_1) \rightarrow (p_1, n) \rightarrow (n, n) $$$
This sequence ensures that $$$a_1 = mn$$$.
Then, repeat steps $$$2$$$ and $$$3$$$ until the array is sorted.
Step $$$2$$$:
Perform Odd-Even Sorting:
Perform an
Odd-Even Sort
(a round of comparison) using the key path above on the subarray $$$a_2, \dots, a_n$$$.
Step $$$3$$$:
Maintain the orderliness of $$$[a_{2}, \dots ,a_{n}]$$$ while repeatedly making $$$a_1 = mn$$$:
After step $$$2$$$, we want $$$mn$$$ back to the head of the array. To achieve this, perform the following operations:
$$$ (1, 1) \rightarrow (1, n) \rightarrow (n, n) $$$
This sequence transforms the array as follows:
$$$ [a_1, a_2, \dots, a_n(a_n=mn)] \rightarrow [a'_1, a'_2, \dots, a'_n]=[a_n, a_{n-1}, a_1, a_2, \dots, a_{n-2}] $$$
When this is performed after an odd-even sort, it ensures that:
$$$mn$$$ is back to the head of the array.
The subarray $$$a_1, \dots, a_{n-1}$$$ has been cyclically shifted.
Handling Continuous Cyclic Shifts in Odd-Even Sort:
Even Length ($$$n-1$$$ is even):
Cyclic shifting does not affect the odd-even sort. You can continue applying the sort as usual.
Odd Length ($$$n-1$$$ is odd):
A small modification is needed. Specifically, First compare $$$(a_3,a_4),(a_5,a_6),\ldots$$$ instead of $$$(a_2,a_3),(a_4,a_5),\ldots$$$ This adjustment ensures that the odd-even sort operates correctly despite the continuous cyclic shifts.
Overall, we obtained a sorted array using $$$2n$$$ walks.
Code
#include <map>
#include <set>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <bitset>
using namespace std;
typedef double db;
typedef long long ll;
typedef unsigned long long ull;
const int N=2010;
int T,n,mn,tot;
int a[N];
vector<int> X[N],Y[N];

void path1(int num) //(1,1)->(1,2)->(2,2)->(2,3)->(3,3)->...
{
	for(int i=1;i<=n;i++)
	{
		X[num].push_back(i),Y[num].push_back(i);
		if(i!=n)
		{
			X[num].push_back(i),Y[num].push_back(i+1);
			swap(a[i],a[i+1]);
		}
	}
}

void path2(int num) //(1,1)->(1,n)->(n,n)
{
	for(int i=1;i<=n;i++)
	{
		X[num].push_back(1),Y[num].push_back(i);
		swap(a[1],a[i]);
	}
	for(int i=2;i<=n;i++)
	{
		X[num].push_back(i),Y[num].push_back(n);
		swap(a[i],a[n]);
	}
}

void walk1(int j)
{
	X[tot].push_back(j-1),Y[tot].push_back(j);
	X[tot].push_back(j-1),Y[tot].push_back(j+1);
    X[tot].push_back(j),Y[tot].push_back(j+1);
	X[tot].push_back(j+1),Y[tot].push_back(j+1);
    swap(a[j-1],a[j+1]);
}

void walk2(int j)
{
	X[tot].push_back(j-1),Y[tot].push_back(j);
	X[tot].push_back(j),Y[tot].push_back(j);
	X[tot].push_back(j),Y[tot].push_back(j+1);
	X[tot].push_back(j+1),Y[tot].push_back(j+1);
	swap(a[j-1],a[j]);
	swap(a[j],a[j+1]);
}

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",&a[i]);
		mn=n;tot=0;
		for(int i=1;i<=n;i++)   mn=min(mn,a[i]);
		for(int i=1;i<=3*n;i++) X[i].clear(),Y[i].clear();
		int p1;
		for(int i=1;i<=n;i++) if(a[i]==mn) p1=i;
		if(p1!=1)
		{
		    tot++;
		    for(int i=1;i<=p1;i++) X[tot].push_back(1),Y[tot].push_back(i),swap(a[1],a[i]);
		    for(int i=2;i<=p1;i++) X[tot].push_back(i),Y[tot].push_back(p1),swap(a[i],a[p1]);
		    for(int i=p1+1;i<=n;i++) X[tot].push_back(p1),Y[tot].push_back(i),swap(a[p1],a[i]);
		    for(int i=p1+1;i<=n;i++) X[tot].push_back(i),Y[tot].push_back(n),swap(a[i],a[n]);
		}
		for(int i=2;i<=n;i++)
		{
			tot++;
			X[tot].push_back(1),Y[tot].push_back(1);
			if(n&1)
			{
				if(i&1)
				{
					for(int j=2;j<=n;j+=2)
					{
						if(j+1==i) walk2(j);
						else if(a[j]>a[j+1]) walk1(j);
						else walk2(j);
					}
				}
				else
				{
					for(int j=2;j<=n;j+=2)
					{
						if(a[j]>a[j+1]) walk1(j);
						else walk2(j);
					}
				}
			}
			else
			{
				if(i&1)
				{
					for(int j=2;j<=n;j+=2)
					{
						if(j==i-1)
						{
							X[tot].push_back(j-1),Y[tot].push_back(j);
							X[tot].push_back(j),Y[tot].push_back(j);
							swap(a[j-1],a[j]);
							j--;
						}
						else if(a[j]>a[j+1]) walk1(j);
						else walk2(j);
					}
				}
				else
				{
					for(int j=2;j<=n;j+=2)
					{
						if(j==i)
						{
							X[tot].push_back(j-1),Y[tot].push_back(j);
							X[tot].push_back(j),Y[tot].push_back(j);
							swap(a[j-1],a[j]);
							j--;
						}
						else if(a[j]>a[j+1]) walk1(j);
						else walk2(j);
					}
				}
			}
			path2(++tot);
		}
		printf("%d\n",tot);
		for(int i=1;i<=tot;i++)
		{
			for(int j=1;j<2*n-1;j++)
			{
			    if(X[i][j]==X[i][j-1]) printf("R");
			    else printf("D");
			}
			printf("\n");
		}

	}

	return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2039G
Editorial Content:
2039G - Shohag Loves Pebae
Tutorial
Tutorial is loading...
Code
#include<bits/stdc++.h>
using namespace std;
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;

struct custom_hash {
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
    return x ^ (x >> 31);
  }
  size_t operator()(uint64_t x) const {
    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x + FIXED_RANDOM);
  }
};

const int N = 1e6 + 9, T = 1e7 + 9, RT = 33333, mod = 998244353; 
using ll = long long;

int power(int n, long long k) {
  int ans = 1 % mod;
  while (k) {
    if (k & 1) ans = (long long) ans * n % mod;
    n = (long long) n * n % mod;
    k >>= 1;
  }
  return ans;
}

int SQRT(int n) {
  int x = sqrt(n);
  while (x * x < n) ++x;
  while (x * x > n) --x;
  return x;
}

int spf[T], id[T], DIAMETER, mu[T];
vector<int> primes; // 1 indexed
int prefix_prime_count[T], prefix_sum_mu[T];
void init() {
  mu[1] = 1;
  for(int i = 2; i < T; i++) {
    if (spf[i] == 0) spf[i] = i, mu[i] = i <= DIAMETER ? 0 : -1, primes.push_back(i);
    int sz = primes.size();
    for (int j = 0; j < sz && i * primes[j] < T && primes[j] <= spf[i]; j++) {
      spf[i * primes[j]] = primes[j];
      if (i % primes[j] == 0) mu[i * primes[j]] = 0;
      else mu[i * primes[j]] = mu[i] * (primes[j] <= DIAMETER ? 0 : -1);
    }
  }
  primes.insert(primes.begin(), 0);
  for (int i = 1; i < primes.size(); i++) {
    id[primes[i]] = i;
  }
  for (int i = 2; i < T; i++) {
    prefix_prime_count[i] = prefix_prime_count[i - 1] + (spf[i] == i);
  }
  for (int i = 1; i < T; i++) prefix_sum_mu[i] = prefix_sum_mu[i - 1] + mu[i];
}
int cnt[N]; // count of nodes having each diameter
int m;
namespace GoodNumbers { // numbers which aren't divisible by the first k primes
  gp_hash_table<int, int, custom_hash> mp[RT << 1];
  int count_num(int n, int k) { // n is a floor value, returns good numbers <= n
    if (k == 0 or n == 0) return n;
    if (primes[k] >= n) return 1;
    if (n < T and 1LL * primes[k] * primes[k] > n) {
      return 1 + prefix_prime_count[n] - k;
    }
    if (mp[k].find(n) != mp[k].end()) return mp[k][n];
    int ans;
    if (1LL * primes[k] * primes[k] > n) {
      int x = upper_bound(primes.begin(), primes.begin() + k, (int)SQRT(n)) - primes.begin() - 1;
      ans = count_num(n, x) - (k - x);
    }
    else ans = count_num(n, k - 1) - count_num(n / primes[k], k - 1);
    mp[k][n] = ans;
    return ans;
  }
};

vector<pair<int, int>> v;
namespace Dirichlet {
  // good number = numbers that aren't divisible by any prime <= DIAMETER
  // we will run dirichlet imagining there exists no prime <= DIAMETER
  gp_hash_table<int, int, custom_hash> mp;
  int p_c(int n) {
    return n < 1 ? 0 : 1;
  }
  int p_g(int n) {
    return GoodNumbers::count_num(n, v.back().first);
  }
  int solve (int x) { // sum of mob[i] over 1 <= i <= x and i is a good number
    if (x < T) return prefix_sum_mu[x];
    if (mp.find(x) != mp.end()) return mp[x];
    int ans = 0;
    for (int i = 2, last; i <= x; i = last + 1) {
      last = x / (x / i);
      ans += solve(x / i) * (p_g(last) - p_g(i - 1));
    }
    ans = p_c(x) - ans;
    return mp[x] = ans;
  }
};

int count_primes(int n) {
  if (n < T) return prefix_prime_count[n];
  int x = SQRT(n);
  int k = upper_bound(primes.begin(), primes.end(), x) - primes.begin() - 1;
  return GoodNumbers::count_num(n, k) + k - 1;
}


// diameter > 2 * sqrt(m)
void solve_large() {
  // only primes are good, so count total ways
  // and subtract where gcd is prime (means all nodes have a fixed prime)
  int total_ways = 1;
  int primes_under_m = count_primes(m);
  for (auto [k, c]: v) {
    if (m <= primes[k]) break;
    total_ways = 1LL * total_ways * power((primes_under_m - k + 1) % mod, c) % mod; // 1 or a prime > k
  }
  int bad_ways = (max(0, primes_under_m - v.back().first)) % mod;
  int ans = (total_ways - bad_ways + mod) % mod;
  cout << ans << '\n';
}

// diameter <= 2 * sqrt(m)
void solve_small() {
  int ans = 0;
  for (int l = 1, r; l <= m; l = r + 1) {
    int x = m / l;
    r = m / x;
    int cur = ((Dirichlet::solve(r) - Dirichlet::solve(l - 1)) % mod + mod) % mod;
    if (cur) {
      int mul = 1;
      for (auto [k, c]: v) {
        if (x <= primes[k]) break;
        mul = 1LL * mul * power(GoodNumbers::count_num(x, k) % mod, c) % mod;
      }
      ans += 1LL * cur * mul % mod;
      ans %= mod;
    }
  }
  cout << ans << '\n';
}

vector<int> g[N];
int dp[N], up[N];
void dfs(int u, int p = 0) {
  dp[u] = 0;
  if (p) g[u].erase(find(g[u].begin(), g[u].end(), p));
  for (auto v: g[u]) {
    if (v ^ p) {
      dfs(v, u);
      dp[u] = max(dp[u], dp[v] + 1);
    }
  }
}
int pref[N], suf[N];
void dfs2(int u) {
  int sz = g[u].size();
  for (int i = 0; i < sz; i++) {
    int v = g[u][i];
    pref[i] = dp[v] + 1;
    if (i) pref[i] = max(pref[i], pref[i - 1]);
  }
  for (int i = sz - 1; i >= 0; i--) {
    int v = g[u][i];
    suf[i] = dp[v] + 1;
    if (i + 1 < sz) suf[i] = max(suf[i], suf[i + 1]);
  }
  for (int i = 0; i < sz; i++) {
    int v = g[u][i];
    int cur = up[u];
    if (i) cur = max(cur, pref[i - 1]);
    if (i + 1 < sz) cur = max(cur, suf[i + 1]);
    up[v] = cur + 1;
  }
  for (auto v: g[u]) {
    dfs2(v);
  }
}
int mx_d[N];
int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int n; cin >> n >> m;
  for (int i = 1; i < n; i++) {
    int u, v; cin >> u >> v;
    g[u].push_back(v);
    g[v].push_back(u);
  }
  dfs(1);
  dfs2(1);
  for (int u = 1; u <= n; u++) {
    vector<int> vec;
    if (u != 1) vec.push_back(up[u]);
    for (auto v: g[u]) {
      vec.push_back(dp[v] + 1);
    }
    sort(vec.rbegin(), vec.rend());
    mx_d[u] = vec[0];
    if (vec.size() > 1) {
      mx_d[u] += vec[1];
    }
    mx_d[u] += 1;
  }
  for (int i = 1; i <= n; i++) {
    cnt[mx_d[i]]++;
    DIAMETER = max(DIAMETER, mx_d[i]);
  }

  init();

  int last_prime = 0;
  for (int i = 2; i <= DIAMETER; i++) {
    if (spf[i] == i) last_prime = i;
    if (cnt[i]) {
      int k = id[last_prime];
      if (!v.empty() and v.back().first == k) {
        v.back().second += cnt[i];
      } else {
        v.push_back({k, cnt[i]});
      }
    }
  }

  if (DIAMETER > 2 * SQRT(m)) solve_large();
  else solve_small();
  return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2039F2
Editorial Content:
2039F2 - Shohag Loves Counting (Hard Version)
Tutorial
Tutorial is loading...
Code (unoptimized)
#include<bits/stdc++.h>
using namespace std;
 
const int N = 1e6 + 9, mod = 998244353;
 
inline void add(int &x, int y) {
  x = x + y >= mod ? x + y - mod : x + y;
}
int mob[N];
void mobius() {
  mob[1] = 1;
  for (int i = 2; i < N; i++){
    mob[i]--;
    for (int j = i + i; j < N; j += i) {
      mob[j] -= mob[i];
    }
  }
  for (int i = 1; i < N; i++) {
    mob[i] = (mob[i] % mod + mod) % mod;
  }
}
vector<int> divs[N];
int dp[N];
int f[N];
int tmp[N], ans[N];
void solve() {
  for (int i = 1; i < N; i++) {
    for (int d: divs[i]) {
      tmp[d] = (mod - f[d]) % mod;
      for (int c: divs[d]) {
        add(tmp[d], dp[c]);
      }
      tmp[d] = (2 * tmp[d] + 1) % mod;
    }

    // apply mobius inversion formula
    for (int d: divs[i]) {
      for (int c: divs[d]) {
        add(dp[d], 1LL * mob[c] * tmp[d / c] % mod);
      }
      add(f[d], tmp[d]);
    }

    ans[i] = ans[i - 1];
    add(ans[i], f[i]);
  }
}
 
int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  for (int i = 1; i < N; i++) {
    for (int j = i; j < N; j += i) {
      divs[j].push_back(i);
    }
  }
  mobius();
  solve();
  int t = 1;
  cin >> t;
  while (t--) {
    int m; cin >> m;
    cout << ans[m] << '\n';
  }
  return 0;
}
Code (optimized)
#include<bits/stdc++.h>
using namespace std;
 
const int N = 1e6 + 9, mod = 998244353;
 
inline void add(int &x, int y) {
  x = x + y >= mod ? x + y - mod : x + y;
}
int spf[N];
void sieve() {
  vector<int> p;
  for(int i = 2; i < N; i++) {
    if (spf[i] == 0) spf[i] = i, p.push_back(i);
    int sz = p.size();
    for (int j = 0; j < sz && i * p[j] < N && p[j] <= spf[i]; j++) {
      spf[i * p[j]] = p[j];
    }
  }
}
int mob[N];
void mobius() {
  mob[1] = 1;
  for (int i = 2; i < N; i++){
    mob[i]--;
    for (int j = i + i; j < N; j += i) {
      mob[j] -= mob[i];
    }
  }
  for (int i = 1; i < N; i++) {
    mob[i] = (mob[i] % mod + mod) % mod;
  }
}
int c[N];
vector<int> divs[N];
void gen_divs(int n) { // not sorted
  int id = 1, x = n;
  divs[n][0] = 1;
  while (n > 1) {
    int k = spf[n];
    int cur = 1, sz = id;
    while (n % k == 0) {
      cur *= k;
      n /= k;
      for (int i = 0; i < sz; i++) {
        divs[x][id++] = divs[x][i] * cur;
      }
    }
  }
}

void prec() {
  sieve();
  // generate divisors without using push_back as its really slow on Codeforces
  for (int i = 1; i < N; i++) {
    for (int j = i; j < N; j += i) {
      c[j]++;
    }
    divs[i].resize(c[i]);
    gen_divs(i);
  }
  mobius();
}
int dp[N];
int f[N];
int tmp[N], ans[N];
void solve() {
  for (int i = 1; i < N; i++) {
    for (int d: divs[i]) {
      tmp[d] = (mod - f[d]) % mod;
      for (int c: divs[d]) {
        add(tmp[d], dp[c]);
      }
      tmp[d] = (2 * tmp[d] + 1) % mod;
    }

    // apply mobius inversion formula
    for (int d: divs[i]) {
      for (int c: divs[d]) {
        add(dp[d], 1LL * mob[c] * tmp[d / c] % mod);
      }
      add(f[d], tmp[d]);
    }

    ans[i] = ans[i - 1];
    add(ans[i], f[i]);
  }
}
 
int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  prec();
  solve();
  int t = 1;
  cin >> t;
  while (t--) {
    int m; cin >> m;
    cout << ans[m] << '\n';
  }
  return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2039F1
Editorial Content:
2039F1 - Shohag Loves Counting (Easy Version)
Tutorial
Tutorial is loading...
Code (by LipArcanjo)
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 9, mod = 998244353;
using ll = long long;

int add(int a, int b){
	a += b;
	if(a > mod) a -= mod;
	if(a < 0) a += mod;
	return a;
}

// dp[i][j] = number of arrays where starting element is i and gcd of the array is j
int dp[N], cur[N], uni[N];
int sum[N];
vector<int> d[N];
void solve() {
  int m; cin >> m;
  for (int i = 1; i <= m; i++) {
    dp[i] = cur[i] = 0;
	uni[i] = 0;
	sum[i] = 0;
  }
  int ans = 0;
  ans = 0;
  for (int i = m; i >= 1; i--) {
    for (int j: d[i]) {
      cur[j] = 0;
    }
	int sz = d[i].size();
	for(int idj = sz-1; idj >= 0; idj--){
		int j = d[i][idj];
		uni[j] = add(sum[j],sum[j]);
		for(int idk = idj+1; idk < sz; idk++){
			int k = d[i][idk];
			if(k%j) continue;
			uni[j] = add(uni[j],-uni[k]);
		}
		cur[j] = add(uni[j], - add(dp[j],dp[j]));
	}

    cur[i] += 1;

    for (int j : d[i]) {
	  dp[j] = add(dp[j],cur[j]);
	  for(auto k : d[j]){
	  	sum[k] = add(sum[k],cur[j]);
	  }
	  ans = add(ans,cur[j]);
    }
	
  }
  cout << ans << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  for (int i = 1; i < N; i++) {
    for (int j = i; j < N; j += i) {
      d[j].push_back(i);
    }
  }
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2039E
Editorial Content:
2039E - Shohag Loves Inversions
Tutorial
Tutorial is loading...
Code
#include<bits/stdc++.h>
using namespace std;

const int N = 1e6 + 9, mod = 998244353;
using ll = long long;

int dp[N]; // count of arrays that we can get if the current number of inversions is > max element of the array
void solve() {
  int n; cin >> n;
  int sum = 0;
  for (int i = n; i >= 1; i--) {
    dp[i] = (1LL * i * sum % mod + 1) % mod;
    sum = (sum + dp[i]) % mod;
  }
  int ans = n - 1; // arrays having 0 and 1 inversions
  for (int k = 3; k <= n; k++) {
    int ways = (1LL * (k - 1) * (k - 2) / 2 - 1 + mod) % mod; // count of arrays achievable such that > 1 inversion count was inserted for the first time
    ans += 1LL * ways * dp[k] % mod;
    ans %= mod;
  }
  cout << ans << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}
Code (by wyrqwq, without initial casework)
#include <bits/stdc++.h>

#include <chrono>
std::mt19937 eng(std::chrono::steady_clock::now().time_since_epoch().count());
int rnd(int l, int r) { return std::uniform_int_distribution<int>(l, r)(eng); }

namespace FastIO {
//	char buf[1 << 21], *p1 = buf, *p2 = buf;
//	#define getchar() (p1 == p2 && (p1 = buf, p2 = (p1 + fread(buf, 1, 1 << 21, stdin))) == p1 ? EOF : *p1++)
	template <typename T> inline T read() { T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= (ch == '-'), ch = getchar(); while ('0' <= ch && ch <= '9') x = x * 10 + (ch ^ '0'), ch = getchar(); return w ? -x : x; }
	template <typename T> inline void write(T x) { if (!x) return; write<T>(x / 10), putchar((x % 10) ^ '0'); }
	template <typename T> inline void print(T x) { if (x > 0) write<T>(x); else if (x < 0) putchar('-'), write<T>(-x); else putchar('0'); }
	template <typename T> inline void print(T x, char en) { print<T>(x), putchar(en); }
//	inline char rChar() { char ch = getchar(); while (!isalpha(ch)) ch = getchar(); return ch; }
}; using namespace FastIO;

using i32 = int32_t;
using u32 = uint32_t;
using u64 = uint64_t;
template <uint32_t MOD> struct mint {
	static constexpr u32 get_r() {
		u32 ret = MOD;
		for (i32 i = 0; i < 4; ++i) ret *= 2 - MOD * ret;
		return ret;
	}
	static constexpr u32 r = get_r();
	static constexpr u32 n2 = -u64(MOD) % MOD;
	static_assert(r * MOD == 1, "invalid, r * MOD != 1");
	static_assert(MOD < (1 << 30), "invalid, MOD >= 2 ^ 30");
	static_assert((MOD & 1) == 1, "invalid, MOD % 2 == 0");
	u32 a;
	constexpr mint() : a(0) {}
	constexpr mint(const int64_t &b) : a(reduce(u64(b % MOD + MOD) * n2)){};
	static constexpr u32 reduce(const u64 &b) { return (b + u64(u32(b) * u32(-r)) * MOD) >> 32; }
	 constexpr mint &operator += (const mint &b) { if (i32(a += b.a - 2 * MOD) < 0) a += 2 * MOD; return *this; }
	constexpr mint &operator -= (const mint &b) { if (i32(a -= b.a) < 0) a += 2 * MOD; return *this; }
	constexpr mint &operator *= (const mint &b) { a = reduce(u64(a) * b.a); return *this; }
	constexpr mint &operator /= (const mint &b) { *this *= b.inverse(); return *this; }
	constexpr mint operator + (const mint &b) const { return mint(*this) += b; }
	constexpr mint operator - (const mint &b) const { return mint(*this) -= b; }
	constexpr mint operator * (const mint &b) const { return mint(*this) *= b; }
	constexpr mint operator / (const mint &b) const { return mint(*this) /= b; }
	constexpr bool operator == (const mint &b) const { return (a >= MOD ? a - MOD : a) == (b.a >= MOD ? b.a - MOD : b.a); }
	constexpr bool operator != (const mint &b) const { return (a >= MOD ? a - MOD : a) != (b.a >= MOD ? b.a - MOD : b.a); }
	constexpr mint operator-() const { return mint() - mint(*this); }
	constexpr mint pow(u64 n) const { mint ret(1), mul(*this); while (n > 0) { if (n & 1) ret *= mul; mul *= mul, n >>= 1; } return ret; }
	constexpr mint inverse() const { return pow(MOD - 2); }
	friend std::ostream &operator<< (std::ostream &os, const mint &b) { return os << b.get(); }
	friend std::istream &operator>> (std::istream &is, mint &b) { int64_t t; is >> t; b = mint<MOD>(t); return (is); }
	constexpr u32 get() const { u32 ret = reduce(a); return ret >= MOD ? ret - MOD : ret; }
	static constexpr u32 get_MOD() { return MOD; }
    explicit operator u32() const { return get(); }
}; using modint = mint<998244353>;

// Let's write some brute first
// dp[i][j] := current length is i, current number of inversions is j (not inserted)
// dp[i][j] -> dp[>= i + 1][[j + 1, j + i]]
// this is true for j >= 1, so let's do something when j = 0
// we can generate [0, (0 ... ), 1, 0] -> dp[>= 3][1]
// this is still kinda annoying because 1 > 1 does not hold, we process it till j >= 2
// [0, 0, ..., 0, 1, 0] -> [0, 0, ..., 0, 1, 0, 1, ..., 1]
// after that we insert an 1 before some numbers of 0 and we get dp[i][1] -> dp[>= i + 1][[j + 1, j + i - 1]]
// the answer is sum dp[i][j] for all 1 <= i <= n, j >= 1, plus 1 ([0, 0, 0 ... 1])
// actually we care nothing 'bout, j so let's say f[i] = sum dp[i][j]
// (f[i] * i - 1) -> f[i + 1], f[i + 2], ..., f[n]

#define MAXN 1000001
modint f[MAXN];
void solve() {
	int n = read<int>(); modint ans = 1, pre = 2;
	f[3] = 1;
	for (int i = 4; i <= n; ++i) 
		f[i] = pre + modint(1), pre += f[i] * modint(i) - modint(1);
	for (int i = 3; i <= n; ++i) ans += f[i];
	// f[3] : [0, 1, 0]
	// f[4] : [0, 0, 1, 0] (+1), [0, 1, 1, 0], [1, 0, 1, 0] (dp[3][1] * 2)
	print<int>(ans.get(), '\n');
}

int main() { int T = read<int>(); while (T--) solve(); return 0; }
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2039D
Editorial Content:
2039D - Shohag Loves GCD
Tutorial
Tutorial is loading...
Code (Solution 1)
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 9;
int p[N];
void solve() {
  int n, m; cin >> n >> m;
  vector<int> s(m + 1);
  for (int i = 1; i <= m; i++) {
    cin >> s[i];
  }
  if (m < __lg(n) + 1) {
    cout << -1 << '\n';
    return;
  }
  for (int i = 1; i <= n; i++) {
    cout << s[m - p[i]] << ' ';
  }
  cout << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  for (int i = 2; i < N; i++) {
    if (p[i]) continue;
    for (int j = i; j < N; j += i) {
      int x = j;
      while (x % i == 0) x /= i, ++p[j];
    }
  }
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}
Code (Solution 2)
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 9;
using ll = long long;

vector<int> d[N];
void solve() {
  int n, m; cin >> n >> m;
  vector<int> s(m + 1);
  for (int i = 1; i <= m; i++) {
    cin >> s[i];
  }
  vector<int> a(n + 1, -1);
  for (int i = 1; i <= n; i++) {
    set<int> banned;
    for (int j: d[i]) {
      banned.insert(a[j]);
    }
    for (int k = m; k >= 1; k--) {
        if (banned.find(s[k]) == banned.end()) {
            a[i] = s[k];
            break;
        }
    }
    if (a[i] == -1) {
        cout << -1 << '\n';
        return;
    }
  }
  for (int i = 1; i <= n; i++) {
    cout << a[i] << ' ';
  }
  cout << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  for (int i = 1; i < N; i++) {
    for (int j = i + i; j < N; j += i) {
        d[j].push_back(i);
    }
  }
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2039C2
Editorial Content:
2039C2 - Shohag Loves XOR (Hard Version)
Tutorial
Tutorial is loading...
Code
#include<bits/stdc++.h>
using namespace std;

using ll = long long;

void solve() {
  int x; ll m; cin >> x >> m;

  // divisible by x
  ll p = m - m % x;
  ll ans = p / x - (x < p);
  if ((x ^ p) >= 1 and (x ^ p) <= m) ++ans;
  p += x;
  if ((x ^ p) >= 1 and (x ^ p) <= m) ++ans;

  // divisibly by y
  for (int y = 1; y <= min(1LL * x, m); y++) {
    ll cur = x ^ y;
    if (cur % y == 0) {
      ++ans;
    }
  }

  // divisible by both
  if (x <= m) {
    --ans;
  }

  cout << ans << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2039C1
Editorial Content:
2039C1 - Shohag Loves XOR (Easy Version)
Tutorial
Tutorial is loading...
Code
#include<bits/stdc++.h>
using namespace std;

using ll = long long;

void solve() {
  int x; ll m; cin >> x >> m;

  int ans = 0;
  for (int y = 1; y <= min(2LL * x, m); y++) {
    if (x != y and ((x % (x ^ y)) == 0 or (y % (x ^ y) == 0))) {
      ++ans;
    }
  }
  cout << ans << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2039B
Editorial Content:
2039B - Shohag Loves Strings
Tutorial
Tutorial is loading...
Code
#include<bits/stdc++.h>
using namespace std;

const int N = 3e5 + 9;
using ll = long long;

void solve() {
  string s; cin >> s;
  int n = s.size();
  for (int i = 0; i + 1 < n; i++) {
    if (s[i] == s[i + 1]) {
      cout << s.substr(i, 2) << '\n';
      return;
    }
  }
  for (int i = 0; i + 2 < n; i++) {
    if (s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]) {
      cout << s.substr(i, 3) << '\n';
      return;
    }
  }
  cout << -1 << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2039A
Editorial Content:
2039A - Shohag Loves Mod
Tutorial
Tutorial is loading...
Code
#include<bits/stdc++.h>
using namespace std;

const int N = 3e5 + 9;
using ll = long long;

void solve() {
  int n; cin >> n;
  for (int i = 1; i <= n; i++) {
    cout << 2 * i - 1 << ' ';
  }
  cout << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2038N
Editorial data not available.
--------------------------------------------------
Problem ID: 2038M
Editorial data not available.
--------------------------------------------------
Problem ID: 2038L
Editorial data not available.
--------------------------------------------------
Problem ID: 2038K
Editorial data not available.
--------------------------------------------------
Problem ID: 2038J
Editorial data not available.
--------------------------------------------------
Problem ID: 2038I
Editorial data not available.
--------------------------------------------------
Problem ID: 2038H
Editorial data not available.
--------------------------------------------------
Problem ID: 2038G
Editorial data not available.
--------------------------------------------------
Problem ID: 2038F
Editorial data not available.
--------------------------------------------------
Problem ID: 2038E
Editorial data not available.
--------------------------------------------------
Problem ID: 2038D
Editorial data not available.
--------------------------------------------------
Problem ID: 2038C
Editorial data not available.
--------------------------------------------------
Problem ID: 2038B
Editorial data not available.
--------------------------------------------------
Problem ID: 2038A
Editorial data not available.
--------------------------------------------------
Problem ID: 2037G
Editorial Content:
2037G — Natlan Exploring
Video
--------------------------------------------------
Problem ID: 2037F
Editorial Content:
2037F — Ardent Flames
Video
--------------------------------------------------
Problem ID: 2037E
Editorial Content:
2037E — Kachina's Favorite Binary String
Video
--------------------------------------------------
Problem ID: 2037D
Editorial Content:
2037D — Sharky Surfing
Video
--------------------------------------------------
Problem ID: 2037C
Editorial Content:
2037C — Superultra's Favorite Permutation
Video
--------------------------------------------------
Problem ID: 2037B
Editorial Content:
2037B — Intercepted Inputs
Video
--------------------------------------------------
Problem ID: 2037A
Editorial Content:
2037A — Twice
Video
--------------------------------------------------
Problem ID: 2036G
Editorial Content:
2036G - Library of Magic
Hint 1
Have you considered the cases where $$$a \oplus b \oplus c = 0$$$?
Hint 2
Suppose you are certain that at least one lost number is located on some segment $$$[le, ri]$$$. Can you choose a value $$$mid$$$ such that the queries
xor {le} {mid}
and
xor {mid + 1} {ri}
you can unambiguously understand on which of the segments ($$$[le, mid]$$$ or $$$[(mid + 1), ri]$$$) lies at least one lost number, even if both of these queries return $$$0$$$?
Tutorial
To begin with, we note that for any number $$$x$$$, $$$x \oplus x = 0$$$ is satisfied. Therefore, by querying
xor l r
, you will get bitwise XOR of only those volume numbers that are in the library in a single copy (within the scope of querying $$$l$$$ and $$$r$$$, of course). Also note that for
two
pairwise distinct numbers $$$x$$$ and $$$y$$$, $$$x \oplus y \neq 0$$$ is always satisfied.
Initially, our goal is — to determine the largest bit of the maximum of the lost numbers. To do this, we can go through the bits starting from the largest significant bit in n. For each $$$i$$$-th bit, we will ask
xor {2^i} {min(2^(i + 1) - 1, n)}
. Note that all numbers on this interval have $$$i$$$-th bit equal to one. Then if we get a result
not
equal to zero, then this bit is the desired largest bit of the maximum of the lost numbers. If we get a result
equal
to zero, then this bit is guaranteed not to be present in any of the numbers, i.e. all three numbers are less than $$$2^i$$$.
Let's prove it. If we had one or two numbers on the requested interval, their XOR would not be $$$0$$$ (see the first paragraph). If all three numbers are on this interval, then the XOR of their $$$i$$$-th bit is $$$1 \oplus 1 \oplus 1 = 1$$$, and hence the XOR of the numbers themselves is also different from $$$0$$$.
Now that we know the largest bit $$$i$$$ of the desired number, we can find this number by any realization of binary search inside the interval $$$[2^i; \min(2^{i + 1} - 1, n)]$$$. By the answer to any query on any interval within that interval, we can unambiguously know whether our number is present on that interval or not — the proof is similar to the one above.
The first number is found. The second number can be found using any bin search, since XOR of two different numbers is always different from zero. The main thing is not to forget to “exclude” the already found number from the obtained result using the same XOR. And the third number can be found by requesting the result of the whole interval from $$$1$$$ to $$$n$$$ and “excluding” the already found two numbers from it.
Number of requests: $$$\approx 2 \cdot \log n \approx 120 < 150$$$
Solution (m3tr0)
#include <cstdio>
typedef long long l;

l n, num1, num2;

l req(l le, l ri, l num) {
    if (le > n) return 0;
    if (ri > n) ri = n;
    
    printf("xor %lld %lld\n", le, ri); fflush(stdout);
    l res; scanf("%lld", &res);
    
    if (num > 1 && le <= num1 && num1 <= ri) res ^= num1;
    if (num > 2 && le <= num2 && num2 <= ri) res ^= num2;
    return res;
}

void solve() {
    scanf("%lld", &n); num1 = 0; num2 = 0;
    l start = 1LL << (63 - __builtin_clzll(n));

    for (l i = start; i > 0; i >>= 1) {
        l res = req(num1 | i, num1 | (i * 2 - 1), 1);
        if (res) num1 |= i;
    }

    for (l i = start; i > 0; i >>= 1) {
        l res = req(num2 | i, num2 | (i * 2 - 1), 2);
        if (res) num2 |= i;
    }
    
    printf("ans %lld %lld %lld\n", num1, num2, req(1, n, 3));
    fflush(stdout);
}

int main() {
    l t; scanf("%lld", &t);
    while (t--) solve();
}
--------------------------------------------------
Problem ID: 2036F
Editorial Content:
2036F - XORificator 3000
Hint 1
Note the base of the module
Hint 2
Can we quickly compute XOR on the segment $$$[l, r]$$$?
Tutorial
We also recommend the beautiful
tutorial
by
ne_justlm
!
Let us introduce the notation $$$\DeclareMathOperator{\XOR}{XOR}\XOR(l, r) = l \oplus (l+1) \oplus \dots \oplus r$$$ .
The first thing that comes to mind when reading the condition is that we can compute XOR of all numbers on the segment $$$(0, x)$$$ for $$$O(1)$$$ by the following formula:
$$$ \XOR(0, x) = \begin{cases} x & \text{if } x \equiv 0 \pmod{4} \\ 1 & \text{if } x \equiv 1 \pmod{4} \\ x + 1 & \text{if } x \equiv 2 \pmod{4} \\ 0 & \text{if } x \equiv 3 \pmod{4} \end{cases} $$$
Then $$$\XOR(l, r)$$$ can be found as $$$\XOR(0, r) \oplus \XOR(0, l-1)$$$.
Now note that for the answer we only need to learn for $$$O(1)$$$ to find XOR of all
uninteresting
on the segment: then we can do XOR with the whole segment and get XOR of all
interesting
numbers already.
The base of the modulus, equal to the degree of two, is not chosen by chance: we only need to “compress” $$$l$$$ and $$$r$$$ by $$$2^i$$$ times in such a way that the resulting range contains all
uninteresting
numbers shifted $$$i$$$ bits to the right. Then computing $$$\XOR(l', r')$$$ we get exactly the desired XOR of
uninteresting
numbers, also shifted $$$i$$$ bits to the right. Then, to find these remaining lower $$$i$$$ bits, we just need to find the number of
uninteresting
numbers on the segment $$$[l, r]$$$. If it is odd, these $$$i$$$ bits will be equal to $$$k$$$, since they are all equal to $$$k \mod 2^i$$$, and so have the same $$$i$$$ minor bits equal to $$$k$$$ proper, and so their XOR an odd number of times will also be equal to $$$k$$$.
Otherwise, the lower $$$i$$$ bits of the answer will be $$$0$$$, since we have done XOR an even number of times. The number of
uninteresting
numbers on the segment can be calculated in a similar way to $$$\XOR(l, r)$$$, namely find their number on the segments $$$[0, r]$$$ and $$$[0, l-1]$$$ and subtract the latter from the former. The number of numbers equal to $$$k$$$ modulo $$$m$$$ and not exceeding $$$r$$$ is calculated as $$$\left\lfloor \frac{r - k}{m} \right\rfloor$$$.
Time complexity of the solution: $$$O(\mathit{\log r})$$$.
Solution (eugenechka.boyko.2_0-0)
#include <iostream>
using namespace std;
#define int uint64_t
#define SPEEDY std::ios_base::sync_with_stdio(0); std::cin.tie(0); std::cout.tie(0);
 
int xor_0_n(int n) {
    int rem = n % 4;
    if (rem == 0) {
        return n;
    }
    if (rem == 1) {
        return 1;
    }
    if (rem == 2) {
        return n + 1;
    }
    return 0;
}
 
int xor_range(int l, int r) {
    return xor_0_n(r) ^ xor_0_n(l - 1);
}
 
int32_t main() {
    int t;
    cin >> t;
    while (t--) {
        int l, r, i, k;
        cin >> l >> r >> i >> k;
        int highBits = xor_range((l - k + (1 << i) - 1) >> i, (r - k) >> i) << i;
        int lowBits = k * (((r - k) / (1 << i) - (l - k - 1) / (1 << i)) & 1);
        cout << (xor_range(l, r) ^ highBits ^ lowBits) << '\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2036E
Editorial Content:
2036E - Reverse the Rivers
Hint
For any non-negative integers, $$$a \leq a | b$$$, where $$$|$$$ is the bitwise “or” operation.
Tutorial
After computing the values of $$$b_{i,j}$$$ for all countries and regions, we can notice that for a fixed region $$$j$$$, the values of $$$b_{i,j}$$$ increase as the index $$$i$$$ increases. This is because the bitwise “or” operation cannot decrease a number, but only increase or leave it unchanged. Hence, we can use binary search to quickly find the country that matches the given conditions.
For each query and for each requirement, if $$$o$$$ = “<”, we search for the first country where $$$b_{i,r} \geq c$$$ (this will be the first country that does not satisfy the condition). If sign $$$o$$$ = “>”, we look for the first country where $$$b_{i,r} \leq c$$$. In both cases, we can use standard binary search to find the index. If the checks leave at least one country that satisfies all the requirements, we choose the country with the lowest number.
Complexity: counting values $$$O(n\cdot k)$$$, processing each query using binary search $$$O(m \log n)$$$, total $$$O(n \cdot k + q \cdot m \cdot \log n)$$$.
Solution (m3tr0)
#include <cstdio>
typedef long long l;

l ** arr;

int main() {
	l n, k, q; scanf("%lld %lld %lld", &n, &k, &q);
	
	arr = new l*[n];
	for (l i = 0; i < n; i++) arr[i] = new l[k];
	for (l i = 0; i < n; i++) for (l j = 0; j < k; j++) scanf("%lld", &arr[i][j]);
	
	for (l i = 1; i < n; i++) for (l j = 0; j < k; j++) arr[i][j] |= arr[i - 1][j];
	
	while (q--) {
		l m; scanf("%lld", &m);
		l left_pos = 0, right_pos = n - 1;
		while (m--) {
			l r, c; char o; scanf("%lld %c %lld", &r, &o, &c); r--;
			if (o == '<') {
				l le = -1, ri = n, mid;
				while (le + 1 != ri) {
					mid = (le + ri) / 2;
					if (arr[mid][r] < c) le = mid;
					else ri = mid;
				}
				if (le < right_pos) right_pos = le;
			} else {
				l le = -1, ri = n, mid;
				while (le + 1 != ri) {
					mid = (le + ri) / 2;
					if (arr[mid][r] <= c) le = mid;
					else ri = mid;
				}
				if (ri > left_pos) left_pos = ri;
			}
		}
		if (left_pos <= right_pos) printf("%lld\n", left_pos + 1);
		else printf("-1\n");
	}
}
--------------------------------------------------
Problem ID: 2036D
Editorial Content:
2036D - I Love 1543
Tutorial
We will go through all layers of the carpet, adding to the answer the number of $$$1543$$$ records encountered on each layer. To do this, we can iterate over, for example, the top-left cells of each layer having the form $$$(i, i)$$$ for all $$$i$$$ in the range $$$[1, \frac{min(n, m)}{2}]$$$, and then traverse the layer with a naive algorithm, writing the encountered digits into some array. Then traverse the array and count the $$$1543$$$ occurrences in that layer. Also, when traversing the array, we should take into account the cyclic nature of the layer, remembering to check for possible occurrences of $$$1543$$$ containing a starting cell.
Complexity: $$$O(n \cdot m)$$$
Solution (m3tr0)
#include <cstdio>

char a[1005][1005];
char layer[4005];

void solve() {
    int n, m; scanf("%d %d", &n, &m);
    for (int i = 0; i < n; ++i) scanf("%s", a[i]);
    
    int count = 0;
    for (int i = 0; (i + 1) * 2 <= n && (i + 1) * 2 <= m; ++i) {
        int pos = 0;
        for (int j = i; j < m - i; ++j) layer[pos++] = a[i][j];
        for (int j = i + 1; j < n - i - 1; ++j) layer[pos++] = a[j][m - i - 1];
        for (int j = m - i - 1; j >= i; --j) layer[pos++] = a[n - i - 1][j];
        for (int j = n - i - 2; j >= i + 1; --j) layer[pos++] = a[j][i];
        
        for (int j = 0; j < pos; ++j)
            if (layer[j] == '1' && layer[(j + 1) % pos] == '5' && layer[(j + 2) % pos] == '4' && layer[(j + 3) % pos] == '3')
                count++;
        
    }
    
    printf("%lld\n", count);
}
 
int main() {
    int t; scanf("%d", &t);
    while (t--) solve();
}
--------------------------------------------------
Problem ID: 2036C
Editorial Content:
2036C - Anya and 1100
Hint
With each query, to track the change in the presence of “1100” in a row, you don't have to go through the entire row — you can check just a few neighboring cells.
Tutorial
First, in a naive way, let's count $$$count$$$ — the number of times “1100” occurs in $$$s$$$.
Then for each of $$$q$$$ queries we will update $$$count$$$: consider the substring $$$s[\max(1, i - 3); \min(i + 3, n)]$$$ before changing $$$s_i$$$ and find $$$before$$$ — the number of times that “1100” occurs in it. Then update $$$s_i = v$$$ and similarly find $$$after$$$ — the number of times that “1100” occurs in $$$s[\max(1, i - 3); \min(i + 3, n)]$$$ after applying the query.
Thus, by doing $$$count = count + (after - before)$$$, we get the number of times that “1100” occurs in $$$s$$$ after the query is applied. If $$$count > 0$$$, the answer to the query is “YES”, otherwise it is “NO”.
Complexity: $$$O(|s| + q)$$$
Solution (m3tr0)
#include <cstdio>
#include <cstring>

using namespace std;
typedef long long l;

char buf[1000000];
l n;

bool check_1100(l i) {
	if (i < 0) return false;
	if (i >= n - 3) return false;
	if (buf[i] == '1' && buf[i + 1] == '1' && buf[i + 2] == '0' && buf[i + 3] == '0') return true;
	return false;
}

void solve() {
	scanf("%s", buf);
	n = strlen(buf);
	l count = 0;
	for (l i = 0; i < n; i++)
		if (check_1100(i)) count++;
	
	l q; scanf("%lld", &q);
	while (q--) {
		l i, v; scanf("%lld %lld", &i, &v); i--;
		if (buf[i] != '0' + v) {
		    bool before = check_1100(i - 3) || check_1100(i - 2) || check_1100(i - 1) || check_1100(i);
		    buf[i] = '0' + v;
		    bool after = check_1100(i - 3) || check_1100(i - 2) || check_1100(i - 1) || check_1100(i);
		    count += after - before;
		}
		printf(count ? "YES\n" : "NO\n");
	}
}

int main() {
	l t; scanf("%lld", &t);
	while (t--) solve();
}
--------------------------------------------------
Problem ID: 2036B
Editorial Content:
2036B - Startup
Tutorial
Let's create an array
brand_cost
of length $$$k$$$ and fill it so that
brand_cost[i]
stores the cost of all bottles of brand $$$i+1$$$. Then sort the array by non-growing and calculate the sum of its first
min(n, k)
elements, which will be the answer to the problem.
Complexity: $$$O(k \cdot \log k)$$$
Solution (Seny)
#include <bits/stdc++.h>
using namespace std;
 
void solve() {
  int n, k;
  cin >> n >> k;
  vector<int> brand_cost(k, 0);
  for (int i = 0; i < k; i++) {
    int b, c;
    cin >> b >> c;
    brand_cost[b - 1] += c;
  }
  sort(brand_cost.rbegin(), brand_cost.rend());
  long long ans = 0;
  for (int i = 0; i < min(n, k); i++) {
    ans += brand_cost[i];
  }
  cout << ans << '\n';
}
 
int main() {
  int t;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}
--------------------------------------------------
Problem ID: 2036A
Editorial Content:
2036A - Quintomania
Tutorial
If for all $$$i$$$ $$$(1 \leq i \leq n - 1)$$$ is true $$$|a_i - a_{i+1}| = 5$$$ or $$$|a_i - a_{i+1}| = 7$$$, the answer to the problem is “YES”, otherwise it is “NO”.
Complexity: $$$O(n)$$$
Solution (myav)
#include <bits/stdc++.h>
using namespace std;
 
bool solve(){
    int n;
    cin >> n;
    vector<int>a(n);
    for(int i = 0; i < n; i++) cin >> a[i];
    for(int i = 1; i < n; i++) {
        if(abs(a[i] - a[i - 1]) != 5 && abs(a[i] - a[i - 1]) != 7) return false;
    }
    return true;
}
int main() {
    int t;
    cin >> t;
    while(t--){
        cout << (solve() ? "YES" : "NO") << "\n";
    }
}
--------------------------------------------------
Problem ID: 2035H
Editorial data not available.
--------------------------------------------------
Problem ID: 2035G2
Editorial data not available.
--------------------------------------------------
Problem ID: 2035G1
Editorial data not available.
--------------------------------------------------
Problem ID: 2035F
Editorial data not available.
--------------------------------------------------
Problem ID: 2035E
Editorial data not available.
--------------------------------------------------
Problem ID: 2035D
Editorial data not available.
--------------------------------------------------
Problem ID: 2035C
Editorial data not available.
--------------------------------------------------
Problem ID: 2035B
Editorial data not available.
--------------------------------------------------
Problem ID: 2035A
Editorial data not available.
--------------------------------------------------
Problem ID: 2034H
Editorial Content:
2034H - Rayan vs. Rayaneh
Solution
Step 1:
According to
Bézout's Identity
, we can compute $$$\gcd(x_1, \ldots, x_t)$$$ and all its multipliers as an integer linear combination of $$$x_1, x_2, \ldots, x_t$$$.
Step 2:
A set {$$$a_1, \ldots, a_k$$$} is good (integer linearly independent) if for every $$$i$$$, $$$\gcd($$${$$$a_j \mid j \neq i$$$}$$$) \nmid a_i$$$.
Step 3:
A set {$$$a_1, \ldots, a_k$$$} is good if and only if there exists a set {$$${p_1}^{q_1}, {p_2}^{q_2}, \ldots, {p_k}^{q_k}$$$} such that $$${p_i}^{q_i} \mid a_j$$$ for $$$j \neq i$$$ and $$${p_i}^{q_i} \nmid a_i$$$.
Step 4:
The set {$$$a_1, \ldots, a_k$$$} can be identified by determining {$$${p_1}^{q_1}, {p_2}^{q_2}, \ldots, {p_k}^{q_k}$$$}. Assume $$$p_1^{q_1} < p_2^{q_2} < \ldots < p_k^{q_k}$$$, where $$$p_i \neq p_j$$$ and $$$p_i$$$ is prime.
Step 5:
Let $$$G = {p_1}^{q_1} \cdot {p_2}^{q_2} \ldots \cdot {p_k}^{q_k}.$$$ Then {$$$a_1, \ldots, a_k$$$} is good if and only if $$$\frac{G}{{p_i}^{q_i}} \mid a_i$$$ and $$$G \nmid a_i$$$ for every $$$i$$$.
Step 6:
The answer is a singleton if, for every pair of numbers $$$x$$$ and $$$y$$$ in the array, $$$x \mid y$$$ or $$$y \mid x$$$. Since the numbers are distinct, a good subset {$$$a_1, a_2$$$} can always be found by searching the first $$$\log M + 2$$$ elements.
Step 7:
Define $$$CM[i]$$$ (count multipliers of $$$i$$$) as the number of $$$x$$$ such that $$$i \mid a_x$$$. This can be computed in $$$O(n + M \log M)$$$.
Step 8:
A corresponding set {$$$a_1, \ldots, a_k$$$} exists for a set {$$${p_1}^{q_1}, {p_2}^{q_2}, \ldots, {p_k}^{q_k}$$$} if and only if $$$CM\left[\frac{G}{{p_i}^{q_i}}\right] > CM[G] \geq 0$$$ for all $$$i$$$.
Step 9:
Iterate over all valid sets of the form {$$${p_1}^{q_1}, {p_2}^{q_2}, \ldots, {p_k}^{q_k}$$$}, and check if a corresponding {$$$a_1, a_2, \ldots, a_k$$$} exists. Note that $$$k \geq 3$$$ since a good subset {$$$a_1, a_2$$$} is found using another method.
Step 10:
We know $$$\frac{G}{{p_1}^{q_1}} \leq M$$$ and also $$${p_1}^{q_1} \leq \sqrt{M},$$$ as $$${p_1}^{q_1} \leq \sqrt{{p_2}^{q_2} \cdot {p_3}^{q_3}} \leq \sqrt{\frac{G}{{p_1}^{q_1}}} \leq \sqrt{M}.$$$
Step 11:
There are $$$\sum_{i=1}^{\frac{\log M}{2}} P[\lfloor \sqrt[2i]{M} \rfloor]$$$ numbers in the form $$${p_1}^{q_1}$$$, where $$$P[i]$$$ denotes the number of primes in the range $$$[1, i]$$$. This count is $$$O(\frac{\sqrt M}{\log M})$$$.
Step 12:
The value of $$$k$$$ is at most 6 (denoted as $$$K$$$), as $$${p_2}^{q_2} \ldots {p_k}^{q_k} = \frac{G}{{p_1}^{q_1}} \leq M,$$$ and $$$3 \cdot 5 \cdot 7 \cdot 11 \cdot 13 \leq M < 3 \cdot 5 \cdot 7 \cdot 11 \cdot 13 \cdot 17.$$$
Step 13:
We can determine {$$$a_1, \ldots, a_k$$$} from {$$${p_1}^{q_1}, {p_2}^{q_2}, \ldots, {p_k}^{q_k}$$$} in $$$O(n \cdot K)$$$.
The total time complexity is $$$O\left(T \cdot M \cdot \frac{\sqrt M}{\log M} \cdot K + T \cdot M \cdot \log M + \sum_{i=0}^T n_i \cdot K\right).$$$
Implementation
/// In the name of God the most beneficent the most merciful

#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math,O3")
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

constexpr int T = 100;
constexpr int M = 100001;
constexpr int SQM = 320;
constexpr int LGM = 20;
vector<pair<int,int>> factor;
int t, n[T], count_multipliers[T][M];
bitset<M> is_composite;
vector<int> ans[T], a[T];

inline void calculate_importants() {
    for(int i = 2; i < SQM; i++)
        if(!is_composite[i]) {
            for(int j = i; j < M; j *= i)
                factor.push_back({j,i});
            for(int j = i*i; j < M; j += i)
                is_composite.set(j);
        }
    for(int i = SQM; i < M; i++)
        if(!is_composite[i])
            factor.push_back({i,i});
    sort(factor.begin(), factor.end());
}

void check(vector<int> &factors, int G) {
    if(factors.size() > 2u) {
        for(int i = 0; i < t; i++) 
            if(ans[i].size() < factors.size()) {
                int count_product = (G < M? count_multipliers[i][G] : 0);
                bool can = true;	
                for(auto u: factors)
                    if(count_multipliers[i][G/factor[u].first] == count_product) {
                        can = false;
                        break;
                    }
                if(can)
                    ans[i] = factors;
            }
    }
    int bound = (factors.size() == 1 ? SQM : M);
    if(1LL*G/factor[factors[0]].first*factor[factors.back()].first > bound)
        return;
    for(int new_factor = factors.back(); G/factor[factors[0]].first*factor[new_factor].first <= bound; new_factor++) 
        if(G%factor[new_factor].second) {
            factors.push_back(new_factor);
            check(factors, G*factor[new_factor].first);
            factors.pop_back();
        }
}

int main() {
    ios_base :: sync_with_stdio(false); cin.tie(nullptr);
    calculate_importants();
    cin >> t;
    for(int i = 0; i < t; i++) {
        cin >> n[i];
        a[i].resize(n[i]);
        for(int j = 0; j < n[i]; j++) {
            cin >> a[i][j];
            count_multipliers[i][a[i][j]]++;
        }
        ans[i] = {a[i][0]};
        sort(a[i].begin(), a[i].begin()+min(n[i], LGM));
        for(int c = 0; c+1 < n[i]; c++)
            if(a[i][c+1]%a[i][c]) {
                ans[i] = {a[i][c], a[i][c+1]};
                break;
            }
        for(int c = 1; c < M; c++)
            for(int j = c+c; j < M; j += c)
                count_multipliers[i][c] += count_multipliers[i][j];
    }
    for(int i = 0; factor[i].first < SQM; i++) {
        vector<int> starter = {i};
        check(starter, factor[i].first);
    }
    for(int i = 0; i < t; i++) {
        int k = ans[i].size();
        cout << k << '\n';
        if(k == 1u) {
            cout << ans[i][0] << '\n';
        } else if(k == 2u) {
            cout << ans[i][0] << ' ' << ans[i][1] << '\n';
        } else {
            int subset[k];
            for(auto u: a[i]) {
                int ls = -1;
                for(int j = 0; j < (int)k; j++)
                    if(u%factor[ans[i][j]].first)
                        ls = (ls == -1? j: -2);
                if(ls >= 0)
                    subset[ls] = u;
            }
            for(int j = 0; j < k; j++)
                cout << subset[j] << (j+1 == k? '\n' : ' ');
        }
    }
    return 0;
}

/// Thank God . . .
--------------------------------------------------
Problem ID: 2034G2
Editorial Content:
2034G2 - Simurgh's Watch (Hard Version)
Solution
Step 1:
It is easy to check if the solution can be achieved with only one color. For any time point $$$x$$$, there must be at most one interval containing $$$x$$$, since if multiple intervals contain $$$x$$$, they must be colored differently.
Step 2:
A simple strategy is to solve the problem using three colors; First, we color some intervals with colors 1 and 2, then color others with color 3. For each step, we find the leftmost point that has not been colored yet and color the segment that contains this point. We always choose the interval with the largest endpoint that contains the current point. By coloring the intervals alternately with colors 1 and 2, we ensure that all points are covered by exactly one of these colors.
Step 3:
Now, we check if we can color the intervals with just two colors. For some point, $$$x$$$, suppose we have already colored the intervals $$$[l_i, r_i]$$$ with $$$l_i \leq x$$$, such that all points before $$$x$$$ have a unique color. At each step, we only need to determine which of the intervals like $$$p$$$ that $$$l_p \leq x \leq r_p$$$ can have a unique color. The key observation is that if an interval can be uniquely colored at time $$$x$$$, it can also remain uniquely colored for all times $$$t$$$ such that $$$x \leq t \leq r_i$$$.
Lemma:
If an interval $$$[l_i, r_i]$$$ can be uniquely colored at time $$$x$$$, it can also be uniquely colored at all subsequent times $$$x \leq t \leq r_i$$$.
Proof:
Consider coloring the intervals at time $$$x$$$. Intervals starting at $$$x + 1$$$ will be colored with the opposite color to interval $$$i$$$, ensuring that the interval remains uniquely colored at time $$$x+1$$$.
With this lemma, we can conclude that the changes in the coloring are $$$O(n)$$$. It suffices to track the intervals that are added and removed at each point in time.
Step 4:
To efficiently move from time $$$x$$$ to $$$x + 1$$$, we perform the following steps:
Remove the intervals that have $$$r_i = x$$$ (since they no longer contain $$$x+1$$$).
Add the intervals that have $$$l_i = x + 1$$$.
Update the set of intervals that can be uniquely colored at time $$$x+1$$$.
Step 5:
Finally, we observe that only the following points are important for the coloring:
$$$l_i$$$ and $$$r_i$$$ for each interval.
$$$l_i - 1$$$ and $$$r_i + 1$$$, since these points mark the boundaries where intervals start or end.
Thus, we can compress the numbers to reduce the range of values we need to process.
Implementation
/* In the name of Allah */
// Welcome to the Soldier Side!
// Where there's no one here, but me...
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
vector<int> st[N << 2], en[N << 2];
int t, n, k, l[N], r[N], dp[N], col[N], prv[N];

void compress_numbers() {
    vector<int> help;
    for (int i = 0; i < n; i++) {
        help.push_back(l[i] - 1);
        help.push_back(l[i]);
        help.push_back(r[i]);
        help.push_back(r[i] + 1);
    }

    sort(help.begin(), help.end());
    help.resize(k = unique(help.begin(), help.end()) - help.begin());
    for (int i = 0; i < n; i++) {
        l[i] = lower_bound(help.begin(), help.end(), l[i]) - help.begin();
        r[i] = lower_bound(help.begin(), help.end(), r[i]) - help.begin();
    }
}

void save_checkpoints() {
    for (int i = 0; i < n; i++) {
        st[l[i]].push_back(i);
        en[r[i]].push_back(i);
    }
}

bool check_one() {
    for (int i = 0, open = 0; i < k; i++) {
        open += st[i].size();
        if (open > 1)
            return false;
        open -= en[i].size();
    }
    return true;
}

void color_with_two() {
    for (int i = k - 1, cur = -1; ~i; i--) {
        if (en[i].empty())
            continue;

        while (!~cur || i < dp[cur])
            if (~cur && ~prv[cur]) {
                col[prv[cur]] = col[cur];
                if (r[prv[cur]] >= l[cur])
                    col[prv[cur]] ^= 1;
                cur = prv[cur];
            }
            else
                for (int p: en[i])
                    if (~dp[p] && (!~cur || dp[p] < dp[cur]))
                        cur = p;

        for (int p: en[i])
            if (p ^ cur)
                col[p] = col[cur] ^ 1;
    }
}

bool check_two() {
    set<int> goods, bads;
    fill(dp, dp + n, -1);
    fill(prv, prv + n, -1);
    for (int i = 0; i < k; i++) {
        int prev = -1;
        if (i)
            for (int p: en[i - 1]) {
                bads.erase(p), goods.erase(p);
                if (~dp[p] && (!~prev || dp[p] < dp[prev]))
                    prev = p;
            }
        int open = goods.size() + bads.size();

        if (open == 1 || (open == 2 && !goods.empty())) {
            for (int p: bads) {
                if (open == 1)
                    prv[p] = prev;
                else
                    prv[p] = *goods.begin();
                goods.insert(p);
                dp[p] = i;
            }
            bads.clear();
        }

        if (open == 1)
            prev = *goods.begin();
        for (int p: st[i])
            if (!open || open == 1 || ~prev) {
                goods.insert(p);
                prv[p] = prev;
                dp[p] = i;
            }
            else
                bads.insert(p);
        open += st[i].size();

        if (open && goods.empty())
            return false;
    }

    color_with_two();
    return true;
}

void color_with_three() {
    int cur = -1, nxt = -1;
    for (int i = 0; i < k; i++) {
        if (st[i].empty())
            continue;

        if (~cur && i > r[cur] && nxt ^ cur) {
            col[nxt] = col[cur] ^ 3;
            cur = nxt;
        }
        if (!~cur || i > r[cur]) {
            for (int p: st[i])
                if (!~cur || r[p] > r[cur])
                    cur = p;
            col[nxt = cur] = 1;
        }

        for (int p: st[i])
            if (r[p] > r[nxt])
                nxt = p;
    }

    if (cur ^ nxt)
        col[nxt] = col[cur] ^ 3;
}

void read_input() {
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> l[i] >> r[i];
}

void solve() {
    compress_numbers();
    save_checkpoints();
    if (check_one())
        return;
    if (check_two())
        return;
    color_with_three();
}

void write_output() {
    cout << *max_element(col, col + n) + 1 << endl;
    for (int i = 0; i < n; i++)
        cout << col[i] + 1 << "\n "[i < n - 1];
}

void reset_variables() {
    fill(col, col + n, 0);
    for (int i = 0; i < k; i++) {
        st[i].clear();
        en[i].clear();
    }
}

int main() {
    ios:: sync_with_stdio(0), cin.tie(0), cout.tie(0);
    for (cin >> t; t--; reset_variables())
        read_input(), solve(), write_output();
    return 0;
}
--------------------------------------------------
Problem ID: 2034G1
Editorial Content:
2034G1 - Simurgh's Watch (Easy Version)
Solution
It is easy to check if the solution can be achieved with only one color. For any time point $$$x$$$, there must be at most one interval containing $$$x$$$, since if multiple intervals contain $$$x$$$, they must be colored differently.
A simple strategy is to solve the problem using three colors. First, we color some intervals with colors 1 and 2, then color others with color 3.
For each step, we find the leftmost point that has not been colored yet and color the segment that contains this point.
We always choose the interval with the largest endpoint that contains the current point.
By coloring the intervals alternately with colors 1 and 2, we ensure that all points are covered by exactly one of these colors.
Now, we check if we can color the intervals with just two colors using a greedy algorithm:
We iterate over the intervals sorted by start (increasingly) and then by end (decreasingly).
At each point, we keep track of the number of colors used in previous intervals that are not yet closed. Let this number be $$$I$$$, and suppose we are currently at interval $$$i$$$.
We color the current interval based on the value of $$$I$$$:
If $$$I = 0$$$, color interval $$$i$$$ with color 1.
If $$$I = 1$$$, color interval $$$i$$$ with the opposite color of the current used color.
If $$$I = 2$$$, color interval $$$i$$$ with the opposite color of the interval with the greatest endpoint among the currently open intervals.
If it is impossible to assign a unique color between overlapping intervals at any point, it can be shown that coloring the intervals using only 2 colors is impossible.
Solving G1 using G2:
It’s sufficient to check the integer points and half-points (e.g., 1.5, 2.5, …) to verify whether the coloring is valid (Why?).
To handle this, we can multiply all the given points by two, effectively converting the problem into one in which only integer points exist.
After this transformation, we solve the problem in the integer system of G2, where the intervals and coloring rules are defined using integer boundaries!
Note:
A brief explanation of why this greedy algorithm works can be found
here
.
Implementation
/* In the name of Allah */
// Welcome to the Soldier Side!
// Where there's no one here, but me...
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
int t, n, l[N], r[N], col[N];
vector<int> st[N << 1], en[N << 1];

void compress_points() {
    vector<int> help;
    for (int i = 0; i < n; i++) {
        help.push_back(l[i]);
        help.push_back(r[i]);
    }

    sort(help.begin(), help.end());
    help.resize(unique(help.begin(), help.end()) - help.begin());
    for (int i = 0; i < n; i++) {
        l[i] = lower_bound(help.begin(), help.end(), l[i]) - help.begin();
        r[i] = lower_bound(help.begin(), help.end(), r[i]) - help.begin();
    }
}

void record_points() {
    for (int i = 0; i < n; i++) {
        st[l[i]].push_back(i);
        en[r[i] + 1].push_back(i);
    }
    for (int i = 0; i < 2 * n; i++)
        sort(st[i].begin(), st[i].end(), [](int i, int j) {
            return r[i] > r[j];
        });
}

void try3_points() {
    fill(col, col + n, 0);
    int cur = -1, nxt = -1, c = 2;
    for (int i = 0; i < 2 * n; i++) {
        if (st[i].empty())
            continue;

        if (!~cur || i > r[cur]) {
            if (cur ^ nxt && r[nxt] < i) {
                col[nxt] = (c ^= 3);
                cur = nxt;
            }

            if (cur ^ nxt)
                cur = nxt;
            else {
                cur = st[i][0];
                for (int p: st[i])
                    if (r[p] > r[cur])
                        cur = p;
                nxt = cur;
            }
            col[cur] = (c ^= 3);
        }
        
        for (int p: st[i])
            if (r[p] > r[nxt])
                nxt = p;
    }
    if (cur ^ nxt)
        col[nxt] = c ^ 3;
}

bool is_bad(set<pair<int, int>> s[2]) {
    int cnt1 = s[0].size(), cnt2 = s[1].size();
    return cnt1 + cnt2 && cnt1 ^ 1 && cnt2 ^ 1;
}

void try2_points() {
    set<pair<int, int>> s[2];
    for (int i = 0; i <= 2 * n; i++) {
        for (int p: en[i])
            s[col[p]].erase({r[p], p});
        if (is_bad(s)) {
            try3_points();
            return;
        }

        for (int p: st[i]) {
            int cnt1 = s[0].size();
            int cnt2 = s[1].size();
            if (!cnt1 || !cnt2)
                col[p] = cnt1 > 0;
            else if (cnt1 ^ cnt2)
                col[p] = cnt1 < cnt2;
            else
                col[p] = s[0].begin()->first > s[1].begin()->first;

            s[col[p]].insert({r[p], p});
            if (is_bad(s)) {
                try3_points();
                return;
            }
        }
    }
}

void read_input() {
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> l[i] >> r[i];
}

void solve() {
    compress_points();
    record_points();
    try2_points();
}

void write_output() {
    cout << *max_element(col, col + n) + 1 << endl;
    for (int i = 0; i < n; i++)
        cout << col[i] + 1 << "\n "[i < n - 1];
}

void reset_variables() {
    for (int i = 0; i < n; i++) {
        col[i] = 0;
        st[l[i]].clear();
        en[r[i] + 1].clear();
    }
}

int main() {
    ios:: sync_with_stdio(0), cin.tie(0), cout.tie(0);
    for (cin >> t; t--; reset_variables())
        read_input(), solve(), write_output();
    return 0;
}
--------------------------------------------------
Problem ID: 2034F2
Editorial Content:
2034F2 - Khayyam's Royal Decree (Hard Version)
Solution
Step 1:
For simplicity, redefine the special conditions for the number of rubies and sapphires in your satchel (not chest).
Step 2:
Order the redefined conditions $$$(x, y)$$$ in increasing order based on the value of $$$x + y$$$.
Step 3:
Define $$$total_{i,j}$$$ as the total number of ways to move from state $$$i$$$ to state $$$j$$$ (ignoring special condition constraints). This can be computed as:
$$$total_{i,j} = \binom{|x_i - x_j| + |y_i - y_j|}{|x_i - x_j|}$$$
Step 4:
Define $$$weight_i$$$ as the total contribution of all paths passing through condition $$$i$$$ to reach the final state $$$(n, m)$$$. This can be computed recursively as:
$$$weight_i = \sum_{i < j \leq k} total_{i,j} \times weight_j$$$
Step 5:
The main insight is to account for the doubling effect of passing through multiple scrolls. If a path passes through a sequence of conditions $$$s_1, \dots, s_c$$$, each gem collected before entering $$$s_1$$$ is counted with multiplicity $$$2^c$$$. Instead of explicitly multiplying by $$$2^c$$$, consider the number of subsets $$$q_1, \dots, q_d$$$ of $$$s_1, \dots, s_c$$$. By summing over all subsets, the correct multiplicity is automatically handled.
Step 6:
Define $$$dp_i$$$ as the total value of all paths passing through condition $$$i$$$, considering the contribution of each state’s rubies and sapphires. This can be computed as:
$$$dp_i = (2x_i + y_i) \times total_{0, i} \times weight_i$$$
Step 7:
Compute the final answer as $$$\sum dp_i$$$ divided by the total number of ways to move from $$$(0,0)$$$ to $$$(n,m)$$$, which is equal to $$$\binom{n+m}{n}$$$.
Clarification:
The approach hinges on the insight that $$$2^i$$$ can be derived from the structure of subsets of scrolls $$$s_1, \dots, s_c$$$. Generalizations to $$$3^i$$$ or other multiplicative factors are possible by appropriately modifying $$$weight_i$$$ and adjusting the factor in Step 5. For example, a factor of 3 can be applied by multiplying path contributions by 2 at the relevant steps.
Implementation
#include <bits/stdc++.h>
using namespace std;
 
#define nl "\n"
#define nf endl
#define ll long long
#define pb push_back
#define _ << ' ' <<
 
#define INF (ll)1e18
#define mod 998244353
#define maxn 400010
 
ll fc[maxn], nv[maxn];
 
ll fxp(ll b, ll e) {
    ll r = 1, k = b;
    while (e != 0) {
        if (e % 2) r = (r * k) % mod;
        k = (k * k) % mod; e /= 2;
    }
    return r;
}
 
ll inv(ll x) {
    return fxp(x, mod - 2);
}
 
ll bnm(ll a, ll b) {
    if (a < b || b < 0) return 0;
    ll r = (fc[a] * nv[b]) % mod;
    r = (r * nv[a - b]) % mod;
    return r;
}
 
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
 
    fc[0] = 1; nv[0] = 1;
    for (ll i = 1; i < maxn; i++) {
        fc[i] = (i * fc[i - 1]) % mod; nv[i] = inv(fc[i]);
    }
 
    ll t; cin >> t;
    while (t--) {
        ll n, m, k; cin >> n >> m >> k;
        vector<array<ll, 2>> a(k + 2, {0, 0});
        for (ll i = 1; i <= k; i++) {
            cin >> a[i][0] >> a[i][1];
            a[i][0] = n - a[i][0]; a[i][1] = m - a[i][1];
        }
        a[k + 1] = {n, m}; k++;
        sort(a.begin() + 1, a.end());
 
        auto paths = [&](ll i, ll j) {
            ll dx = a[j][0] - a[i][0], dy = a[j][1] - a[i][1];
            return bnm(dx + dy, dx);
        };
 
        auto add = [&](ll &x, ll y) {
            x = (x + y) % mod;
            x = (x + mod) % mod;
        };
 
        vector<ll> cnt_weighted(k + 1, 0);
        cnt_weighted[k] = 1;
        for (ll i = k - 1; i >= 1; i--) {
            for (ll j = i + 1; j <= k; j++) {
                add(cnt_weighted[i], paths(i, j) * cnt_weighted[j]);
            }
        }
 
        ll ans = 0;
        for (ll i = 1; i <= k; i++) {
            ll delta = 2 * a[i][0] + a[i][1];
            add(ans, delta * paths(0, i) % mod * cnt_weighted[i]);
        }
 
        ans = (ans * inv(bnm(n + m, m))) % mod;
        cout << ans << nl;
    }
 
    return 0;
}
--------------------------------------------------
Problem ID: 2034F1
Editorial Content:
2034F1 - Khayyam's Royal Decree (Easy Version)
Solution
Step 1:
For simplicity, redefine the special conditions for the number of rubies and sapphires in your satchel (not chest). Add two dummy states, $$$(0,0)$$$ and $$$(n,m)$$$ for convenience (the first one indexed as $$$0$$$ and the second one indexed as $$$k+1$$$). Note that these dummy states won’t involve doubling the value.
Step 2:
Order the redefined conditions $$$(x, y)$$$ in increasing order based on the value of $$$x + y$$$.
Step 3:
Define $$$ways_{i,j}$$$ as the number of ways to move from state $$$i$$$ to state $$$j$$$ without passing through any other special condition. This can be computed using inclusion-exclusion in $$$O(k^3)$$$.
Step 4:
Define $$$cost_{i,j}$$$, the increase in value for moving directly from state $$$i$$$ to state $$$j$$$ without intermediate doubling, as:
$$$cost_{i,j} = 2|x_i - x_j| + |y_i - y_j|$$$
Step 5:
Define $$$dp_i$$$ as the total sum of the value of your satchel across all ways to reach the state defined by the $$$i$$$-th condition. This can be computed recursively as:
$$$dp_i = 2 \sum_{0 \leq j < i} ways_{j,i} \times (dp_j + \binom{x_j + y_j}{x_j} \times cost_{j,i})$$$
Step 6:
Compute the final answer as the value of $$$dp_{k+1}$$$ divided by the total number of ways to move from $$$(0,0)$$$ to $$$(n,m)$$$, which is $$$\binom{n+m}{n}$$$.
Implementation
#include <bits/stdc++.h>
using namespace std;
 
#define nl "\n"
#define nf endl
#define ll long long
#define pb push_back
#define _ << ' ' <<
 
#define INF (ll)1e18
#define mod 998244353
#define maxn 400010
 
ll fc[maxn], nv[maxn];
 
ll fxp(ll b, ll e) {
    ll r = 1, k = b;
    while (e != 0) {
        if (e % 2) r = (r * k) % mod;
        k = (k * k) % mod; e /= 2;
    }
    return r;
}
 
ll inv(ll x) {
    return fxp(x, mod - 2);
}
 
ll bnm(ll a, ll b) {
    if (a < b || b < 0) return 0;
    ll r = (fc[a] * nv[b]) % mod;
    r = (r * nv[a - b]) % mod;
    return r;
}
 
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
 
    fc[0] = 1; nv[0] = 1;
    for (ll i = 1; i < maxn; i++) {
        fc[i] = (i * fc[i - 1]) % mod; nv[i] = inv(fc[i]);
    }
 
    ll t; cin >> t;
    while (t--) {
        ll n, m, k; cin >> n >> m >> k;
        vector<array<ll, 2>> a(k + 2, {0, 0});
        for (ll i = 1; i <= k; i++) {
            cin >> a[i][0] >> a[i][1];
            a[i][0] = n - a[i][0]; a[i][1] = m - a[i][1];
        }
        a[k + 1] = {n, m}; k++;
        sort(a.begin() + 1, a.end());
 
        auto paths = [&](ll i, ll j) {
            ll dx = a[j][0] - a[i][0], dy = a[j][1] - a[i][1];
            return bnm(dx + dy, dx);
        };
 
        auto add = [&](ll &x, ll y) {
            x = (x + y) % mod;
            x = (x + mod) % mod;
        };
 
        vector direct(k + 1, vector<ll>(k + 1, 0));
        for (ll i = 1; i <= k; i++) {
            for (ll j = i - 1; j >= 0; j--) {
                direct[j][i] = paths(j, i);
                for (ll l = j + 1; l < i; l++) {
                    add(direct[j][i], -paths(j, l) * direct[l][i]);
                }
            }
        }
 
        vector<ll> dp(k + 1, 0);
        for (ll i = 1; i <= k; i++) {
            for (ll j = 0; j < i; j++) {
                if (direct[j][i] == 0) continue;
                ll partial = dp[j];
                ll delta = 2 * (a[i][0] - a[j][0]) + (a[i][1] - a[j][1]);
                add(partial, paths(0, j) * delta);
                add(dp[i], partial * direct[j][i]);
            }
            if (i != k) dp[i] = (2 * dp[i]) % mod;
        }
 
        ll ans = (dp[k] * inv(bnm(n + m, m))) % mod;
        cout << ans << nl;
    }
 
    return 0;
}
--------------------------------------------------
Problem ID: 2034E
Editorial Content:
2034E - Permutations Harmony
Solution
Step 1:
There are $$$n$$$ positions that must be equal, and their sum is $$$\frac{n \cdot (n+1) \cdot k}{2}$$$. Hence, each position must be $$$\frac{(n+1) \cdot k}{2}$$$. Additionally, there must be $$$k$$$ distinct permutations, so $$$k \leq n!$$$.
Step 2:
For even $$$k$$$, we can group $$$n!$$$ permutations into $$$\frac{n!}{2}$$$ double handles, where each group corresponds to a solution for $$$k = 2$$$. Then, pick $$$\frac{k}{2}$$$ handles. The match for permutation $$$a_1, a_2, \ldots, a_n$$$ is $$$(n+1)-a_1, (n+1)-a_2, \ldots, (n+1)-a_n$$$.
Step 3:
For $$$k = 1$$$, $$$n$$$ must be $$$1$$$. Symmetrically, $$$k$$$ cannot be $$$n! - 1$$$. Solutions for other odd $$$k$$$ will now be provided.
Step 4:
To construct an answer for $$$k = 3$$$ and $$$n = 2x + 1$$$, consider the following derived using a greedy approach:
$$$p_1$$$
$$$p_2$$$
$$$p_3$$$
$$$p_4$$$
$$$p_5$$$
$$$ \ldots $$$
$$$p_{2x-1} $$$
$$$ p_{2x} $$$
$$$ p_{2x+1} $$$
1
2
3
4
5
$$$ \ldots $$$
$$$ 2x-1 $$$
$$$ 2x $$$
$$$ 2x+1 $$$
$$$ x+1 $$$
$$$ 2x+1 $$$
$$$ x $$$
$$$ 2x $$$
$$$ x-1 $$$
$$$ \ldots $$$
2
$$$ x+2 $$$
1
$$$ 2x+1 $$$
$$$ x $$$
$$$ 2x $$$
$$$ x-1 $$$
$$$ 2x-1 $$$
$$$ \ldots $$$
$$$ x+2 $$$
1
$$$ x+1 $$$
Step 5:
Now, combine the solution for even $$$k$$$ and the $$$k = 3$$$ solution by selecting the 3 permutations and $$$\frac{k-3}{2}$$$ other handles.
Implementation
// In the name of God
#include <bits/stdc++.h>
using namespace std;
 
int main() {
    ios_base::sync_with_stdio(false), cin.tie(0);
    int t;
    cin >> t;
    int f[8] = {1,1,2,6,24,120,720,5040};
    while(t--) {
        int n, k;
        cin >> n >> k;
        if(min(n, k) == 1) {
            if(n*k == 1) {
                cout << "Yes\n1\n";
            } else cout << "No\n";
        } else if(n < 8 and (f[n] < k or f[n] == k+1)) {
            cout << "No\n";
        } else if(n % 2 == 0 and k % 2 == 1) {
            cout << "No\n";
        } else {
            vector<vector<int>> base, all;
            vector<int> per(n);
            for(int i = 0; i < n; i++) per[i] = i+1;
            if(k % 2) {
                vector<int> p1(n), p2(n);
                for(int i = 0; i < n; i += 2) p1[i] = (n+1)/2-i/2, p2[i] = n-i/2;
                for(int i = 1; i < n; i += 2) p1[i] = n-i/2, p2[i] = n/2-i/2;
                all = base = {per, p1, p2};
                k -= 3;
            }
            do {
                if(k == 0)
                    break;
                vector<int> mirror(n);
                for(int i = 0; i < n; i++)
                    mirror[i] = n+1-per[i];
                if(per < mirror) {
                    bool used = false;
                    for(auto &p: base) used |= (p == per), used |= (p == mirror);
                    if(not used) {
                        k -= 2;
                        all.push_back(per);
                        all.push_back(mirror);
                    }
                }
            } while (next_permutation(per.begin(), per.end()));
            cout << "Yes\n";
            for(auto p: all) {
                for(int i = 0; i < n; i++)
                    cout << p[i] << (i+1==n?'\n':' ');
            }
        }
    }
 
    return 0;
}
 
// Thanks God
--------------------------------------------------
Problem ID: 2034D
Editorial Content:
2034D - Darius' Wisdom
Solution
Step 1:
Using two moves, we can move an element to any arbitrary position in the array. Thus, we can place all $$$0$$$'s in their correct positions with at most $$$2 \min(count(0), count(1) + count(2))$$$ moves.
Step 2:
After placing all $$$0$$$'s, the rest of the array will contain only $$$1$$$'s and $$$2$$$'s. To sort this part of the array, we need at most $$$min(count(1), count(2))$$$ moves.
Step 3:
The first step takes at most $$$n$$$ moves, and the second step takes at most $$$\frac{n}{2}$$$ moves. However, it can be proven that the total number of moves is at most $$$\frac{8n}{7}$$$.
Step 4:
We can assume $$$count(0) \leq count(2)$$$ without loss of generality (Why?). So, the maximum number of moves are:
$$$2 \min(count(0), count(1)+count(2))+\min(count(1), count(2))$$$
$$$= 2 \cdot count(0) + \min(count(1), count(2))$$$
$$$\le count(0) + \max(count(1), count(2)) + \min(count(1), count(2))$$$
$$$=count(0)+count(1)+count(2)=n$$$
Better approach:
Step 1:
Since we are allowed to perform $$$n$$$ moves, assign each index one
"move"
as its
"specified cost"
.
Step 2:
While there exists an index with a value of $$$0$$$ or $$$2$$$ that can be fixed with just one move, fix it using its assigned cost.
Step 3:
After fixing all $$$0$$$'s, $$$2$$$'s, and all $$$1$$$'s except one, the remaining array will have the following structure and we are now allowed to use $$$2x+1$$$ moves:
$$$2\ 2\ \dots\ 2\ (x\ \text{times})\ 1\ 0\ 0\ \dots\ 0\ (x\ \text{times}),$$$
Step 4:
First, swap the $$$1$$$ with a random element (denote it as $$$r$$$). Then, for $$$2x-1$$$ moves, swap the index with the value $$$1$$$ with any index where the correct value must be placed, except $$$r$$$. Finally, swap $$$1$$$ and $$$r$$$.
Implementation (first approach)
#include <bits/stdc++.h>

using namespace std;

const int N = 200000;
int n, cnt[3], a[N];
vector<int> vip[3][3]; // Value In Position
vector<pair<int, int>> swaps;

inline int Pos(int index) {
    if(index < cnt[0])
        return 0;
    else if(index < cnt[0]+cnt[1])
        return 1;
    else
        return 2; 
}

inline void AddBack(int index) {
    vip[a[index]][Pos(index)].push_back(index);
}

inline void RemoveBack(int index) {
    vip[a[index]][Pos(index)].pop_back();
}

inline void Swap(int i, int j) {
    swaps.push_back({i, j});
    RemoveBack(i);
    RemoveBack(j);
    swap(a[i], a[j]);
    AddBack(i);
    AddBack(j);
}

inline void Fix(int x) {
    while(!vip[1][x].empty() or !vip[2-x][x].empty()) {
        if(vip[1][x].empty()) {
            if(!vip[1][2-x].empty())
                Swap(vip[2-x][x].back(), vip[1][2-x].back());
            else
                Swap(vip[2-x][x].back(), vip[1][1].back());
        }
        if(!vip[x][1].empty()) 
            Swap(vip[1][x].back(), vip[x][1].back());
        else
            Swap(vip[1][x].back(), vip[x][2-x].back());
    }  
}


int main() 
{
    ios_base::sync_with_stdio(false), cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        cin >> n;
        for(int i = 0; i < n; i++)
            cin >> a[i], cnt[a[i]]++;
        for(int i = 0; i < n; i++)
            AddBack(i);
        if(cnt[0] <= cnt[2]) {
            Fix(0);
            Fix(2);
        } else {
            Fix(2);
            Fix(0);
        }
        cout << swaps.size() << endl;
        for(auto [i, j]: swaps)
            cout << i+1 << ' ' << j+1 << endl;
        cnt[0] = cnt[1] = cnt[2] = 0;
        for(int i = 0; i < 3; i++)
            for(int j = 0; j < 3; j++)
                vip[i][j].clear();
        swaps.clear();
    }
    return 0;
}
Implementation (second approach)
// In the name of god
#include <bits/stdc++.h>

using namespace std;

const int N = 200000;
int n, cnt[3], a[N];
vector<int> vip[3][3]; // Value In Position
vector<pair<int, int>> swaps;

inline int Pos(int index) {
    if(index < cnt[0])
        return 0;
    else if(index < cnt[0]+cnt[1])
        return 1;
    else
        return 2; 
}

inline void AddBack(int index) {
    vip[a[index]][Pos(index)].push_back(index);
}

inline void RemoveBack(int index) {
    vip[a[index]][Pos(index)].pop_back();
}

inline void Swap(int i, int j) {
    swaps.push_back({i, j});
    RemoveBack(i);
    RemoveBack(j);
    swap(a[i], a[j]);
    AddBack(i);
    AddBack(j);
}

inline void Fix() {
    bool change;
    do {
        change = false;
        while ((!vip[1][0].empty()) && (!vip[0][1].empty()))
            Swap(vip[1][0].back(), vip[0][1].back()), change = true;
        while ((!vip[1][0].empty()) && (!vip[0][2].empty()))
            Swap(vip[1][0].back(), vip[0][2-0].back()), change = true;
        while ((!vip[1][2].empty()) && (!vip[2][1].empty()))
            Swap(vip[1][2].back(), vip[2][1].back()), change = true;
        while ((!vip[1][2].empty()) && (!vip[2][0].empty()))
            Swap(vip[1][2].back(), vip[2][0].back()), change = true;
    } while (change);    
}

inline void PingPong() {
    if(vip[0][2].empty())
        return;
    Swap(vip[1][1].back(), vip[0][2].back());
    while (true){
        Swap(vip[1][2].back(), vip[2][0].back());
        if(vip[0][2].empty())
            break;
        Swap(vip[1][0].back(), vip[0][2].back());
    }
    Swap(vip[1][0].back(), vip[0][1].back());
}

int main() 
{
    ios_base::sync_with_stdio(false), cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        cin >> n;
        for(int i = 0; i < n; i++)
            cin >> a[i], cnt[a[i]]++;
        for(int i = 0; i < n; i++)
            AddBack(i);
        Fix();
        PingPong();
        cout << swaps.size() << endl;
        for(auto [i, j]: swaps)
            cout << i+1 << ' ' << j+1 << endl;
        // reset
        cnt[0] = cnt[1] = cnt[2] = 0;
        for(int i = 0; i < 3; i++)
            for(int j = 0; j < 3; j++)
                vip[i][j].clear();
        swaps.clear();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2034C
Editorial Content:
2034C - Trapped in the Witch's Labyrinth
Solution
If a cell has a fixed direction (i.e., it points to another cell), and following that direction leads outside the maze, it must eventually exit the maze. Such cells cannot be part of any loop.
We can analyze the remaining cells once we identify cells that lead out of the maze. Any undirected cell or $$$?$$$ cell might either lead to the exit or form part of a loop.
If all neighboring cells of a $$$?$$$ cell can eventually lead out of the maze, then this $$$?$$$ cell will also lead out of the maze. The state of such $$$?$$$ cells can be determined based on their surroundings.
For any remaining cells (directed cells that do not lead out of the maze, or other $$$?$$$ cells that cannot be determined to lead to an exit), we can assign directions such that starting from those cells will eventually lead to a loop. These cells will form the loops.
To find how many cells will eventually lead to a loop, we can use a Depth-First Search (DFS) on the reversed graph, where all directions are reversed. By performing DFS starting from the
"out-of-maze"
cells, we can identify all cells that are reachable from the outside and thus will eventually lead out of the maze.
Count the number of cells that can reach the exit. Subtract this number from the total number of cells in the maze to determine how many are part of loops (i.e., cells that cannot reach the exit).
Implementation
#include <bits/stdc++.h>
 
using namespace std;
 
int main() 
{
    int tc;
    cin >> tc;
    while(tc--){
        int n, m;
        cin >> n >> m;
        string c[n+1];
        for(int i = 1 ; i <= n ; i++) cin >> c[i] , c[i] = "-" + c[i];
        vector<pair<int,int>> jda[n+2][m+2];
        for(int i = 1 ; i <= n ; i++){
            for(int j = 1 ; j <= m ; j++){
                if(c[i][j] == 'U') jda[i-1][j].push_back({i , j});
                if(c[i][j] == 'R') jda[i][j+1].push_back({i , j});
                if(c[i][j] == 'D') jda[i+1][j].push_back({i , j});
                if(c[i][j] == 'L') jda[i][j-1].push_back({i , j});
            }
        }
        int vis[n+2][m+2] = {};
        queue<pair<int,int>> q;
        for(int j = 0 ; j <= m+1 ; j++) vis[0][j] = 1 , q.push({0 , j});
        for(int i = 1 ; i <= n+1 ; i++) vis[i][0] = 1 , q.push({i , 0});
        for(int j = 1 ; j <= m+1 ; j++) vis[n+1][j] = 1 , q.push({n+1 , j});
        for(int i = 1 ; i <= n ; i++) vis[i][m+1] = 1 , q.push({i , m+1});
        while(q.size()){
            auto [i , j] = q.front();
            q.pop();
            for(auto [a , b] : jda[i][j]){
                if(vis[a][b] == 0){
                    vis[a][b] = 1;
                    q.push({a , b});
                }
            }
        }
        for(int i = 1 ; i <= n ; i++){
            for(int j = 1 ; j <= m ; j++){
                if(c[i][j] == '?' and
                vis[i-1][j] and vis[i][j+1] and vis[i+1][j] and vis[i][j-1]) vis[i][j] = 1;
            }
        }
        int ans = n * m;
        for(int i = 1 ; i <= n ; i++){
            for(int j = 1 ; j <= m ; j++){
                if(vis[i][j] == 1) ans -= 1;
            }
        }
        cout << ans << endl;
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2034B
Editorial Content:
2034B - Rakhsh's Revival
Solution
We will solve the problem using the following approach:
Start from the leftmost spot and move rightwards.
Whenever a consecutive segment of $$$m$$$ weak spots (i.e., $$$0$$$'s) is found, apply Timar to a segment of length $$$k$$$, starting from the last index of the weak segment.
Repeat this process until no segment of $$$m$$$ consecutive weak spots remains.
The key idea behind this solution is that whenever we encounter a block of $$$m$$$ consecutive $$$0$$$'s, we need to strengthen it. Since we can apply Timar to a segment of length $$$k$$$, the optimal strategy is always to apply Timar starting at the last index of the block of $$$m$$$ consecutive $$$0$$$'s.
Correctness Proof:
For any block of $$$m$$$ consecutive $$$0$$$'s, we must apply Timar to at least one index within this block. Hence, the strengthened segment of length $$$k$$$ must overlap with the block of weak spots.
Suppose an optimal solution exists where Timar is applied to a segment starting leftward within the block. Suppose we shift this segment one step to the right (closer to the end of the block). In that case, the solution remains valid and optimal since it covers all weak spots in the block while reducing unnecessary overlap with already-strengthened areas.
By always starting from the last index of a block of $$$m$$$ consecutive $$$0$$$'s, this greedy strategy ensures that Timar is used in the minimum number of applications, making it correct and efficient.
Implementation
# include <bits/stdc++.h>

using namespace std;

const int xn = 2e5 + 10;

int q, n, m, k, ps[xn];
string s;

int main() {
    cin >> q;
    while (q --) {
        cin >> n >> m >> k >> s;
        fill(ps, ps + n, 0);
        int ans = 0, cnt = 0, sum = 0;
        for (int i = 0; i < n; ++ i) {
            sum += ps[i];
            if (sum || s[i] == '1') cnt = 0;
            else {
                cnt++;
                if (cnt == m) {
                    sum++, ans++, cnt = 0;
                    if (i + k < n) ps[i + k]--;
                }
            }
        }
        cout << ans << "\n";
    }
}
--------------------------------------------------
Problem ID: 2034A
Editorial Content:
2034A - King Keykhosrow's Mystery
Solution
Step 1:
Prove that for the minimum value of $$$m$$$, we must have $$$m \% a = m \% b = 0$$$.
Step 2:
To prove this, show that if $$$m \% a = m \% b = x > 0$$$, then $$$m-1$$$ will also satisfy the problem's requirements.
Step 3:
Since $$$m \ge \min(a , b)$$$, if $$$x > 0$$$, then $$$m > \min(a , b)$$$ must hold. Therefore, $$$m - 1 \ge \min(a , b)$$$ implies that $$$m-1$$$ satisfies the requirements.
Step 4:
Thus, $$$m$$$ must be divisible by both $$$a$$$ and $$$b$$$. The smallest such $$$m$$$ is $$$lcm(a, b)$$$ which can be calculated in $$$O(\log(\max(a, b)))$$$.
Implementation
#include <bits/stdc++.h>

using namespace std;

int main(){
  int tt;
  cin >> tt;
  while(tt--){
    int a, b;
    cin >> a >> b;
    cout << lcm(a , b) << endl;
  }
}
--------------------------------------------------
Problem ID: 2033G
Editorial Content:
2033G - Sakurako and Chefir
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
//#define int long long
#define pb emplace_back
#define mp make_pair
#define x first
#define y second
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
 
typedef long double ld;
typedef long long ll;
 
using namespace std;
 
mt19937 rnd(time(nullptr));
 
const int inf = 1e9;
const int M = 1e9 + 7;
const ld pi = atan2(0, -1);
const ld eps = 1e-6;
 
void precalc(int v, int p, vector<vector<int>> &sl, vector<pair<int, int>> &maxd, vector<int> &h){
    maxd[v] = {0, 0};
    if (v != p) h[v] = h[p] + 1;
    for(int u: sl[v]){
        if (u == p) continue;
        precalc(u, v, sl, maxd, h);
        if (maxd[v].y < maxd[u].x + 1) {
            maxd[v].y = maxd[u].x + 1;
        }
        if (maxd[v].y > maxd[v].x) {
            swap(maxd[v].x, maxd[v].y);
        }
    }
}
 
void calc_binups(int v, int p, vector<vector<int>> &sl, vector<vector<pair<int, int>>> &binup, vector<pair<int, int>> &maxd, vector<int> &h){
    binup[v][0] = {maxd[p].x, p};
    if (maxd[p].x == maxd[v].x + 1) {
        binup[v][0].x = maxd[p].y;
    }
    binup[v][0].x -= h[p];
    for(int i = 1; i < 20; ++i){
        binup[v][i].y = binup[binup[v][i - 1].y][i - 1].y;
        binup[v][i].x = max(binup[v][i - 1].x, binup[binup[v][i - 1].y][i - 1].x);
    }
 
    for(int u: sl[v]){
        if (u == p) continue;
        calc_binups(u, v, sl, binup, maxd, h);
    }
}
 
int get_ans(int v, int k, vector<vector<pair<int, int>>> &binup, vector<pair<int, int>> &maxd, vector<int> &h){
    k = min(k, h[v]);
    int res = maxd[v].x - h[v];
    int ini = h[v];
    for(int i = 19; i >= 0; --i){
        if ((1 << i) <= k) {
            res = max(res, binup[v][i].x);
            v = binup[v][i].y;
            k -= (1 << i);
        }
    }
    return res + ini;
}
 
void solve(int tc){
    int n;
    cin >> n;
    vector<vector<int>> sl(n);
    for(int i = 1; i < n; ++i){
        int u, v;
        cin >> u >> v;
        sl[--u].emplace_back(--v);
        sl[v].emplace_back(u);
    }
    vector<pair<int, int>> maxd(n);
    vector<int> h(n);
    precalc(0, 0, sl, maxd, h);
    vector<vector<pair<int, int>>> binup(n, vector<pair<int, int>>(20));
    calc_binups(0, 0, sl, binup, maxd, h);
    int q;
    cin >> q;
    for(int _ = 0; _ < q; ++_){
        int v, k;
        cin >> v >> k;
        cout << get_ans(v - 1, k, binup, maxd, h) << " ";
    }
}
 
bool multi = true;
 
signed main() {
    int t = 1;
    if (multi)cin >> t;
    for (int i = 1; i <= t; ++i) {
        solve(i);
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2033F
Editorial Content:
2033F - Kosuke's Sloth
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
using LL = long long;
#define ssize(x) (int)(x.size())
#define ALL(x) (x).begin(), (x).end()
 
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
 
int rd(int l, int r) {
    return uniform_int_distribution<int>(l, r)(rng);
}
const LL MOD = 1e9 + 7;
int bp(int a, int n) {
    if (n == 0)
        return 1;
    if (n % 2 == 0)
        return bp(1LL * a * a % MOD, n / 2);
    else
        return 1LL * bp(a, n - 1) * a % MOD;
}
int inv(int a) {
    return bp(a, MOD - 2);
}
void solve() {
    LL n, k;
    cin >> n >> k;
    n %= MOD;
    if (k == 1) {
        cout << n << "\n";
        return;
    }
    vector<int> fib(3);
    fib[0] = fib[1] = 1;
    int cnt = 0;
    for (int i = 2; i <= 10 * k; i++) {
        fib[i % 3] = (fib[(i + 2) % 3] + fib[(i + 1) % 3]) % k;
        if (fib[i % 3] == 0)
            cnt++;
        if (fib[i % 3] == 1 && fib[(i + 2) % 3] == 0) {
            cout << 1LL * i * n % MOD * inv(cnt) % MOD << "\n";
            return;
        }
    }
}
int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
     cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 2033E
Editorial Content:
2033E - Sakurako, Kosuke, and the Permutation
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    ios_base::sync_with_stdio(false);cout.tie(nullptr);cin.tie(nullptr);
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int p[n+1];
        for(int i=1;i<=n;i++){
            cin>>p[i];
        }
        bool us[n+1];
        memset(us,0,sizeof us);
        int re=0;
        for(int i=1;i<=n;i++){
            if(!us[i]){
                int cu=i;
                int le=0;
                while(us[cu]==0){
                    le++;
                    us[cu]=1;
                    cu=p[cu];
                }
                re+=(le-1)/2;
            }
        }
        cout<<re<<'\n';
    }
}
--------------------------------------------------
Problem ID: 2033D
Editorial Content:
2033D - Kousuke's Assignment
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int a[n+1];
        map<int,int>mp;
        for(int i=1;i<=n;i++){
            cin>>a[i];
        }
        int p_su[n+1];
        p_su[0]=0;
        int lst[n+1];
        mp[0]=0;
        for(int i=1;i<=n;i++){
            p_su[i]=p_su[i-1]+a[i];
            if(mp.find(p_su[i])==mp.end()){
                lst[i]=-1;
            }
            else{
                lst[i]=mp[p_su[i]];
            }
            mp[p_su[i]]=i;
        }
        int dp[n+1];
        memset(dp,0,sizeof dp);
        for(int i=1;i<=n;i++){
            dp[i]=max(dp[i],dp[i-1]);
            if(lst[i]!=-1){
                dp[i]=max(dp[i],dp[lst[i]]+1);
            }
        }
        cout<<*max_element(dp,dp+n+1)<<endl;
    }
}
--------------------------------------------------
Problem ID: 2033C
Editorial Content:
2033C - Sakurako's Field Trip
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int a[n+1];
        for(int i=1;i<=n;i++){
            cin>>a[i];
        }
        for(int i=n/2-1;i>=1;i--){
            if(a[i]==a[i+1] || a[n-i+1]==a[n-i]){
                swap(a[i],a[n-i+1]);
            }
        }
        int re=0;
        for(int i=1;i<n;i++){
            re+=(a[i]==a[i+1]);
        }
        cout<<re<<endl;
    }
}
--------------------------------------------------
Problem ID: 2033B
Editorial Content:
2033B - Sakurako and Water
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    mn = dict()
    for i in range(n):
        a = [int(x) for x in input().split()]
        for j in range(n):
            mn[i - j] = min(a[j], mn.get(i - j, 0))
    ans = 0
    for value in mn.values():
        ans -= value
    print(ans)
 
t = int(input())
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 2033A
Editorial Content:
2033A - Sakurako and Kosuke
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    x = 0
    c = 1
    while -n <= x <= n:
        if c % 2 == 1:
            x -= 2 * c - 1
        else:
            x += 2 * c - 1
        c += 1
    if c % 2 == 0:
        print("Sakurako")
    else:
        print("Kosuke")


for tc in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 2032F
Editorial Content:
2032F - Peanuts
Hint #1
Try to solve if all pockets are in the same box. Does the problem seem familiar?
Hint #2
There's one kind of cases for a box that its game has a fixed move sequence, and thus a fixed outcome. What is it?
Hint #3
Let's take the cases found in hint #2 out of the equation from here on. Is there any way for a player to win in two consecutive boxes?
Hint #4
If a player can win a box if both play optimally to win, can they also lose it if both play optimally to lose?
Tutorial
Tutorial is loading...
Solution (C++)
Submission link:
289293663
Plaintext
namespace solution {
    bool hasMultipleTests = true;

    int n;
    vector<int> a;
    
    const int MAXN = 1000000;
    const int MOD  = 998244353;
    int pow2[MAXN];

    void preprocess() {
        pow2[0] = 1;
        for (int i = 1; i < MAXN; i++) {
            pow2[i] = (2LL * pow2[i-1]) % MOD;
        }
    }

    void input(int testcase) {
        cin >> n;
        a.clear();
        a.resize(n);
        for (auto &z: a) cin >> z;
    }

    void solve(int testcase) {
        if (*ranges::max_element(a) == 1) {
            cout << (n & 1 ? pow2[n-1] : 0) << endl;
            return;
        }
        
        int ans = 0;
        
        // The critical layer (assuming prefix Grundy > 1) can only fall into Alice's control
        // if and only if before it is an even amount of pockets
        int alice_at_critical = 1;
        int prefix_1 = 0;
        while (a[prefix_1] == 1) {
            prefix_1++;
            if (prefix_1 % 2 == 0) {
                alice_at_critical = (alice_at_critical + pow2[prefix_1 - 1]) % MOD;
            }
        }
        
        int grundy = (prefix_1 & 1);
        for (int r = prefix_1; r < n; r++) {
            grundy ^= a[r];
            
            if (!grundy) continue;
            
            int post_critical = (r < n - 1 ? pow2[n - 2 - r] : 1);
            int pre_critical = (grundy == 1 ? pow2[prefix_1] : alice_at_critical);
            
            ans += (1LL * pre_critical * post_critical) % MOD;
            ans %= MOD;
        }
        
        cout << ans << endl;
    }
}
--------------------------------------------------
Problem ID: 2032E
Editorial Content:
2032E - Balanced
Hint #1
Why is $$$n$$$ odd? Does it imply anything of the availability of a solution?
Hint #2
$$$n = 1$$$ is trivial. Try to solve this problem if $$$n = 3$$$ and $$$a_1 = a_3$$$.
Hint #3
Try to solve this problem for any array with $$$n = 3$$$. Is there any way to solve this without going pass a state of $$$a_1 = a_3$$$ (or $$$a_1 = a_2$$$ or $$$a_2 = a_3$$$)?
Hint #4
Assume that $$$n = 5$$$, $$$a_1 = a_5$$$ and $$$a_2 = a_3 = a_4$$$. Now refer to hint #2, can you see any similarity in the solution?
Hint #5
Refer to hint #4. What would happen if we apply an operation to index $$$2$$$ and another to index $$$4$$$?
Hint #6
For any array with $$$n = 5$$$, how would you convert it into the form stated in hint #4?
Hint #7
Refer to hint #6. How would you make $$$a_1 = a_5$$$ and $$$a_2 = a_4$$$? Does the fact that $$$n$$$ is odd help in any way?
Hint #8
Can you draw a generalized conclusion?
Tutorial
Tutorial is loading...
Solution (C++)
Submission link:
289293300
Plaintext
namespace solution {
    bool hasMultipleTests = true;

    int n;
    vector<int> a;
    
    void apply_prefixes(vector<long long> &prefixes, vector<long long> &v) {
        for (int i = 2; i < n * 2; i++) {
            prefixes[i] += prefixes[i - 2];
        }
        
        for (int i = 0; i < n * 2; i++) {
            v[i % n] += prefixes[i];
        }
    }
    
    void construct_trench(vector<long long> &arr, vector<long long> &v) {
        vector<long long> prefixes(n * 2, 0LL);
        vector<long long> delta(n, 0LL);
        
        for (int i = 0; i < n / 2; i++) {
            long long diff = arr[n - 1 - i] - (arr[i] + delta[i]);
            
            delta[i] += 2 * diff;
            delta[i + 1] += diff;
            
            prefixes[n - i] += diff;
            prefixes[n + i + 2] -= diff;
        }
        
        apply_prefixes(prefixes, v);
        
        for (int i = 0; i < n; i++) {
            arr[i] += v[i] * 2;
            arr[(i + 1) % n] += v[i];
            arr[(i + n - 1) % n] += v[i];
        }
    }
    
    void construct_plateau(vector<long long> &arr, vector<long long> &v) {
        vector<long long> prefixes(n * 2, 0LL);
        vector<long long> delta(n, 0LL);
        
        for (int i = n / 2 - 1; i >= 0; i--) {
            long long diff = arr[i] - (arr[i + 1] + delta[i + 1]);
            
            delta[i] += diff;
            
            prefixes[i + 1] += diff;
            prefixes[n - i] -= diff;
        }
        
        apply_prefixes(prefixes, v);
    }

    void preprocess() {
        
    }

    void input(int testcase) {
        cin >> n;
        a.clear();
        a.resize(n);
        for (auto &z: a) cin >> z;
    }

    void solve(int testcase) {
        if (n == 1) {
            cout << "0\n";
            return;
        }
        
        vector<long long> v(n, 0LL);
        vector<long long> arr(n);
        for (int i = 0; i < n; i++) {
            arr[i] = 1LL * a[i];
        }
        
        construct_trench(arr, v);
        construct_plateau(arr, v);
        
        long long offset = *ranges::min_element(v);
        
        for (auto &z: v) cout << z - offset << " ";
        cout << endl;
    }
}
--------------------------------------------------
Problem ID: 2032D
Editorial Content:
2032D - Genokraken
Hint #1
There are many specific constraints on the system tree.
First, notice that $$$1 \le x \le y \le n-1$$$ if and only if $$$p_x \le p_y$$$. Draw a few trees with this constraint and start pointing your finger on the nodes from $$$0$$$ to $$$n-1$$$. Notice the pattern your finger is making.
Hint #2
Incorporate hint #1 with the fact that the "tentacles" of the Genokraken are just paths. Try to draw more detailed conclusion about that pattern.
Hint #3A
Is there a way to know how many tentacles there are?
Hint #3B
What use could we make of the fact that node $$$1$$$ has
exactly two
adjacent nodes?
Hint #4
The query limit is very small. Is there a way to query that the information obtained in each query should (at least partially) determine a node?
Hint #5
For each "tentacle", can we know when its path has ended? How many queries should it take?
Tutorial
Tutorial is loading...
Solution (C++)
Submission link:
289292866
Plaintext
namespace datastruct {
    // A doubly-linked list that only supports modify and (pseudo) deletion at pointer
    class DeleteOnly_DLL {
    public:
        vector<int> values;
        vector<int> prev;
        vector<int> next;
        int pointer;
        
        DeleteOnly_DLL(int size) {
            values.resize(size);
            prev.resize(size);
            next.resize(size);
            
            for (int i = 0; i < size; i++) {
                prev[i] = (i + size - 1) % size;
                next[i] = (i +        1) % size;
            }
            
            pointer = 0;
        }
        
        int current() {
            return values[pointer];
        }
        
        // Set value at pointer and move pointer to next
        void set_and_move(int val) {
            values[pointer] = val;
            pointer = next[pointer];
        }
        
        // "Delete" node and move pointer to next
        void erase() {
            if (prev[pointer] != -1) {
                next[prev[pointer]] = next[pointer];
            }
            if (next[pointer] != -1) {
                prev[next[pointer]] = prev[pointer];
            }
            
            int next_id = next[pointer];
            prev[pointer] = next[pointer] = -1;
            pointer = next_id;
        }
    };
}

namespace solution {
    bool hasMultipleTests = true;

    int n;
    
    int ask(int a, int b) {
        cout << "? " << a << " " << b << endl;
        cout.flush();
        
        int res; cin >> res;
        return res;
    }
    
    void answer(vector<int> &p) {
        cout << "!";
        for (int i=1; i<n; i++) {
            cout << " " << p[i];
        }
        cout << endl;
        cout.flush();
    }

    void preprocess() {

    }

    void input(int testcase) {
        cin >> n;
    }

    void solve(int testcase) {
        vector<int> p(n, -1);
        p[1] = 0;
        
        int r = 2;
        while (true) {
            int response = ask(1, r);
            if (response == -1) exit(2226);
            
            if (response == 1) {
                p[r] = 0;
                r++;
            }
            else break;
        }
        
        int tentacle_count = r - 1;
        
        datastruct::DeleteOnly_DLL tentacles = datastruct::DeleteOnly_DLL(tentacle_count);
        for (int i = 0; i < tentacle_count; i++) {
            tentacles.set_and_move(i + 1);
        }

        p[r] = tentacles.current();
        tentacles.set_and_move(r);
        r++;
        
        while (r < n) {
            int response = ask(tentacles.current(), r);
            if (response == -1) exit(2226);
            
            if (response == 1) {
                tentacles.erase();
            }
            else {
                p[r] = tentacles.current();
                tentacles.set_and_move(r);
                r++;
            }
        }
        
        answer(p);
    }
}
--------------------------------------------------
Problem ID: 2032C
Editorial Content:
2032C - Trinity
Hint #1
Without loss of generality, you can rewrite the triangle inequality into a much more compacted form if the side lengths are properly ordered.
Hint #2A
Given four integers $$$a \le b \le c \le d$$$, if $$$(a, b, d)$$$ are side lengths of a non-degenerate triangle, so does $$$(a, b, c)$$$.
Hint #2B
Given four integers $$$a \le b \le c \le d$$$, if $$$(a, b, d)$$$ are side lengths of a non-degenerate triangle, so does $$$(a, c, d)$$$.
Hint #2C
Given four integers $$$a \le b \le c \le d$$$, if $$$(a, b, d)$$$ are side lengths of a non-degenerate triangle, so does $$$(b, c, d)$$$.
Hint #3
To make a sorted array $$$[b_1, b_2, \ldots, b_m] \space (m \ge 3)$$$ satisfy the problem, we must ensure that $$$b_1 + b_2 > b_m$$$.
Hint #4
Fix the result array to have two minimas and one maxima at respectively $$$a_x$$$, $$$a_y$$$ and $$$a_z$$$. How many operations are required to do so?
Hint #5
Is there a fast and optimal way to try all possible $$$(a_x, a_y, a_z)$$$ triplets?
Tutorial
Tutorial is loading...
Solution (C++)
Submission link:
289292343
Plaintext
namespace solution {
    bool hasMultipleTests = true;

    int n;
    vector<int> a;

    void preprocess() {

    }

    void input(int testcase) {
        cin >> n;
        a.clear();
        a.resize(n);
        for (auto &z: a) cin >> z;
    }

    void solve(int testcase) {
        sort(a.begin(), a.end());

        int l = 0, ans = n - 2;
        for (int r = 2; r < n; r++) {
            while (r - l >= 2 && a[l] + a[l+1] <= a[r]) l++;
            ans = min(ans, n - (r - l + 1));
        }

        cout << ans << endl;
    }
}
--------------------------------------------------
Problem ID: 2032B
Editorial Content:
2032B - Medians
Hint #1
There is always exactly one solution for $$$n = 1$$$. For $$$n \ge 3$$$, for which $$$k$$$ should there be no solution at all?
Hint #2A
Try to find a solution with $$$k = 2$$$ and $$$k = 4$$$, assuming $$$n$$$ allows at least one solution to exist. Can you find a pattern and generalize it for all even $$$k$$$?
Hint #2B
Try to find a solution with $$$k = 3$$$ and $$$k = 5$$$, assuming $$$n$$$ allows at least one solution to exist. Can you find a pattern and generalize it for all odd $$$k$$$?
Tutorial
Tutorial is loading...
Solution (C++)
Submission link:
289291698
Plaintext
namespace solution {
    bool hasMultipleTests = true;

    int n, k;

    void preprocess() {

    }

    void input(int testcase) {
        cin >> n >> k;
    }

    void solve(int testcase) {
        if (n == 1) {cout << "1\n1\n"; return;}

        if (k == 1 || k == n) {cout << "-1\n"; return;}

        int p2 = k - k % 2;
        int p3 = k + 1 + k % 2;
        cout << "3\n1 " << p2 << " " << p3 << endl;
    }
}
--------------------------------------------------
Problem ID: 2032A
Editorial Content:
2032A - Circuit
Hint #1
In which cases would a light be on?
Hint #2A
Imagine that you have $$$x$$$ white socks and $$$y$$$ black socks. What would you do to make the maximum pairs of matched socks?
Hint #2B
Imagine that you have $$$x$$$ white socks and $$$y$$$ black socks. What would you do to make the maximum pairs of unmatched socks?
Tutorial
Tutorial is loading...
Solution (C++)
Submission link:
289291089
Plaintext
namespace solution {
    bool hasMultipleTests = true;

    int n;
    vector<int> a;

    void preprocess() {

    }

    void input(int testcase) {
        cin >> n;
        a.clear();
        a.resize(n * 2);
        for (auto &z: a) cin >> z;
    }

    void solve(int testcase) {
        int cnt0 = 0;

        for (auto &z: a) {
            cnt0 += z;
        }

        cout << (cnt0 & 1) << " " << min(cnt0, n * 2 - cnt0) << endl;
    }
}
--------------------------------------------------
Problem ID: 2031F
Editorial Content:
2031F - Penchick and Even Medians
Hint 1
Querying $$$n - 2$$$ elements is very powerful.
Hint 2
Try to find two indices $$$x$$$ and $$$y$$$ such that one of $$$p_x, p_y$$$ is strictly smaller than $$$\frac{n}{2}$$$ and the other is strictly greater than $$$\frac{n}{2} + 1$$$. What can you do after finding these two elements?
Solution 1
This solution is non-deterministic and uses $$$\frac{n}{2} + O(1)$$$ queries
Part 1
Suppose we select all elements except for two indices $$$1 \le i, j \le n$$$ to be used in the query. Let the result we receive be $$$(a, b)$$$ where $$$a \lt b$$$. If $$$a = \frac{n}{2}$$$ and $$$b = \frac{n}{2} + 1$$$, it means that one of $$$p_i, p_j$$$ is strictly smaller than $$$\frac{n}{2}$$$ and the other is strictly larger than $$$\frac{n}{2}$$$.
If we do the above query randomly, there is around $$$50\%$$$ chance of getting the above outcome. So we can just randomly select two indices to exclude from the query until we get the above result.
Part 2
Now that we have two elements $$$x$$$ and $$$y$$$ such that one of $$$p_x, p_y$$$ is strictly smaller than $$$\frac{n}{2}$$$ and the other is strictly greater than $$$\frac{n}{2} + 1$$$, we can query $$$[x, y, i, j]$$$. The median of $$$[p_x, p_y, p_i, p_j]$$$ will include $$$\frac{n}{2}$$$ if and only if one of $$$p_i, p_j$$$ is equal to $$$\frac{n}{2}$$$. The same is true for $$$\frac{n}{2} + 1$$$. We can iterate through all $$$\frac{n}{2} - 1$$$ pairs to find the two pairs that contain the median, then iterate through all $$$4\choose 2$$$ combinations of median to find the answer.
Implementation: (by
ACGN
)
291677579
--------------------------------------------------
Problem ID: 2031E
Editorial Content:
2031E - Penchick and Chloe's Trees
Hint 1
Consider the tree where root $$$1$$$ has $$$k$$$ children which are all leaves. What is its minimum depth?
Hint 2
Consider undoing the operations from the given tree back to the perfect binary tree. Where can each child of the tree go?
Solution
As in Hint 2, suppose that there exists a finite sequence of operations that convert a perfect binary tree $$$T_d$$$ of depth $$$d$$$ to our target tree $$$T$$$. We consider where each child of vertex $$$1$$$ in $$$T$$$ is mapped to the binary tree; specifically, for each such child $$$c$$$, let $$$c'$$$ be the highest vertex in $$$T_d$$$ that maps to $$$c$$$ under the operations. Then we can see that the subtree rooted at $$$c'$$$ in $$$T_d$$$ maps to the subtree rooted at $$$c$$$ in $$$T$$$.
Suppose that the minimum depth required for the subtree rooted at $$$c$$$ in $$$T$$$ is $$$d_c$$$.
Claim 1: $$$2^d\ge \sum_{c}2^{d_c}$$$, where the sum is taken across all children $$$c$$$ of $$$1$$$.
Proof
Note that no two of the $$$v_c$$$ are ancestors or descendants of each other; otherwise, if $$$v_{c_1}$$$ is an ancestor of $$$v_{c_2}$$$, then $$$c_1$$$ would be an ancestor of $$$c_2$$$.
Consider the $$$2^d$$$ leaves of $$$T_d$$$. Of them, for each $$$c$$$, $$$2^{d_c}$$$ of them are descendants of $$$v_c$$$. As no leaf can be descendants of two $$$v_c$$$'s, the inequality follows.
Claim 2: If $$$1$$$ has only one child $$$c$$$, then $$$d=d_c+1$$$; otherwise, $$$d$$$ is the least integer that satisfies the inequality of Claim 1.
Proof
Suppose $$$1$$$ only has one child $$$c$$$. Then $$$d\le d_c$$$ clearly does not suffice, but $$$d=d_c+1$$$ does as we can merge the entire right subtree into the root $$$1$$$.
Suppose now that $$$1$$$ has multiple children $$$c_1,c_2,\ldots c_k$$$, sorted by descending $$$d_c$$$. For each child $$$c_i$$$ from $$$c_1$$$ to $$$c_k$$$, allocate $$$v_{c_i}$$$ to be the leftmost possible vertex at a height of $$$d_{c_i}$$$. Then the leaves that are ancestors of $$$c_i$$$ form a contiguous segment, so this construction ensures that each child $$$c_i$$$ can be placed on the tree.
Thus, we can apply tree dp with the transition function from $$$d_{c_i}$$$ to $$$d$$$ described by Claim 2. However, naively implementing it has a worst-case time complexity of $$$O(n^2).$$$
Example of worst-case time complexity
Consider a tree constructed this way: $$$2$$$ and $$$3$$$ are children of $$$1$$$, $$$4$$$ and $$$5$$$ are children of $$$3$$$, $$$6$$$ and $$$7$$$ are children of $$$5$$$, and so on; the odd-numbered vertices form a chain with the even-numbered vertices being leaves.
In such a graph, the depth $$$d$$$ is the length of the odd-numbered chain. Thus, during the computation of $$$d$$$, we would have to evaluate $$$2^x+1$$$ for $$$x$$$ from $$$1$$$ to $$$d\approx\frac{n}{2}.$$$ However, evaluating $$$2^x+1$$$ naively requires at least $$$O(x)$$$ time, so the algorithm runs in $$$O(n^2)$$$.
There are several ways to improve the time complexity of the dp transition.
For example, sort $$$d_{c_i}$$$ in increasing order, then maintain the sum as $$$a\times 2^b$$$, where initially $$$a=b=0$$$. For each $$$c_i$$$ in order, replace $$$a$$$ by $$$\lceil \frac{a}{2^{d_{c_i}-b}}\rceil$$$ and replace $$$b$$$ by $$$d_{c_i}$$$, which essentially serves to round up the sum to the nearest $$$2^{d_{c_i}}$$$. Then, increment $$$a$$$ to add $$$2^{d_{c_i}}$$$ to the sum. At the end of these operations, we have $$$d=\lceil \log_2 a\rceil+b$$$.
Implementation: (by
ACGN
)
291677229
Another way to do so is to "merge" terms from smallest to largest; importantly, since we just need to crudely bound $$$S=\sum_{c}2^{d_c}$$$, we can replace $$$2^x+2^y$$$ by $$$2^{max(x,y)+1}$$$. Then we can repeat this process until only one element remains.
Why does this work?
Suppose that $$$x>y$$$. Then the above operation rounds up $$$S$$$ to the nearest $$$2^x$$$. Since $$$2^d\ge S>2^x$$$, rounding up $$$S$$$ will not cause it to exceed the next power of $$$2$$$, so $$$2^d\ge S$$$ remains true after the operation.
Implementation: (by
Dominater069
)
291677365
Both transitions work in $$$O(k\log{k})$$$, leading to an overall time complexity of $$$O(n\log{n})$$$.
UPD: Thanks to
sleepyessheep
for an $$$O(n)$$$ solution, refer to
this thread.
Thanks!!
Proof
Note that no two of the $$$v_c$$$ are ancestors or descendants of each other; otherwise, if $$$v_{c_1}$$$ is an ancestor of $$$v_{c_2}$$$, then $$$c_1$$$ would be an ancestor of $$$c_2$$$.
Consider the $$$2^d$$$ leaves of $$$T_d$$$. Of them, for each $$$c$$$, $$$2^{d_c}$$$ of them are descendants of $$$v_c$$$. As no leaf can be descendants of two $$$v_c$$$'s, the inequality follows.
Proof
Suppose $$$1$$$ only has one child $$$c$$$. Then $$$d\le d_c$$$ clearly does not suffice, but $$$d=d_c+1$$$ does as we can merge the entire right subtree into the root $$$1$$$.
Suppose now that $$$1$$$ has multiple children $$$c_1,c_2,\ldots c_k$$$, sorted by descending $$$d_c$$$. For each child $$$c_i$$$ from $$$c_1$$$ to $$$c_k$$$, allocate $$$v_{c_i}$$$ to be the leftmost possible vertex at a height of $$$d_{c_i}$$$. Then the leaves that are ancestors of $$$c_i$$$ form a contiguous segment, so this construction ensures that each child $$$c_i$$$ can be placed on the tree.
Example of worst-case time complexity
Consider a tree constructed this way: $$$2$$$ and $$$3$$$ are children of $$$1$$$, $$$4$$$ and $$$5$$$ are children of $$$3$$$, $$$6$$$ and $$$7$$$ are children of $$$5$$$, and so on; the odd-numbered vertices form a chain with the even-numbered vertices being leaves.
In such a graph, the depth $$$d$$$ is the length of the odd-numbered chain. Thus, during the computation of $$$d$$$, we would have to evaluate $$$2^x+1$$$ for $$$x$$$ from $$$1$$$ to $$$d\approx\frac{n}{2}.$$$ However, evaluating $$$2^x+1$$$ naively requires at least $$$O(x)$$$ time, so the algorithm runs in $$$O(n^2)$$$.
--------------------------------------------------
Problem ID: 2031D
Editorial Content:
2031D - Penchick and Desert Rabbit
Hint 1
Suppose that you have found the maximum height reachable from tree $$$i+1$$$. How do you find the maximum height reachable from tree $$$i$$$?
Hint 2
Let $$$p$$$ be the
highest
height among trees indexed from $$$1$$$ to $$$i$$$, and $$$s$$$ be the
lowest
height among trees indexed from $$$i+1$$$ to $$$n$$$. When can tree $$$i$$$ be reachable from tree $$$i+1$$$?
Solution
First, observe that a rabbit at tree $$$n$$$ can reach the highest tree; if the tree has index $$$i<n$$$, then the rabbit can jump from tree $$$n$$$ to $$$i$$$. Let $$$ans_k$$$ denote the tallest height reachable from tree $$$k$$$, then $$$ans_n=\max(a_1,a_2,\ldots a_n)$$$.
We iteratively look at trees $$$n-1$$$ to $$$1$$$. Suppose we have found the tallest height $$$ans_{i+1}$$$ reachable from tree $$$i+1$$$. Note that from tree $$$i$$$ we can reach the tallest tree with index between $$$1$$$ and $$$i$$$, and from tree $$$i+1$$$ we can reach the shortest tree with index between $$$i+1$$$ and $$$n$$$. Let $$$a_x=p_i=\max(a_1,a_2,\ldots a_i)$$$ and $$$a_y=s_i=\min(a_{i+1},a_{i+1},\ldots a_n)$$$.
Then if $$$p_i>s_i$$$ then tree $$$i+1$$$ is reachable from tree $$$i$$$ by the sequence $$$i\leftrightarrow x\leftrightarrow y\leftrightarrow i+1$$$. Thus, any tree reachable from tree $$$i$$$ is reachable from tree $$$i+1$$$, and vice versa; thus, $$$ans_i=ans_{i+1}.$$$
On the other hand, if $$$p_i\le s_i$$$, then for any $$$r\le i$$$ and $$$s\ge i+1$$$, we have $$$r<s$$$ and $$$a_r\le p_i\le s_i\le a_s$$$. Thus,
no tree
between index $$$i+1$$$ and $$$n$$$ inclusive is reachable from any tree from $$$1$$$ and $$$i$$$ inclusive. Similar to the first paragraph, we have $$$ans_i=\max(a_1,a_2,\ldots a_i)=p_i$$$.
Time complexity: $$$O(n)$$$
Implementation: (by
ACGN
)
291677082
--------------------------------------------------
Problem ID: 2031C
Editorial Content:
2031C - Penchick and BBQ Buns
Hint 1
Solve the problem for $$$n=2$$$ and for even $$$n$$$ in general.
Hint 2
For odd $$$n$$$, there exists a color that appears at least thrice. What does this mean?
Solution
Note that $$$1$$$ is a square number; thus, for even $$$n$$$, the construction $$$1~1~2~2~3~3\ldots\frac{n}{2}~\frac{n}{2}$$$ works.
For odd $$$n$$$, note that there exists a color that appears at least thrice, say at positions $$$x\lt y \lt z$$$. Then $$$y-x$$$, $$$z-y$$$ and $$$z-x$$$ are all square numbers. Note that $$$z-x=(z-y)+(y-x)$$$, which has the smallest solution being $$$z-x=5^2=25$$$, and $$${z-y,y-x}={9,16}$$$. Therefore, there is no solution if $$$n\le 25$$$.
We devise a solution for $$$n=27$$$. By the above, we have the following posts filled in:
$$$1\text{ (8 blanks) }1\text{ (15 blanks) }1~\underline{ }$$$
We can use the same color for positions $$$11$$$ and $$$27$$$, to obtain the following:
$$$1\text{ (8 blanks) }1~2\text{ (14 blanks) }1~2$$$
The remaining even-length blanks can be filled in similar to above. The result is as follows and can be hard-coded:
$$$\mathtt{1~3~3~4~4~5~5~6~6~1~2~7~7~8~8~9~9~10~10~11~11~12~12~13~13~1~2}$$$
Then, for odd $$$n\ge 27$$$, add $$$\frac{n-27}{2}$$$ pairs with distance $$$1$$$ to complete the construction.
Note that there are different ways to construct this starting array for $$$n=27$$$ as well.
Time complexity: $$$O(n)$$$
Implementation: (by
ACGN
)
291676952
--------------------------------------------------
Problem ID: 2031B
Editorial Content:
2031B - Penchick and Satay Sticks
Hint 1
Consider which permutations you can get by reversing the operations and starting from the identity permutation
Hint 2
After $$$p_i$$$ and $$$p_{i+1}$$$ have been swapped, i.e. $$$p_i=i+1$$$ and $$$p_{i+1}=i$$$, neither of them can then be involved in another different swap.
Solution
Suppose we begin with the identity permutation. Consider what happens after swapping $$$p_i=i$$$ and $$$p_{i+1}=i+1$$$. After this swap, elements $$$p_1$$$ to $$$p_{i-1}$$$ will consist of $$$1$$$ to $$$i-1$$$, and $$$p_{i+2}$$$ to $$$p_n$$$ will consist of $$$i+2$$$ to $$$n$$$. Thus, it is impossible for $$$p_i=i+1$$$ to swap with $$$p_{i-1}\lt i$$$, or for $$$p_{i+1}=i$$$ to swap with $$$p_{i+2}\gt i+1$$$.
Therefore, the swaps made must be independent of each other; in other words, the indices $$$i$$$ chosen in the process must differ from each other than at least $$$2$$$. These permutations satisfy the following: for each index $$$i$$$,
$$$p_i=i$$$, or
$$$p_i=i+1$$$ and $$$p_{i+1}=i$$$, or
$$$p_i=i-1$$$ and $$$p_{i-1}=i$$$.
One way to check for this is to iterate for $$$i$$$ from $$$1$$$ to $$$n$$$. If $$$p_i=i$$$ then continue, and if $$$p_i=i+1$$$ then check if $$$p_{i+1}=i$$$, then swap $$$p_i$$$ and $$$p_{i+1}$$$. Otherwise, the permutation cannot be sorted.
Time complexity: $$$O(n)$$$
Implementation: (by
AlperenT
)
291676758
--------------------------------------------------
Problem ID: 2031A
Editorial Content:
2031A - Penchick and Modern Monument
Hint 1
Consider the maximum number of pillars that can be left untouched instead.
Hint 2
Under what conditions can $$$k>1$$$ pillars be untouched?
Solution
Note that if pillars $$$i$$$ and $$$j$$$ with different heights are both untouched, then the first pillar must be taller than the second, which contradicts the fact that the heights must be non-decreasing after the adjustment. Thus, all unadjusted pillars must be of the same height.
Therefore, the required number of pillars to adjust is $$$n-k$$$, where $$$k$$$ is the maximum number of pillars with the same height $$$h$$$. This bound is reachable by, for example, adjusting all pillars to height $$$h$$$.
To find $$$k$$$, we can go through each index $$$i$$$ and find the number of pillars with the same height as $$$i$$$; this gives $$$O(n^2)$$$ time complexity, which is good enough for this problem. Alternatively, you can use a frequency array or
std::map
, or sequentially go through the list and find the longest sequence of equal terms, all of which have better time complexities.
Implementation:
$$$O(n^2)$$$: (by
ACGN
)
291675590
Frequency array: (by
pavement
)
291676291
Map: (by
newb_programmer
)
291676566
Sequential approach: (by
AlperenT
)
291676646
--------------------------------------------------
Problem ID: 2030G2
Editorial Content:
2030G2 - The Destruction of the Universe (Hard Version)
Solution (Easy Version)
To find the score of a set of intervals $$$([l_1, r_1], [l_2, r_2], \ldots, [l_v, r_v])$$$, we follow these steps:
Initially, the score is set to $$$0$$$.
We perform the following process repeatedly:
Let $$$x$$$ be the interval with the smallest $$$r_i$$$ among all active intervals.
Let $$$y$$$ be the interval with the largest $$$l_i$$$ among all active intervals.
If $$$r_x < l_y$$$, add $$$l_y - r_x$$$ to the score, mark intervals $$$x$$$ and $$$y$$$ as inactive, and continue the process.
If $$$r_x \geq l_y$$$, stop the process.
At the end of this process, all active intervals will intersect at least one common point.
Now, we need to prove that the process indeed gives us the minimum possible score. We can prove this by induction.
Let $$$S$$$ be some set of intervals, and let $$$x$$$ and $$$y$$$ be the intervals defined above. Consider the set $$$S' = S \setminus {x, y}$$$ (i.e., $$$S'$$$ is the set $$$S$$$ excluding $$$x$$$ and $$$y$$$). We claim that:
$$$ \text{score}(S) \geq \text{score}(S') + \text{distance}(x, y) $$$
This is true because, for $$$x$$$ and $$$y$$$ to intersect, we must perform at least $$$\text{distance}(x, y)$$$ operations. Our construction achieves the lower bound of $$$\text{score}(S') + \text{distance}(x, y)$$$. Thus,
$$$ \text{score}(S) = \text{score}(S') + \text{distance}(x, y) $$$
During the process, we pair some intervals (possibly none). Specifically, in the $$$k$$$-th step, we pair the interval with the $$$k$$$-th smallest $$$r_i$$$ with the interval having the $$$k$$$-th largest $$$l_j$$$, and add the distance between them to the score.
In the problem G1, we can compute the contribution of each pair of intervals as follows:
Suppose we consider a pair $$$(i, j)$$$. Without loss of generality, assume that $$$r_i < l_j$$$.
The pair $$$(i, j)$$$ will be considered in some subset $$$S$$$ if there are exactly $$$x$$$ intervals $$$p$$$ such that $$$r_p < r_i$$$ and exactly $$$x$$$ intervals $$$p$$$ such that $$$l_p > l_j$$$, for some non-negative integer $$$x$$$.
Let there be $$$g$$$ intervals $$$p$$$ such that $$$r_p < r_i$$$ and $$$h$$$ intervals $$$p$$$ such that $$$l_p > l_j$$$.
For $$$(i, j)$$$ to be paired in some subset $$$S$$$, we must choose $$$x$$$ intervals from the $$$g$$$ intervals on the left and $$$x$$$ intervals from the $$$h$$$ intervals on the right, for some non-negative integer $$$x$$$. There are no restrictions on the remaining $$$n - 2 - g - h$$$ intervals.
Therefore, the contribution of $$$(i, j)$$$ is:
$$$ \sum_{x = 0}^{g} (l_j - r_i) \cdot \binom{g}{x} \cdot \binom{h}{x} \cdot 2^{n - 2 - g - h} $$$
We can simplify this sum using the identity:
$$$ \sum_{x = 0}^{g} \binom{g}{x} \cdot \binom{h}{x} = \binom{g + h}{g} $$$
(This is a form of the Vandermonde Identity.)
Thus, the contribution of $$$(i, j)$$$ becomes:
$$$ (l_j - r_i) \cdot \binom{g + h}{g} \cdot 2^{n - 2 - g - h} $$$
This can be computed in $$$O(1)$$$ time.
Note that in the explanation above, we assumed that the interval endpoints are distinct for simplicity. If they are not, we can order the intervals based on their $$$l_i$$$ values to maintain consistency.
Solution (Hard Version)
Let us find the contribution of $$$r[i]$$$, the right endpoint of $$$i$$$-th interval.
Let $$$x$$$ be the number of intervals $$$j$$$ such that $$$r[j] < r[i]$$$, and let $$$y$$$ be the number of intervals $$$j$$$ such that $$$l[j] > r[i]$$$.
To determine the contribution of $$$r[i]$$$ to the final answer, we consider selecting $$$p$$$ intervals from the $$$x$$$ intervals to the left and $$$q$$$ intervals from the $$$y$$$ intervals to the right, with the constraint that $$$p < q$$$. We require $$$p < q$$$ so that interval $$$i$$$ is paired with some other interval on the right (as discussed in the solution for G1). Therefore, the contribution of $$$r[i]$$$ can be expressed as:
$$$ \text{Contribution} = -r[i] \cdot \text{ways}(x, y) \cdot 2^{n - 1 - x - y} $$$
Here, $$$\text{ways}(x, y)$$$ represents the number of valid selections where $$$p < q$$$.
Calculating $$$\text{ways}(x, y)$$$
To compute $$$\text{ways}(x, y)$$$, we can use the Vandermonde identity to simplify the expression:
$$$ \text{ways}(x, y) = \sum_{\substack{0 \leq p < q \leq y}} \binom{x}{p} \binom{y}{q} $$$
This can be rewritten as:
$$$ \text{ways}(x, y) = \sum_{p=0}^{x} \sum_{k=1}^{y} \binom{x}{p} \binom{y}{p + k} $$$
Define the function $$$g(k)$$$ as:
$$$ g(k) = \sum_{p=0}^{x} \binom{x}{p} \binom{y}{p + k} $$$
By applying the Vandermonde identity, we get:
$$$ g(k) = \binom{x + y}{x + k} $$$
Thus, the total number of ways is:
$$$ \text{ways}(x, y) = \sum_{k=1}^{y} \binom{x + y}{x + k} $$$
We can simplify this summation using the property of binomial coefficients:
$$$ \text{ways}(x, y) = 2^{x + y} - h(x + y, x) $$$
where the function $$$h(p, q)$$$ is defined as:
$$$ h(p, q) = \sum_{i=0}^{q} \binom{p}{i} $$$
Efficient Computation of $$$h(p, q)$$$
Note that:
$$$ h(p, q) = 2 \cdot h(p - 1, q) - \binom{p - 1}{q} $$$
Suppose throughout the solution, we call the function $$$h(p, q)$$$ $$$d$$$ times for pairs $$$(p_1, q_1), (p_2, q_2), \ldots, (p_d, q_d)$$$, in that order. We can observe that:
$$$ \sum_{i=2}^{d} |p_i - p_{i-1}| + |q_i - q_{i-1}| = O(n) $$$
Since $$$h(p_i, q_i)$$$ can be computed from $$$h(p_{i-1}, q_{i-1})$$$ in $$$|p_i - p_{i-1}| + |q_i - q_{i-1}|$$$ operations, the amortized time complexity for this part is $$$O(n)$$$.
Final Contribution
Combining the above results, the contribution of $$$r[i]$$$ to the answer is:
$$$ -r[i] \cdot \left(2^{x + y} - h(x + y, x)\right) \cdot 2^{n - 1 - x - y} $$$
A similar calculation can be applied to the contribution of $$$l[i]$$$. By summing these contributions across all relevant intervals, we obtain the final answer.
G1 Code (C++)
#pragma GCC optimize("Ofast")
 
#include <bits/stdc++.h>   
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;   
using namespace std;
#define ll long long
#define ld long double
#define nline "\n"
#define f first
#define s second
#define sz(x) (ll)x.size()
#define vl vector<ll>
const ll INF_MUL=1e13;
const ll INF_ADD=1e18;
#define all(x) x.begin(),x.end()
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     
const ll MOD=998244353;
const ll MAX=500500;
vector<ll> fact(MAX+2,1),inv_fact(MAX+2,1);
ll binpow(ll a,ll b,ll MOD){
    ll ans=1;
    a%=MOD;  
    while(b){
        if(b&1)
            ans=(ans*a)%MOD;
        b/=2;
        a=(a*a)%MOD;
    }
    return ans;
}
ll inverse(ll a,ll MOD){
    return binpow(a,MOD-2,MOD);
} 
void precompute(ll MOD){
    for(ll i=2;i<MAX;i++){
        fact[i]=(fact[i-1]*i)%MOD;
    }
    inv_fact[MAX-1]=inverse(fact[MAX-1],MOD);
    for(ll i=MAX-2;i>=0;i--){
        inv_fact[i]=(inv_fact[i+1]*(i+1))%MOD;
    }
}
ll nCr(ll a,ll b,ll MOD){
    if((a<0)||(a<b)||(b<0))
        return 0;   
    ll denom=(inv_fact[b]*inv_fact[a-b])%MOD;
    return (denom*fact[a])%MOD;  
}
ll l[MAX],r[MAX],lft[MAX],rght[MAX],power[MAX];
void solve(){ 
  ll n; cin>>n;
  power[0]=1;
  for(ll i=1;i<=n;i++){
    cin>>l[i]>>r[i];
    power[i]=(power[i-1]*2ll)%MOD;
  }
  for(ll i=1;i<=n;i++){
    lft[i]=rght[i]=0;
    for(ll j=1;j<=n;j++){
      if(make_pair(r[i],i)>make_pair(r[j],j)){
        lft[i]++;
      }
      if(make_pair(l[i],i)<make_pair(l[j],j)){
        rght[i]++;
      }
    }
  }
  ll ans=0;
  for(ll i=1;i<=n;i++){
    for(ll j=1;j<=n;j++){
      if(r[i]<l[j]){
        ll found=lft[i]+rght[j];
        ll now=nCr(found,lft[i],MOD)*(l[j]-r[i]);
        now%=MOD;
        ll remaining=n-found-2;
        ans=(ans+now*power[remaining])%MOD;
      }
    }
  }
  cout<<ans<<nline;
  return;    
}  
int main()                                                                                 
{         
  ios_base::sync_with_stdio(false);                         
  cin.tie(NULL);                              
  ll test_cases=1;                 
  cin>>test_cases;
  precompute(MOD);
  while(test_cases--){
    solve();
  }
  cout<<fixed<<setprecision(12);  
  cerr<<"Time:"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms\n"; 
}
G2 Code (C++)
#pragma GCC optimize("Ofast")
 
#include <bits/stdc++.h>   
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;   
using namespace std;
#define ll long long
#define ld long double
#define nline "\n"
#define f first
#define s second
#define sz(x) (ll)x.size()
#define vl vector<ll>
const ll INF_MUL=1e13;
const ll INF_ADD=1e18;
#define all(x) x.begin(),x.end()
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     
const ll MOD=998244353;
const ll MAX=5000500;
vector<ll> fact(MAX+2,1),inv_fact(MAX+2,1);
ll binpow(ll a,ll b,ll MOD){
    ll ans=1;
    a%=MOD;  
    while(b){
        if(b&1)
            ans=(ans*a)%MOD;
        b/=2;
        a=(a*a)%MOD;
    }
    return ans;
}
ll inverse(ll a,ll MOD){
    return binpow(a,MOD-2,MOD);
} 
void precompute(ll MOD){
    for(ll i=2;i<MAX;i++){
        fact[i]=(fact[i-1]*i)%MOD;
    }
    inv_fact[MAX-1]=inverse(fact[MAX-1],MOD);
    for(ll i=MAX-2;i>=0;i--){
        inv_fact[i]=(inv_fact[i+1]*(i+1))%MOD;
    }
}
ll nCr(ll a,ll b,ll MOD){
    if((a<0)||(a<b)||(b<0))
        return 0;   
    ll denom=(inv_fact[b]*inv_fact[a-b])%MOD;
    return (denom*fact[a])%MOD;  
}
ll l[MAX],r[MAX],power[MAX];
ll ans=0,on_left=0,on_right,len;
ll x=0,y=0,ways=0,inv2;
ll getv(){
  while(x>=len+1){
    ways=((ways+nCr(x-1,y,MOD))*inv2)%MOD;
    x--;
  }
  while(x<=len-1){
    ways=(2ll*ways-nCr(x,y,MOD)+MOD)%MOD;
    x++;
  }
  while(y<=on_left-1){
    ways=(ways+nCr(x,y+1,MOD))%MOD;
    y++;
  }
  return ways;
}
void solve(){ 
  ll n; cin>>n;
  power[0]=1;
  vector<array<ll,2>> track;
  multiset<ll> consider;
  for(ll i=1;i<=n;i++){
    cin>>l[i]>>r[i];
    track.push_back({r[i],l[i]});
    consider.insert(l[i]);
    power[i]=(power[i-1]*2ll)%MOD;
  }
  ans=on_left=0;
  on_right=len=n;
  x=y=0; ways=1;
  sort(all(track));
  for(auto it:track){
    while(!consider.empty()){
      if(*consider.begin() <= it[0]){
        consider.erase(consider.begin());
        on_right--,len--;
      }
      else{
        break;
      }
    }
    ll now=power[len]-getv();
    now=(now*power[n-1-len])%MOD;
    now=(now*it[0])%MOD;
    ans=(ans+MOD-now)%MOD;
    on_left++,len++;
  }
  track.clear(); consider.clear();
  for(ll i=1;i<=n;i++){
    track.push_back({l[i],r[i]});
    consider.insert(r[i]);
  }
  sort(all(track));
  reverse(all(track));
  on_left=0;
  on_right=len=n;
  x=y=0; ways=1;
  for(auto it:track){
    while(!consider.empty()){
      if(*(--consider.end()) >= it[0]){
        consider.erase(--consider.end());
        on_right--,len--;
      }
      else{
        break;
      }
    }
    ll now=power[len]-getv();
    now=(now*power[n-1-len])%MOD;
    now=(now*it[0])%MOD;
    ans=(ans+now)%MOD;
    on_left++,len++;
  }
  ans=(ans+MOD)%MOD;
  cout<<ans<<nline;
  return;    
}  
int main()                                                                                 
{         
  ios_base::sync_with_stdio(false);                         
  cin.tie(NULL);                              
  ll test_cases=1;                 
  cin>>test_cases;
  precompute(MOD);
  inv2=inverse(2,MOD);
  while(test_cases--){
    solve();
  }
  cout<<fixed<<setprecision(12);  
  cerr<<"Time:"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms\n"; 
}
--------------------------------------------------
Problem ID: 2030G1
Editorial Content:
2030G1 - The Destruction of the Universe (Easy Version)
--------------------------------------------------
Problem ID: 2030F
Editorial Content:
2030F - Orangutan Approved Subarrays
Solution
First, let's try to find whether a single array is orangutan-approved or not.
Claim
: The array $$$b$$$ of size $$$n$$$ is not orangutan-approved if and only if there exists indices $$$1\leq w < x < y < z \leq n$$$ such that $$$b_w=b_y$$$, $$$b_x=b_z$$$, and $$$b_w\neq b_x$$$.
Proof
: Let's prove this with strong induction. For $$$n=0$$$, the claim is true because the empty array is orangutan-approved. Now, let's suppose that the claim is true for all $$$m < n$$$.
Now, let $$$s$$$ be a sorted sequence such that $$$x$$$ is in $$$s$$$ if and only if $$$b_x=b_1$$$. Suppose $$$s$$$ is length $$$k$$$. We can split the array $$$b$$$ into disjoint subarrays $$$c_1, c_2, \ldots, c_k$$$ such that $$$c_i$$$ is the subarray $$$b[s_i+1\ldots s_{i+1}-1]$$$ for all $$$1 \leq i < k$$$ and $$$c_k=b[s_k+1\ldots n]$$$ That is, $$$c_i$$$ is the subarray that lies between each occurrence of $$$b_1$$$ in the array $$$b$$$.
First, we note that the set of unique elements of $$$c_i$$$ and $$$c_j$$$ cannot contain any elements in common for all $$$i\neq j$$$. This is because suppose that there exists $$$i$$$ and $$$j$$$ such that $$$i < j$$$ and the set of unique values in $$$c_i$$$ and $$$c_j$$$ both contain $$$y$$$. Then, in the original array $$$b$$$, there must exist a subsequence $$$b_1, y, b_1, y$$$. This makes our premise false.
By our inductive claim, each of the arrays $$$c_1, c_2, \ldots, c_k$$$ must be orangutan-approved. Since there are no overlapping elements, we may delete each of the arrays $$$c_1, c_2, \ldots, c_k$$$ separately. Finally, the array $$$b$$$ is left with $$$k$$$ copies of $$$b_1$$$, and we can use one operation to delete all remaining elements in the array $$$b$$$.
Now, how do we solve for all queries? First, precompute the array $$$last$$$, which is the array containing for each $$$i$$$ the largest index $$$j<i$$$ such that $$$a[j]=a[i]$$$. Let's then use two pointers to compute the last element $$$j<i$$$ such that $$$a[j\ldots i]$$$ is orangutan-approved but $$$a[j-1\ldots i]$$$ is not, and store this in an array called $$$left$$$. Let's also keep a maximum segment tree $$$next$$$ such that $$$next[i]$$$ is the first element $$$j>i$$$ such that $$$a_j=a_i$$$. As we sweep from $$$i-1$$$ to $$$i$$$, we do the following:
Set $$$L=left[i-1]$$$
Otherwise, while $$$\max(next[L...last[i]-1]>last[i]$$$ and $$$last[i]\neq-1$$$), increment $$$L$$$ by $$$1$$$.
Set $$$left[i]=L$$$
When the $$$left$$$ array is fully calculated, we can solve each query in $$$O(1)$$$.
Code (C++)
#pragma GCC optimize("Ofast")
 
#include <bits/stdc++.h> 
using namespace std;
#define ll long long
#define nline "\n"
#define f first
#define s second
#define sz(x) x.size()
#define all(x) x.begin(),x.end()
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const ll INF_ADD=1e18;
const ll MOD=1e9+7;
const ll MAX=1048579;
class ST {
public:
    vector<ll> segs;
    ll size = 0;
    ll ID = 0;
 
    ST(ll sz) {
        segs.assign(2 * sz, ID);
        size = sz;  
    }   
   
    ll comb(ll a, ll b) {
        return max(a, b);  
    }
 
    void upd(ll idx, ll val) {
        segs[idx += size] = val;
        for(idx /= 2; idx; idx /= 2) segs[idx] = comb(segs[2 * idx], segs[2 * idx + 1]);
    }
 
    ll query(ll l, ll r) {
        ll lans = ID, rans = ID;
        for(l += size, r += size + 1; l < r; l /= 2, r /= 2) {
            if(l & 1) lans = comb(lans, segs[l++]);
            if(r & 1) rans = comb(segs[--r], rans);
        }
        return comb(lans, rans);
    }
}; 
void solve(){
  ll n,q,l=1; cin>>n>>q;
  ST track(n+5);
  vector<ll> a(n+5),last(n+5,0),lft(n+5);
  for(ll i=1;i<=n;i++){
    cin>>a[i];
    ll till=last[a[i]];
    while(track.query(l,till)>=till+1){
      l++;
    }
    if(till){
      track.upd(till,i);
    }
    lft[i]=l;
    last[a[i]]=i;
  }
  while(q--) {
    ll l,r; cin>>l>>r;
    if(lft[r]<=l){
      cout<<"YES\n";
    } 
    else{
      cout<<"NO\n";
    }
  }
}
int main()                                                                                 
{         
  ios_base::sync_with_stdio(false);                         
  cin.tie(NULL);                                  
  ll test_cases=1;                 
  cin>>test_cases;
  while(test_cases--){
    solve();
  }
}
--------------------------------------------------
Problem ID: 2030E
Editorial Content:
2030E - MEXimize the Score
Solution
Observation: The score of $$$b$$$ is equivalent to $$$f_0$$$ + $$$\min(f_0, f_1)$$$ + $$$\ldots$$$ + $$$\min(f_0, \ldots, f_{n-1})$$$ where $$$f_i$$$ stores the frequency of integer $$$i$$$ in $$$b$$$.
Intuition: We can greedily construct the $$$k$$$ arrays by repeating this step: Select the minimum $$$j$$$ such that $$$f_j = 0$$$ and $$$\min(f_0, \ldots f_{j-1}) > 0$$$, and construct the array $$$[0, 1, \ldots, j-1]$$$. This is optimal because every element we add will increase the MEX by $$$1$$$, which will increase the score by $$$1$$$. If we add $$$j$$$, the MEX will not increase. Also, when we add an element, we cannot increase the score by more than $$$1$$$. Adding less than $$$j$$$ elements cannot increase MEX for future arrays.
From this observation, we can see that only the frequency array of $$$a$$$ matters. From now on, let's denote the frequency of $$$i$$$ in $$$a$$$ as $$$f_i$$$. We can find the sum over all subsequences using dynamic programming.
Let's denote $$$dp[i][j]$$$ as the number of subsequences containing only the first $$$i$$$ integers and $$$min(f_0, \ldots, f_i) = j$$$. Initially, $$$dp[0][i] = \binom{f_0}{i}$$$. To transition, we need to consider two cases:
In the first case, let's assume $$$j < \min(f_0, \ldots, f_{i-1})$$$. The number of subsequences that can be created is $$$(\sum_{k=j+1}^n dp[i-1][k]) \cdot \binom{f_i}{j}$$$. That is, all the subsequences from previous length such that it is possible for $$$j$$$ to be the new minimum, multiplied by the number of subsequences where $$$f_i = j$$$.
In the second case, let's assume $$$j \geq \min(f_0, \ldots, f_{i-1})$$$. The number of subsequences that can be created is $$$(\sum_{k=j}^{f_i} \binom{f_i}{k}) \cdot dp[i-1][j]$$$. That is, all subsequences containing at least $$$j$$$ elements of $$$i$$$, multiplied by all previous subsequences with minimum already equal to $$$j$$$.
The total score is $$$dp[i][j] \cdot j \cdot 2^{f_{i+1} + \dots + f_{n-1}}$$$ over the length of the prefix $$$i$$$ and prefix minimum $$$j$$$.
We can speed up the calculations for both cases using suffix sums, however, this still yields an $$$O(n^2)$$$ algorithm. However, $$$j$$$ is bounded to the interval $$$[1, f_i]$$$ for each $$$i$$$. Since the sum of $$$f_i$$$ is $$$n$$$, the total number of secondary states is $$$n$$$. This becomes just a constant factor, so the total complexity is $$$O(n)$$$.
Code (C++)
#include <bits/stdc++.h>
#define int long long
#define ll long long 
#define pii pair<int,int> 
#define piii pair<pii,pii>
#define fi first
#define se second
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt")
using namespace std;

const int MX = 2e5;
ll fact[MX+1];
ll ifact[MX+1];
ll MOD=998244353;
 
ll binPow(ll base, ll exp) {
    ll ans = 1;
    while(exp) {
        if(exp%2) {
            ans = (ans*base)%MOD;
        }
        base = (base*base)%MOD;
        exp /= 2;
    }
    return ans;
}
 
int nCk(int N, int K) {
    if(K>N||K<0) {
        return 0;
    }
    return (fact[N]*((ifact[K]*ifact[N-K])%MOD))%MOD;
}
 
void ICombo() {
	fact[0] = 1;
    for(int i=1;i<=MX;i++) {
        fact[i] = (fact[i-1]*i)%MOD;
    }    
    ifact[MX] = binPow(fact[MX],MOD-2);
    for(int i=MX-1;i>=0;i--) {
        ifact[i] = (ifact[i+1]*(i+1))%MOD;
    }
}

void solve() {
    int n, ans=0; cin >> n;
    vector<int> c(n);
    for (int r:c) {
        cin >> r; c[r]++; 
    }
    vector<vector<int>> dp(n,vector<int>(1));
    vector<int> ps, co; 
    for (int i = 1; i <= c[0]; i++) dp[0].push_back(nCk(c[0],i));
    for (int i = 1; i < n; i++) {
        ps.resize(1); co=ps; 
        for (int r:dp[i-1]) ps.push_back((ps.back()+r)%MOD); 
        int m=ps.size()-1;
        dp[i].resize(min(m,c[i]+1));
        for (int j = 0; j <= c[i]; j++) co.push_back((co.back()+nCk(c[i],j))%MOD);
        for (int j = 1; j < dp[i].size(); j++) dp[i][j]=nCk(c[i],j)*(ps[m]-ps[j]+MOD)%MOD+(co.back()-co[j+1]+MOD)*dp[i-1][j]%MOD; 
    }
    int j=0;
    for (auto r:dp) {
        n-=c[j++];
        for (int i = 1; i < r.size(); i++) (ans+=i*r[i]%MOD*binPow(2,n))%=MOD;
    }
    cout << ans << "\n"; 
}

int32_t main() {
	ios::sync_with_stdio(0); cin.tie(0);
        ICombo();
	int t = 1; cin >> t;
	while (t--) solve();
}
--------------------------------------------------
Problem ID: 2030D
Editorial Content:
2030D - QED's Favorite Permutation
Solution
Observation: Through a series of swaps, we can swap an element from position $$$i$$$ to position $$$j$$$ (WLOG, assume $$$i < j$$$) if there is no such $$$k$$$ such that $$$i \leq k < j$$$ such that $$$s_k = \texttt{L}$$$ and $$$s_{k+1} = \texttt{R}$$$.
Let's mark all indices $$$i$$$ such that $$$s_i = \texttt{L}$$$ and $$$s_{i+1} = \texttt{R}$$$ as bad. If $$$pos_i$$$ represents the position of $$$i$$$ in $$$p$$$, then we must make sure it is possible to swap from $$$\min(i, pos_i)$$$ to $$$\max(i, pos_i)$$$. As you can see, we can model these conditions as intervals. We must make sure there are no bad indices included in any intervals.
We need to gather indices $$$i$$$ such that $$$i$$$ is included in at least one interval. This can be done with difference array. Let $$$d_i$$$ denote the number of intervals that include $$$i$$$. If $$$d_i > 0$$$, then we need to make sure $$$i$$$ is not a bad index.
We can keep all bad indices in a set. Notice that when we update $$$i$$$, we can only potentially toggle indices $$$i$$$ and $$$i-1$$$ from good to bad (or vice versa). For example, if $$$s_i = \texttt{L}$$$, $$$s_i = \texttt{R}$$$, $$$d_i > 0$$$ and index $$$i$$$ is not in the bad set, then we will insert it. After each query, if the bad set is empty, then the answer is "YES".
Code (C++)
#include <bits/stdc++.h>

using namespace std;

int main() {
    int t;
    cin >> t;
    while(t--) {
        int n,q;
        cin >> n >> q;
        vector<int> perm(n);
        for(int i = 0; i < n; i++) cin >> perm[i];
        for(int i = 0; i < n; i++) perm[i]--;
        vector<int> invperm(n);
        for(int i = 0; i < n; i++) invperm[perm[i]]=i;
        vector<int> diffArr(n);
        for(int i = 0; i < n; i++) {
            diffArr[min(i, invperm[i])]++;
            diffArr[max(i, invperm[i])]--;
        }
        for(int i = 1; i < n; i++) diffArr[i]+=diffArr[i-1];
        string s;
        cin >> s;
        set<int> problems;
        for(int i = 0; i < n-1; i++) {
            if(s[i]=='L'&&s[i+1]=='R'&&diffArr[i]!=0) {
                problems.insert(i);
            } 
        }
        while(q--) {
            int x;
            cin >> x;
            x--;
            if(s[x]=='L') {
                s[x]='R';
            } else {
                s[x]='L';
            }
            if(s[x-1]=='L'&&s[x]=='R'&&diffArr[x-1]!=0) {
                problems.insert(x-1);
            } else {
                problems.erase(x-1);
            }
            if(s[x]=='L'&&s[x+1]=='R'&&diffArr[x]!=0) {
                problems.insert(x);
            } else {
                problems.erase(x);
            }
            if(problems.size()) {
                cout << "NO" << endl;
            } else {
                cout << "YES" << endl;
            }
        }
    }
}
--------------------------------------------------
Problem ID: 2030C
Editorial Content:
2030C - A TRUE Battle
Solution
Let's understand what Alice wants to do. She wants to separate a statement that evaluates to
true
between two
or
's. This guarantees her victory since
or
is evaluated after all
and
's.
First, if the first or last boolean is
true
, then Alice instantly wins by placing
or
between the first and second, or second to last and last booleans.
Otherwise, if there are two
true
's consecutively, Alice can also win. Alice may place
or
before the first of the two on her first move. If Bob does not put his operator between the two
true
's, then Alice will put an
or
between the two
true
's on her next move and win. Otherwise, Bob does place his operator between the two
true
's. However, no matter what Bob placed, the two
true
's will always evaluate to
true
, so on her second move Alice can just place an
or
on the other side of the two
true
's to win.
We claim these are the only two cases where Alice wins. This is because otherwise, there does not contain two
true
's consecutively. Now, whenever Alice places an
or
adjacent to a
true
, Bob will respond by placing
and
after the
true
, which will invalidate this clause to be false.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t;
    cin >> t;
    while(t--) {
        int n;
        cin >> n;
        string s;
        cin >> s;
        vector<int> v(n);
        for(int i = 0; i < n; i++) {
            if(s[i]=='1') v[i]=1;
        }
        bool win = false;
        if(v[0]||v[n-1]) win=true;
        for(int i = 1; i < n; i++) {
            if(v[i]&&v[i-1]) win=true;
        }
        if(win) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
}
--------------------------------------------------
Problem ID: 2030B
Editorial Content:
2030B - Minimise Oneness
Solution
Observation
: $$$f(t)-g(t)$$$ is odd.
Proof: $$$f(t)+g(t)$$$ is the set of all non-empty subsets of $$$t$$$, which is $$$2^{|t|}-1$$$, which is odd. The sum and difference of two integers has the same parity, so $$$f(t)-g(t)$$$ is always odd.
By including exactly one $$$1$$$ in the string $$$s$$$, we can make $$$f(s)=2^{n-1}-1$$$ and $$$g(s)=2^{n-1}$$$, or $$$f(s)-g(s)=1$$$ by the multiplication principle. Clearly, this is the best we can do. So, we print out any string with exactly one $$$1$$$.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t;
    cin >> t;
    while(t--) {
        int n;
        cin >> n;
        cout << '1';
        for(int i = 1; i < n; i++) cout << '0';
        cout << endl;
    }
}
--------------------------------------------------
Problem ID: 2030A
Editorial Content:
2030A - A Gift From Orangutan
Solution
First, what is the maximum possible value of $$$c_i-b_j$$$ for any $$$i,j$$$? Since $$$c_i$$$ is the maximum element of some subset of $$$a$$$ and $$$b_i$$$ is the minimum element of some subset of $$$a$$$, the maximum possible value of $$$c_i-b_j$$$ is $$$max(a)-min(a)$$$.
Also note that $$$c_1=b_1$$$ for any reordering of $$$a$$$. By reordering such that the largest element of $$$a$$$ appears first and the smallest element of $$$a$$$ appears second, the maximum possible value of the score is achieved. This results in a score of $$$(max(a)-min(a))\cdot(n-1)$$$.
Code (Python)
for i in range(int(input())):
    n = int(input())
    mx = 0
    mn= 1000000
    lst = input().split()
    for j in range(n):
        x = int(lst[j])
        mx = max(mx, x)
        mn = min(mn, x)
    print((mx-mn)*(n-1))
--------------------------------------------------
Problem ID: 2029I
Editorial Content:
2029I - Variance Challenge
Hint 1
The intended solution has nothing to do with dynamic programming.
Hint 2
This is the key observation of the problem. Suppose we have an array $$$b$$$ and a function $$$f(x)=\sum (b_i-x)^2$$$, then the minimum value of $$$f(x)$$$ is the variance of $$$b$$$.
Hint 3
Using the observation mentioned in Hint 2, we can reduce the problem to minimizing $$$\sum(a_i-x)^2$$$ for a
given
$$$x$$$. There are only $$$\mathcal{O}(n\cdot m)$$$ possible $$$x$$$-s.
Hint 4
The rest of the problem is somehow easy. Try flows, or just find a greedy algorithm!
Hint 5
If you are trying flows: the quadratic function is always convex.
Solution
Key Observation.
Suppose we have an array $$$b$$$ and a function $$$f(x)=\sum (b_i-x)^2$$$, then the minimum value of $$$f(x)$$$ is the variance of $$$b$$$.
Proof.
This is a quadratic function of $$$x$$$, and the its symmetry axis is $$$x=\frac{1}{n}\sum b_i$$$. So the minimum value is $$$f\left(\frac{1}{n}\sum b_i\right)$$$. That is exactly the definition of variance.
Thus, we can enumerate all possible $$$x$$$-s, and find the minimum $$$\sum (a_i-x)^2$$$ after the operations, then take the minimum across them. That will give the correct answer to the original problem. Note that there are only $$$\mathcal{O}(n\cdot m)$$$ possible $$$x$$$-s.
More formally, let $$$k_{x,c}$$$ be the minimum value of $$$\sum (a_i-x)^2$$$ after exactly $$$c$$$ operations. Then $$$\mathrm{ans}_i=\displaystyle\min_{\text{any possible }x} k_{x,i}$$$.
So we only need to solve the following (reduced) problem:
Given a (maybe non-integer) number $$$x$$$. For each $$$1\le i\le m$$$, find the minimum value of $$$\sum (a_i-x)^2$$$ after exactly $$$i$$$ operations.
To solve this, we can use the MCMF model:
Set a source node $$$s$$$ and a target node $$$t$$$.
For each $$$1\le i\le n$$$, add an edge from $$$s$$$ to $$$i$$$ with cost $$$0$$$.
For each $$$1\le i\le n$$$, add an edge from $$$i$$$ to $$$t$$$ with cost $$$0$$$.
For each $$$1\le i< n$$$, add an edge from $$$i$$$ to $$$i+1$$$ with cost being a function $$$\mathrm{cost}(f)=(a_i+f-x)^2-(a_i-x)^2$$$, where $$$f$$$ is the flow on this edge.
Note that the $$$\mathrm{cost}$$$ function is convex, so this model is correct, as you can split an edge into some edges with cost of $$$\mathrm{cost}(1)$$$, $$$\mathrm{cost}(2)-\mathrm{cost}(1)$$$, $$$\mathrm{cost}(3)-\mathrm{cost}(2)$$$, and so on.
Take a look at the model again. We don't need to run MCMF. We can see that it is just a process of regret greedy. So you only need to find the LIS (Largest Interval Sum :) ) for each operation.
Thus, we solved the reduced problem in $$$\mathcal{O(n\cdot m)}$$$.
Overall time complexity: $$$\mathcal{O}((n\cdot m)^2)$$$ per test case.
Reminder: don't forget to use
__int128
if you didn't handle the numbers carefully!
Code (C++)
#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;

const int _N = 1e5 + 5;

int T;

void solve() {
	ll n, m, k; cin >> n >> m >> k;
	vector<ll> a(n + 1);
	for (int i = 1; i <= n; i++) cin >> a[i];
	vector<ll> kans(m + 1, LLONG_MAX);
	vector<__int128> f(n + 1), g(n + 1), v(n + 1);
	vector<int> vis(n + 1), L(n + 1), L2(n + 1);
	ll sum = 0;
	for (int i = 1; i <= n; i++) sum += a[i];
	__int128 pans = 0;
	for (int i = 1; i <= n; i++) pans += n * a[i] * a[i];
	auto work = [&](ll s) {
		__int128 ans = pans;
		ans += s * s - 2ll * sum * s;
		f.assign(n + 1, LLONG_MAX);
		g.assign(n + 1, LLONG_MAX);
		for (int i = 1; i <= n; i++) {
			v[i] = n * (2 * a[i] * k + k * k) - 2ll * s * k;
			vis[i] = 0;
		}
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= n; j++) {
				L[j] = L2[j] = j;
				if (f[j - 1] < 0) f[j] = f[j - 1] + v[j], L[j] = L[j - 1];
				else f[j] = v[j];
				if (!vis[j]) {
					g[j] = LLONG_MAX;
					continue;
				}
				if (g[j - 1] < 0) g[j] = g[j - 1] + 2ll * n * k * k - v[j], L2[j] = L2[j - 1];
				else g[j] = 2ll * n * k * k - v[j];
			}
			__int128 min_sum = LLONG_MAX;
			int l = 1, r = n, type = 0;
			for (int j = 1; j <= n; j++) {
				if (f[j] < min_sum) {
					min_sum = f[j], r = j, l = L[j];
				}
			}
			for (int j = 1; j <= n; j++) {
				if (g[j] < min_sum) {
					min_sum = g[j], r = j, l = L2[j];
					type = 1;
				}
			}
			ans += min_sum;
			if (type == 0) {
				for (int j = l; j <= r; j++) vis[j]++, v[j] += 2 * n * k * k;
			} else {
				for (int j = l; j <= r; j++) vis[j]--, v[j] -= 2 * n * k * k;
			}
			kans[i] = min((__int128)kans[i], ans);
		}
	};
	
	for (ll x = sum; x <= sum + n * m * k; x += k) {
		work(x);
	}
	for (int i = 1; i <= m; i++) cout << kans[i] << " \n"[i == m];
	return;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		solve();
	}
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2029H
Editorial Content:
2029H - Message Spread
Hint 1
It's hard to calculate the expected number. Try to change it to the probability.
Hint 2
Consider a $$$\mathcal{O}(3^n)$$$ dp first.
Hint 3
Use inclusion and exclusion.
Hint 4
Write out the transformation. Try to optimize it.
Solution
Let $$$dp_S$$$ be the probability such that exactly the points in $$$S$$$ have the message.
The answer is $$$\sum dp_S\cdot tr_S$$$, where $$$tr_S$$$ is the expected number of days before at least one vertex out of $$$S$$$ to have the message (counting from the day that exactly the points in $$$S$$$ have the message).
For transformation, enumerate $$$S,T$$$ such that $$$S\cap T=\varnothing$$$. Transfer $$$dp_S$$$ to $$$dp_{S\cup T}$$$. It's easy to precalculate the coefficient, and the time complexity differs from $$$\mathcal{O}(3^n)$$$, $$$\mathcal{O}(n\cdot 3^n)$$$ to $$$\mathcal{O}(n^2\cdot 3^n)$$$, according to the implementation.
The transformation is hard to optimize. Enumerate $$$T$$$ and calculate the probability such that vertices in $$$S$$$ is only connected with vertices in $$$T$$$, which means that the real status $$$R$$$ satisfies $$$S\subseteq R\subseteq (S\cup T)$$$. Use inclusion and exclusion to calculate the real probability.
List out the coefficient:
$$$\frac{\displaystyle\prod_{e\in\{1,2,3,\dots,n\}}(1-w_e)\cdot\prod_{e\in(S\cup T)}\frac{1}{1-w_e}\cdot\prod_{e\in \{1,2,\dots,n\}\setminus S}\frac{1}{1-w_e}\cdot\prod_{e\in T}(1-w_e)}{\displaystyle1-\prod_{e\in\{1,2,3,\dots,n\}}(1-w_e)\cdot\prod_{e\in S}\frac{1}{1-w_e}\cdot\prod_{e\in\{1,2,3,\dots,n\}\setminus S}\frac{1}{1-w_e}}$$$
(Note that $$$w_e$$$ denotes the probability of the appearance of the edge $$$e$$$)
We can express it as $$$\mathrm{Const}\cdot f_{S\cup T}\cdot g_S\cdot h_T$$$. Use a subset convolution to optimize it. The total time complexity is $$$\mathcal{O}(2^n\cdot n^2)$$$.
It's easy to see that all $$$dp_S\neq0$$$ satisfies $$$1\in S$$$, so the time complexity can be $$$\mathcal{O}(2^{n-1}\cdot n^2)$$$ if well implemented.
Code (C++)
#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int N=(1<<21),mod=998244353;
const int Lim=8e18;
inline void add(signed &i,int j){
	i+=j;
	if(i>=mod) i-=mod;
}
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
int dp[N],f[N],g[N],h[N];
int s1[N],s2[N];
signed pre[22][N/2],t[22][N/2],pdp[N][22];
int p[N],q[N],totp,totq;
signed main(){
	int n,m; cin>>n>>m;
	int totprod=1;
	for(int i=0;i<(1<<n);i++) s1[i]=s2[i]=1;
	for(int i=1;i<=m;i++){
		int u,v,p,q; cin>>u>>v>>p>>q;
		int w=p*qp(q,mod-2)%mod;
		(s1[(1<<(u-1))+(1<<(v-1))]*=(mod+1-w))%=mod;
		(s2[(1<<(u-1))+(1<<(v-1))]*=qp(mod+1-w,mod-2))%=mod;
		(totprod*=(mod+1-w))%=mod;
	}
	for(int j=1;j<=n;j++) for(int i=0;i<(1<<n);i++) if((i>>(j-1))&1) (s1[i]*=s1[i^(1<<(j-1))])%=mod,(s2[i]*=s2[i^(1<<(j-1))])%=mod;
	for(int i=0;i<(1<<n);i++) f[i]=s2[i],g[i]=totprod*s2[((1<<n)-1)^i]%mod*qp(mod+1-totprod*s2[i]%mod*s2[((1<<n)-1)^i]%mod,mod-2)%mod,h[i]=s1[i];
	for(int i=1;i<(1<<n);i++) pre[__builtin_popcount(i)][i>>1]=h[i];
	dp[1]=1;
	for(int j=1;j<=n;j++){
		if(!((1>>(j-1))&1)) add(pdp[1|(1<<(j-1))][j],mod-(dp[1]*g[1]%mod*f[1]%mod));
	}
	t[0][0]=dp[1]*g[1]%mod;
	for(int k=1;k<=n;k++) for(int j=1;j<n;j++) for(int i=0;i<(1<<(n-1));i++) if((i>>(j-1))&1) add(pre[k][i],pre[k][i^(1<<(j-1))]);
	for(int j=1;j<n;j++) for(int i=0;i<(1<<(n-1));i++) if((i>>(j-1))&1) add(t[0][i],t[0][i^(1<<(j-1))]);
	for(int k=1;k<n;k++){
		totp=totq=0;
		for(int i=0;i<(1<<(n-1));i++) if(__builtin_popcount(i)<=k) p[++totp]=i; else q[++totq]=i;
		for(int l=1,i=p[l];l<=totp;l++,i=p[l]) for(int j=0;j<k;j++) add(t[k][i],1ll*t[j][i]*pre[k-j][i]%mod);
		for(int i=0;i<(1<<(n-1));i++) t[k][i]%=mod;
		for(int j=1;j<n;j++) for(int l=1,i=p[l];l<=totp;l++,i=p[l]) if((i>>(j-1))&1) add(t[k][i],mod-t[k][i^(1<<(j-1))]);
		for(int i=0;i<(1<<(n-1));i++){
			if(__builtin_popcount(i)==k){
				add(pdp[(i<<1)|1][0],t[k][i]*f[(i<<1)|1]%mod);
				int pre=0;
				for(int j=1;j<=n;j++){
					(pre+=pdp[(i<<1)|1][j-1])%=mod;
					if(!((((i<<1)|1)>>(j-1))&1)) add(pdp[(i<<1)|1|(1<<(j-1))][j],mod-pre);
				}
				(pre+=pdp[(i<<1)|1][n])%=mod;
				dp[(i<<1)|1]=pre;
				for(int j=1;j<=n;j++){
					if(!((((i<<1)|1)>>(j-1))&1)) add(pdp[(i<<1)|1|(1<<(j-1))][j],mod-(dp[(i<<1)|1]*g[(i<<1)|1]%mod*f[(i<<1)|1]%mod));
				}
				t[k][i]=pre*g[(i<<1)|1]%mod;
			}
			else t[k][i]=0;
		}
		for(int j=1;j<n;j++) for(int l=1,i=q[l];l<=totq;l++,i=q[l]) if((i>>(j-1))&1) add(t[k][i],t[k][i^(1<<(j-1))]);
	}
	int ans=0;
	for(int i=1;i<(1<<n)-1;i+=2) (ans+=dp[i]*qp(mod+1-totprod*s2[i]%mod*s2[((1<<n)-1)^i]%mod,mod-2)%mod)%=mod;
	cout<<ans;
	return 0;
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2029G
Editorial Content:
2029G - Balanced Problem
Solution 1 (with hints)
Hint 1
The array $$$a$$$ is constructed with the operations. How can we use this property?
Hint 2
If we want to make all $$$a_i=x$$$, what is the minimum value of $$$x$$$? Use the property mentioned in Hint 1.
Hint 3
(For the subproblem in Hint 2), try to find an algorithm related to the positions of $$$\texttt{L/R}$$$-s directly.
Hint 4
(For the subproblem in Hint 2), the conclusion is that, the minimum $$$x$$$ equals $$$\text{# of }\texttt{L}\text{-s} + \text{# of }\texttt{R}\text{-s} - \text{# of adjacent }\texttt{LR}\text{-s}$$$. Think why.
Hint 5
Go for DP.
Solution
Read the hints first.
Then, note that there are only $$$\mathcal{O}(V)$$$ useful positions: If (after the initial operations) $$$a_i>V$$$ or $$$a_{i}=a_{i-1}$$$, we can simply ignore $$$a_i$$$, or merge $$$c_i$$$ into $$$c_{i-1}$$$.
Now let $$$dp(i,s)$$$ denote the answer when we consider the prefix of length $$$i$$$, and we have "saved" $$$s$$$ pairs of $$$\texttt{LR}$$$.
Then,
$$$ dp(i,s)=\displaystyle\max_{j< i} dp(j,s-|\mathrm{cntL}(j,i-1)-\mathrm{cntR}(j+1,i)|)+c_i $$$
Write $$$\mathrm{cntL}$$$ and $$$\mathrm{cntR}$$$ as prefix sums:
$$$ dp(i,s)=\displaystyle\max_{j< i} dp(j,s-|\mathrm{preL}(i-1)-\mathrm{preR}(i)+\mathrm{preR}(j)-\mathrm{preL}(j-1)|)+c_i $$$
Do casework on the sign of the things inside the $$$\mathrm{abs}$$$, and you can maintain both cases with 1D Fenwick trees.
Thus, you solved the problem in $$$\mathcal{O}(V^2\log V)$$$.
Hint 1
The array $$$a$$$ is constructed with the operations. How can we use this property?
Hint 2
If we want to make all $$$a_i=x$$$, what is the minimum value of $$$x$$$? Use the property mentioned in Hint 1.
Hint 3
(For the subproblem in Hint 2), try to find an algorithm related to the positions of $$$\texttt{L/R}$$$-s directly.
Hint 4
(For the subproblem in Hint 2), the conclusion is that, the minimum $$$x$$$ equals $$$\text{# of }\texttt{L}\text{-s} + \text{# of }\texttt{R}\text{-s} - \text{# of adjacent }\texttt{LR}\text{-s}$$$. Think why.
Hint 5
Go for DP.
Solution
Read the hints first.
Then, note that there are only $$$\mathcal{O}(V)$$$ useful positions: If (after the initial operations) $$$a_i>V$$$ or $$$a_{i}=a_{i-1}$$$, we can simply ignore $$$a_i$$$, or merge $$$c_i$$$ into $$$c_{i-1}$$$.
Now let $$$dp(i,s)$$$ denote the answer when we consider the prefix of length $$$i$$$, and we have "saved" $$$s$$$ pairs of $$$\texttt{LR}$$$.
Then,
$$$ dp(i,s)=\displaystyle\max_{j< i} dp(j,s-|\mathrm{cntL}(j,i-1)-\mathrm{cntR}(j+1,i)|)+c_i $$$
Write $$$\mathrm{cntL}$$$ and $$$\mathrm{cntR}$$$ as prefix sums:
$$$ dp(i,s)=\displaystyle\max_{j< i} dp(j,s-|\mathrm{preL}(i-1)-\mathrm{preR}(i)+\mathrm{preR}(j)-\mathrm{preL}(j-1)|)+c_i $$$
Do casework on the sign of the things inside the $$$\mathrm{abs}$$$, and you can maintain both cases with 1D Fenwick trees.
Thus, you solved the problem in $$$\mathcal{O}(V^2\log V)$$$.
Solution 2 (with hints)
Hint 1
Solve the problem for a single $$$v$$$ first.
Hint 2
Don't think too much, just go straight for a DP solution.
Hint 3
Does your time complexity in DP contain $$$n$$$ or $$$m$$$? In fact, both $$$n$$$ and $$$m$$$ are useless. There are only $$$\mathcal{O}(V)$$$ useful positions.
Hint 4
Use some data structures to optimize your DP. Even $$$\mathcal{O}(v^2\log^2 v)$$$ is acceptable.
Hint 5
Here is the final step: take a look at your DP carefully. Can you change the definition of states a little, so that it can get the answer for each $$$1\le v\le V$$$?
Solution
First, note that there are only $$$\mathcal{O}(V)$$$ useful positions: If (after the initial operations) $$$a_i>V$$$ or $$$a_{i}=a_{i-1}$$$, we can simply ignore $$$a_i$$$, or merge $$$c_i$$$ into $$$c_{i-1}$$$.
Now, let's solve the problem for a single $$$v$$$.
Denote $$$dp(i,j,k)$$$ as the maximum answer when considering the prefix of length $$$i$$$, and there are $$$j$$$ prefix additions covering $$$i$$$, $$$k$$$ suffix additions covering $$$i$$$.
Enumerate on $$$i$$$, and it is easy to show that the state changes if and only if $$$j+k+a_i=v$$$, and
$$$ dp(i,j,k)=\displaystyle\max_{p\le j,q\ge k} dp(i-1,p,q) + c_i $$$
You can use a 2D Fenwick tree to get the 2D prefix max. Thus, you solved the single $$$v$$$ case in $$$\mathcal{O}(v^2\log^2 v)$$$.
In fact, we can process the DP in $$$\mathcal{O}(v^2 \log v)$$$ by further optimization:
$$$ dp(i,j,k)=\displaystyle\max_{p\le i-1,q\ge j,v-a_p-q\le k} dp(p,q,v-a_p-q) + c_i $$$
This only requires $$$a_p+q\ge a_i+j$$$ when $$$a_p\le a_i$$$, and $$$q\le j$$$ when $$$a_p\ge a_i$$$. So you can use 1D Fenwick trees to process the dp in $$$\mathcal{O}(v^2 \log v)$$$.
Now, let's go for the whole solution.
Let's modify the DP state a bit: now $$$dp(i,j,k)$$$ is the state when using $$$v-k$$$ suffix operations (note that $$$v$$$ is not a constant here). The transformation is similar.
Then the answer for $$$v=i$$$ will be $$$\max dp(*,*,i)$$$.
Hint 1
Solve the problem for a single $$$v$$$ first.
Hint 2
Don't think too much, just go straight for a DP solution.
Hint 3
Does your time complexity in DP contain $$$n$$$ or $$$m$$$? In fact, both $$$n$$$ and $$$m$$$ are useless. There are only $$$\mathcal{O}(V)$$$ useful positions.
Hint 4
Use some data structures to optimize your DP. Even $$$\mathcal{O}(v^2\log^2 v)$$$ is acceptable.
Hint 5
Here is the final step: take a look at your DP carefully. Can you change the definition of states a little, so that it can get the answer for each $$$1\le v\le V$$$?
Solution
First, note that there are only $$$\mathcal{O}(V)$$$ useful positions: If (after the initial operations) $$$a_i>V$$$ or $$$a_{i}=a_{i-1}$$$, we can simply ignore $$$a_i$$$, or merge $$$c_i$$$ into $$$c_{i-1}$$$.
Now, let's solve the problem for a single $$$v$$$.
Denote $$$dp(i,j,k)$$$ as the maximum answer when considering the prefix of length $$$i$$$, and there are $$$j$$$ prefix additions covering $$$i$$$, $$$k$$$ suffix additions covering $$$i$$$.
Enumerate on $$$i$$$, and it is easy to show that the state changes if and only if $$$j+k+a_i=v$$$, and
$$$ dp(i,j,k)=\displaystyle\max_{p\le j,q\ge k} dp(i-1,p,q) + c_i $$$
You can use a 2D Fenwick tree to get the 2D prefix max. Thus, you solved the single $$$v$$$ case in $$$\mathcal{O}(v^2\log^2 v)$$$.
In fact, we can process the DP in $$$\mathcal{O}(v^2 \log v)$$$ by further optimization:
$$$ dp(i,j,k)=\displaystyle\max_{p\le i-1,q\ge j,v-a_p-q\le k} dp(p,q,v-a_p-q) + c_i $$$
This only requires $$$a_p+q\ge a_i+j$$$ when $$$a_p\le a_i$$$, and $$$q\le j$$$ when $$$a_p\ge a_i$$$. So you can use 1D Fenwick trees to process the dp in $$$\mathcal{O}(v^2 \log v)$$$.
Now, let's go for the whole solution.
Let's modify the DP state a bit: now $$$dp(i,j,k)$$$ is the state when using $$$v-k$$$ suffix operations (note that $$$v$$$ is not a constant here). The transformation is similar.
Then the answer for $$$v=i$$$ will be $$$\max dp(*,*,i)$$$.
Code (Solution 1, C++)
#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;
using ld = double;

const int _N = 4105;
const ld inf = 1e15;

int T;

struct fenwick {
	ll c[_N]; int N;
	int lowbit(int x) { return x & (-x); }
	void init(int n) {
		N = n;
		for (int i = 1; i <= N; i++) c[i] = -1e18;
	}
	void update(int x, ll v) {
		// assert(x != 0);
		while (x < N) {
			c[x] = max(c[x], v);
			x += lowbit(x);
		}
	}
	ll getmx(int x) {
		// assert(x != 0);
		ll res = -1e18;
		while (x > 0) {
			res = max(res, c[x]);
			x -= lowbit(x);
		}
		return res;
	}
} pre[4105], suf[4105];

void solve() {
	int n, o, m, k; cin >> n >> o >> m;
	k = 0;
	vector<ll> a(n + 3), c(n + 3), d(n + 3), L(n + 3), R(n + 3), L2(n + 3), R2(n + 3);
	for (int i = 1; i <= n; i++) cin >> c[i];
	for (int i = 1; i <= o; i++) {
		char op; int x; cin >> op >> x;
		if (op == 'L') L[x]++;
		else R[x]++;
	}
	vector<int> tL(n + 3), tR(n + 3);
	for (int i = 1; i <= n; i++) tR[i] = tR[i - 1] + R[i];
	for (int i = n; i >= 1; i--) tL[i] = tL[i + 1] + L[i];
	int q = 0, curL = 0, curR = 0;
	for (int i = 1; i <= n; i++) {
		a[i] = tL[i] + tR[i];
		if (a[i] <= m + k) {
		    if (a[i] == a[i - 1] && L[i] == 0 && R[i] == 0) {
		        if (q == 0) q++;
		        d[q] += c[i];
		        continue;
		    }
			q++;
			L2[q] += L[i];
			R2[q] += R[i] + curR;
			L2[q - 1] += curL;
			d[q] += c[i];
			curL = curR = 0;
		} else {
			curL += L[i];
			curR += R[i];
		}
	}
	L2[0] = 0; L2[q] += curL;
	for (int i = 1; i <= q; i++) L2[i] += L2[i - 1], R2[i] += R2[i - 1];
    m += k;
    vector<ll> dp(2 * m + 2, -1e18);
	for (int i = 0; i <= 2 * m; i++) {
		pre[i].init(2 * m + 2);
		suf[i].init(2 * m + 2);
	}
	vector<ll> ans(m + 1);
	for (int i = 1; i <= q; i++) {
        dp.resize(2 * m + 2, -1e18);
		dp[L2[i - 1]] = d[i];
		for (int s = 0; s <= m; s++) {
			ll res1 = pre[s - L2[i - 1] + m].getmx(R2[i] - L2[i - 1] + m + 1);
			ll res2 = suf[s - R2[i] + m].getmx(m + 1 - R2[i] + L2[i - 1]);
			dp[s] = max({ dp[s], res1 + d[i], res2 + d[i] });
			if (L2[q] + R2[i] - s >= 0 && L2[q] + R2[i] - s <= m) ans[L2[q] + R2[i] - s] = max(ans[L2[q] + R2[i] - s], dp[s]);
		}
		for (int s = 0; s <= m; s++) {
			if (dp[s] <= -1e12) continue;
			pre[s - L2[i - 1] + m].update(R2[i] - L2[i - 1] + m + 1, dp[s]);
			suf[s - R2[i] + m].update(m + 1 - R2[i] + L2[i - 1], dp[s]);
		}
	}
	for (int i = 1; i <= m; i++) {
		ans[i] = max(ans[i - 1], ans[i]);
		cout << ans[i] << " \n"[i == m];
	}
	return;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		solve();
	}
}
Code (Solution 2, C++)
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pb push_back
#define pii pair<int, int>
#define all(a) a.begin(), a.end()
const int mod = 1e9 + 7, N = 5005;

void solve() {
    int n, m, V;
    cin >> n >> m >> V;
    vector <int> c(n);
    for (int i = 0; i < n; ++i) {
        cin >> c[i];
    }
    vector <int> pre(n + 1);
    for (int i = 0; i < m; ++i) {
        char x; int v; cin >> x >> v, --v;
        if (x == 'L') {
            pre[0]++, pre[v + 1]--;
        } else {
            pre[v]++;
        }
    }
    for (int i = 0; i < n; ++i) {
        pre[i + 1] += pre[i];
    }
    vector <pair <ll, int>> vec;
    for (int i = 0, j = 0; i < n; i = j) {
        ll tot = 0;
        while (j < n && pre[i] == pre[j]) {
            tot += c[j], j++;
        }
        if (pre[i] <= V) {
            vec.emplace_back(tot, pre[i]);
        }
    }

    vector bit(V + 5, vector <ll>(V + 5, -1ll << 60));
    auto upd = [&](int x, int y, ll v) {
        for (int i = x + 1; i < V + 5; i += i & (-i)) {
            for (int j = y + 1; j < V + 5; j += j & (-j)) {
                bit[i][j] = max(bit[i][j], v);
            }
        }
    };
    auto query = [&](int x, int y) {
        ll ans = -1ll << 60;
        for (int i = x + 1; i > 0; i -= i & (-i)) {
            for (int j = y + 1; j > 0; j -= j & (-j)) {
                ans = max(ans, bit[i][j]);
            }
        }
        return ans;
    };

    upd(0, 0, 0);
    vector <ll> tmp(V + 1);
    for (auto [val, diff] : vec) {
        for (int i = 0; i + diff <= V; ++i) {
            tmp[i] = query(i, i + diff);
        }
        for (int i = 0; i + diff <= V; ++i) {
            upd(i, i + diff, tmp[i] + val);
        }
    }

    for (int i = 1; i <= V; ++i) {
        cout << query(i, i) << " \n"[i == V];
    }
}

int main() {
    ios::sync_with_stdio(false), cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
Bonus
Solve the problem in $$$\mathcal{O}(V^2)$$$.
--------------------------------------------------
Problem ID: 2029F
Editorial Content:
2029F - Palindrome Everywhere
Hint 1
If there are both consecutive $$$\texttt{R}$$$-s and $$$\texttt{B}$$$-s, does the condition hold for all $$$(i,j)$$$? Why?
Hint 2
Suppose that there are only consecutive $$$\texttt{R}$$$-s, check the parity of the number of $$$\texttt{R}$$$-s in each consecutive segment of $$$\texttt{R}$$$-s.
Hint 3
If for each consecutive segment of $$$\texttt{R}$$$-s, the parity of the number of $$$\texttt{R}$$$-s is odd, does the condition hold for all $$$(i,j)$$$? Why?
Hint 4
If for at least two of the consecutive segments of $$$\texttt{R}$$$-s, the parity of the number of $$$\texttt{R}$$$-s is even, does the condition hold for all $$$(i,j)$$$? Why?
Hint 5
Is this the necessary and sufficient condition? Why?
Hint 6
Don't forget some trivial cases like $$$\texttt{RRR...RB}$$$ and $$$\texttt{RRR...R}$$$.
Solution
For each $$$k>n$$$ or $$$k\leq0$$$, let $$$c_k$$$ be $$$c_{k\bmod n}$$$.
Lemma 1
: If there are both consecutive $$$\texttt{R}$$$-s and $$$\texttt{B}$$$-s, the answer is
NO
.
Proof 1
: Suppose that $$$c_{i-1}=c_i=\texttt{R}$$$ and $$$c_{j-1}=c_j=\texttt{B}$$$, it's obvious that there doesn't exist a palindrome route between $$$i$$$ and $$$j$$$.
Imagine there are two persons on vertex $$$i$$$ and $$$j$$$. They want to meet each other (they are on the same vertex or adjacent vertex) and can only travel through an edge of the same color.
Lemma 2
: Suppose that there are only consecutive $$$\texttt{R}$$$-s, if for each consecutive segment of $$$\texttt{R}$$$-s, the parity of the number of $$$\texttt{R}$$$-s is odd, the answer is
NO
.
Proof 2
: Suppose that $$$c_i=c_j=\texttt{B}$$$, $$$i\not\equiv j\pmod n$$$ and $$$c_{i+1}=c_{i+2}=\dots=c_{j-1}=\texttt{R}$$$. The two persons on $$$i$$$ and $$$j$$$ have to "cross" $$$\texttt{B}$$$ simultaneously. As for each consecutive segment of $$$\texttt{R}$$$-s, the parity of the number of $$$\texttt{R}$$$-s is odd, they can only get to the same side of their current consecutive segment of $$$\texttt{R}$$$-s. After "crossing" $$$\texttt{B}$$$, they will still be on different consecutive segments of $$$\texttt{R}$$$-s separated by exactly one $$$\texttt{B}$$$ and can only get to the same side. Thus, they will never meet.
Lemma 3
: Suppose that there are only consecutive $$$\texttt{R}$$$-s, if, for at least two of the consecutive segments of $$$\texttt{R}$$$-s, the parity of the number of $$$\texttt{R}$$$-s is even, the answer is
NO
.
Proof 3
: Suppose that $$$c_i=c_j=\texttt{B}$$$, $$$i\not\equiv j \pmod n$$$ and vertex $$$i$$$ and $$$j$$$ are both in a consecutive segment of $$$\texttt{R}$$$-s with even number of $$$\texttt{R}$$$-s. Let the starting point of two persons be $$$i$$$ and $$$j-1$$$ and they won't be able to "cross" and $$$\texttt{B}$$$. Thus, they will never meet.
The only case left is that there is exactly one consecutive segment of $$$\texttt{R}$$$-s with an even number of $$$\texttt{R}$$$-s.
Lemma 4
: Suppose that there are only consecutive $$$\texttt{R}$$$-s, if, for exactly one of the consecutive segments of $$$\texttt{R}$$$-s, the parity of the number of $$$\texttt{R}$$$-s is even, the answer is
YES
.
Proof 4
: Let the starting point of the two persons be $$$i,j$$$. Consider the following cases:
Case 1
: If vertex $$$i$$$ and $$$j$$$ are in the same consecutive segment of $$$\texttt{R}$$$-s, the two persons can meet each other by traveling through the $$$\texttt{R}$$$-s between them.
Case 2
: If vertex $$$i$$$ and $$$j$$$ are in the different consecutive segment of $$$\texttt{R}$$$-s and there are odd numbers of $$$\texttt{R}$$$-s in both segments, the two person may cross $$$\texttt{B}$$$-s in the way talked about in
Proof 2
. However, when one of them reaches a consecutive segment with an even number of $$$\texttt{R}$$$-s, the only thing they can do is let the one in an even segment cross the whole segment and "cross" the next $$$\texttt{B}$$$ in the front, while letting the other one traveling back and forth and "cross" the $$$\texttt{B}$$$ he just "crossed". Thus, unlike the situation in
Proof 2
, we successfully changed the side they can both get to and thus they will be able to meet each other as they are traveling toward each other and there are only odd segments between them.
Case 3
: If vertex $$$i$$$ and $$$j$$$ are in the different consecutive segment of $$$\texttt{R}$$$-s and there are an odd number of $$$\texttt{R}$$$-s in exactly one of the segments, we can let both of them be in one side of there segments and change the situation to the one we've discussed about in
Case 2
(when one of them reached a consecutive segment with even number of $$$\texttt{R}$$$-s).
As a result, the answer is
YES
if:
At least $$$n-1$$$ of $$$c_1,c_2,\dots,c_n$$$ are the same (Hint 6), or
Suppose that there are only consecutive $$$\texttt{R}$$$-s, there's exactly one of the consecutive segments of $$$\texttt{R}$$$-s such that the parity of the number of $$$\texttt{R}$$$-s is even.
And we can judge them in $$$\mathcal{O}(n)$$$ time complexity.
Code (C++)
#include <bits/stdc++.h>
using namespace std;
void solve(){
	int n; cin>>n;
	string s; cin>>s;
	int visr=0,visb=0,ok=0; 
	for(int i=0;i<n;i++){
		if(s[i]==s[(i+1)%n]){
			if(s[i]=='R') visr=1;
			else visb=1;
			ok++;
		}
	}
	if(visr&visb){
		cout<<"NO\n";
		return ;
	}
	if(ok==n){
		cout<<"YES\n";
		return ;
	}
	if(visb) for(int i=0;i<n;i++) s[i]='R'+'B'-s[i];
	int st=0;
	for(int i=0;i<n;i++) if(s[i]=='B') st=(i+1)%n;
	vector<int> vc;
	int ntot=0,cnt=0;
	for(int i=0,j=st;i<n;i++,j=(j+1)%n){
		if(s[j]=='B') vc.push_back(ntot),cnt+=(ntot&1)^1,ntot=0;
		else ntot++;
	}
	if(vc.size()==1||cnt==1){
		cout<<"YES\n";
		return ;
	}
	cout<<"NO\n";
	return ;
}
signed main(){
	int t; cin>>t;
	while(t--) solve();
	return 0;
}
Bonus 1
Count the number of strings of length $$$n$$$ satisfying the condition.
Bonus 2
Solve the problem for $$$c_i\in\{\texttt{A},\texttt{B},\dots,\texttt{Z}\}$$$, and solve the counting version.
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2029E
Editorial Content:
2029E - Common Generator
Hint 1
$$$2$$$ is powerful.
Hint 2
Consider primes.
Hint 3
How did you prove that $$$2$$$ can generate every integer except odd primes? Can you generalize it?
Solution
In this problem, we do not take the integer $$$1$$$ into consideration.
Claim 1.
$$$2$$$ can generate every integer except odd primes.
Proof.
For a certain non-prime $$$x$$$, let $$$\operatorname{mind}(x)$$$ be the minimum divisor of $$$x$$$. Then $$$x-\operatorname{mind}(x)$$$ must be an even number, which is $$$\ge 2$$$. So $$$x-\operatorname{mind}(x)$$$ can be generated by $$$2$$$, and $$$x$$$ can be generated by $$$x-\operatorname{mind}(x)$$$. Thus, $$$2$$$ is a generator of $$$x$$$.
Claim 2.
Primes can only be generated by themselves.
According to the above two claims, we can first check if there exist primes in the array $$$a$$$. If not, then $$$2$$$ is a common generator. Otherwise, let the prime be $$$p$$$, the only possible generator should be $$$p$$$ itself. So we only need to check whether $$$p$$$ is a generator of the rest integers.
For an even integer $$$x$$$, it is easy to see that, $$$p$$$ is a generator of $$$x$$$ if and only if $$$x\ge 2\cdot p$$$.
Claim 3.
For a prime $$$p$$$ and an odd integer $$$x$$$, $$$p$$$ is a generator of $$$x$$$ if and only if $$$x - \operatorname{mind}(x)\ge 2\cdot p$$$.
Proof.
First, $$$x-\operatorname{mind}(x)$$$ is the largest integer other than $$$x$$$ itself that can generate $$$x$$$. Moreover, only even numbers $$$\ge 2\cdot p$$$ can be generated by $$$p$$$ ($$$x-\operatorname{mind}(x)$$$ is even). That ends the proof.
Thus, we have found a good way to check if a certain number can be generated from $$$p$$$. We can use the linear sieve to pre-calculate all the $$$\operatorname{mind}(i)$$$-s.
Time complexity: $$$\mathcal{O}(\sum n+V)$$$, where $$$V=\max a_i$$$.
Some other solutions with worse time complexity can also pass, such as $$$\mathcal{O}(V\log V)$$$ and $$$\mathcal{O}(t\sqrt{V})$$$.
Code (C++)
#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;

const int _N = 4e5 + 5;

int vis[_N], pr[_N], cnt = 0;

void init(int n) {
	vis[1] = 1;
	for (int i = 2; i <= n; i++) {
		if (!vis[i]) {
			pr[++cnt] = i;
		}
		for (int j = 1; j <= cnt && i * pr[j] <= n; j++) {
			vis[i * pr[j]] = pr[j];
			if (i % pr[j] == 0) continue;
		}
	}
}

int T;

void solve() {
	int n; cin >> n;
	vector<int> a(n + 1);
	for (int i = 1; i <= n; i++) cin >> a[i];
	int p = 0;
	for (int i = 1; i <= n; i++) {
		if (!vis[a[i]]) p = a[i];
	}
	if (!p) {
		cout << 2 << '\n';
		return;
	}
	for (int i = 1; i <= n; i++) {
		if (a[i] == p) continue;
		if (vis[a[i]] == 0) {
			cout << -1 << '\n';
			return;
		}
		if (a[i] & 1) {
			if (a[i] - vis[a[i]] < 2 * p) {
				cout << -1 << '\n';
				return;
			}
		} else {
			if (a[i] < 2 * p) {
				cout << -1 << '\n';
				return;
			}
		}
	}
	cout << p << '\n';
	return;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	init(400000);
	cin >> T;
	while (T--) {
		solve();
	}
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2029D
Editorial Content:
2029D - Cool Graph
Hint 1
Try to make the graph into a forest first.
Hint 2
($$$deg_i\le 1$$$ for every $$$i$$$) $$$\Longrightarrow$$$ (The graph is a forest).
Solution
Let $$$d_i$$$ be the degree of vertex $$$i$$$.
First, we keep doing the following until it is impossible:
Choose a vertex $$$u$$$ with $$$d_u\ge 2$$$, then find any two vertices $$$v,w$$$ adjacent to $$$u$$$. Perform the operation on $$$(u,v,w)$$$.
Since each operation decreases the number of edges by at least $$$1$$$, at most $$$m$$$ operations will be performed. After these operations, $$$d_i\le 1$$$ holds for every $$$i$$$. Thus, the resulting graph consists only of components with size $$$\le 2$$$.
If there are no edges, the graph is already
cool
, and we don't need to do any more operations.
Otherwise, let's pick an arbitrary edge $$$(u,v)$$$ as the base of the final tree, and then merge everything else to it.
For a component with size $$$=1$$$ (i.e. it is a single vertex $$$w$$$), perform the operation on $$$(u, v, w)$$$, and set $$$(u, v) \gets (u, w)$$$.
For a component with size $$$=2$$$ (i.e. it is an edge connecting $$$a$$$ and $$$b$$$), perform the operation on $$$(u, a, b)$$$.
It is clear that the graph is transformed into a tree now.
The total number of operations won't exceed $$$n+m\le 2\cdot \max(n,m)$$$.
In the author's solution, we used some data structures to maintain the edges, thus, the time complexity is $$$\mathcal{O}(n+m\log m)$$$ per test case.
Code (C++)
#include <bits/stdc++.h>
using namespace std;
#ifdef DEBUG
#include "debug.hpp"
#else
#define debug(...) (void)0
#endif

using i64 = int64_t;
constexpr bool test = false;

int main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  int t;
  cin >> t;
  for (int ti = 0; ti < t; ti += 1) {
    int n, m;
    cin >> n >> m;
    vector<set<int>> adj(n + 1);
    for (int i = 0, u, v; i < m; i += 1) {
      cin >> u >> v;
      adj[u].insert(v);
      adj[v].insert(u);
    }
    vector<tuple<int, int, int>> ans;
    for (int i = 1; i <= n; i += 1) {
      while (adj[i].size() >= 2) {
        int u = *adj[i].begin();
        adj[i].erase(adj[i].begin());
        int v = *adj[i].begin();
        adj[i].erase(adj[i].begin());
        adj[u].erase(i);
        adj[v].erase(i);
        ans.emplace_back(i, u, v);
        if (adj[u].contains(v)) {
          adj[u].erase(v);
          adj[v].erase(u);
        } else {
          adj[u].insert(v);
          adj[v].insert(u);
        }
      }
    }
    vector<int> s;
    vector<pair<int, int>> p;
    for (int i = 1; i <= n; i += 1) {
      if (adj[i].size() == 0) {
        s.push_back(i);
      } else if (*adj[i].begin() > i) {
        p.emplace_back(i, *adj[i].begin());
      }
    }
    if (not p.empty()) {
      auto [x, y] = p.back();
      p.pop_back();
      for (int u : s) {
        ans.emplace_back(x, y, u);
        tie(x, y) = pair(x, u);
      }
      for (auto [u, v] : p) {
        ans.emplace_back(y, u, v);
      }
    }
    println("{}", ans.size());
    for (auto [x, y, z] : ans) println("{} {} {}", x, y, z);
  }
}
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2029C
Editorial Content:
2029C - New Rating
Solution 1 (with hints)
Hint 1
Binary search.
Hint 2
Do something backward.
Solution
First, do binary search on the answer. Suppose we're checking whether the answer can be $$$\ge k$$$ now.
Let $$$f_i$$$ be the current rating after participating in the $$$1$$$-st to the $$$i$$$-th contest (without skipping).
Let $$$g_i$$$ be the minimum rating before the $$$i$$$-th contest to make sure that the final rating is $$$\ge k$$$ (without skipping).
$$$f_i$$$-s can be calculated easily by simulating the process in the statement. For $$$g_i$$$-s, it can be shown that
$$$ g_i= \begin{cases} g_{i+1}-1, & a_i\ge g_{i+1}\\ g_{i+1}+1, & a_i< g_{i+1} \end{cases} $$$
where $$$g_{n+1}=k$$$.
Then, we should check if there exists an interval $$$[l,r]$$$ ($$$1\le l\le r\le n$$$), such that $$$f_{l-1}\ge g_{r+1}$$$. If so, we can choose to skip $$$[l,r]$$$ and get a rating of $$$\ge k$$$. Otherwise, it is impossible to make the rating $$$\ge k$$$.
We can enumerate on $$$r$$$ and use a prefix max to check whether valid $$$l$$$ exists.
Time complexity: $$$\mathcal{O}(n\log n)$$$ per test case.
Hint 1
Binary search.
Hint 2
Do something backward.
Solution
First, do binary search on the answer. Suppose we're checking whether the answer can be $$$\ge k$$$ now.
Let $$$f_i$$$ be the current rating after participating in the $$$1$$$-st to the $$$i$$$-th contest (without skipping).
Let $$$g_i$$$ be the minimum rating before the $$$i$$$-th contest to make sure that the final rating is $$$\ge k$$$ (without skipping).
$$$f_i$$$-s can be calculated easily by simulating the process in the statement. For $$$g_i$$$-s, it can be shown that
$$$ g_i= \begin{cases} g_{i+1}-1, & a_i\ge g_{i+1}\\ g_{i+1}+1, & a_i< g_{i+1} \end{cases} $$$
where $$$g_{n+1}=k$$$.
Then, we should check if there exists an interval $$$[l,r]$$$ ($$$1\le l\le r\le n$$$), such that $$$f_{l-1}\ge g_{r+1}$$$. If so, we can choose to skip $$$[l,r]$$$ and get a rating of $$$\ge k$$$. Otherwise, it is impossible to make the rating $$$\ge k$$$.
We can enumerate on $$$r$$$ and use a prefix max to check whether valid $$$l$$$ exists.
Time complexity: $$$\mathcal{O}(n\log n)$$$ per test case.
Solution 2 (with hints)
Hint 1
Consider DP.
Hint 2
There are only three possible states for each contest: before, in, or after the skipped interval.
Solution
Consider $$$dp_{i,0/1/2}=$$$ the maximum rating after the $$$i$$$-th contest, where the $$$i$$$-th contest is before/in/after the skipped interval.
Let $$$f(a,x)=$$$ the result rating when current rating is $$$a$$$ and the performance rating is $$$x$$$, then
$$$ \begin{cases} dp_{i,0} = f(dp_{i-1,0}, a_i),\\ dp_{i,1} = \max(dp_{i-1,1}, dp_{i-1,0}), \\ dp_{i,2} = \max(f(dp_{i-1,1}, a_i), f(dp_{i-1,2}, a_i)). \end{cases} $$$
And the final answer is $$$\max(dp_{n,1}, dp_{n,2})$$$.
Time complexity: $$$\mathcal{O}(n)$$$ per test case.
Hint 1
Consider DP.
Hint 2
There are only three possible states for each contest: before, in, or after the skipped interval.
Solution
Consider $$$dp_{i,0/1/2}=$$$ the maximum rating after the $$$i$$$-th contest, where the $$$i$$$-th contest is before/in/after the skipped interval.
Let $$$f(a,x)=$$$ the result rating when current rating is $$$a$$$ and the performance rating is $$$x$$$, then
$$$ \begin{cases} dp_{i,0} = f(dp_{i-1,0}, a_i),\\ dp_{i,1} = \max(dp_{i-1,1}, dp_{i-1,0}), \\ dp_{i,2} = \max(f(dp_{i-1,1}, a_i), f(dp_{i-1,2}, a_i)). \end{cases} $$$
And the final answer is $$$\max(dp_{n,1}, dp_{n,2})$$$.
Time complexity: $$$\mathcal{O}(n)$$$ per test case.
Code (Solution 1, C++)
#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;

const int _N = 1e5 + 5;

int T;

void solve() {
	int n; cin >> n;
	vector<int> a(n + 1);
	for (int i = 1; i <= n; i++) cin >> a[i];
	vector<int> pre(n + 1);
	int curf = 0;
	for (int i = 1; i <= n; i++) {
		if (curf < a[i]) curf++;
		else if (curf > a[i]) curf--;
		pre[i] = max(pre[i - 1], curf);
	}
	auto check = [&](int k) {
		int curg = k;
		for (int i = n; i >= 1; i--) {
			if (pre[i - 1] >= curg) return true;
			if (a[i] < curg) curg++;
			else curg--;
		}
		return false;
	};
	int L = 0, R = n + 1;
	while (L < R) {
		int mid = (L + R + 1) >> 1;
		if (check(mid)) L = mid;
		else R = mid - 1;
	}
	cout << L << '\n';
	return;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		solve();
	}
}
Code (Solution 2, Python 3)
for _ in range(int(input())):
    n = int(input())
    
    def f(a, x):
        return a + (a < x) - (a > x)
    
    dp = [0, -n, -n]
    for x in map(int, input().split()):
        dp[2] = max(f(dp[1], x), f(dp[2], x))
        dp[1] = max(dp[1], dp[0])
        dp[0] = f(dp[0], x)

    print(max(dp[1], dp[2]))
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2029B
Editorial Content:
2029B - Replacement
Hint
($$$\texttt{01}$$$ or $$$\texttt{10}$$$ exists) $$$\Longleftrightarrow$$$ (both $$$\texttt{0}$$$ and $$$\texttt{1}$$$ exist).
Solution
Each time we do an operation, if $$$s$$$ consists only of $$$\texttt{0}$$$ or $$$\texttt{1}$$$, we surely cannot find any valid indices. Otherwise, we can always perform the operation successfully. In the $$$i$$$-th operation, if $$$t_i=\texttt{0}$$$, we actually decrease the number of $$$\texttt{1}$$$-s by $$$1$$$, and vice versa. Thus, we only need to maintain the number of $$$\texttt{0}$$$-s and $$$\texttt{1}$$$-s in $$$s$$$. If any of them falls to $$$0$$$ before the last operation, the answer is
NO
, otherwise, the answer is
YES
.
Time complexity: $$$\mathcal{O}(n)$$$ per test case.
Code (C++)
#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()

using namespace std;
using ll = long long;

const int _N = 1e5 + 5;

void solve() {
	int n; cin >> n;
	string s, t; cin >> s >> t;
	int cnt0 = count(all(s), '0'), cnt1 = n - cnt0;
	for (int i = 0; i < n - 1; i++) {
		if (cnt0 == 0 || cnt1 == 0) {
			cout << "NO" << '\n';
			return;
		}
		if (t[i] == '1') cnt0--;
		else cnt1--;
	}
	cout << "YES" << '\n';
}

int main() {
	int T; cin >> T;
	while (T--) {
		solve();
	}
}
Code (Python 3)
for _ in range(int(input())):
    n = int(input())
    s = input()
    one = s.count("1")
    zero = s.count("0")
    ans = "YES"
    for ti in input():
        if one == 0 or zero == 0:
            ans = "NO"
            break
        one -= 1
        zero -= 1
        if ti == "1":
            one += 1
        else:
            zero += 1
    print(ans)
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2029A
Editorial Content:
2029A - Set
Hint
Greedy from small to large.
Solution
We can delete the numbers from small to large. Thus, previously removed numbers will not affect future choices (if $$$x<y$$$, then $$$x$$$ cannot be a multiple of $$$y$$$). So an integer $$$x$$$ ($$$l\le x\le r$$$) can be removed if and only if $$$k\cdot x\le r$$$, that is, $$$x\le \left\lfloor\frac{r}{k}\right\rfloor$$$. The answer is $$$\max\left(\left\lfloor\frac{r}{k}\right\rfloor-l+1,0\right)$$$.
Time complexity: $$$\mathcal{O}(1)$$$ per test case.
Code (C++)
#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;
 
const int _N = 1e5 + 5;
 
int T;
 
void solve() {
	int l, r, k; cin >> l >> r >> k;
	cout << max(r / k - l + 1, 0) << endl;
	return;
}
 
int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		solve();
	}
}
Code (Python 3)
for _ in range(int(input())):
    l, r, k = map(int, input().split())
    print(max(r // k - l + 1, 0))
Rate the Problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 2028F
Editorial Content:
2028F - Приключения Алисы в сложении
Hint 1
Come up with a DP algorithm running in time $$$O(n^2 m)$$$.
Hint 2
Try optimizing the Hint 1 DP to run in time $$$O(nm \log m)$$$ when $$$a_i \ge 2$$$ for all $$$i$$$.
Hint 3
Do some casework to extend Hint 2 to $$$a_i \ge 0$$$.
Hint 4
Bitset
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using ld = long double;
using pii = pair<int, int>;
using vi = vector<int>;
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()
#define smx(a, b) a = max(a, b)
#define smn(a, b) a = min(a, b)
#define pb push_back
#define endl '\n'

const ll MOD = 1e9 + 7;
const ld EPS = 1e-9;

mt19937 rng(time(0));

const int LOG = 14;
const int MAX = 10000 + 1;

int main() {
    cin.tie(0)->sync_with_stdio(0);
 
    int t; cin >> t;
    while (t--) {
        int n, m; cin >> n >> m;
        bitset<MAX> prev(1), pfx(1), zero(0);
        list<pair<int, bitset<MAX>>> q;
        rep(i,0,n) {
            int x; cin >> x;
            bitset<MAX> curr = zero;

            if (x == 0) {
                curr |= pfx;
                zero = curr;
                q.push_front({0, prev});
            } else if (x == 1) {
                curr |= prev | (prev << 1);
            } else {
                int prod = 1;
                q.push_front({x, prev});
                for (auto const& val : q) {
                    if (prod == 0 || prod * val.first > m) break;
                    prod *= val.first;
                    curr |= val.second << prod;
                }
            }
            pfx |= curr;
            prev = curr;
            if (sz(q) > LOG) q.pop_back();
        }

        cout << (prev[m] ? "YES" : "NO") << "\n";
    }
}
--------------------------------------------------
Problem ID: 2028E
Editorial Content:
2028E - Приключения Алисы в кроличьей норе
Hint 1
What are Alice's and the Red Queen's optimal moves at a given position?
Hint 2
Solve the problem for a path (bamboo) of length $$$n$$$ first.
Hint 3
Solve Hint 2 first. Now, generalize the solution to an arbitrary tree.
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
 
using ll = long long;
using ld = long double;
using pii = pair<int, int>;
using vi = vector<int>;
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()
#define smx(a, b) a = max(a, b)
#define smn(a, b) a = min(a, b)
#define pb push_back
#define endl '\n'
 
const ll MOD = 1e9 + 7;
const ld EPS = 1e-9;
 
// mt19937 rng(time(0));
 
ll euclid(ll a, ll b, ll &x, ll &y) {
	if (!b) return x = 1, y = 0, a;
	ll d = euclid(b, a % b, y, x);
	return y -= a/b * x, d;
}
 
const ll mod = 998244353;
struct mint {
	ll x;
	mint(ll xx) : x(xx) {}
	mint operator+(mint b) { return mint((x + b.x) % mod); }
	mint operator-(mint b) { return mint((x - b.x + mod) % mod); }
	mint operator*(mint b) { return mint((x * b.x) % mod); }
	mint operator/(mint b) { return *this * invert(b); }
	mint invert(mint a) {
		ll x, y, g = euclid(a.x, mod, x, y);
		assert(g == 1); return mint((x + mod) % mod);
	}
	mint operator^(ll e) {
		if (!e) return mint(1);
		mint r = *this ^ (e / 2); r = r * r;
		return e&1 ? *this * r : r;
	}
};
 
void solve() {
	int n; cin >> n;
	vector<vector<int>> t(n);
	rep(i,0,n-1) {
		int x, y; cin >> x >> y; --x, --y;
		t[x].push_back(y);
		t[y].push_back(x);
	}
 
	vector<int> d(n, n + 1);
	function<int(int, int)> depths = [&](int curr, int par) {
		for (auto v : t[curr]) {
			if (v == par) continue;
			d[curr] = min(d[curr], 1 + depths(v, curr));
		}
		if (d[curr] > n) d[curr] = 0;
		return d[curr];
	};
 
	depths(0, -1);
 
	vector<mint> ans(n, 0);
	function<void(int, int, mint)> dfs = [&](int curr, int par, mint val) {
		ans[curr] = val;
		for (auto v : t[curr]) {
			if (v == par) continue;
			dfs(v, curr, val * d[v] / (d[v] + 1));
		}
	};
 
	dfs(0, -1, mint(1));
	for (auto x : ans) {
		cout << x.x << " ";
	}
	cout << "\n";
}
 
int main() {
	cin.tie(0)->sync_with_stdio(0);
 
	int t; cin >> t;
	while (t--) solve();
}
--------------------------------------------------
Problem ID: 2028D
Editorial Content:
2028D - Приключения Алисы в картах
Hint
This is not a graph problem. Try to think about for each card $$$i$$$ whether Alice can ever trade up from $$$i$$$ to $$$n$$$.
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
 
using ll = long long;
using ld = long double;
using pii = pair<int, int>;
using vi = vector<int>;
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()
#define smx(a, b) a = max(a, b)
#define smn(a, b) a = min(a, b)
#define pb push_back
#define endl '\n'
 
const ll MOD = 1e9 + 7;
const ld EPS = 1e-9;
 
mt19937 rng(time(0));
 
int main() {
	cin.tie(0)->sync_with_stdio(0);
 
	int t; cin >> t;
	std::string s = "qkj";
	while (t--) {
		int n; cin >> n;
		vector p(3, vector<int>(n + 1));
		rep(i,0,3) rep(j,1,n + 1) cin >> p[i][j];
		vector<pair<char, int>> sol(n + 1, {'\0', -1});
		array<int, 3> mins = {n, n, n}; // minimizing index
		for (int i = n - 1; i >= 1; i--) {
			int win = -1;
			rep(j,0,3) if (p[j][i] > p[j][mins[j]]) win = j;
			if (win == -1) continue;
			sol[i] = {s[win], mins[win]};
			rep(j,0,3) if (p[j][i] < p[j][mins[j]]) mins[j] = i;
		}
		if (sol[1].second == -1) {
			cout << "NO\n";
			continue;
		}
		cout << "YES\n";
		vector<pair<char, int>> ans = {sol[1]};
		while (ans.back().second >= 0) {
			ans.push_back(sol[ans.back().second]);
		}
		ans.pop_back();
		cout << sz(ans) << "\n";
		for (auto && [c, i] : ans) {
			cout << c << " " << i << "\n";
		}
	}
}
Bonus
Solve the same problem, but now with the additional requirement that the solution must use the minimum number of trades (same constraints).
--------------------------------------------------
Problem ID: 2028C
Editorial Content:
2028C - Приключения Алисы в нарезании торта
Hint 1
How can you quickly determine if Alice can ever receive the piece $$$a[i:j] = [a_i, a_{i+1}, \ldots, a_{j-1}]$$$?
Hint 2
For a given $$$i$$$, how can you quickly check the maximum $$$j$$$ such that Alice can receive the piece $$$a[i:j]$$$?
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
 
using ll = long long;
using ld = long double;
using pii = pair<int, int>;
using vi = vector<int>;
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()
#define smx(a, b) a = max(a, b)
#define smn(a, b) a = min(a, b)
#define pb push_back
#define endl '\n'
 
const ll MOD = 1e9 + 7;
const ld EPS = 1e-9;
 
mt19937 rng(time(0));
 
int main() {
	cin.tie(0)->sync_with_stdio(0);
 
	int t; cin >> t;
	while (t--) {
		int n, m; cin >> n >> m;
		ll v; cin >> v;
		vector<ll> a(n);
		rep(i,0,n) cin >> a[i];
 
		vector<ll> sums(n + 1);
		rep(i,0,n) sums[i + 1] = sums[i] + a[i];
 
		auto query = [&](int i, int j) { // [i, j)
			return sums[j] - sums[i];
		};
 
		auto compute_pfx = [&]() -> vector<int> {
			vector<int> pfx(n + 1, 0);
			int end = 0, val = 0;
			ll sum = 0;
			for (int start = 0; start < n; start++) {
				while (end < n && sum < v) {
					sum += a[end];
					++end;
					pfx[end] = max(pfx[end], pfx[end - 1]);
				}
				if (sum >= v) {
					pfx[end] = 1 + pfx[start];
				}
				sum -= a[start];
			}
			rep(i,1,n+1) {
				pfx[i] = max(pfx[i], pfx[i - 1]);
			}
			return pfx;
		};
 
		auto pfx = compute_pfx();
		reverse(all(a));
		auto sfx = compute_pfx();
		reverse(all(a));
		reverse(all(sfx));
 
		if (pfx[n] < m) {
			cout << "-1\n";
			continue;
		}
 
		int end = 0;
		ll ans = 0;
		for (int start = 0; start < n; start++) {
			while (end < n && pfx[start] + sfx[end + 1] >= m) ++end;
			if (pfx[start] + sfx[end] >= m)
				ans = max(ans, query(start, end));
		}
		cout << ans << "\n";
	}
}
--------------------------------------------------
Problem ID: 2028B
Editorial Content:
2028B - Приключения Алисы в перестановках
Hint
Do casework on whether $$$b = 0$$$ or not.
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
 
using ll = long long;
using ld = long double;
using pii = pair<int, int>;
using vi = vector<int>;
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()
#define smx(a, b) a = max(a, b)
#define smn(a, b) a = min(a, b)
#define pb push_back
#define endl '\n'
 
const ll MOD = 1e9 + 7;
const ld EPS = 1e-9;
 
mt19937 rng(time(0));
 
int main() {
	cin.tie(0)->sync_with_stdio(0);
 
	int t; cin >> t;
	while (t--) {
		ll n, b, c; cin >> n >> b >> c;
		if (b == 0) {
			if (c >= n) {
				cout << n << "\n";
			} else if (c >= n - 2) {
				cout << n - 1 << "\n";
			} else {
				cout << -1 << "\n";
			}
		} else {
		    if (c >= n) cout << n << "\n";
			else cout << n - max(0ll, 1 + (n - c - 1) / b) << "\n";
		}
	}
}
--------------------------------------------------
Problem ID: 2028A
Editorial Content:
2028A - Приключения Алисы в "Шахматах"
Hint
How many times do you have to repeat the string until you know for certain whether Alice will ever reach the Red Queen?
Solution
Tutorial is loading...
Code
def solve():
    [n, a, b] = list(map(int, input().split()))
    s = str(input())
    x, y = 0, 0
    for __ in range(100):
        for c in s:
            if c == 'N':
                y += 1
            elif c == 'E':
                x += 1
            elif c == 'S':
                y -= 1
            else:
                x -= 1
            if x == a and y == b:
                print("YES")
                return
    print("NO")
 
t = int(input())
 
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 2027E2
Editorial Content:
2027E2 - Bit Game (Hard Version)
Tutorial
Tutorial is loading...
Code
#include <bits/stdc++.h>
 
using namespace std;
        
int dp[32][32][6][2][2];
 
const int mod = 1000000007;
 
int main() {
  cin.tie(0)->sync_with_stdio(0);
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<int> A(n);
    for (int i=0; i<n; i++) cin >> A[i];
    vector<int> B(n);
    for (int i=0; i<n; i++) cin >> B[i];
    vector<int> curr(32);
    curr[0] = 1; // identity
    for (int i=0; i<n; i++) {
      memset(dp, 0, sizeof dp);
      dp[0][0][0][0][0] = 1;
      for (int j=0; j<=29; j++) {
        int p = 29 - j; // place we are going to add a bit in
        for (int k=0; k<=29; k++) { // position of most significant one in a'
          for (int type=0; type<6; type++) { // 0, 1, 11111, 11110, 10000, else
            for (int good=0; good<2; good++) { // good=1 iff good bit has occured
              for (int low=0; low<2; low++) { // low=1 iff prefix below b
                for (int bit=0; bit<2; bit++) { // bit in x
                  if (dp[j][k][type][good][low] == 0) 
                    continue; // no point in transition since count is 0
                  if (!low && (B[i] & (1 << p)) == 0 && bit == 1) 
                    continue; // x can't go higher than B[i]
                  if (bit == 0) {
                    int good2 = good || (A[i] & (1 << p)) != 0; // check good bit
                    int low2 = low || (B[i] & (1 << p)) != 0; // check if low
                    // nothing added to a' so nothing else changes
                    (dp[j+1][k][type][good2][low2] += dp[j][k][type][good][low]) %= mod;
                  } else {
                    int bita = good || (A[i] & (1 << p)) != 0; // bit in a'
                    int k2 = type == 0 ? 0 : k + 1; // increase if MSOne exists
                    int type2 = bita ?
                      (
                        type == 0 ? 1 : // add first one
                        (type == 1 || type == 2) ? 2 : // 11111
                        5 // can't add 1 after a 0
                      ) : (
                        (type == 0) ? 0 : // 0
                        (type == 1 || type == 4) ? 4 : // 10000
                        (type == 2) ? 3 : // 11110
                        5 // can't have a zero in any other case
                      );
                    (dp[j+1][k2][type2][good][low] += dp[j][k][type][good][low]) %= mod;
                  }
                }
              }
            }
          }
        } 
      }
      vector<int> count(32); // number of x-values for each nimber
      for (int k=0; k<=29; k++) { // position of MSOne
        for (int good=0; good<2; good++) { // doesn't matter
          for (int low=0; low<2; low++) { // doesn't matter
            (count[0] += dp[30][k][0][good][low]) %= mod; // 0
            (count[1] += dp[30][k][1][good][low]) %= mod; // 1
            (count[k+1] += dp[30][k][2][good][low]) %= mod; // 11111
            (count[0] += dp[30][k][3][good][low]) %= mod; // 11110
            (count[k+(k%2?-1:1)] += dp[30][k][4][good][low]) %= mod; // 10000
            (count[k+1] += dp[30][k][5][good][low]) %= mod; // else
          }
        }
      }
      count[0] -= 1; // remove when x=0
      vector<int> next(32); // knapsack after adding this pile
      for (int j=0; j<32; j++)
        for (int k=0; k<32; k++)
          (next[j ^ k] += 1LL * curr[j] * count[k] % mod) %= mod;
      swap(curr, next);
    }
    cout << curr[0] << "\n";
  }
  return 0;
}
--------------------------------------------------
Problem ID: 2027E1
Editorial Content:
2027E1 - Bit Game (Easy Version)
Tutorial
Tutorial is loading...
Code
#include <bits/stdc++.h>
 
using namespace std;
 
int nimber(int x, int a) {
  int aprime = 0;
  bool goodbit = false;
  for (int bit=30; bit>=0; bit--) {
    if (x & (1 << bit)) {
      aprime *= 2;
      if (goodbit || (a & (1 << bit))) {
        aprime += 1;
      }
    } else if (a & (1 << bit)) {
      goodbit = true;
    }
  }
 
  // g(2^k - 2) = 0, for all k >= 1.
  for (int k=1; k<=30; k++) {
    if (aprime == (1 << k) - 2) {
      return 0;
    }
  }
 
  // g(2^k - 1) = k, for all k >= 1.
  for (int k=1; k<=30; k++) {
    if (aprime == (1 << k) - 1) {
      return k;
    }
  }
 
  // g(2^k) = k + (-1)^k, for all k >= 0.
  for (int k=1; k<=30; k++) {
    if (aprime == (1 << k)) {
      if (k % 2) return k - 1;
      else return k + 1;
    }
  }
 
  // g(2^k+1) = g(2^k+2) = ... = g(2^{k+1} - 3) = k + 1, for all k >= 2.
  for (int k=2; k<=30; k++) {
    if ((1 << k) < aprime && aprime <= (2 << k) - 3) {
      return k + 1;
    }
  }
 
  // should never get to this point
  assert(false);
  return -1;
}
 
int main() {
  cin.tie(0)->sync_with_stdio(0);
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<int> A(n);
    for (int i=0; i<n; i++) cin >> A[i];
    vector<int> X(n);
    for (int i=0; i<n; i++) cin >> X[i];
    int curr = 0;
    for (int i=0; i<n; i++) curr ^= nimber(X[i], A[i]);
    cout << (curr ? "Alice" : "Bob") << "\n";
  }
  return 0;
}
--------------------------------------------------
Problem ID: 2027D2
Editorial Content:
2027D2 - The Endspeaker (Hard Version)
Tutorial
2027D2 - The Endspeaker (Hard Version)
Following on from the editorial for D1. Let's have the $$$\operatorname{dp}$$$ table store a pair of the minimum cost and the number of ways. Since we're now counting the ways, it's not enough just to consider the transition to $$$\operatorname{dp}_{r,j}$$$; we also need to transition to all $$$\operatorname{dp}_{x,j}$$$. Doing this naively is too slow, so let's instead find a way to perform range updates.
Let's say we want to range update $$$\operatorname{dp}_{l,j}, \operatorname{dp}_{l+1,j}, ..., \operatorname{dp}_{r,j}$$$. We'll store some updates in another table at either end of the range. Then, for a fixed value of $$$k$$$ as we iterate through increasing $$$i$$$-values, let's maintain a map of cost to ways. Whenever the number of ways falls to zero, we can remove it from the map. On each iteration, we can set $$$\operatorname{dp}_{i,j}$$$ to the smallest entry in the map, and then perform the transitions. This works in $$$\mathcal{O}(nm \log n)$$$.
Bonus: It's also possible to solve without the $$$\log n$$$ factor. We can use the fact that $$$\operatorname{dp}_{i,k}$$$ is non-increasing for a fixed value of $$$k$$$ to make the range updates non-intersecting by updating a range strictly after the previous iteration. Then we can just update a prefix sum array, instead of using a map.
2027D2 - The Endspeaker (Hard Version)
Code
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

const int inf = 1 << 30;
const int MOD = 1000000007;

int main() {
  cin.tie(0)->sync_with_stdio(0);
  int t;
  cin >> t;
  while (t--) {
    int n, m;
    cin >> n >> m;
    vector<int> A(n+1);
    for (int i=0; i<n; i++) cin >> A[i];
    vector<int> B(m);
    for (int i=0; i<m; i++) cin >> B[i];
    vector nxt(n, vector<int>(m));
    for (int k=0; k<m; k++) {
      int r = -1, sum = 0;
      for (int i=0; i<n; i++) {
        while (r < n && sum <= B[k]) sum += A[++r];
        nxt[i][k] = r;
        sum -= A[i];
      }
    }
    vector dp(n+1, vector<array<int,2>>(m, {inf, 0}));
    vector upd(n+1, vector(m, vector<array<int,3>>()));
    upd[0][0].push_back({0, 0, 1});
    upd[1][0].push_back({1, 0, 1});
    for (int k=0; k<m; k++) {
      map<int,array<int,2>> mp;
      for (int i=0; i<=n; i++) {
        for (auto [t, move, count] : upd[i][k]) {
          if (t == 0) {
            auto &[a, b] = mp[move];
            a += 1;
            (b += count) %= MOD;
          } else {
            auto &[a, b] = mp[move];
            a -= 1;
            (b += MOD - count) %= MOD;
            if (a == 0) mp.erase(move);
          }
        }
        if (mp.empty()) continue;
        auto &[move, info] = *mp.begin();
        dp[i][k] = {move, info[1]};
        if (i == n) continue;
        if (k < m-1) {
          upd[i][k+1].push_back({0, move, info[1]});
          upd[i+1][k+1].push_back({1, move, info[1]});
        }
        if (nxt[i][k] > i) {
          upd[i+1][k].push_back({0, move + (m - k - 1), info[1]});
          if (nxt[i][k] < n) {
            upd[nxt[i][k]+1][k].push_back({1, move + (m - k - 1), info[1]});
          }
        }
      }
    }
    map<int,int> mp;
    for (int k=0; k<m; k++) {
      auto &[move, count] = dp[n][k];
      (mp[move] += count) %= MOD;
    }
    auto &[move, count] = *mp.begin();
    if (move == inf) {
      cout << "-1\n";
    } else {
      cout << move << " " << count << "\n";
    }
  }
  return 0;
}
Tutorial (Segment Tree)
There exists an alternative solution for D1 & D2, using segment tree. We can actually consider the process in reverse; let's reformulate $$$\operatorname{dp}_{i,j}$$$ to represent the minimum score required to remove all elements after the $$$i$$$-th element, given that the current value of $$$k$$$ is $$$j$$$.
Instead of using a dp table, we maintain $$$m$$$ segment trees, each of length $$$n$$$. The $$$i$$$-th segment tree will represent the $$$i$$$-th column of the dp table.
We precalculate for each $$$i$$$ and $$$j$$$ the furthest position we can remove starting from $$$i$$$ — specifically, the maximum subarray starting from $$$i$$$ with a sum less than $$$b_j$$$. We store this in $$$\operatorname{nxt}_{i,j}$$$. This calculation can be done in $$$\mathcal{O}(nm)$$$ time using a sliding window.
To transition in the dp, we have:
$$$ \operatorname{dp}_{i,j} = \min\left( \operatorname{dp}_{i, j + 1}, \, \min(\operatorname{dp}_{i + 1, j}, \operatorname{dp}_{i + 2, j}, \ldots, \operatorname{dp}_{{\operatorname{nxt}_{i,j}}, j}) + m - j + 1 \right) $$$
This transition can be computed in $$$\mathcal{O}(\log n)$$$ time thanks to range querying on the segment tree, so our total complexity is $$$\mathcal{O}(nm \log n)$$$. For D2, we can store the count of minimums within each segment, and simply sum these counts to get the total number of ways.
Code (Segment Tree)
#include <bits/stdc++.h>
using namespace std;

#define int long long
int modN = 1e9 + 7;

int mod(int n) {
    return (n + modN) % modN;
}

struct SegmentTree { 
    struct Node {
        int val = 1e18;
        int cnt = 1;
    }; 
 
    vector<Node> st;
    int n;
    SegmentTree(int n): n(n) {
        st.resize(4 * n + 1, Node());
    }
 
    SegmentTree(vector<int> a): n(a.size()) {
        st.resize(4 * n + 1, Node());
        build(a, 1, 0, n - 1);
    }
 
    void merge(Node& a, Node& b, Node& c) {
        a.val = min(b.val, c.val);
        if (b.val == c.val)
            a.cnt = mod(b.cnt + c.cnt);
        else if (b.val < c.val)
            a.cnt = b.cnt;
        else if (b.val > c.val)
            a.cnt = c.cnt;
    }
 
    void build(vector<int>& a, int id, int l, int r) {
        if (l == r) {
            st[id].val = a[l];
            return;
        }
        int mid = (l + r) / 2;
        build(a, id * 2, l, mid);
        build(a, id * 2 + 1, mid + 1, r);
        merge(st[id], st[id * 2], st[id * 2 + 1]);
    }
 
    void update(int id, int l, int r, int u, int val, int cnt) {
        if (l == r) {
            st[id].val = val; // or st[id].sum += val
            st[id].cnt = cnt;
            return;
        }
        int mid = (l + r) / 2;
        if (u <= mid) update(id * 2, l, mid, u, val, cnt);
        else update(id * 2 + 1, mid + 1, r, u, val, cnt); 
        merge(st[id], st[id * 2], st[id * 2 + 1]);
    }
 
    void update(int idx, int val, int cnt) { //wrapper
        update(1, 0, n - 1, idx, val, cnt);
    }
 
    Node query(int id, int l, int r, int u, int v) { //give 0, n - 1 as l and r and 1 as id
        if (v < l || r < u) return Node();
        if (u <= l && r <= v) {
            return st[id];
        }
        int mid = (l + r) / 2;
        auto a = query(id * 2, l, mid, u, v);
        auto b = query(id * 2 + 1, mid + 1, r, u, v);
        Node res;
        merge(res, a, b);
        return res;
    }
 
    Node query(int l, int r) { //wrapper
        return query(1, 0, n - 1, l, r);
    }
};

void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> a(n), b(m);
    for (int &A : a) cin >> A;
    for (int &B : b) cin >> B;
    if (*max_element(a.begin(), a.end()) > b[0]) {
        cout << -1 << '\n';
        return;
    }
    vector<vector<int>> nxt(m, vector<int>(n));
    for (int i = 0; i < m; i++) {
        int curr = 0, r = -1;
        for (int j = 0; j < n; j++) {
            while (r + 1 < n && curr + a[r + 1] <= b[i]) 
                curr += a[r + 1], r += 1;
            nxt[i][j] = r + 1;
            if (j <= r) curr -= a[j];
            r = max(r, j);
        }
    }
    vector<SegmentTree> dp(m, SegmentTree(vector<int>(n + 1, 1e18)));
    for (int i = 0; i < m; i++)
        dp[i].update(n, 0, 1);
    for (int i = n - 1; i >= 0; i--) {
        for (int j = m - 1; j >= 0; j--) {
            auto q1 = dp[j].query(i + 1, nxt[j][i]);
            int v1 = q1.val + m - (j + 1), ps1 = q1.cnt;
            if (i + 1 <= nxt[j][i]) dp[j].update(i, v1, ps1); 
            if (j != m - 1) {
                auto q2 = dp[j + 1].query(i, i);
                int v2 = q2.val, ps2 = q2.cnt;
                auto q3 = dp[j].query(i, i);
                if (v2 < q3.val)
                    dp[j].update(i, v2, ps2);
                else if (v2 == q3.val)
                    dp[j].update(i, v2, mod(ps2 + q3.cnt));
            }
        }
    }
    cout << dp[0].query(0, 0).val << ' ' << dp[0].query(0, 0).cnt << '\n';
}

signed main() {
    cin.tie(0) -> sync_with_stdio(false);
    int t;  
    cin >> t;
    while (t--) 
       solve();
    return 0;
}
--------------------------------------------------
Problem ID: 2027D1
Editorial Content:
2027D1 - The Endspeaker (Easy Version)
Tutorial
2027D1 - The Endspeaker (Easy Version)
Let's use dynamic programming. We will have $$$\operatorname{dp}_{i,j}$$$ be the minimum cost to remove the prefix of length $$$i$$$, where the current value of $$$k$$$ is $$$j$$$. By a type $$$1$$$ operation, we can transition from $$$\operatorname{dp}_{i,j}$$$ to $$$\operatorname{dp}_{i,j+1}$$$ at no cost. Otherwise, by a type $$$2$$$ operation, we need to remove some contiguous subarray $$$a_{i+1}, a_{i+2}, \dots, a_{x}$$$ (a prefix of the current array), to transition to $$$\operatorname{dp}_{x,j}$$$ with a cost of $$$m - k$$$.
Let $$$r$$$ be the largest value of $$$x$$$ possible. Given we're spending $$$m - k$$$ whatever value of $$$x$$$ we choose, it's clear to see that we only need to transition to $$$\operatorname{dp}_{r,j}$$$. To find $$$r$$$ for each value of $$$i$$$ and $$$j$$$, we can either binary search over the prefix sums or simply maintain $$$r$$$ as we increase $$$i$$$ for a fixed value of $$$k$$$. The answer is then $$$\operatorname{dp}_{n,k}$$$. The latter method solves the problem in $$$\mathcal{O}(nm)$$$.
2027D1 - The Endspeaker (Easy Version)
Code
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

const int inf = 1 << 30;

void chmin(int &a, int b) {
  a = min(a, b);
}

int main() {
  cin.tie(0)->sync_with_stdio(0);
  int t;
  cin >> t;
  while (t--) {
    int n, m;
    cin >> n >> m;
    vector<int> A(n+1);
    for (int i=0; i<n; i++) cin >> A[i];
    vector<int> B(m);
    for (int i=0; i<m; i++) cin >> B[i];
    vector nxt(n, vector<int>(m));
    for (int k=0; k<m; k++) {
      int r = -1, sum = 0;
      for (int i=0; i<n; i++) {
        while (r < n && sum <= B[k]) sum += A[++r];
        nxt[i][k] = r;
        sum -= A[i];
      }
    }
    vector dp(n+1, vector<int>(m, inf));
    dp[0][0] = 0;
    for (int k=0; k<m; k++) {
      for (int i=0; i<n; i++) {
        chmin(dp[nxt[i][k]][k], dp[i][k] + m - k - 1);
        if (k < m-1)
          chmin(dp[i][k+1], dp[i][k]);
      }
    }
    int ans = inf;
    for (int k=0; k<m; k++) {
      chmin(ans, dp[n][k]);
    }
    if (ans == inf) {
      cout << "-1\n";
    } else {
      cout << ans << "\n";
    }
  }
  return 0;
}
--------------------------------------------------
Problem ID: 2027C
Editorial Content:
2027C - Add Zeros
Tutorial
Tutorial is loading...
Code
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

int main() {
  cin.tie(0)->sync_with_stdio(0);
  int t;
  cin >> t;
  while (t--) {
        int n;
        cin >> n;
        vector<ll> A(n);
        for (int i=0; i<n; i++) cin >> A[i];
        map<ll,vector<ll>> adj;
        for (int i=1; i<n; i++) {
            ll u = A[i] + i;
            ll v = u + i;
            adj[u].push_back(v);
        }
        set<ll> vis;
        function<void(ll)> dfs = [&](ll u) -> void {
            if (vis.count(u)) return;
            vis.insert(u);
            for (ll v : adj[u]) dfs(v);
        };
        dfs(n);
        cout << *vis.rbegin() << "\n";
  }
  return 0;
}
--------------------------------------------------
Problem ID: 2027B
Editorial Content:
2027B - Stalin Sort
Tutorial
Tutorial is loading...
Code
#include <bits/stdc++.h>

using namespace std;

int main() {
    cin.tie(0)->sync_with_stdio(0);
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> A(n);
        for (int i=0; i<n; i++) cin >> A[i];
        int best = 0;
        for (int i=0; i<n; i++) {
            int curr = 0;
            for (int j=i; j<n; j++) {
                if (A[j] <= A[i]) {
                    curr += 1;
                }
            }
            best = max(best, curr);
        }
        cout << n - best << "\n";
    }
  return 0;
}
--------------------------------------------------
Problem ID: 2027A
Editorial Content:
2027A - Rectangle Arrangement
Tutorial
Tutorial is loading...
Code
#include <bits/stdc++.h>

using namespace std;

int main() {
    cin.tie(0)->sync_with_stdio(0);
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        int maxw = 0, maxh = 0;
        for (int i=0; i<n; i++) {
            int w, h;
            cin >> w >> h;
            maxw = max(maxw, w);
            maxh = max(maxh, h);
        }
        cout << 2 * (maxw + maxh) << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2026F
Editorial Content:
2026F - Bermart Ice Cream
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
using namespace std;
 
const int P = 2000 + 5;
 
struct item{
	int p, t;
};
 
struct minstack {
	stack<item> st;
	stack<array<int, P>> dp;
	int get(int p) {return dp.empty() ? 0 : dp.top()[p];}
	bool empty() {return st.empty();}
	int size() {return st.size();}
	void push(item it) {
		if (empty()){
		    dp.push({});
		    for (int i = 0; i < P; ++i)
		        dp.top()[i] = 0;
		}
		else{
		    dp.push(dp.top());
		}
		st.push(it);
		for (int i = P - it.p - 1; i >= 0; --i)
			dp.top()[i + it.p] = max(dp.top()[i + it.p], dp.top()[i] + it.t);
	}
	void pop() {
		st.pop();
		dp.pop();
	}
	item top() {
		return st.top();
	}
	void swap(minstack &x) {
		st.swap(x.st);
		dp.swap(x.dp);
	}
};
 
struct mindeque {
	minstack l, r, t;
	void rebalance() {
		bool f = false;
		if (r.empty()) {f = true; l.swap(r);}
		int sz = r.size() / 2;
		while (sz--) {t.push(r.top()); r.pop();}
		while (!r.empty()) {l.push(r.top()); r.pop();}
		while (!t.empty()) {r.push(t.top()); t.pop();}
		if (f) l.swap(r);
	}
	int get(int p) {
		int ans = 0;
		for (int i = 0; i <= p; ++i)
			ans = max(ans, l.get(i) + r.get(p - i));
		return ans;
	}
	bool empty() {return l.empty() && r.empty();}
	int size() {return l.size() + r.size();}
	void push_front(item it) {l.push(it);}
	void push_back(item it) {r.push(it);}
	void pop_front() {if (l.empty()) rebalance(); l.pop();}
	void pop_back() {if (r.empty()) rebalance(); r.pop();}
	item front() {if (l.empty()) rebalance(); return l.top();}
	item back() {if (r.empty()) rebalance(); return r.top();}
	void swap(mindeque &x) {l.swap(x.l); r.swap(x.r);}
};
 
struct edge{
	int u, tp, p, t;
};
 
struct query{
	int i, p;
};
 
vector<vector<edge>> g;
vector<vector<query>> qs;
vector<int> ans;
mindeque ks;
 
void dfs(int v){
	for (auto& [i, p] : qs[v]){
		ans[i] = ks.get(p);
	}
	for (auto& [u, tp, p, t] : g[v]){
		if (tp == 0){
			dfs(u);
		}
		else if (tp == -1){
		    auto it = ks.front();
		    ks.pop_front();
			dfs(u);
			ks.push_front({it.p, it.t});
		}
		else{
			ks.push_back({p, t});
			dfs(u);
			ks.pop_back();
		}
	}
}
 
int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	int q;
	cin >> q;
	vector<int> st(1);
	vector<int> where(q, -1);
	int cnt = 1, cnt_real = 1;
	where[0] = 0;
	g.push_back({});
	qs.push_back({});
	
	auto copy_shop = [&](int x, bool real){
		g.push_back({});
		qs.push_back({});
		st.push_back(st[x]);
		if (real){
			where[cnt_real] = cnt;
			++cnt_real;
		}
		++cnt;
	};
	
	forn(i, q){
		int tp, x;
		cin >> tp >> x;
		--x;
		int v = where[x], u = -1;
		if (tp != 4){
			copy_shop(v, tp == 1);
			u = cnt - 1;
		}
		if (tp == 1){
			g[v].push_back({u, 0, -1, -1});
			continue;
		}
		if (tp == 3){
			g[v].push_back({u, -1, -1, -1});
			++st[u];
			where[x] = u;
			continue;
		}
		int p;
		cin >> p;
		if (tp == 4){
			qs[v].push_back({i, p});
			continue;
		}
		int t;
		cin >> t;
		g[v].push_back({u, 1, p, t});
		where[x] = u;
	}
	
	ans.assign(q, -1);
	dfs(0);
	forn(i, q) if (ans[i] != -1) cout << ans[i] << '\n';
	return 0;
}
--------------------------------------------------
Problem ID: 2026E
Editorial Content:
2026E - Best Subsequence
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
#define sz(a) int((a).size())
 
template<typename T = int>
struct Dinic {
  struct edge {
    int u, rev;
    T cap, flow;
  };
  
  int n, s, t;
  T flow;
  vector<int> lst;
  vector<int> d;
  vector<vector<edge>> g;
  
  Dinic() {}
  
  Dinic(int n, int s, int t) : n(n), s(s), t(t) {
    g.resize(n);
    d.resize(n);
    lst.resize(n);
    flow = 0;
  }
 
  void add_edge(int v, int u, T cap, bool directed = true) {
    g[v].push_back({u, sz(g[u]), cap, 0});
    g[u].push_back({v, sz(g[v]) - 1, directed ? 0 : cap, 0});
  }
 
  T dfs(int v, T flow) {
    if (v == t) return flow;
    if (flow == 0) return 0;
    T result = 0;
    for (; lst[v] < sz(g[v]); ++lst[v]) {
      edge& e = g[v][lst[v]];
      if (d[e.u] != d[v] + 1) continue;
      T add = dfs(e.u, min(flow, e.cap - e.flow));
      if (add > 0) {
        result += add;
        flow -= add;
        e.flow += add;
        g[e.u][e.rev].flow -= add;
      }
      if (flow == 0) break;
    }
    return result;
  }
 
  bool bfs() {
    fill(d.begin(), d.end(), -1);
    queue<int> q({s});
    d[s] = 0;
    while (!q.empty() && d[t] == -1) {
      int v = q.front(); q.pop();
      for (auto& e : g[v]) {
        if (d[e.u] == -1 && e.cap - e.flow > 0) {
          q.push(e.u);
          d[e.u] = d[v] + 1;
        }
      }
    }
    return d[t] != -1;
  }
 
  T calc() {
    T add;
    while (bfs()) {
      fill(lst.begin(), lst.end(), 0);
      while((add = dfs(s, numeric_limits<T>::max())) > 0)
        flow += add;
    }
    return flow;
  }
};
 
const int B = 60;
const int INF = 1e9;
 
int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    int s = n + B, t = n + B + 1;
    Dinic mf(t + 1, s, t);
    for (int i = 0; i < n; ++i) {
      long long x;
      cin >> x;
      mf.add_edge(s, i, 1);
      for (int j = 0; j < B; ++j) {
        if ((x >> j) & 1) mf.add_edge(i, j + n, INF);
      }
    }
    for (int i = 0; i < B; ++i) mf.add_edge(i + n, t, 1);
    cout << n - mf.calc() << '\n';
  }
}
--------------------------------------------------
Problem ID: 2026D
Editorial Content:
2026D - Sums of Segments
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
const int MOD = 998244353;
 
int n;
 
vector<long long> a;
vector<long long> pa;
vector<long long> ppa;
vector<long long> start;
vector<long long> block;
vector<long long> pblock;
 
vector<long long> prefix_sums(vector<long long> v)
{
 	int k = v.size();
 	vector<long long> res(k + 1);
 	for(int i = 0; i < k; i++) res[i + 1] = res[i] + v[i];
 	return res;
}
 
long long get_partial(int l, int r1, int r2)
{
	// s(l, r1) + s(l, r1 + 1) + ... + s(l, r2 - 1)
 	if(r2 <= r1) return 0ll;
 	int cnt = r2 - r1;
 	long long rem = pa[l] * cnt;
 	long long add = ppa[r2 + 1] - ppa[r1 + 1];
 	return add - rem;
}
 
pair<int, int> convert(long long i)
{
	int idx = upper_bound(start.begin(), start.end(), i) - start.begin() - 1;
	pair<int, int> res = {idx, i - start[idx] + idx};
	return res; 	
}
 
long long query(long long l, long long r)
{
	pair<int, int> lf = convert(l);
	pair<int, int> rg = convert(r);
	long long res = pblock[rg.first + 1] - pblock[lf.first];
	if(lf.second != lf.first) res -= get_partial(lf.first, lf.first, lf.second);
	if(rg.second != n - 1) res -= get_partial(rg.first, rg.second + 1, n);
	return res;	
}
 
int main()
{
	scanf("%d", &n);
	a.resize(n);
	for(int i = 0; i < n; i++) scanf("%lld", &a[i]);
	pa = prefix_sums(a);
	ppa = prefix_sums(pa);
	start = {0};
	for(int i = n; i >= 1; i--)
		start.push_back(start.back() + i);
	block.resize(n);
	for(int i = 0; i < n; i++)
		block[i] = get_partial(i, i, n);
	pblock = prefix_sums(block);
	int q;
	scanf("%d", &q);
	for(int i = 0; i < q; i++)
	{
	 	long long l, r;
	 	scanf("%lld %lld", &l, &r);
	 	printf("%lld\n", query(l - 1, r - 1));
	}
 
}
--------------------------------------------------
Problem ID: 2026C
Editorial Content:
2026C - Action Figures
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
const int N = 400043;
char buf[N];
 
bool can(const string& s, int k)
{
    int n = s.size();
    vector<int> used(n);
    for(int i = n - 1; i >= 0; i--)
        if(k > 0 && s[i] == '1')
        {
            used[i] = 1;
            k--;
        }
    int cur = 0;
    for(int i = 0; i < n; i++)
        if(used[i])
        {
            cur--;
            if(cur < 0) return false;
        }
        else cur++;
    return true;
}   
 
void solve()
{
    int n;
    scanf("%d", &n);
    scanf("%s", buf);                         
    if(n == 1)
    {
        puts("1");
        return;
    }
    string s = buf;
    int count_1 = 0;
    for(auto x : s) if (x == '1') count_1++;
    int l = 1;
    int r = count_1 + 1;
    while(r - l > 1)
    {
        int mid = (l + r) / 2;
        if(can(s, mid))
            l = mid;
        else
            r = mid;
    }
    long long ans = 0;
    for(int i = n - 1; i >= 0; i--)
        if(s[i] == '1' && l > 0)
            l--;
        else
            ans += (i + 1);
    printf("%lld\n", ans);
}
 
int main()
{
    int t;
    scanf("%d", &t);
    for(int i = 0; i < t; i++)
        solve();
}
--------------------------------------------------
Problem ID: 2026B
Editorial Content:
2026B - Black Cells
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<long long> a(n);
    for (auto& x : a) cin >> x;
    
    long long ans = 1e18;
    
    auto upd = [&](vector<long long> a) {
      sort(a.begin(), a.end());
      for (int i = 1; i < (int)a.size(); ++i)
        if (a[i - 1] == a[i]) return;
      long long res = 0;
      for (int i = 0; i < (int)a.size(); i += 2)
        res = max(res, a[i + 1] - a[i]);
      ans = min(ans, res);
    };
    
    if (n % 2 == 0) {
      upd(a);
      cout << ans << '\n';
      continue;
    }
    
    for (int i = 0; i < n; ++i) {
      for (int x : {-1, 1}) {
        a.push_back(a[i] + x);
        upd(a);
        a.pop_back();
      }
    }
    
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 2026A
Editorial Content:
2026A - Perpendicular Segments
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>
using namespace std;
 
int main() {
	int t; cin >> t;
	while (t--) {
		int X, Y, K;
		cin >> X >> Y >> K;
		int M = min(X, Y);
		cout << "0 0 " << M << " " << M << endl;
		cout << "0 " << M << " " << M << " 0" << endl;
	}
}
--------------------------------------------------
Problem ID: 2025G
Editorial Content:
2025G - Variable Damage
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
using namespace std;
 
struct query{
	int t, v;
};
 
int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	int m;
	cin >> m;
	vector<query> q(m);
	forn(i, m) cin >> q[i].t >> q[i].v;
	
	vector<pair<int, int>> xs;
	forn(i, m) xs.push_back({q[i].v, i});
	sort(xs.rbegin(), xs.rend());
	forn(i, m) q[i].v = xs.rend() - lower_bound(xs.rbegin(), xs.rend(), make_pair(q[i].v, i)) - 1;
	
	const int p = sqrt(m + 10);
	const int siz = (m + p - 1) / p;
	
	vector<int> tp(m);
	vector<int> val(m);
	vector<vector<long long>> dp(p, vector<long long>(2 * siz + 1));
	vector<int> blbal(p);
	
	auto upd = [&](const query &q){
		tp[q.v] = q.t;
		val[q.v] = xs[q.v].first;
		blbal[q.v / siz] += q.t == 1 ? 1 : -1;
	};
	
	auto recalc = [&](int b){
		dp[b].assign(2 * siz + 1, 0);
		int bal = 0;
		for (int i = b * siz; i < m && i < (b + 1) * siz; ++i){
			if (tp[i] == 1){
				dp[b][0] += val[i];
				dp[b][0] += val[i];
				dp[b][-bal + siz] -= val[i];
				++bal;
			}
			else if (tp[i] == 2){
				dp[b][-bal + 1 + siz] += val[i];
				--bal;
			}
		}
		forn(i, 2 * siz){
			dp[b][i + 1] += dp[b][i];
		}
	};
	
	auto get = [&](int b, int bal){
		bal += siz;
		if (bal < 0) return dp[b][0];
		if (bal >= 2 * siz + 1) return dp[b].back();
		return dp[b][bal];
	};
	
	for (auto it : q){
		upd(it);
		recalc(it.v / siz);
		int bal = 0;
		long long ans = 0;
		for (int i = 0; i * siz < m; ++i){
			ans += get(i, bal);
			bal += blbal[i];
		}
		cout << ans << '\n';
	}
	
	return 0;
}
--------------------------------------------------
Problem ID: 2025F
Editorial Content:
2025F - Choose Your Queries
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
const int N = 300043;
 
string choice = "xy";
string sign = "+-";
 
int qs[N][2];
string ans[N];
int n, q;
vector<int> g[N];
int color[N];
 
void pair_queries(int q1, int q2)
{
 	if(q1 > q2) swap(q1, q2);
 	for(int i = 0; i < 2; i++)
 		for(int j = 0; j < 2; j++)
 			if(qs[q1][i] == qs[q2][j])
 			{
 			 	ans[q1] = { choice[i], sign[0] };
 			 	ans[q2] = { choice[j], sign[1] };
 			 	return;
 			}
}
 
bool dfs(int v, int pe = -1)
{
 	// return true if parent edge still exists
 	color[v] = 1;
 	vector<int> edge_nums;
 	for(auto e : g[v])
 	{
 		int u = v ^ qs[e][0] ^ qs[e][1];
 		if(color[u] == 1) continue;
 		if(color[u] == 0)
 		{
 			if(dfs(u, e))
 				edge_nums.push_back(e);
 		}
 		else
 			edge_nums.push_back(e);
 	}
 	bool res = true;
 	if(edge_nums.size() % 2 != 0)
 	{
 		if(pe != -1) edge_nums.push_back(pe);
 		else edge_nums.pop_back();
 		res = false;
 	}
 	for(int i = 0; i < edge_nums.size(); i += 2)
 		pair_queries(edge_nums[i], edge_nums[i + 1]);
 	color[v] = 2;
 	return res;
}
 
int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> q;
	for(int i = 0; i < q; i++)
	{
	 	cin >> qs[i][0] >> qs[i][1];
	 	--qs[i][0];
	 	--qs[i][1];
	 	g[qs[i][0]].push_back(i);
	 	g[qs[i][1]].push_back(i);
	 	ans[i] = "x+";
	}
	for(int i = 0; i < n; i++)
		if(color[i] == 0)
			dfs(i);
	for(int i = 0; i < q; i++) cout << ans[i] << endl;
}
--------------------------------------------------
Problem ID: 2025E
Editorial Content:
2025E - Card Game
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
const int MOD = 998244353;
 
int add(int x, int y) {
  x += y;
  if (x >= MOD) x -= MOD;
  return x;
}
 
int mul(int x, int y) {
  return x * 1LL * y % MOD;
}
 
int main() {
  int n, m;
  cin >> n >> m;
  vector<vector<int>> ways(m + 1, vector<int>(m + 1));
  ways[0][0] = 1;
  for (int i = 0; i < m; ++i) {
    for (int j = 0; j <= i; ++j) {
      ways[i + 1][j + 1] = add(ways[i + 1][j + 1], ways[i][j]);
      if (j) ways[i + 1][j - 1] = add(ways[i + 1][j - 1], ways[i][j]);
    }
  }
  
  vector<vector<int>> dp(n + 1, vector<int>(m + 1));
  dp[0][0] = 1;
  for (int i = 0; i < n; ++i) {
    for (int j = 0; j <= m; ++j) {
      for (int k = 0; k <= m; ++k) {
        int nj = i ? j - k : j + k;
        if (0 <= nj && nj <= m) {
          dp[i + 1][nj] = add(dp[i + 1][nj], mul(dp[i][j], ways[m][k]));
        }
      }
    }
  }
  cout << dp[n][0] << '\n';
}
--------------------------------------------------
Problem ID: 2025D
Editorial Content:
2025D - Attribute Checks
Tutorial
Tutorial is loading...
Solution 1 (adedalic)
#include<bits/stdc++.h>
 
using namespace std;
 
#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define sz(a) int((a).size())
 
typedef long long li;
 
const int INF = int(1e9);
const li INF64 = li(1e18);
 
int n, m;
vector<int> rs;
 
bool read() {
	if(!(cin >> n >> m))
		return false;
	rs.resize(n);
	fore (i, 0, n)
		cin >> rs[i];
	return true;
}
 
struct LazySum {
	vector<int> ps;
	LazySum(int n) : ps(n, 0) {}
	
	//[l, r]
	void add(int l, int r, int val) {
		if (l > r) return;
		ps[l] += val;
		ps[r + 1] -= val;
	}
	void pushToAndClear(vector<int> &d) {
		int sum = 0;
		fore (i, 0, sz(ps)) {
			sum += ps[i];
			ps[i] = 0;
			if (i < sz(d))
				d[i] += sum;
		}
	}
};
 
void solve() {
	LazySum ls(m + 2);
	vector<int> d(m + 1, -INF);
	d[0] = 0;
 
	int cntP = 0;
	for (int r : rs) {
		if (r == 0) {
			ls.pushToAndClear(d);
			for (int i = m; i > 0; i--)
				d[i] = max(d[i], d[i - 1]);
			cntP++;
			continue;
		}
		if (r > 0)
			ls.add(r, m, 1);
		else
			ls.add(0, cntP + r, 1);
	}
	ls.pushToAndClear(d);
	cout << *max_element(d.begin(), d.end()) << endl;
}
 
int main() {
#ifdef _DEBUG
	freopen("input.txt", "r", stdin);
	int tt = clock();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(15);
	
	if(read()) {
		solve();
		
#ifdef _DEBUG
		cerr << "TIME = " << clock() - tt << endl;
		tt = clock();
#endif
	}
	return 0;
}
Solution 2 (adedalic)
n, m = map(int, input().split())
rs = map(int, input().split())

d = [-int(1e9)] * (m + 1)
d[0] = 0
add = [0] * (m + 2)
def addSegment(l, r):
    if l <= r:
        add[l] += 1
        add[r + 1] -= 1

def pushAll():
    sum = 0
    for i in range(m + 1):
        sum += add[i]
        d[i] += sum
    for i in range(m + 2):
        add[i] = 0

cntPoints = 0
for r in rs:
    if r == 0:
        pushAll()
        for i in range(m, 0, -1):
            d[i] = max(d[i], d[i - 1])
        cntPoints += 1
    else:
        lf, rg = 0, 0
        if (r > 0):
            lf = min(r, m + 1)
            rg = m
        else:
            lf = 0
            rg = max(-1, cntPoints + r)
        addSegment(lf, rg)
pushAll()
print(max(d))
--------------------------------------------------
Problem ID: 2025C
Editorial Content:
2025C - New Game
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	n, k = map(int, input().split())
	a = list(map(int, input().split()))
	a.sort()
	ans = 0
	j = 0
	for i in range(n):
		j = max(i, j)
		while j + 1 < n and a[j + 1] - a[j] <= 1 and a[j + 1] - a[i] < k:
			j += 1
		ans = max(ans, j - i + 1)
	print(ans)
--------------------------------------------------
Problem ID: 2025B
Editorial Content:
2025B - Binomial Coefficients, Kind Of
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>

using namespace std;

const int MOD = int(1e9) + 7;

int main() {
	int t; cin >> t;
	vector<int> ks(t);
	for (int _ = 0; _ < 2; _++)
		for (int i = 0; i < t; i++)
			cin >> ks[i];
	
	vector<int> ans(1 + *max_element(ks.begin(), ks.end()), 1);
	for (int i = 1; i < (int)ans.size(); i++)
		ans[i] = (2LL * ans[i - 1]) % MOD;
	
	for (int k : ks)
		cout << ans[k] << '\n';
	return 0;
}
--------------------------------------------------
Problem ID: 2025A
Editorial Content:
2025A - Two Screens
Tutorial
Tutorial is loading...
Solution (BledDest)
for _ in range(int(input())):
	s = input()
	t = input()

	lcp = 0
	n = len(s)
	m = len(t)
	for i in range(1, min(n, m) + 1):
		if s[:i] == t[:i]:
			lcp = i
	print(n + m - max(lcp, 1) + 1)
--------------------------------------------------
Problem ID: 2024B
Editorial Content:
2024B - Buying Lemonade
--------------------------------------------------
Problem ID: 2024A
Editorial Content:
2024A - Profitable Interest Rate
--------------------------------------------------
Problem ID: 2023F
Editorial Content:
2023F - Hills and Pits
--------------------------------------------------
Problem ID: 2023E
Editorial Content:
2023E - Tree of Life
--------------------------------------------------
Problem ID: 2023D
Editorial Content:
2023D - Many Games
--------------------------------------------------
Problem ID: 2023C
Editorial Content:
2023C - C+K+S
--------------------------------------------------
Problem ID: 2023B
Editorial Content:
2023B - Skipping
--------------------------------------------------
Problem ID: 2023A
Editorial Content:
2023A - Concatenation of Arrays
--------------------------------------------------
Problem ID: 2022E2
Editorial Content:
2022E2 - Billetes MX (Hard Version)
Solution 1
Through the observations in E1, we can reduce the problem to the following: We have a graph, we add edges, and we want to determine after each addition if all its cycles have xor 0, and the number of connected components in the graph.
The edges are never removed, so whenever an edge is added that creates a cycle with xor distinct to zero, this cycle will stay in the graph for all following updates. So we can binary search the first addition that creates a cycle with xor distinct to zero, using the same dfs we used in E1. After the first such edge, the answer will always be zero.
Now, for all the additions before that, we must determine how many connected components the graph has at each step. But this is easily solvable with Disjoint Set Union.
Complexity: $$$\mathcal{O}(\log(q)(n + m + k + q) + \alpha(n + m)(q + k))$$$.
Solution 2
We will answer the queries online. Remember that if the graph only contains cycles with xor $$$0$$$, the xor of a path between a pair of nodes is unique. We'll use this in our advantage. Let $$$W(u, v)$$$ be the unique value of the xor of a path between nodes $$$u$$$ and $$$v$$$.
Lets modify a dsu, drop the path compression, and define array $$$p$$$, that maintains the following invariant:
For every node $$$u$$$ in a component with root $$$r$$$, $$$W(u, r)$$$ equals the xor of $$$p[x]$$$ for all ancestors $$$x$$$ of $$$u$$$ in our dsu (we also consider $$$u$$$ an ancestor of itself).
Whenever we add an edge between two nodes $$$u$$$ and $$$v$$$ in two different components with weight $$$w$$$, we consider consider the roots $$$U$$$ and $$$V$$$ of their respective components. Without loss of generality, assume $$$U$$$'s component has more elements than $$$V$$$'s. We will add an edge with weight $$$W(u, U) \oplus W(v, V) \oplus w$$$ between $$$V$$$ and $$$U$$$, and make $$$U$$$ the root of our new component.
This last step is the small to large optimization, to ensure the height of our trees is logarithmic.
With this data structure, we can maintain the number of connected components like in a usual dsu, and whenever an edge $$$(u, v)$$$ with weight $$$w$$$ is added, and $$$u$$$ and $$$v$$$ belong to the same component, we can obtain the value of $$$W(u, v)$$$ in $$$\mathcal{O(\log(n))}$$$, and check if it is equal to $$$w$$$.
This idea is similar to the data structure
described here
, and is useful in other contexts.
Complexity: $$$\mathcal{O}(\log(q + k)(n + m + k + q))$$$.
Code by Marckess:
#include <bits/stdc++.h>
using namespace std;
 
int const Mxn = 2e5 + 2;
long long int const MOD = 1e9 + 7;
 
vector<vector<array<int, 2>>> adj;
vector<array<int, 3>> Edges;
long long int precalc[Mxn];
 
 
struct DSU {
  vector<int> leader;
  vector<int> sz;
  int components;
 
  DSU(int N) {
    leader.resize(N); iota(leader.begin(), leader.end(), 0);
    sz.assign(N, 1);
    components = N;
  }
 
  int find(int x) {
    return (leader[x] == x) ? x : (leader[x] = find(leader[x]));
  }
 
  void unite(int x, int y) {
    x = find(x), y = find(y);
    if (x == y) return;
    if (sz[x] < sz[y]) swap(x, y);
    leader[y] = leader[x]; sz[x] += sz[y];
    components--;
  }
};
 
bool valid = 1;
int pref[Mxn];
 
void dfs(int node = 0) {
  for (auto [child, w] : adj[node]) {
    if (pref[child] == -1) {
      pref[child] = pref[node]^w;
      dfs(child);
    } else {
      if ((pref[child]^pref[node]) != w) valid = 0;
    }
  }
}
 
int main() {
  precalc[0] = 1;
  for (int i = 1; i < Mxn; i++) {
    precalc[i] = (precalc[i - 1]<<30)%MOD;
  }
 
  int tt; 
  for (cin >> tt; tt; --tt) {
 
    int N, M, K, Q;
    cin >> N >> M >> K >> Q;
 
    Edges.clear();
    adj.clear();
    adj.assign(N + M, vector<array<int, 2>>{});
 
    DSU dsu(N + M);
    dsu.components = N + M;
 
    int x, y, z;
    for (int i = 0; i < K; i++) {
      cin >> x >> y >> z;
      x--, y--;
      adj[x].push_back({y + N, z});
      adj[y + N].push_back({x, z});
      dsu.unite(x, y + N);
    }
 
    for (int i = 0; i < Q; i++) {
      cin >> x >> y >> z;
      x--, y--;
      Edges.push_back({x, y + N, z});
    }
 
    int firstzero = 0;
 
    for (int k = 20; k >= 0; k--) {
      if (firstzero + (1<<k) > Q) continue;
 
      for (int i = firstzero; i < firstzero + (1<<k); i++) {
        x = Edges[i][0], y = Edges[i][1], z = Edges[i][2];
        adj[x].push_back({y, z});
        adj[y].push_back({x, z});
      }
 
      valid = 1;
      for (int i = 0; i < N + M; i++) pref[i] = -1;
      for (int i = 0; i < N + M; i++) {
        if (pref[i] == -1) pref[i] = 0, dfs(i);
      }
 
      if (!valid) {
        for (int i = firstzero + (1<<k) - 1; i >= firstzero; --i) {
          x = Edges[i][0], y = Edges[i][1];
          adj[x].pop_back();
          adj[y].pop_back();
        }
      } else {
        firstzero += (1<<k);
      }
    }
 
    if (firstzero == 0) {
      valid = 1;
      for (int i = 0; i < N + M; i++) pref[i] = -1;
      for (int i = 0; i < N + M; i++) {
        if (pref[i] == -1) pref[i] = 0, dfs(i);
      }
 
      if (!valid) firstzero--;
    }
 
    for (int i = 0; i <= Q; i++) {
      if (i <= firstzero) cout << precalc[dsu.components - 1] << '\n';
      else cout << 0 << '\n';
      if (i == Q) break;
      x = Edges[i][0], y = Edges[i][1];
      dsu.unite(x, y);
    }
 
  }
}
Bonus
In our Olympiad, we had $$$v_i \le 1$$$ instead of $$$v_i \le 2^{30}$$$, and we also had a final subtask were tiles could change values. How would you solve this?
We have three different solutions for this problem, one of them found during the Olympiad! I'll let the contestant who found it post it if he wants to.
Main takeaways
You can model a grid as a bipartite graph between rows and columns.
Whenever coding or designing a data structure, keep in mind all the invariants you are maintaining. I like to think of data structures as graphs with invariants or monovariants in each node. I have a blog draft on how to use this to design data structures, inspired by
this
. Maybe I will publish it.
--------------------------------------------------
Problem ID: 2022E1
Editorial Content:
2022E1 - Billetes MX (Easy Version)
Hint 1
Consider the extremal cases, what is the answer if the grid is empty? What is the answer if the grid is full? What happens if $$$N = 2$$$?
Hint 2
Observe that if $$$N = 2$$$, the xor of every column is constant. Can we generalize this idea?
Hint 4
Imagine you have a valid full grid $$$a$$$. For each $$$i$$$, change $$$a[0][i]$$$ to $$$a[0][0]\oplus a[0][i]$$$. Observe that the grid still satisfies the condition!
Hint 5
Using the previous idea we can show that for any valid grid, there must exist two arrays $$$X$$$ and $$$Y$$$, such that $$$a[i][j] = X[i] \oplus Y[j]$$$.
Proof
Consider doing the operation described in hint 4 for every row and every column of a full grid that satisfies the condition;
That is, for each row, and each column, fix the first element, and change every value in that row or column by their xor with the first element.
We will be left with a grid whose first row and first column are all zeros.
But this grid also satisfies the condition! So it must hold that $$$a[i][j] \oplus a[i][0] \oplus a[0][j] \oplus a[0][0] = 0$$$, but 3 of this values are zero!
We can conclude that $$$a[i][j]$$$ must also be zero. This shows that there must exist two arrays $$$X$$$ and $$$Y$$$, such that $$$a[i][j] = X[i] \oplus Y[j]$$$, for any valid full grid.
Proof
Consider doing the operation described in hint 4 for every row and every column of a full grid that satisfies the condition;
That is, for each row, and each column, fix the first element, and change every value in that row or column by their xor with the first element.
We will be left with a grid whose first row and first column are all zeros.
But this grid also satisfies the condition! So it must hold that $$$a[i][j] \oplus a[i][0] \oplus a[0][j] \oplus a[0][0] = 0$$$, but 3 of this values are zero!
We can conclude that $$$a[i][j]$$$ must also be zero. This shows that there must exist two arrays $$$X$$$ and $$$Y$$$, such that $$$a[i][j] = X[i] \oplus Y[j]$$$, for any valid full grid.
Hint 6
Think of each tile of the grid that we know of, as imposing a condition between two elements of arrays $$$X$$$ and $$$Y$$$. For each tile added, we lose one degree of freedom right? We could make a bunch of substitutions to determine new values of the grid. How can we best model the problem now?
Hint 7
Think about it as a graph where the nodes are rows and columns, and there is an edge between row $$$i$$$ and column $$$j$$$ with weight $$$a[i][j]$$$. Substitutions are now just paths on the graph. If we have a path between the node that represents row $$$i$$$ and column $$$j$$$, the xor of the weights in this path represents the value of $$$a[i][j]$$$. What happens if there's more than one path, and two paths have different values?
Hint 8
To continue hint 7, we can deduce that if there is a cycle with xor of weights distinct to $$$0$$$ in this graph, there would be a contradiction, and arrays $$$X$$$ and $$$Y$$$ can't exist. How can we check if this is the case?
Answer to hint 8
Do a dfs on this graph, maintaining an array $$$p$$$, such that $$$p[u]$$$ is the xor of all edges in the path you took from the root, to node $$$u$$$. Whenever you encounter a back edge between nodes $$$u$$$ and $$$v$$$ with weight $$$w$$$, check if $$$p[u] \oplus p[v] = w$$$.
Hint 9
So lets assume there is no contradiction, ie, all cycles have xor 0. What would be the answer to the problem? We know that if the graph is connected, there exists a path between any two tiles and all the values of the tiles would be determined. So, in how many ways can we make a graph connected?
Answer to hint 9
Say there are $$$K$$$ connected components. We can connect them all using $$$K - 1$$$ edges. For each edge, there are $$$2^{30}$$$ possible values they can have. Thus, the number of ways of making the graph connected is $$$\left(2^{30} \right)^{K - 1}$$$.
Check your understanding
Why is this the answer to the problem?
Check your understanding
Why is this the answer to the problem?
Solution
This is just the solution. Please read the hints in order to understand why it works and how to derive it.
Precompute an array $$$c$$$, with $$$c[i] = 2^{30\cdot i} \pmod{10^9 + 7}$$$.
Let $$$a$$$ be the 2d array with known values of the grid. Consider the graph formed by adding an edge between node $$$i$$$ and node $$$j + n$$$ and weight $$$a[i][j]$$$ for every known tile $$$(i, j)$$$ in the grid. Iterate from $$$1$$$ to $$$n + m$$$ maintaining an array $$$p$$$ initialized in $$$-1$$$s. If the current proceed node hasn't been visited, we run a dfs through it. We will use array $$$p$$$ to maintain the running xor for each node during the dfs. If we ever encounter a back edge between nodes $$$u, v$$$ and weight $$$w$$$, we check if $$$p[u] \oplus p[v] = w$$$. If not, we the answer is zero. If this condition always holds, let $$$K$$$ be the number of times you had to run the dfs. $$$K$$$ is also the number of connected components in the graph. The answer is $$$c[K - 1]$$$.
Complexity: $$$\mathcal{O}(n + m + k)$$$.
Code:
#include <bits/stdc++.h>
using namespace std;
 
int const Mxn = 2e5 + 2;
long long int const MOD = 1e9 + 7;
long long int precalc[Mxn];
 
vector<vector<array<int, 2>>> adj;
 
bool valid = 1;
int pref[Mxn];
 
void dfs(int node) {
  for (auto [child, w] : adj[node]) {
    if (pref[child] == -1) {
      pref[child] = pref[node]^w;
      dfs(child);
    } else {
      if ((pref[child]^pref[node]) != w) valid = 0;
    }
  }
}
 
int main() {
    
  precalc[0] = 1;
  for (int i = 1; i < Mxn; i++) {
    precalc[i] = (precalc[i - 1]<<30)%MOD;
  }
 
  int tt;
  for (cin >> tt; tt; --tt) {
    int N, M, K, Q;
    cin >> N >> M >> K >> Q;
    
    adj.clear();
    adj.assign(N + M, vector<array<int, 2>>{});
 
    int x, y, z;
    for (int i = 0; i < K; i++) {
      cin >> x >> y >> z;
      x--, y--;
      adj[x].push_back({y + N, z});
      adj[y + N].push_back({x, z});
    }
 
    for (int i = 0; i < N + M; i++) pref[i] = -1;
    valid = 1;
    int cnt = 0;
 
    for (int i = 0; i < N + M; i++) {
      if (pref[i] != -1) continue;
      cnt++; pref[i] = 0; dfs(i);
    }
 
    if (valid) cout << precalc[cnt - 1] << '\n';
    else cout << 0 << '\n';
  }
}
--------------------------------------------------
Problem ID: 2022D2
Editorial Content:
2022D2 - Asesino (Hard Version)
Hint 4
What is the minimal value anyway? Our solution to D1 used $$$n$$$ queries if $$$n$$$ is even and $$$n + 1$$$ queries when $$$n$$$ is odd. Is this the optimal strategy? Can we find a lower bound? Can we find the optimal strategy for small $$$n$$$?
Hint 5
There's only $$$9$$$ possible unlabeled directed graphs with $$$3$$$ nodes and at most $$$3$$$ edges, you might as well draw them. They are illustrated in the image below for convenience though. Stare at them and convince yourself $$$4$$$ queries is the optimal for $$$n = 3$$$.
Hint 6
We would have to prove that $$$n - 1 < f(n)$$$ for all $$$n$$$ and $$$n < f(n)$$$ for $$$n$$$ odd. How could we structure a proof?
Hint 7
For $$$n - 1$$$ we have some control over the graph. We can show by pigeonhole principle that at least one of them has in-degree $$$0$$$, and at least one of them has out-degree $$$0$$$.
If those two nodes are different, call $$$A$$$ the node with in-degree $$$0$$$ and $$$B$$$ the node with out-degree $$$0$$$. Let the grader always reply yes to your queries.
$$$A$$$ can be the impostor and everyone else Knaves.
$$$B$$$ can be the impostor and everyone else Knights.
If those two nodes are the same, then the graph looks like a collection of cycles and one isolated node. The grader will always reply yes except for the last query where it replies no.  Let the last query be to player $$$A$$$ about player $$$B$$$. The two assignments of roles are:
$$$A$$$ is the impostor and everyone else in the cycle is a Knight.
$$$B$$$ is the impostor and everyone else in the cycle is a Knave.
Hint 8
Note that the structure of our proof is very general and is very easy to simulate for small values of $$$n$$$ and small number of queries. Can we extend it to $$$n$$$ odd and $$$n$$$ queries? Try writing an exhaustive checker and run it for small values. According to our conjecture, $$$n = 5$$$ shouldn't solvable with $$$5$$$ queries. So we should find a set of answers that for any queries yields two valid assignments with different nodes as the impostor.
Hint 9
It doesn't exist! Which means $$$n = 5$$$ is solvable with $$$5$$$ queries. How? Also, observe that if we find a solution to $$$n = 5$$$ we can apply the same idea and recursively solve the problem in $$$n$$$ queries for all $$$n > 3$$$.
Solution
Consider the natural directed graph representation, adding a directed edge with weight $$$0$$$ between node $$$i$$$ and $$$j$$$ if the answer to the query ''? i j'' was yes, and a $$$1$$$ otherwise. We will also denote this query by $$$i \mapsto j$$$.
We will use a lemma, that generalizes the idea for D1.
Lemma:
The sum of weights of a cycle is odd if and only if the impostor is among us (among the cycle, I mean).
Proof
Suppose the impostor is not in the cycle. Then observe that the only time you get an edge with weight $$$1$$$ is whenever there are two consecutive nodes with different roles. — Consider consecutive segments of nodes with the same role in this cycle, and compress each of this segments into one node. The image bellow illustrates how, grey edges are queries with answer no.
The new graph is bipartite, and thus has an even number of edges. But all the edges in this new graph, are all the grey edges in the original graph, which implies what we want.
If the impostor is in the cycle, there are three ways of inserting it (assume the cycle has more than $$$2$$$ nodes that case is exactly what we proved in hint 2).
We can insert the impostor into one of this ``segments'' of consecutive nodes with the same role. This would increase the number of grey edges by $$$1$$$, changing the parity,
We can insert it between two segments.
If we have Knight $$$\mapsto$$$ Impostor $$$\mapsto$$$ Knave, the number of grey edges decreases by $$$1$$$.
If thee is Knave $$$\mapsto$$$ Impostor $$$\mapsto$$$ Knight, the number of grey edges increases by $$$1$$$.
Either way, we changed the parity of the cycle. $$$\blacksquare$$$
The algorithm that solves the problem is the following:
If $$$n = 3$$$,
First case
query $$$1 \mapsto 2$$$ and $$$2 \mapsto 1$$$,
If queries match, $$$3$$$ is the impostor.
Else, query $$$1 \mapsto 3$$$ and $$$3 \mapsto 1$$$.
If queries match, $$$2$$$ is the impostor.
Else, $$$1$$$ is the impostor.
Else, $$$n > 3$$$. To solve $$$n > 3$$$ players with $$$n$$$ queries, do:
While $$$n > 5$$$,
query $$$n \mapsto n - 1$$$ and $$$n - 1 \mapsto n$$$.
If their answers don't match, one of them is the impostor. Query $$$n \mapsto n - 2$$$ and $$$n - 2 \mapsto n$$$.
If their answers don't match, $$$n$$$ is the impostor.
Otherwise, $$$n - 1$$$ is the impostor.
If the answers match, do $$$n -= 2$$$.
If $$$n > 5$$$ doesn't hold and we haven't found the impostor, we either have the $$$n = 4$$$ case or the $$$n = 5$$$ case, we solve them optimally in $$$4$$$ or $$$5$$$ queries each.
To solve $$$n = 5$$$ in $$$5$$$ queries,
Second case
We will form a cycle of size $$$3$$$, asking for $$$1 \mapsto 2$$$, $$$2 \mapsto 3$$$ and $$$3 \mapsto 2$$$ (blue edges in the image below).
If the cycle has an even number of no's, we know the impostor is among $$$4$$$ or $$$5$$$. So we ask $$$3 \mapsto 4$$$ and $$$4 \mapsto 3$$$ (green edges).
If both queries match, $$$5$$$ is the impostor.
Else, $$$4$$$ is the impostor.
Else, The impostor is among us (among the cycle, I mean). Ask $$$1 \mapsto 3$$$ and $$$2 \mapsto 1$$$ (purple edges).
If $$$1 \mapsto 2$$$ doesn't match with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ doesn't match with $$$3 \mapsto 1$$$, $$$1$$$ is the impostor.
If $$$1 \mapsto 2$$$ doesn't match with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ matches with $$$3 \mapsto 1$$$, $$$2$$$ is the impostor.
If $$$1 \mapsto 2$$$ matches with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ doesn't match with $$$3 \mapsto 1$$$, $$$3$$$ is the impostor.
It is impossible for $$$1 \mapsto 2$$$ to match with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ to match with $$$3 \mapsto 1$$$, because we know at least one of this cycles will contain the impostor.
To solve $$$n = 4$$$ in $$$4$$$ queries,
Third case
We will query $$$1 \mapsto 2$$$, $$$2 \mapsto 1$$$, $$$1 \mapsto 3$$$ and $$$3 \mapsto 1$$$.
If $$$1 \mapsto 2$$$ doesn't match with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ doesn't match with $$$3 \mapsto 1$$$, $$$1$$$ is the impostor.
If $$$1 \mapsto 2$$$ doesn't match with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ matches with $$$3 \mapsto 1$$$, $$$2$$$ is the impostor.
If $$$1 \mapsto 2$$$ matches with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ doesn't match with $$$3 \mapsto 1$$$, $$$3$$$ is the impostor.
If $$$1 \mapsto 2$$$ matches with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ matches with $$$3 \mapsto 1$$$, then $$$4$$$ is the impostor.
We have proven that that $$$f(n) \le \max(4, n)$$$. Now we will prove that $$$n \le f(n)$$$.
Proof of the lower bound
We will show it is impossible to solve the problem for any $$$n$$$ with only $$$n - 1$$$ queries. We will show that the grader always has a strategy of answering queries, such that there exists at least 2 different assignments of roles that are consistent with the answers given, and have different nodes as the impostor.
Consider the directed graph generated from the queries. By pigeonhole principle at least one node has in-degree $$$0$$$, and at least one node has out-degree $$$0$$$.
If those two nodes are different, call $$$A$$$ the node with in-degree $$$0$$$ and $$$B$$$ the node with out-degree $$$0$$$. Let the grader always reply yes to your queries.
$$$A$$$ can be the impostor and everyone else Knaves.
$$$B$$$ can be the impostor and everyone else Knights.
If those two nodes are the same, then the graph looks like a collection of cycles and one isolated node. The grader will always reply yes except for the last query where it replies no.  Let the last query be to player $$$A$$$ about player $$$B$$$. The two assignments of roles are:
$$$A$$$ is the impostor and everyone else in the cycle is a Knight.
$$$B$$$ is the impostor and everyone else in the cycle is a Knave.
Thus, we have shown that regardless what the questions asked are, it is impossible to find the impostor among $$$n$$$ players, in $$$n - 1$$$ queries. $$$\blacksquare$$$
Now, we prove that $$$f(3) = 4$$$:
'Proof'
Stare at this image:
lol,
Actually, one of the testers coded the exhaustive checker. I will let them post their code if they want to.
Proof
Suppose the impostor is not in the cycle. Then observe that the only time you get an edge with weight $$$1$$$ is whenever there are two consecutive nodes with different roles. — Consider consecutive segments of nodes with the same role in this cycle, and compress each of this segments into one node. The image bellow illustrates how, grey edges are queries with answer no.
The new graph is bipartite, and thus has an even number of edges. But all the edges in this new graph, are all the grey edges in the original graph, which implies what we want.
If the impostor is in the cycle, there are three ways of inserting it (assume the cycle has more than $$$2$$$ nodes that case is exactly what we proved in hint 2).
We can insert the impostor into one of this ``segments'' of consecutive nodes with the same role. This would increase the number of grey edges by $$$1$$$, changing the parity,
We can insert it between two segments.
If we have Knight $$$\mapsto$$$ Impostor $$$\mapsto$$$ Knave, the number of grey edges decreases by $$$1$$$.
If thee is Knave $$$\mapsto$$$ Impostor $$$\mapsto$$$ Knight, the number of grey edges increases by $$$1$$$.
Either way, we changed the parity of the cycle. $$$\blacksquare$$$
First case
query $$$1 \mapsto 2$$$ and $$$2 \mapsto 1$$$,
If queries match, $$$3$$$ is the impostor.
Else, query $$$1 \mapsto 3$$$ and $$$3 \mapsto 1$$$.
If queries match, $$$2$$$ is the impostor.
Else, $$$1$$$ is the impostor.
Second case
We will form a cycle of size $$$3$$$, asking for $$$1 \mapsto 2$$$, $$$2 \mapsto 3$$$ and $$$3 \mapsto 2$$$ (blue edges in the image below).
If the cycle has an even number of no's, we know the impostor is among $$$4$$$ or $$$5$$$. So we ask $$$3 \mapsto 4$$$ and $$$4 \mapsto 3$$$ (green edges).
If both queries match, $$$5$$$ is the impostor.
Else, $$$4$$$ is the impostor.
Else, The impostor is among us (among the cycle, I mean). Ask $$$1 \mapsto 3$$$ and $$$2 \mapsto 1$$$ (purple edges).
If $$$1 \mapsto 2$$$ doesn't match with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ doesn't match with $$$3 \mapsto 1$$$, $$$1$$$ is the impostor.
If $$$1 \mapsto 2$$$ doesn't match with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ matches with $$$3 \mapsto 1$$$, $$$2$$$ is the impostor.
If $$$1 \mapsto 2$$$ matches with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ doesn't match with $$$3 \mapsto 1$$$, $$$3$$$ is the impostor.
It is impossible for $$$1 \mapsto 2$$$ to match with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ to match with $$$3 \mapsto 1$$$, because we know at least one of this cycles will contain the impostor.
Third case
We will query $$$1 \mapsto 2$$$, $$$2 \mapsto 1$$$, $$$1 \mapsto 3$$$ and $$$3 \mapsto 1$$$.
If $$$1 \mapsto 2$$$ doesn't match with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ doesn't match with $$$3 \mapsto 1$$$, $$$1$$$ is the impostor.
If $$$1 \mapsto 2$$$ doesn't match with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ matches with $$$3 \mapsto 1$$$, $$$2$$$ is the impostor.
If $$$1 \mapsto 2$$$ matches with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ doesn't match with $$$3 \mapsto 1$$$, $$$3$$$ is the impostor.
If $$$1 \mapsto 2$$$ matches with $$$2 \mapsto 1$$$ and $$$1 \mapsto 3$$$ matches with $$$3 \mapsto 1$$$, then $$$4$$$ is the impostor.
Proof of the lower bound
We will show it is impossible to solve the problem for any $$$n$$$ with only $$$n - 1$$$ queries. We will show that the grader always has a strategy of answering queries, such that there exists at least 2 different assignments of roles that are consistent with the answers given, and have different nodes as the impostor.
Consider the directed graph generated from the queries. By pigeonhole principle at least one node has in-degree $$$0$$$, and at least one node has out-degree $$$0$$$.
If those two nodes are different, call $$$A$$$ the node with in-degree $$$0$$$ and $$$B$$$ the node with out-degree $$$0$$$. Let the grader always reply yes to your queries.
$$$A$$$ can be the impostor and everyone else Knaves.
$$$B$$$ can be the impostor and everyone else Knights.
If those two nodes are the same, then the graph looks like a collection of cycles and one isolated node. The grader will always reply yes except for the last query where it replies no.  Let the last query be to player $$$A$$$ about player $$$B$$$. The two assignments of roles are:
$$$A$$$ is the impostor and everyone else in the cycle is a Knight.
$$$B$$$ is the impostor and everyone else in the cycle is a Knave.
Thus, we have shown that regardless what the questions asked are, it is impossible to find the impostor among $$$n$$$ players, in $$$n - 1$$$ queries. $$$\blacksquare$$$
'Proof'
Stare at this image:
lol,
Actually, one of the testers coded the exhaustive checker. I will let them post their code if they want to.
Code by Marckess:
#include <bits/stdc++.h>
 
using namespace std;
 
int n;
 
void answer (int a) {
	cout << "! " << a << endl;
} 
 
int query (int a, int b) {
	cout << "? " << a << " " << b << endl;
	int r;
	cin >> r;
	if (r == -1)
		exit(0);
	return r;
}
 
void main_ () {
	cin >> n;
	
	if (n == -1)
	    exit(0);
	
	if (n == 3) {
	    if (query(1, 2) != query(2, 1)) {
	        if (query(1, 3) != query(3, 1)) {
	            answer(1);
	        } else {
	            answer(2);
	        }
	    } else {
	        answer(3);
	    }
	    return;
	}
	
	for (int i = 1; i + 1 <= n; i += 2) {
		if (n % 2 == 1 && i == n - 4)
			break;
		
		if ((n % 2 == 0 && i + 1 == n) || query(i, i + 1) != query(i + 1, i)) {
			int k = 1;
			while (k == i || k == i + 1)
				k++;
			
			if (query(i, k) != query(k, i)) {
				return answer(i);
			} else {
				return answer(i + 1);
			}
		}
	}
	
	vector<int> v = {
		query(n - 4, n - 3),
		query(n - 3, n - 2),
		query(n - 2, n - 4)
	};
	
	if ((v[0] + v[1] + v[2]) % 2 == 0) {
		if (query(n - 3, n - 4) != v[0]) {
			if (query(n - 2, n - 3) != v[1]) {
				answer(n - 3);
			} else {
				answer(n - 4);
			}
		} else {
			answer(n - 2);
		}
	} else {
		if (query(n, 1) != query(1, n)) {
			answer(n);
		} else {
			answer(n - 1);
		}
	}
}
 
int main () {
	
	int t;
	cin >> t;
	
	while (t--)
		main_();
		
	return 0;
}
Bonus
In the Olympiad version, the impostor behaved differently. It could either disguise as a Knight while secretly being a Knave, or disguise as a Knave while secretly being a Knight. Turns out the test cases and the interactor in both versions are practically the same. Why would that be?
Main takeaways
Do small cases! Let the pencil (or the computer) do the work and use your brain to look out for patterns.
Try to find the most natural and simple way of modeling the problem.
Learn how to code a decision tree, or other models to exhaustively search for constructions, proof patterns, recursive complete search, etc. and build intuition on that to solve the more general cases of the problem.
--------------------------------------------------
Problem ID: 2022D1
Editorial Content:
2022D1 - Asesino (Easy Version)
Hint 1
Try to do casework for small $$$n$$$. It is also a good idea to simulate it. Think about this problem as a directed graph, where for each query there is a directed edge.
Hint 2
Observe that if you ask $$$u \mapsto v$$$ and $$$v \mapsto u$$$, both answers will match if and only if $$$u$$$ and $$$v$$$ are not the impostor. This can be easily shown by case work.
Hint 3
We can observe that $$$n = 3$$$ and $$$n = 4$$$ are solvable with $$$4$$$ queries. This strategies are illustrated in the image below:
Solution to D1
There's many solutions that work. Given that 69 is big enough, we can use the previous observation of asking in pairs and reducing the problem recursively.
Combining hint 2 with our solutions for $$$n = 3$$$ and $$$n = 4$$$, we can come up with the following algorithm:
While $$$n > 4$$$,
query $$$n \mapsto n - 1$$$ and $$$n - 1 \mapsto n$$$.
If their answers don't match, one of them is the impostor. Query $$$n \mapsto n - 2$$$ and $$$n - 2 \mapsto n$$$.
If their answers don't match, $$$n$$$ is the impostor.
Otherwise, $$$n - 1$$$ is the impostor.
If the answers match, do $$$n -= 2$$$.
If $$$n > 4$$$ doesn't hold and we haven't found the impostor, we either have the $$$n = 3$$$ case or the $$$n = 4$$$ case, and we can solve either of them in $$$4$$$ queries.
In the worst case, this algorithm uses $$$n + 1$$$ queries. I'm also aware of a solution with $$$n + 4$$$ queries, $$$n + 2$$$ queries, and one with $$$n + \lceil\log(n)\rceil$$$ queries. We only present this solution to shorten the length of the blog but feel free to ask about the others in the comments.
Code:
#include <bits/stdc++.h>
using namespace std;
 
bool query(int i, int j, int ans = 0) {
  cout << "? " << i << " " << j << endl;
  cin >> ans;
  return ans;
}
 
int main() {
  int tt; 
  for (cin >> tt; tt; --tt) {
    int n, N; cin >> N; n = N;
    array<int, 2> candidates = {-1, -1};
 
    while (n > 4) {
      if (query(n - 1, n) != query(n, n - 1)) {
        candidates = {n - 1, n}; break;
      } else n -= 2;
    }
 
    if (candidates[0] != -1) {
      int not_candidate = (candidates[0] == N - 1) ? N - 2 : N;
 
      if (query(candidates[0], not_candidate) != query(not_candidate, candidates[0])) {
        cout << "! " << candidates[0] << endl;
      } else cout << "! " << candidates[1] << endl;
 
    } else  {
 
      if (n == 3) {
 
        if (query(1, 2) == query(2, 1)) cout << "! 3\n";
        else {
          if (query(1, 3) == query(3, 1)) cout << "! 2\n";
          else cout << "! 1\n";
        }
 
      } else {
 
        if (query(1 , 2) != query(2, 1)) {
          if (query(1, 3) == query(3, 1)) cout << "! 2\n";
          else cout << "! 1\n";
        } else {
          if (query(1, 3) != query(3, 1)) cout << "! 3\n";
          else cout << "! 4\n";
        }
 
      }
    }
  }
}
--------------------------------------------------
Problem ID: 2022C
Editorial Content:
2022C - Gerrymandering
Step 1
We will use dynamic programming to keep track of the maximum number of votes Álvaro can secure as we move from column to column (note that there are many ways to implement the DP, we will use the easiest to understand).
An important observation is that if you use a horizontal piece in one row, you also have to use it in the other to avoid leaving holes.
Step 2:
Let $$$dp[i][j]$$$ represent the maximum number of votes Álvaro can get considering up to the $$$i$$$-th column. The second dimension $$$j$$$ represents the current configuration of filled cells:
$$$j = 0$$$: All cells up to the $$$i$$$-th column are completely filled (including $$$i$$$-th).
$$$j = 1$$$: All cells up to the i-th column are completely filled (including $$$i$$$-th), and there’s one extra cell filled in the first row of the next column. $$$j = 2$$$: The $$$i$$$-th column is filled, and there’s one extra cell filled in the second row of the next column.
Step 3:
For simplicity, we will call "L", "second L", "third L", and "fourth L" respectively the next pieces:
From $$$dp[k][0]$$$ (Both rows filled at column $$$k$$$):
You can place a horizontal piece in both rows, leading to $$$dp[k+3][0]$$$.
You can place a first L piece, leading to $$$dp[k+1][1]$$$.
You can place an L piece, leading to $$$dp[k+1][2]$$$.
From $$$dp[k][1]$$$ (One extra cell in the first row of the next column):
You can place a horizontal piece in the first row occupying from $$$k+2$$$ to $$$k+4$$$ and also a horizontal piece in the second row from $$$k+1$$$ to $$$k+3$$$, leading to $$$dp[k+3][1]$$$.
You can place a fourth L, leading to $$$dp[k+2][0]$$$.
From $$$dp[k][2]$$$ (One extra cell in the second row of the next column):
You can place a horizontal piece in the first row occupying from $$$k+1$$$ to $$$k+3$$$ and also a horizontal piece in the second row from $$$k+2$$$ to $$$k+4$$$, leading to $$$dp[k+3][2]$$$.
You can place a third L, leading to $$$dp[k+2][0]$$$.
Step 4:
More formally for each DP state, the following transitions are possible:
From $$$dp[k][0]$$$:
$$$ dp[k+3][0] = max(dp[k+3][0], dp[k][0] + \text{vot}) $$$
$$$ dp[k+1][1] = max(dp[k+1][1], dp[k][0] + \text{vot}) $$$
$$$ dp[k+1][2] = max(dp[k+1][2], dp[k][0] + \text{vot}) $$$
From $$$dp[k][1]$$$:
$$$ dp[k+3][1] = max(dp[k+3][1], dp[k][1] + \text{vot}) $$$
$$$ dp[k+2][0] = max(dp[k+2][0], dp[k][1] + \text{vot}) $$$
From $$$dp[k][2]$$$:
$$$ dp[k+3][2] = max(dp[k+3][2], dp[k][2] + \text{vot}) $$$
$$$ dp[k+2][0] = max(dp[k+2][0], dp[k][2] + \text{vot}) $$$
To implement the DP solution, you only need to handle the transitions for states $$$dp[i][0]$$$ and $$$dp[i][1]$$$. For $$$dp[i][2]$$$, the transitions are the same as $$$dp[i][1]$$$, with the rows swapped.
Code:
#include <bits/stdc++.h>
using namespace std;
void solve()
{
    int n;
    cin>>n;
    vector<string>cad(n);
    vector<vector<int> >vot(2,vector<int>(n+8));
    for(int k=0;k<2;k++)
    {
	cin>>cad[k];
	for(int i=0;i<n;i++)
		if(cad[k][i]=='A')
			vot[k][i+1]=1;
    }
    vector<vector<int> >dp(n+9,vector<int>(3,-1));
    dp[0][0]=0;
    for(int k=0;k<=n-1;k++)
    {
	for(int i=0;i<3;i++)
	{
	    if(dp[k][i]!=-1)
	    {
	   	int vt=0,val=dp[k][i];
	  	    if(i==0)
		    {
			// *
			// *
			vt=(vot[0][k+1]+vot[0][k+2]+vot[0][k+3])/2+(vot[1][k+1]+vot[1][k+2]+vot[1][k+3])/2;
			dp[k+3][0]=max(vt+val,dp[k+3][0]);
			vt=(vot[1][k+1]+vot[0][k+2]+vot[0][k+1])/2;
			dp[k+1][1]=max(vt+val,dp[k+1][1]);
			vt=(vot[1][k+1]+vot[1][k+2]+vot[0][k+1])/2;
			dp[k+1][2]=max(vt+val,dp[k+1][2]);
		    }
		    if(i==1)
		    {
			// **
			// *
			vt=(vot[0][k+2]+vot[0][k+3]+vot[0][k+4])/2+(vot[1][k+1]+vot[1][k+2]+vot[1][k+3])/2;
			dp[k+3][1]=max(vt+val,dp[k+3][1]);
			vt=(vot[1][k+1]+vot[1][k+2]+vot[0][k+2])/2;
			dp[k+2][0]=max(vt+val,dp[k+2][0]);
	   	    }
		    if(i==2)
		    {
			//*
			//**
			vt=(vot[1][k+2]+vot[1][k+3]+vot[1][k+4])/2+(vot[0][k+1]+vot[0][k+2]+vot[0][k+3])/2;
			dp[k+3][2]=max(vt+val,dp[k+3][2]);
			vt=(vot[0][k+1]+vot[0][k+2]+vot[1][k+2])/2;
			dp[k+2][0]=max(vt+val,dp[k+2][0]);
		    }
	    }
	}
    }
    cout<<dp[n][0]<<endl;
}
int main() {
    int t;
    cin>>t;
    while(t--)
	solve();
}
Key Takeaways
Don't begin to implement until all the details are very clear, this will make your implementation much easier.
Draw images to visualize easier everything.
--------------------------------------------------
Problem ID: 2022B
Editorial Content:
2022B - Kar Salesman
Step 1
Since no customer can buy more than one car from the same model, the minimum number of clients we need is determined by the model with the most cars. Therefore, we need at least:
$$$\max\{a_1, a_2, \cdots a_n\}$$$
clients, because even if a customer buys cars from other models, they cannot exceed this limit for any single model.
Step 2
Each client can buy up to $$$x$$$ cars from different models. To distribute all the cars among the clients, we also need to consider the total number of cars. Thus, the minimum number of clients needed is at least:
$$$\displaystyle\left\lceil \frac{a_1 + a_2 + \cdots + a_n}{x}\right\rceil$$$
This ensures that all cars can be distributed across the clients, respecting the limit of $$$x$$$ cars per customer.
Step 3
The actual number of clients required is the maximum of the two values:
$$$\displaystyle\max\left\{\left\lceil \frac{a_1 + a_2 + \cdots + a_n}{x}\right\rceil, \max\{a_1, a_2, \cdots a_n\}\right\}$$$
This gives us a lower bound for the number of clients required, satisfying both constraints (the maximum cars of a single model and the total number of cars).
Alternative Solution
Apply binary search on the answer.
Proof 1
To demonstrate that this is always sufficient, we can reason that the most efficient strategy is to reduce the car count for the models with the largest numbers first. By doing so, we maximize the benefit of allowing each client to buy up to $$$x$$$ cars from different models.
After distributing the cars, two possible outcomes will arise:
All models will have the same number of remaining cars, and this situation will be optimal when the total cars are evenly distributed (matching the $$$\displaystyle\left\lceil \frac{a_1 + a_2 + ... + a_n}{x}\right\rceil$$$ bound).
There will be still a quantity of models less than or equal to x remaining, which matches the case where the maximum number of cars from a single model $$$\max(a_1, a_2, ..., a_n)$$$ determines the bound.
Proof 2 (by Errorgorn)
Imagine a grid of size $$$w \times x$$$, where $$$w$$$ represents the minimum number of clients needed:
$$$\displaystyle w = \max\left\{\left\lceil \frac{a_1 + a_2 + \cdots + a_n}{x}\right\rceil, \max\{a_1, a_2, \cdots a_n\}\right\}$$$
Now, place the cars in this grid by filling it column by column, from the first model to the $$$n$$$-th model. This method ensures that each client will buy cars from different models and no client exceeds the $$$x$$$ car limit. Since the total number of cars is less than or equal to the size of the grid, this configuration guarantees that all cars will be sold within $$$w$$$ clients.
Code:
#include <bits/stdc++.h>
using namespace std;
 
int main() {
	int t;
	cin>>t;
	while(t--)
	{
		long long n,x;
		cin>>n>>x;
		vector<long long>arr(n);
		long long sum=0;
		long long maximo=0;
		for(int k=0;k<n;k++)
		{
			cin>>arr[k];
			maximo=max(maximo,arr[k]);
			sum+=arr[k];
		}
		long long sec=(sum+x-1)/(long long)x;
		cout<<max(maximo,sec)<<endl;
	}
}
Key Takeaway
If you don't know how to solve a problem, try to solve for small cases to find a pattern.
--------------------------------------------------
Problem ID: 2022A
Editorial Content:
2022A - Bus to Pénjamo
Step 1
The key to maximizing happiness is to seat family members together as much as possible. If two members of the same family sit in the same row, both will be happy, and we only use two seats. However, if they are seated separately, only one person is happy, but two seats are still used. Therefore, we prioritize seating family pairs together first.
Step 2
Once all possible pairs are seated, there may still be some family members left to seat. If a family has an odd number of members, one person will be left without a pair. Ideally, we want to seat this person alone in a row to make them happy. However, if there are no remaining rows to seat them alone, we’ll have to seat them with someone from another family. This means the other person might no longer be happy since they are no longer seated alone.
Step 3
The easiest way to handle part 2 is to check the number of remaining rows and people. If the number of remaining rows is greater than or equal to the number of unpaired people, all unpaired people can sit alone and remain happy. Otherwise, some people will have to share a row, and their happiness will be affected. In that case, the number of happy people will be $$$2 \times$$$
remaining rows
$$$-$$$
remaining people
.
Code:
#include <bits/stdc++.h>
using namespace std;
 
int main() {
	int t;
	cin>>t;
	while(t--)
	{
		int n,r;
		cin>>n>>r;
		vector<int>arr(n);
		int leftalone=0;
		int happy=0;
		for(int k=0;k<n;k++)
		{
			cin>>arr[k];
			happy+=(arr[k]/2)*2;
			r-=arr[k]/2;
			leftalone+=arr[k]%2;
		}
		if(leftalone>r)
			happy+=r*2-leftalone;
		else
		 	happy+=leftalone;
		cout<<happy<<endl;
	}
}
Key Takeaway
Write down key observations and mix them to solve the problem
--------------------------------------------------
Problem ID: 2021E3
Editorial Content:

--------------------------------------------------
Problem ID: 2021E2
Editorial Content:

--------------------------------------------------
Problem ID: 2021E1
Editorial Content:

--------------------------------------------------
Problem ID: 2021D
Editorial Content:

--------------------------------------------------
Problem ID: 2021C2
Editorial Content:

--------------------------------------------------
Problem ID: 2021C1
Editorial Content:

--------------------------------------------------
Problem ID: 2021B
Editorial Content:

--------------------------------------------------
Problem ID: 2021A
Editorial Content:

--------------------------------------------------
Problem ID: 2020F
Editorial Content:

--------------------------------------------------
Problem ID: 2020E
Editorial Content:

--------------------------------------------------
Problem ID: 2020D
Editorial Content:

--------------------------------------------------
Problem ID: 2020C
Editorial Content:

--------------------------------------------------
Problem ID: 2020B
Editorial Content:

--------------------------------------------------
Problem ID: 2020A
Editorial Content:

--------------------------------------------------
Problem ID: 2019B
Editorial Content:
2019B - All Pairs Segments
Hint 1
Can you determine fast how many intervals contain point $$$p$$$?
Hint 2
The intervals that contain point $$$p$$$ are the ones with $$$l \leq p$$$ and $$$r \geq p$$$.
Hint 3
Determine how many intervals contain:
point $$$x_1$$$;
points $$$x_1 + 1, \ldots, x_2 - 1$$$;
point $$$x_2$$$;
$$$\ldots$$$
point $$$x_n$$$.
Solution
First, let's focus on determining how many intervals contain some point $$$x$$$. These intervals are the ones with $$$l \leq x$$$ and $$$x \leq r$$$.
So a point $$$x_i < p < x_{i+1}$$$ satisfies $$$x_1 \leq p, \ldots, x_i \leq p$$$, and $$$p \leq x_{i+1}, \ldots, p \leq x_n$$$. It means that you have found $$$x_{i+1} - x_i - 1$$$ points contained in exactly $$$i(n-i)$$$ intervals (because there are $$$i$$$ possible left endpoints and $$$n-i$$$ possible right endpoints).
Similarly, the point $$$p = x_i$$$ is contained in $$$i(n-i+1) - 1$$$ intervals (you have to remove interval $$$[x_i, x_i]$$$, which you do not draw).
So you can use a map that stores how many points are contained in exactly $$$x$$$ intervals, and update the map in the positions $$$i(n-i)$$$ and $$$i(n-i+1) - 1$$$.
Complexity: $$$O(n \log n)$$$
--------------------------------------------------
Problem ID: 2019A
Editorial Content:
2019A - Max Plus Size
Hint 1
Can you reach the score $$$\max(a) + \lceil n/2 \rceil$$$?
Hint 2
Can you reach the score $$$\max(a) + \lceil n/2 \rceil - 1$$$?
Solution
The maximum red element is $$$\leq \max(a)$$$, and the maximum number of red elements is $$$\lceil n/2 \rceil$$$. Can you reach the score $$$\max(a) + \lceil n/2 \rceil$$$?
If $$$n$$$ is even, you always can, by either choosing all the elements in even positions or all the elements in odd positions (at least one of these choices contains $$$\max(a)$$$).
If $$$n$$$ is odd, you can if and only if there is one occurrence of $$$\max(a)$$$ in an odd position. Otherwise, you can choose even positions and your score is $$$\max(a) + \lceil n/2 \rceil - 1$$$.
Complexity: $$$O(n)$$$
--------------------------------------------------
Problem ID: 2018F3
Editorial Content:
2018F3 - Speedbreaker Counting (Hard Version)
2018F3 - Speedbreaker Counting (Hard Version)
Hint 1
Suppose you are given a starting city and you want to win. Find several strategies to win (if possible) and try to work with the simplest ones.
Hint 2
The valid starting cities are either zero, or all the cities in $$$I := \cap_{i=1}^n [i - a_i + 1, i + a_i - 1] = [l, r]$$$.
Hint 3
Now you have some bounds on the $$$a_i$$$.
Hint 4
Fix the interval $$$I$$$ and try to find a (slow) DP.
Hint 5
Counting paths seems easier than counting arrays. Make sure that, for each array, you make exactly one path (or a number of paths which is easy to handle).
Hint 6
How many distinct states do you calculate in your DP?
Solution
Lemma 1
For a fixed starting city, if you can win, this strategy works:
[Strategy 1] If there is a city on the right whose distance is $$$t$$$ and whose deadline is in $$$t$$$ turns, go to the right. Otherwise, go to the left.
Proof:
All constraints on the right hold.
This strategy minimizes the time to reach any city on the left. So, if any strategy works, this strategy works too.
Corollary
For a fixed starting city, if you can win, this strategy works:
[Strategy 2] If there is a city whose distance is $$$t$$$ and whose deadline is in $$$t$$$ turns, go to that direction. Otherwise, go to any direction.
Lemma 2
The valid starting cities are either zero, or all the cities in $$$I := \cap_{i=1}^n [i - a_i + 1, i + a_i - 1] = [l, r]$$$.
Proof:
The cities outside $$$I$$$ are losing, because there exists at least one unreachable city.
Let's start from any city $$$x$$$ in $$$I$$$, and use Strategy 2.
You want to show that, for any $$$x$$$ in $$$I$$$, Strategy 2 can visit all cities in $$$I$$$ first, then all the other cities. Then, you can conclude that either all the cities in $$$I$$$ are winning, or they are all losing.
The interval $$$I$$$ gives bounds on the $$$a_i$$$: specifically, $$$a_i \geq \max(i-l+1, r-i+1)$$$. Then, you can verify that visiting the interval $$$I$$$ first does not violate Strategy 2.
Corollary
If you use Strategy 1, the first move on the right determines $$$l$$$.
$$$\LARGE O(n^4)$$$ DP
Let's iterate on the (non-empty) interval $$$I$$$. Let's calculate the bounds $$$a_i \geq \max(i-l+1, r-i+1)$$$. Note that Strategy 1 is deterministic (i.e., it gives exactly one visiting order for each fixed pair (starting city, $$$a$$$)). From now, you will use Strategy 1.
Now you will calculate the number of pairs ($$$a$$$, visiting order) such that the cities in $$$I$$$ are valid starting cities (and there might be other valid starting cities).
Let's define
dp[i][j][k] =
number of pairs ($$$a$$$, visiting order), restricted to the interval $$$[i, j]$$$, where $$$k =$$$ "are you forced to go to the right in the next move?". Here are the main ideas to find the transitions:
If you go from $$$[i+1, j]$$$ to $$$[i, j]$$$, you must ensure that $$$a_i \geq \max(i-l+1, r-i+1, j-i+1)$$$ (because you visit it at time $$$j-i+1$$$). Also, $$$k$$$ must be $$$0$$$.
If you go from $$$[i, j-1]$$$ to $$$[i, j]$$$, and you want to make $$$k = 0$$$, you must make $$$a_j = j-i+1$$$. It means that $$$j$$$ was the city that was enforcing you to go to the right.
In my code, the result is stored in
int_ans[i][j]
.
Now you want to calculate the number of pairs ($$$a$$$, visiting order) such that the cities in $$$I$$$ are the only valid starting cities. This is similar to 2D prefix sums, and it's enough to make
int_ans[i][j] -= int_ans[i - 1][j] + int_ans[i][j + 1] - int_ans[i - 1][j + 1]
.
Since, for a fixed $$$a$$$, the visiting order only depends on the starting city, the number of $$$a$$$ for the interval $$$[i, j]$$$ is now
int_ans[i][j] / (j - i + 1)
.
You have solved $$$k \geq 1$$$. The answer for $$$k = 0$$$ is just $$$n^n$$$ minus all the other answers.
$$$\LARGE O(n^3)$$$ DP
In the previous section, you are running the same DP for $$$O(n^2)$$$ different "bound arrays" on the $$$a_i$$$ (in particular, $$$O(n)$$$ arrays for each $$$k$$$). Now you want to solve a single $$$k$$$ with a single DP.
For a fixed $$$k$$$, you can notice that, if you run the DP on an array of length $$$2n$$$ instead of $$$n$$$, the bound array obtained from $$$I = [n-k+1, n]$$$ contains all the bound arrays you wanted as subarrays of length $$$n$$$. So you can run the DP and get all the results as
dp[i][i + n - 1][0]
.
$$$\LARGE O(n^2)$$$ DP
You still have $$$O(n^3)$$$ distinct states in total. How to make "bound arrays" simpler?
It turns out that you can handle $$$l$$$ and $$$r$$$ differently! You can create bound arrays only based on $$$r$$$ (and get $$$O(n^2)$$$ distinct states), and find $$$l$$$ using the Corollary of Lemma 2. The transitions before finding $$$l$$$ are very simple (you always go to the left). So a possible way to get $$$O(n^2)$$$ complexity is processing Strategy 1 and the DP in reverse order (from time $$$n$$$ to time $$$1$$$).
Complexity: $$$O(n^2)$$$
--------------------------------------------------
Problem ID: 2018F2
Editorial Content:
2018F2 - Speedbreaker Counting (Medium Version)
--------------------------------------------------
Problem ID: 2018F1
Editorial Content:
2018F1 - Speedbreaker Counting (Easy Version)
--------------------------------------------------
Problem ID: 2018E2
Editorial Content:
2018E2 - Complex Segments (Hard Version)
Hint 1
Solve for a fixed $$$m$$$ (size of the subsets).
Hint 2
$$$m = 1$$$ is easy. Can you do something similar for other $$$m$$$?
Hint 3
Solve for a fixed $$$k$$$ (number of subsets).
Hint 4
If you have a $$$O(n \log n)$$$ solution for a fixed $$$m$$$, note that there exists a faster solution!
Solution
Let's write a function
max_k(m)
, which returns the maximum $$$k$$$ such that there exists a partition of $$$k$$$ valid sets containing $$$m$$$ intervals each.
max_k
works in $$$O(n \log n)$$$ in the following way (using a lazy segment tree):
(wlog) $$$r_i \leq r_{i+1}$$$;
for each $$$i$$$ not intersecting the previous subset, add $$$1$$$ on the interval $$$[l[i], r[i]]$$$;
as soon as a point belongs to $$$m$$$ intervals, they become a subset;
return the number of subsets.
For a given $$$k$$$, you can binary search the maximum $$$m$$$ such that
max_k(m)
$$$\geq k$$$ in $$$O(n \log^2 n)$$$.
The problem asks for the maximum $$$mk$$$. Since $$$mk \leq n$$$, for any constant $$$C$$$ either $$$m \leq C$$$ or $$$k \leq n/C$$$. For $$$C = (n \log n)^{1/2}$$$, the total complexity becomes $$$O((n \log n)^{3/2})$$$, which is enough to solve
2018E1 - Complex Segments (Easy Version)
. You can also find
max_k(m)
for all $$$m$$$ with a divide and conquer approach, and the complexity becomes $$$O(n \sqrt n \log n)$$$ (see
here
).
Now let's go back to
max_k(m)
. It turns out you can implement it in $$$O(n \alpha(n))$$$.
First of all, let's make all the endpoints distinct, in such a way that two intervals intersect if and only if they were intersecting before.
Let's maintain a binary string of size $$$n$$$, initially containing only ones, that can support the following queries:
set bit in position $$$p$$$ to
0
;
find the nearest
1
to the left of position $$$p$$$.
This can be maintained with DSU, where the components are the maximal intervals containing
100...00
.
Now let's reuse the previous solution (sweeping $$$r$$$ from left to right), but instead of a segment tree we will maintain a binary string with the following information:
the positions $$$> r$$$ store
1
;
the positions $$$\leq r$$$ store
1
if and only if the value in that position (in the previous solution) is a suffix max.
So the queries become:
add $$$1$$$ to $$$[l, r]$$$:
$$$r$$$ changes, so you have to set elements in $$$[r'+1, r-1]$$$ to $$$0$$$;
the only other element that changes is the nearest
1
to the left of position $$$l$$$, which does not represent a suffix max anymore.
find the maximum: it's equal to the number of suffix maximums, which depends on $$$r$$$ and on the number of components.
This solution allows us to replace a $$$O(\log n)$$$ factor with a $$$O(\alpha(n))$$$ factor.
Complexity: $$$O(n \sqrt n \alpha(n))$$$
[Bonus: there exists a data structure faster than DSU to solve the subproblem above, so you can solve the problem in $$$O(n \sqrt n)$$$. See
here
.]
--------------------------------------------------
Problem ID: 2018E1
Editorial Content:
2018E1 - Complex Segments (Easy Version)
2018E1 - Complex Segments (Easy Version)
--------------------------------------------------
Problem ID: 2018D
Editorial Content:
2018D - Max Plus Min Plus Size
Hint 1
The optimal subsequence must contain at least one occurrence of the maximum.
Hint 2
Iterate over the minimum, in decreasing order.
Hint 3
You have some "connected components". How many elements can you pick from each component? How to make sure you have picked at least one occurrence of the maximum?
Solution
The optimal subsequence must contain at least one occurrence of the maximum ($$$r$$$) (suppose it doesn't; then you can just add one occurrence, at the cost of removing at most two elements, and this does not make your score smaller).
Now you can iterate over the minimum value ($$$l$$$), in decreasing order. At any moment, you can pick elements with values $$$[l, r]$$$. Then you have to support queries "insert pick-able element" and "calculate score".
The pick-able elements make some "connected components" of size $$$s$$$, and you can pick $$$\lceil s/2 \rceil$$$ elements. You can maintain the components with a DSU.
You also want to pick an element with value $$$r$$$. For each component, check if it contains $$$r$$$ in a subsequence with maximum size. If this does not happen for any component, your score decreases by $$$1$$$. All this information can be maintained by storing, for each component, if it contains $$$r$$$ in even positions, and if it contains $$$r$$$ in odd positions.
Complexity: $$$O(n \alpha(n))$$$
--------------------------------------------------
Problem ID: 2018C
Editorial Content:
2018C - Tree Pruning
Hint 1
Solve for a fixed final depth of the leaves.
Hint 2
Which nodes are "alive" if all leaves are at depth $$$d$$$ at the end?
Solution
If the final depth of the leaves is $$$d$$$, it's optimal to keep in the tree all the nodes at depth $$$d$$$ and all their ancestors. These nodes are the only ones which satisfy the following two conditions:
their depth ($$$a_i$$$) is $$$\leq d$$$;
the maximum depth of a node in their subtree ($$$b_i$$$) is $$$\geq d$$$.
So every node is alive in the interval of depths $$$[a_i, b_i]$$$. The optimal $$$d$$$ is the one contained in the maximum number of intervals.
--------------------------------------------------
Problem ID: 2018B
Editorial Content:
2018B - Speedbreaker
Hint 1
When is the answer $$$0$$$?
Hint 2
Starting from city $$$x$$$ is equivalent to setting $$$a_x = 1$$$.
Solution
At some time $$$t$$$, consider the minimal interval $$$[l, r]$$$ that contains all the cities with $$$a_i \leq t$$$ (let's call it "the minimal interval at time $$$t$$$"). You have to visit all this interval within time $$$t$$$, otherwise there are some cities with $$$a_i \leq t$$$ which you do not visit in time. So if this interval has length $$$> t$$$, you cannot visit it all within time $$$t$$$, and the answer is $$$0$$$.
Otherwise, the answer is at least $$$1$$$. A possible construction is visiting "the minimal interval at time $$$1$$$", then "the minimal interval at time $$$2$$$", ..., then "the minimal interval at time $$$n$$$". Note that, when you visit "the minimal interval at time $$$t$$$", the actual time is equal to the length of the interval, which is $$$\leq t$$$. In this way, at time $$$t$$$ you will have conquered all the cities in the minimal interval at time $$$t$$$, and possibly other cities.
Starting from city $$$x$$$ is equivalent to setting $$$a_x = 1$$$. After this operation, you have to guarantee that, for each $$$i$$$, the minimal interval at time $$$t$$$ is short enough. If this interval is $$$[l, r]$$$ before the operation, it can become either $$$[x, r]$$$ (if $$$x < l$$$), or $$$[l, x]$$$ (if $$$x > r$$$), or stay the same. In all this cases, the resulting length must be $$$\leq t$$$. With some calculations (e.g., $$$r-x+1 \leq t$$$), you can get than $$$x$$$ must be contained in $$$[r-t+1, l+t-1]$$$. So it's enough to calculate and intersect the intervals obtained at $$$t = 1, \ldots, n$$$, and print the length of the final interval.
You can calculate the minimal intervals by iterating on the cities in increasing order of $$$a_i$$$. Again, if the old interval is $$$[l, r]$$$ and the new city has index $$$x$$$, the new possible intervals are $$$[x, r]$$$, $$$[l, r]$$$, $$$[l, x]$$$.
Another correct solution is to intersect the intervals $$$[i-a_i+1, i+a_i-1]$$$. The proof is contained in the editorial of
2018F3 - Speedbreaker Counting (Hard Version)
.
Complexity: $$$O(n)$$$
--------------------------------------------------
Problem ID: 2018A
Editorial Content:
2018A - Cards Partition
Hint 1
The answer is at most $$$n$$$.
Hint 2
Solve the problem with $$$k = 0$$$.
Hint 3
When is the answer $$$n$$$?
Hint 4
If the answer is not $$$n$$$, how can you buy cards?
Solution
Note that there are $$$n$$$ types of cards, so the subsets have size at most $$$n$$$, and the answer is at most $$$n$$$.
If $$$k = 0$$$, you can make subsets of size $$$s$$$ if and only if the following conditions are true:
the number of cards ($$$m$$$) is a multiple of $$$s$$$;
the maximum number of cards of some type ($$$x$$$) is $$$\leq m/s$$$.
Proof:
$$$m$$$ is the number of decks times $$$s$$$.
The number of decks is $$$m/s$$$. Each deck can contain at most $$$1$$$ card of each type, so there are at most $$$m/s$$$ cards of each type in total.
If the two conditions above hold, you can make a deck containing the $$$s$$$ types of cards with maximum frequency. You can show with some calculations that the conditions still hold after removing these cards. So you can prove by induction that the two conditions are sufficient to make decks of size $$$s$$$.
The same idea is used in problems like
1954D - Colored Balls
and
abc227_d - Project Planning
.
For a generic $$$k$$$, the answer is $$$n$$$ if you can make the number of cards of type $$$1, \ldots, n$$$ equal. Otherwise, for any choice of number of cards to buy, you can buy them without changing $$$x$$$. It means that you need $$$x \cdot s$$$ cards in total:
if you have less than $$$x \cdot s$$$ cards, you have to check if you can reach $$$x \cdot s$$$ cards by buying at most $$$k$$$ new cards;
if you already have $$$x \cdot s$$$ or more cards at the beginning, you have to check if you can make $$$m$$$ a multiple of $$$s$$$.
Complexity: $$$O(n)$$$
--------------------------------------------------
Problem ID: 2014H
Editorial Content:
2014H - Robin Hood Archery
Hint 1
Lets say we are playing game on targets B1,B2,B3,...,Bm
What is the optimal strategy for players?
Hint 2
Players should always chose the maximum target.
Hint 3
Lets sort B in descending order.
Then Robin takes B1,B3,B5... and Sheriff will take B2,B4,....
Hint 4
Because B1 \ge B2, B3 \ge B4, and so on...
At this point, Sheriff can never win.
When can we have a draw?
Hint 5
We will have a draw if and only if no of targets is even, and B1 = B2, B3 = B4, and so on...
Hint 6
In other words, frequency of every no in B should be even.
Hint 7
How to check if frequency of every no is even?
Zobrist Hashing
--------------------------------------------------
Problem ID: 2014G
Editorial Content:
2014G - Milky Days
Hint 1
Lets first process each day one by one.
Hint 2
We should maintain list of all drinkable milks in a map.
We should remove all non drinkable milk.
We should add all the new milk we have got today.
Hint 3
Now split into 2 cases —
Latest milk quantity is less than m.
Latest milk quantity is atleast m,
Hint 4
For case 1, when latest milk quantity is less than m,
We should bruteforce by taking latest milk and until we have total m, or no milk remains.
Then increase time by 1.
Hint 5
For case 2, when latest milk quantity is atleast m,
Here, lets try to find how long can we drink current milk.
We can drink it until —
Some other milk comes
If current quantity is C, then we can drink it for next C/m days
If this milk came on dj day, we can drink it until dj+k-1 day
Take minimum of these 3, and assume we have gotten m milk each day.
Then remove this quantity from latest milk, and increase time.
--------------------------------------------------
Problem ID: 2014F
Editorial Content:
2014F - Sheriff's Defense
Hint 1
DP on trees
Hint 2
For each subtree dp1[u] denotes the best possible sum we can get if we consider only subtree of u and u is destroyed.
For each subtree dp2[u] denotes the best possible sum we can get if we consider only subtree of u and u is not destroyed.
--------------------------------------------------
Problem ID: 2014E
Editorial Content:
2014E - Rendez-vous de Marian et Robin
Hint 1
In addition, h of the n vertices each has a single horse available.
Just forget this condition exists, and assume each place contains unlimited horses.
Hint 1
Now for each place try to find the minimum time, if we reach there using a horse, and without a horse.
Hint 3
Try to solve above problem using a modified version of
Dijkstra's algorithm
Hint 3
At last fix a meeting point, and take maximum of minimum time each person takes to reach there with or without horse.
--------------------------------------------------
Problem ID: 2014D
Editorial Content:
2014D - Robert Hood and Mrs Hood
Hint 1
For each starting day lets find how many jobs it overlaps with.
Hint 2
Two Pointers
--------------------------------------------------
Problem ID: 2014C
Editorial Content:
2014C - Robin Hood in Town
Hint 1
Answer is impossible if n less than 3.
Hint 2
Lets first find minimum no of people that should be unhappy (say K).
Hint 3
Lets sort A, now average should be more than 2*Ak
Hint 4
Lets say pot has X gold.
Let S be the total gold.
$$$2*Ak \lt (S+X)/N$$$
$$$2*N*Ak \lt S+X$$$
$$$2*N*Ak-S \lt X$$$
$$$2*N*Ak-S+1 \le X$$$
So X should be max(0,2*N*ak-S+1)
--------------------------------------------------
Problem ID: 2014B
Editorial Content:
2014B - Robin Hood and the Major Oak
Hint 1
On last day only leaf grown between n-k+1 and n day will remain.
Hint 2
pow(i,i) is odd if i is odd, even if i is even.
Hint 3
We need no of odd numbers between n-k+1 and n
--------------------------------------------------
Problem ID: 2014A
Editorial Content:
2014A - Robin Helps
Idea
Maintain current amount of gold Robin has. Process all ai.
If ai>=k, increase counter by ai
If ai==0 and we have some gold, decrease current gold by 1 and increase answer.
--------------------------------------------------
Problem ID: 2013F2
Editorial Content:
2013F2 - Game in Tree (Hard Version)
Solution
My rating doesn’t allow me to understand it.
--------------------------------------------------
Problem ID: 2013F1
Editorial Content:
2013F1 - Game in Tree (Easy Version)
Hint 1
Let's pick this graph, and say we want to find the answer when Bob starts at node 8.
Hint 2
The game will proceed as follows: both Alice and Bob will move towards each other on the path between 1 and 8.
At some point, one of them will leave this path, allowing another person to take all remaining nodes if they want.
Hint 3
We don't really need a complete tree, just the distances of how long someone can go if they leave this path. The depth array ($$$d_1,d_2,...,d_k$$$) becomes $$$[0,2,1,4,1,2,1,4]$$$
Now, if Alice leaves at node 2, then they will travel a total of 4 nodes. We can
Hint 4
Now, if Alice leaves at node 2, then they will travel a total of 4 nodes.
Formally, if Alice leaves at ith node on this path, the distance she will travel is $$$i+d_i$$$ These will be distances for the example above. $$$[1,4,4,8,6,8,8,12]$$$
If Bob leaves at ith node on this path, the distance he will travel is $$$k-i+1+d_i$$$ These will be distances for the example above. $$$[8,9,7,9,5,5,3,5]$$$
Hint 5
Now, we can brute force game theory problem. FindWinner(aliceIdx,bobIdx,Turn) denotes who will be the winner if Alice is at aliceIdx on path, Bob is at bobIdx on path, and turn is (Alice/Bob) based on who is going to play.
Hint 6
At each turn player can see who will be the winner if they leave the path, and if they do not, and make a rational decision based on it.
Hint 7
Roughly, the following is the pseudo code -
// returns true if Alice wins, and false if Bob wins.
bool FindWinner(const lli aidx,const lli bidx,const bool isAliceTurn){
    if(isAliceTurn){
        // if Alice continues on the path.
        if(aidx+1<bidx&&FindWinner(aidx+1,bidx,!isAliceTurn))
            return true;
        // if Alice leave at current node.
        // You can use segment tree for this range max query.
        if(aliceDist[aidx]>max(bobDist[aidx+1:bidx]))
            return true;
        return false;
    }

    // if Bob continues on the path
    if(aidx+1<bidx&&!FindWinner(aidx,bidx-1,!isAliceTurn))
        return false;
    // if Bob leave at current index.
    // You can use segment tree for this range max query.
    if(bobDist[aidx]>=max(aliceDist[aidx:bidx-1]))
        return false;
    return true;
});
--------------------------------------------------
Problem ID: 2013E
Editorial Content:
2013E - Prefix GCD
Hint 1
What is the minimum value we can have first value? Take minimum.
Hint 2
Now, for the second element, find the element such that gcd(p1,ai) is the minimum possible.
Hint 3
In general, it greedily finds the next value such that gcd reduces as much as it can.
Hint 4
Well. Why does this greedy works?
Proof by AC
Smash me
--------------------------------------------------
Problem ID: 2013D
Editorial Content:
2013D - Minimize the Difference
Hint 1
What is the minimum possible value of the whole array?
Hint 2
One of the value must be less than or equal to the average of the array.
Hint 3
Now, notice that we only do -ve operations on the first element.
What is the minimum possible value of a2....,an?
(Again, think an average of a2....,an)
Hint 4
Similarly for every i, we will reduce (a1,a2,....ai-1) can only increase values in (ai,ai+1,.....,an).
So, what is the minimum value in this part?
(Again think average of ai,....,an)
Hint 5
Now, if we take the minimum of all of the above values, we know for sure that the final minimum is less than or equal to the above value.
As it turns out always possible to create an array such that above value will be the minimum possible.
Hint 6
Do similar stuff for maximum value and print their difference.
--------------------------------------------------
Problem ID: 2013C
Editorial Content:
2013C - Password Cracking
Hint 1
Let's say we know some string $$$s$$$ is a substring of $$$t$$$.
How can we extend it to find char just after this?
Hint 2
The idea is to query for $$$s0$$$ and $$$s1$$$; if one of them returns true, add that char to s and continue again.
Hint 3
If both $$$s0$$$ and $$$s1$$$ return false, then we know that our current string is the suffix of $$$t$$$. Now query for $$$0s$$$ and $$$1s$$$. and keep adding it in front.
Hint 3
In the worst case, this make take $$$2n+2$$$ queries. To avoid this, if $$$0s$$$ returns true, add $$$0$$$ in front. Otherwise, we know $$$1s$$$ will return true, so directly add it without asking.
--------------------------------------------------
Problem ID: 2013B
Editorial Content:
2013B - Battle for Survive
Hint 1
$$$n$$$ is the winner. $$$n-1$$$ will lose only against $$$n$$$.
Hint 2
For others, if we make them first against $$$n-1$$$ and atlast we have $$$n-1$$$ and $$$n$$$ fight, their score will be added.
Hint 3
So the final answer will be $$$A_1+A_2+....+A_{n-2}+A_{n}-A{n-2}$$$
--------------------------------------------------
Problem ID: 2013A
Editorial Content:
2013A - Zhan's Blender
Idea
In each second, we will blend $$$\min(x, c)$$$ fruits. So time taken is $$$\displaystyle \left \lceil \frac{n}{\min(x, c)} \right \rceil$$$
--------------------------------------------------
Problem ID: 2011I
Editorial Content:
2011I - Stack and Queue
Tutorial
Tutorial is loading...
Solution (awoo)
class Query(val t: Int, val x: Int)

class BIT(val mx: Int) {
	val f = LongArray(mx) { 0L }
	
	fun upd_pr(pos: Int, x: Int) {
		var i = pos
		while (i < mx) {
			f[i] = f[i] + x
			i = i or (i + 1)
		}
	}

	fun get_pr(pos: Int) : Long {
		var res = 0L
		var i = pos
		while (i >= 0) {
			res += f[i]
			i = (i and (i + 1)) - 1
		}
		return res
	}

	fun upd_su(pos: Int, x: Int) {
		var i = pos
		while (i >= 0) {
			f[i] = f[i] + x
			i = (i and (i + 1)) - 1
		}
	}

	fun get_su(pos: Int) : Long {
		var res = 0L
		var i = pos
		while (i < mx) {
			res += f[i]
			i = i or (i + 1)
		}
		return res
	}
}

fun main() {
	val n = readLine()!!.toInt()
	val a = readLine()!!.split(" ").map { it.toInt() }
	val q = Array(n) { Query(-1, -1) }
	for (i in 0 until n) {
		val (t, x) = readLine()!!.split(" ").map { it.toInt() }
		q[i] = Query(t, x - 1)
	}
	
	val d = IntArray(n + 1) { 0 }
	
	fun apply(coef: Int) {	
		var qs = Array<ArrayList<Pair<Int, Int>>>(n + 1) { ArrayList<Pair<Int, Int>>() }
		for (i in 0 until n) {
			qs[0].add(Pair(i, n + 1))
		}
		
		var len = n + 1
		while (true) {
			val posq = IntArray(n) { -1 }
			val poss = IntArray(n) { -1 }
			val sv = IntArray(n) { -1 }
			val fq = BIT(n)
			val fs = BIT(n)
			
			var cntq = 0
			var cnts = 0
			val nqs = Array<ArrayList<Pair<Int, Int>>>(n + 1) { ArrayList<Pair<Int, Int>>() }
			var j = 0
			
			var last = true
			for (l in 0 until n + 1) {
				for (it in qs[l]) {
					val i = it.first
					val r = it.second
					if (r - l == 1) {
						d[l] += coef
						continue
					}
					
					last = false
					val m = (l + r) / 2
					while (j < m) {
						val x = q[j].x
						if (q[j].t == 1) {
							posq[x] = cntq
							sv[x] = cnts
							cntq += 1
							cnts += 1
							fq.upd_pr(posq[x], a[x])
						}
						else if (q[j].t == 2){
							poss[x] = cnts
							cnts += 1
							fs.upd_su(poss[x], a[x])
						}
						else{
							fq.upd_pr(posq[x], -a[x])
							posq[x] = -1
							poss[x] = sv[x]
							fs.upd_su(poss[x], a[x])
						}
						j += 1
					}
					assert(j == m)
					if (poss[i] == -1 || posq[i] == -1) {
						nqs[m].add(Pair(i, r))
						continue
					}
					val tq = fq.get_pr(posq[i] - 1)
					val ts = fs.get_su(poss[i] + 1)
					var ok = true
					if (coef == 1) {
						ok = tq - a[i] >= ts
					}
					else {
						ok = tq + a[i] > ts
					}
					if (ok) {
						nqs[m].add(Pair(i, r))
					}
					else {
						nqs[l].add(Pair(i, m))
					}
				}
			}
			qs = nqs
			if (last) {
				break
			}
		}
		println("")
	}
	
	apply(1)
	apply(-1)
	for (i in 0 until n) {
		d[i + 1] += d[i]
	}
	val res = d.map { x -> (if (x == 0) "Yes" else "No") }
	println(res.take(res.size - 1).joinToString(separator = "\n"))
}
Solution 2 (awoo)
class Query(val t: Int, val x: Int)

class BIT(val mx: Int) {
    val f = LongArray(mx) { 0L }
    
    fun upd_pr(pos: Int, x: Int) {
        var i = pos
        while (i < mx) {
            f[i] = f[i] + x
            i = i or (i + 1)
        }
    }

    fun get_pr(pos: Int) : Long {
        var res = 0L
        var i = pos
        while (i >= 0) {
            res += f[i]
            i = (i and (i + 1)) - 1
        }
        return res
    }

    fun upd_su(pos: Int, x: Int) {
        var i = pos
        while (i >= 0) {
            f[i] = f[i] + x
            i = (i and (i + 1)) - 1
        }
    }

    fun get_su(pos: Int) : Long {
        var res = 0L
        var i = pos
        while (i < mx) {
            res += f[i]
            i = i or (i + 1)
        }
        return res
    }
}

fun main() {
    val n = readLine()!!.toInt()
    val a = readLine()!!.split(" ").map { it.toInt() }
    val q = Array(n) { Query(-1, -1) }
    for (i in 0 until n) {
        val (t, x) = readLine()!!.split(" ").map { it.toInt() }
        q[i] = Query(t, x - 1)
    }
    val fq = BIT(n)
    val fs = BIT(n)
    
    val d = IntArray(n + 1) { 0 }
    val posq = IntArray(n) { -1 }
    val poss = IntArray(n) { -1 }
    val sv = IntArray(n) { -1 }
    var cntq = 0
    var cnts = 0
    
    fun calc(l: Int, r: Int, coef: Int, all: ArrayList<Int>) {
        if (l == r - 1) {
            d[l] += all.size * coef
            return
        }
        
        val m = (l + r) / 2
        
        val who_chg = ArrayList<Int>()
        val idx_chg = ArrayList<Int>()
        val val_chg = ArrayList<Int>()
        val chq = ArrayList<Pair<Int, Int>>()
        val chs = ArrayList<Pair<Int, Int>>()
        
        for (i in l until m) {
            val x = q[i].x
            if (q[i].t == 1) {
                who_chg.add(0)
                idx_chg.add(x)
                val_chg.add(posq[x])
                posq[x] = cntq
                who_chg.add(2)
                idx_chg.add(x)
                val_chg.add(sv[x])
                sv[x] = cnts
                cntq += 1
                cnts += 1
                chq.add(Pair(posq[x], -a[x]))
                fq.upd_pr(posq[x], a[x])
            }
            else if (q[i].t == 2){
                who_chg.add(1)
                idx_chg.add(x)
                val_chg.add(poss[x])
                poss[x] = cnts
                cnts += 1
                chs.add(Pair(poss[x], -a[x]))
                fs.upd_su(poss[x], a[x])
            }
            else{
                chq.add(Pair(posq[x], a[x]))
                fq.upd_pr(posq[x], -a[x])
                who_chg.add(0)
                idx_chg.add(x)
                val_chg.add(posq[x])
                posq[x] = -1
                who_chg.add(1)
                idx_chg.add(x)
                val_chg.add(poss[x])
                poss[x] = sv[x]
                who_chg.add(2)
                idx_chg.add(x)
                val_chg.add(sv[x])
                sv[x] = -1
                chs.add(Pair(poss[x], -a[x]))
                fs.upd_su(poss[x], a[x])
            }
        }
    
        val tol = ArrayList<Int>()
        val tor = ArrayList<Int>()
        
        for (x in all) {
            if (poss[x] == -1 || posq[x] == -1) {
                tor.add(x)
                continue
            }
            val tq = fq.get_pr(posq[x] - 1)
            val ts = fs.get_su(poss[x] + 1)
            var ok = true
            if (coef == 1) {
                ok = tq - a[x] >= ts
            }
            else {
                ok = tq + a[x] > ts
            }
            if (ok) {
                tor.add(x)
            }
            else {
                tol.add(x)
            }
        }
    
        calc(m, r, coef, tor)
        
        who_chg.reverse()
        idx_chg.reverse()
        val_chg.reverse()
        
        for (i in 0 until who_chg.size) {
            if (who_chg[i] == 0) {
                posq[idx_chg[i]] = val_chg[i]
            }
            else if (who_chg[i] == 1) {
                poss[idx_chg[i]] = val_chg[i]
            }
            else {
                sv[idx_chg[i]] = val_chg[i]
            }
        }
        
        for (i in l until m) {
            if (q[i].t == 1) {
                cntq -= 1
                cnts -= 1
            }
            else if (q[i].t == 2){
                cnts -= 1
            }
        }

        for (it in chq) {
            fq.upd_pr(it.first, it.second)
        }
        for (it in chs) {
            fs.upd_su(it.first, it.second)
        }
        
        calc(l, m, coef, tol)
    }
    
    val all = ArrayList<Int>()
    for (i in 0 until n) {
        all.add(i)
    }
    calc(0, n + 1, 1, all)
    calc(0, n + 1, -1, all)
    for (i in 0 until n) {
        d[i + 1] += d[i]
    }
    val res = d.map { x -> (if (x == 0) "Yes" else "No") }
    println(res.take(res.size - 1).joinToString(separator = "\n"))
}
--------------------------------------------------
Problem ID: 2011H
Editorial Content:
2011H - Strange Matrix
Tutorial
Tutorial is loading...
Solution (Neon)
const val INF = 1e9.toInt()
const val B = 5

fun main() = repeat(readln().toInt()) {
  val (n, m, k) = readInts()
  val a = Array(n) { readInts() }
  
  var ans = 0
  
  for (bit in 0 until B) {
    val g = Array(n) { ArrayList<Pair<Int, Int>>() }
    for (i in 0 until n) {
      for (j in 0 until i) {
        val cnt = IntArray(4) { 0 }
        for (x in 0 until m) {
          val f = (a[i][x] shr bit) and 1
          val s = (a[j][x] shr bit) and 1
          ++cnt[f * 2 + s];
        }
        val f1 = (cnt[0] < k && cnt[3] < k)
        val f2 = (cnt[1] < k && cnt[2] < k)
        if (f1 != f2) {
          g[i].add(j to if (f2) 1 else 0)
          g[j].add(i to if (f2) 1 else 0)
        } else if (!f1) {
          return@repeat println("-1")
        }
      }
    }
    
    val color = IntArray(n) { -1 }
    val cnt = IntArray(2) { 0 }
    var ok = true
    
    fun dfs(v: Int, c: Int) {
      color[v] = c
      ++cnt[c]
      for ((u, d) in g[v]) {
        if (color[u] != -1) {
          if ((c xor d) != color[u]) {
            ok = false
          }
        } else {
          dfs(u, c xor d)
        }
      }
    }
    
    for (v in 0 until n) {
      if (color[v] != -1) continue
      cnt.fill(0)
      dfs(v, 0)
      if (!ok) return@repeat println("-1")
      ans += cnt.min() shl bit
    }
  }
  
  println(maxOf(0, ans))
}

fun readInts() = readln().split(" ").map { it.toInt() }
--------------------------------------------------
Problem ID: 2011G
Editorial Content:
2011G - Removal of a Permutation
Tutorial
Tutorial is loading...
Solution (Neon)
const val LOG = 19

fun main() = repeat(readln().toInt()) {  
  val n = readln().toInt()
  val p = readln().split(" ").map { it.toInt() - 1 }
  val ans = IntArray(n - 1) { n }
  
  fun rec(step: Int, p: List<Int>) {
    if (p.size == 1 || step == LOG) return
    for (cur in listOf(p, p.reversed())) {
      val (a, b) = cur.zipWithNext().partition { (x, y) -> x < y }
      a.forEach { (x, _) -> ans[x] = minOf(ans[x], step) }
      rec(step + 1, b.map { (x, _) -> x} + cur.last())
    }
  }
  
  rec(1, p)
  
  println(ans.joinToString(" "))
}
--------------------------------------------------
Problem ID: 2011F
Editorial Content:
2011F - Good Subarray
Tutorial
Tutorial is loading...
Solution (Neon)
fun main() = repeat(readln().toInt()) {  
  val n = readln().toInt()
  val a = readln().split(" ").map { it.toInt() - 1 }
  
  val prev = IntArray(n + 1) { -1 }
  val pos = IntArray(n) { -1 } 
  
  for (i in 0 until n) {
    for (j in a[i]-1..a[i]+1) {
      if (0 <= j && j < n) {
        prev[i] = maxOf(prev[i], pos[j])
      }
    }
    pos[a[i]] = i
  }
  
  val st = mutableListOf(n)
  var ans = 0L
  for (i in (n - 1) downTo 0) {
    while (st.size > 0 && prev[st.last()] >= i) {
      st.removeLast()
    }
    ans += st.last() - i
    st.add(i)
  }
  
  println(ans)
}
--------------------------------------------------
Problem ID: 2011E
Editorial Content:
2011E - Rock-Paper-Scissors Bot
Tutorial
Tutorial is loading...
Solution (Neon)
const val INF = 1e9.toInt()
const val vars = "RPS"

fun main() = repeat(readln().toInt()) {  
  val a = readln().map { vars.indexOf(it) }
  
  fun calc(a : List<Int>) : Int {
    if (a[0] != 0) return INF
    val balance = a.zipWithNext().fold(0) { s, (x, y) ->
      s + (if (x == y) 1 else 0) - (if ((x + 2) % 3 == y) 1 else 0)
    }
    return a.size + maxOf(balance, 0)
  }
  
  println(minOf(
    calc(a),
    calc(listOf(0) + a),
    calc(listOf(0, 2) + a)
   ))
}
--------------------------------------------------
Problem ID: 2011D
Editorial Content:
2011D - Among Wolves
Tutorial
Tutorial is loading...
Solution (adedalic)
fun main() {
    repeat(readln().toInt()) {
        val (n, h, b) = readln().split(' ').map { it.toLong() }
        val grid = Array(2) { readln() }
        val sheepColumn = grid[0].indices.find { grid[0][it] == 'S' || grid[1][it] == 'S' }!!
        val wolvesLeft = (0..1).sumOf { grid[it].take(sheepColumn).count { it == 'W' } }
        val wolvesRight = (0..1).sumOf { grid[it].substring(sheepColumn).count { it == 'W' } }

        val ans = minOf(
            (wolvesLeft + wolvesRight) * h,
            wolvesLeft * h + 2 * b,
            wolvesRight * h + 2 * b,
            3 * b
        )
        println(ans)
    }
}
--------------------------------------------------
Problem ID: 2011C
Editorial Content:
2011C - Split the Expression
Tutorial
Tutorial is loading...
Solution (Neon)
fun main() = repeat(readln().toInt()) {
  val a = readln().split("+")
  val ans = a.foldIndexed(0L) { i, res, s ->
    res + if (i == 0 || i == a.size - 1)
      s.toLong()
    else 
      (1 until s.length).maxOf { s.take(it).toLong() + s.drop(it).toLong() }
  }
  println(ans)
}
--------------------------------------------------
Problem ID: 2011B
Editorial Content:
2011B - Shuffle
Tutorial
Tutorial is loading...
Solution (Neon)
fun main() = repeat(readln().toInt()) {
  val n = readln().toInt()
  println((listOf(1) + (n downTo 2)).joinToString(" "))
}
--------------------------------------------------
Problem ID: 2011A
Editorial Content:
2011A - Problem Solving
Tutorial
Tutorial is loading...
Solution (Neon)
fun main() = repeat(readln().toInt()) {
  readln().toInt()
  val a = readln().split(" ").map { it.toInt() }
  println(if (a.dropLast(1).contains(a.last() - 1)) a.last() - 1 else "Ambiguous")
}
--------------------------------------------------
Problem ID: 2010C2
Editorial data not available.
--------------------------------------------------
Problem ID: 2010C1
Editorial data not available.
--------------------------------------------------
Problem ID: 2010B
Editorial data not available.
--------------------------------------------------
Problem ID: 2010A
Editorial data not available.
--------------------------------------------------
Problem ID: 2009G3
Editorial Content:
2009G3 - Yunli's Subarray Queries (extreme version)
Solution
I decided to write the Editorial for this problem in a step-by-step manner. Some of the steps are really short and meant to be used as hints but i decided to have a uniform naming for everything.
Step 1
Continuing from the easier versions of the problem, we know we need to compute sum of min of subarrays, and answer subarray queries on this. Consider the standard approach of finding sum of min over all subarrays.
Step 2
Sum of min of all subarrays for a fixed array is a well known problem. Here is how you can solve it, given an array $$$a$$$ of length $$$n$$$.
Let $$$nx_i$$$ denote the smallest integer $$$j (j > i)$$$ such that $$$a_j < a_i$$$ holds, or $$$n + 1$$$ if no such integer exists. Similarly, define $$$pv_i$$$ denote the largest integer $$$j (j < i)$$$ such that $$$a_j \le a_i$$$ holds, or $$$0$$$ if no such integer exists.
The answer is simply $$$\sum_{i = 1}^{n} a_i \cdot (nx_i - i) \cdot (i - pv_i)$$$. Calculating $$$nx_i$$$ and $$$pv_i$$$ can be done with Monotonic Stack.
Step 3
Given a query $$$(L, R)$$$, divide all indices $$$i$$$ ($$$L \le i \le R$$$) into $$$4$$$ groups depending on the existence of $$$nx_i$$$ and $$$pv_i$$$ within the interval $$$[L, R]$$$, i.e. :
Case $$$1$$$ : $$$L \le pv_i, nx_i \le R$$$
Case $$$2$$$ : $$$pv_i < L, nx_i \le R$$$
Case $$$3$$$ : $$$L \le pv_i, nx_i > R$$$
Case $$$4$$$ : $$$pv_i < L, nx_i > R$$$
Try to calculate the contributions of each of these categories separately.
Step 4
Case $$$1$$$ can be reduced to rectangle queries. Case $$$4$$$ is simple to handle as there is atmost $$$1$$$ element which satisfies that condition, which (if exists) is the minimum element in the range $$$(L, R)$$$ which can be found using any RMQ data structure like Sparse Table or Segment Tree.
What is Rectangle Queries?
Given a list of $$$n$$$ tuples $$$(l, r, v)$$$ and $$$q$$$ queries $$$(L, R)$$$ you have to add $$$v$$$ to answer of the $$$i$$$-th query if $$$L <= l <= r <= R$$$.
This can be solved in $$$O((n + q) log(n))$$$ using Fenwick Tree and Sweepline.
Iterate from $$$i = n$$$ to $$$i = 1$$$. For every tuple with left end at $$$i$$$ say $$$(i, j, v)$$$, add $$$v$$$ to a range query sum data structure at position $$$j$$$. Then, for every query with left end at $$$i$$$, we can simply query the range sum from $$$i = l$$$ to $$$i = r$$$ to get the required answer.
How to reduce Case 1 to Rectangle Queries?
For every index $$$i$$$ from $$$1$$$ to $$$n$$$, generate a tuple as $$$(pv_i, nx_i, a_i \cdot (i - pv_i) \cdot (nx_i - i)$$$. Then, solve the Rectangle Queries problem with this list of tuples. The answer will be the required contribution of all indices belonging to Case $$$1$$$.
Step 5
This leaves us with Case $$$2$$$ and $$$3$$$, which are symmetric, so we discuss only case $$$2$$$.
Let us sweepline from $$$i = n$$$ to $$$i = 1$$$, maintaining a Monotonic Stack of elements, popping elements when we find a smaller element, similar to how we find $$$pv_i$$$.
The indices belonging to Case $$$2$$$ are
precisely
the elements present in the Monotonic Stack (obviously ignore any element $$$> R$$$) when we have swept till $$$i = L$$$, with the possible exception of the minimum in the range $$$[L, R]$$$ (that might belong to Case $$$4$$$).
Step 6
Let's analyze the contribution of the indices in Case $$$2$$$.
It is $$$a_i \cdot (L - i + 1) \cdot (nx_i - i)$$$.
Take a look at what happens when we go from $$$L$$$ to $$$L - 1$$$, how do all the contributions of elements belonging to Case $$$2$$$ change.
Step 7
Some elements get popped from the Monotonic Stack because $$$a_{L - 1}$$$. We need to reset the contribution of all these elements to $$$0$$$.
The elements that do not get popped have their contribution increased by exactly $$$(nx_i - i)$$$.
$$$1$$$ element gets added to the Monotonic Stack, which is $$$a_{L - 1}$$$, so we need to initiliatize its contribution to $$$(nx_{L - 1} - (L - 1)).$$$
Step 8
Resetting and Initiliazing Contribution is simple enough with most data structures, so let us focus on adding $$$(nx_i - i)$$$ to the elements present in the Monotonic Stack.
We can keep a Lazy Segment Tree with $$$2$$$ parameters, $$$sumcon=$$$ sum of all contributions in this segment tree node, and $$$addcon = $$$ sum of $$$(nx_i - i)$$$ of all "non-popped" elements in this node. The lazy tag will denote how many contribution increases I have to do. We can simply do $$$sumcon += lazy * addcon$$$ for the lazy updates.
Then, we can query the range sum from $$$L$$$ to $$$R$$$ to get the sum of contributions of all elements belonging to Case $$$2$$$. Case $$$3$$$ can be solved in a symmetric way. Adding up the answers over Case $$$1$$$, $$$2$$$, $$$3$$$ and $$$4$$$ will give us the required answer.
Minor Detail
We need to be quite careful with the Case $$$4$$$ element, as we might double count its contribution in Case $$$2$$$ and $$$3$$$. I handle this in the model solution by querying the sum of contribution in $$$[L, X - 1]$$$ where $$$X$$$ is the largest element present in the monostack which is $$$\le R$$$, and handling $$$X$$$ separately. You can easily note that $$$X$$$ is the only element belonging to Case $$$4$$$ (if any at all).
Step 1
Continuing from the easier versions of the problem, we know we need to compute sum of min of subarrays, and answer subarray queries on this. Consider the standard approach of finding sum of min over all subarrays.
Step 2
Sum of min of all subarrays for a fixed array is a well known problem. Here is how you can solve it, given an array $$$a$$$ of length $$$n$$$.
Let $$$nx_i$$$ denote the smallest integer $$$j (j > i)$$$ such that $$$a_j < a_i$$$ holds, or $$$n + 1$$$ if no such integer exists. Similarly, define $$$pv_i$$$ denote the largest integer $$$j (j < i)$$$ such that $$$a_j \le a_i$$$ holds, or $$$0$$$ if no such integer exists.
The answer is simply $$$\sum_{i = 1}^{n} a_i \cdot (nx_i - i) \cdot (i - pv_i)$$$. Calculating $$$nx_i$$$ and $$$pv_i$$$ can be done with Monotonic Stack.
Step 3
Given a query $$$(L, R)$$$, divide all indices $$$i$$$ ($$$L \le i \le R$$$) into $$$4$$$ groups depending on the existence of $$$nx_i$$$ and $$$pv_i$$$ within the interval $$$[L, R]$$$, i.e. :
Case $$$1$$$ : $$$L \le pv_i, nx_i \le R$$$
Case $$$2$$$ : $$$pv_i < L, nx_i \le R$$$
Case $$$3$$$ : $$$L \le pv_i, nx_i > R$$$
Case $$$4$$$ : $$$pv_i < L, nx_i > R$$$
Try to calculate the contributions of each of these categories separately.
Step 4
Case $$$1$$$ can be reduced to rectangle queries. Case $$$4$$$ is simple to handle as there is atmost $$$1$$$ element which satisfies that condition, which (if exists) is the minimum element in the range $$$(L, R)$$$ which can be found using any RMQ data structure like Sparse Table or Segment Tree.
What is Rectangle Queries?
Given a list of $$$n$$$ tuples $$$(l, r, v)$$$ and $$$q$$$ queries $$$(L, R)$$$ you have to add $$$v$$$ to answer of the $$$i$$$-th query if $$$L <= l <= r <= R$$$.
This can be solved in $$$O((n + q) log(n))$$$ using Fenwick Tree and Sweepline.
Iterate from $$$i = n$$$ to $$$i = 1$$$. For every tuple with left end at $$$i$$$ say $$$(i, j, v)$$$, add $$$v$$$ to a range query sum data structure at position $$$j$$$. Then, for every query with left end at $$$i$$$, we can simply query the range sum from $$$i = l$$$ to $$$i = r$$$ to get the required answer.
How to reduce Case 1 to Rectangle Queries?
For every index $$$i$$$ from $$$1$$$ to $$$n$$$, generate a tuple as $$$(pv_i, nx_i, a_i \cdot (i - pv_i) \cdot (nx_i - i)$$$. Then, solve the Rectangle Queries problem with this list of tuples. The answer will be the required contribution of all indices belonging to Case $$$1$$$.
What is Rectangle Queries?
Given a list of $$$n$$$ tuples $$$(l, r, v)$$$ and $$$q$$$ queries $$$(L, R)$$$ you have to add $$$v$$$ to answer of the $$$i$$$-th query if $$$L <= l <= r <= R$$$.
This can be solved in $$$O((n + q) log(n))$$$ using Fenwick Tree and Sweepline.
Iterate from $$$i = n$$$ to $$$i = 1$$$. For every tuple with left end at $$$i$$$ say $$$(i, j, v)$$$, add $$$v$$$ to a range query sum data structure at position $$$j$$$. Then, for every query with left end at $$$i$$$, we can simply query the range sum from $$$i = l$$$ to $$$i = r$$$ to get the required answer.
How to reduce Case 1 to Rectangle Queries?
For every index $$$i$$$ from $$$1$$$ to $$$n$$$, generate a tuple as $$$(pv_i, nx_i, a_i \cdot (i - pv_i) \cdot (nx_i - i)$$$. Then, solve the Rectangle Queries problem with this list of tuples. The answer will be the required contribution of all indices belonging to Case $$$1$$$.
Step 5
This leaves us with Case $$$2$$$ and $$$3$$$, which are symmetric, so we discuss only case $$$2$$$.
Let us sweepline from $$$i = n$$$ to $$$i = 1$$$, maintaining a Monotonic Stack of elements, popping elements when we find a smaller element, similar to how we find $$$pv_i$$$.
The indices belonging to Case $$$2$$$ are
precisely
the elements present in the Monotonic Stack (obviously ignore any element $$$> R$$$) when we have swept till $$$i = L$$$, with the possible exception of the minimum in the range $$$[L, R]$$$ (that might belong to Case $$$4$$$).
Step 6
Let's analyze the contribution of the indices in Case $$$2$$$.
It is $$$a_i \cdot (L - i + 1) \cdot (nx_i - i)$$$.
Take a look at what happens when we go from $$$L$$$ to $$$L - 1$$$, how do all the contributions of elements belonging to Case $$$2$$$ change.
Step 7
Some elements get popped from the Monotonic Stack because $$$a_{L - 1}$$$. We need to reset the contribution of all these elements to $$$0$$$.
The elements that do not get popped have their contribution increased by exactly $$$(nx_i - i)$$$.
$$$1$$$ element gets added to the Monotonic Stack, which is $$$a_{L - 1}$$$, so we need to initiliatize its contribution to $$$(nx_{L - 1} - (L - 1)).$$$
Step 8
Resetting and Initiliazing Contribution is simple enough with most data structures, so let us focus on adding $$$(nx_i - i)$$$ to the elements present in the Monotonic Stack.
We can keep a Lazy Segment Tree with $$$2$$$ parameters, $$$sumcon=$$$ sum of all contributions in this segment tree node, and $$$addcon = $$$ sum of $$$(nx_i - i)$$$ of all "non-popped" elements in this node. The lazy tag will denote how many contribution increases I have to do. We can simply do $$$sumcon += lazy * addcon$$$ for the lazy updates.
Then, we can query the range sum from $$$L$$$ to $$$R$$$ to get the sum of contributions of all elements belonging to Case $$$2$$$. Case $$$3$$$ can be solved in a symmetric way. Adding up the answers over Case $$$1$$$, $$$2$$$, $$$3$$$ and $$$4$$$ will give us the required answer.
Minor Detail
We need to be quite careful with the Case $$$4$$$ element, as we might double count its contribution in Case $$$2$$$ and $$$3$$$. I handle this in the model solution by querying the sum of contribution in $$$[L, X - 1]$$$ where $$$X$$$ is the largest element present in the monostack which is $$$\le R$$$, and handling $$$X$$$ separately. You can easily note that $$$X$$$ is the only element belonging to Case $$$4$$$ (if any at all).
Code (C++) (awesomeguy856)
#include <bits/stdc++.h>
#define int long long
#define ll long long 
#define pii pair<int,int> 
#define piii pair<pii,pii>
#define fi first
#define se second
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt")
using namespace std;
struct segtree {
    const static int INF = 1e18, INF2 = 0;
    int l, r;
    segtree* lc, * rc;
    int v = INF, v2=0, v3=0, v4=0;
    segtree* getmem();
    segtree() : segtree(-1, -1) {};
    segtree(int l, int r) : l(l), r(r) {
        if (l == r) return;
        int m = (l + r) / 2;
        lc = getmem(); *lc = segtree(l, m);
        rc = getmem(); *rc = segtree(m + 1, r);
    }
    int op(int a, int b) {
        return min(a,b); 
    }
    int op2(int a, int b) {
        return a+b; 
    }
    void add(int qi, int qv, int h, int h4=0) {
        if (r < qi || l > qi) return;
        if (l == r) { if (v==INF) v=qv; v2+=qv, v3+=qv*h; v4+=qv*h4; return;}
        lc->add(qi, qv, h, h4); rc->add(qi, qv, h, h4);
        v = op(lc->v, rc->v);
        v2 = op2(lc->v2, rc->v2); 
        v3 = op2(lc->v3, rc->v3); 
        v4 = op2(lc->v4, rc->v4); 
    }
    int qrr(int ql, int qx) {
        if (v>=qx||r<ql) return 1e9; 
        if (l==r) return l; 
        int k=lc->qrr(ql,qx); 
        if (k<1e9) return k; 
        return rc->qrr(ql,qx); 
    }
    int q2(int ql, int qr) {
        if (l > qr || r < ql) return INF2;
        if (ql <= l && r <= qr) return v2;
        return op2(lc->q2(ql, qr), rc->q2(ql, qr));
    }
    int q3(int ql, int qr) {
        if (l > qr || r < ql) return INF2;
        if (ql <= l && r <= qr) return v3;
        return op2(lc->q3(ql, qr), rc->q3(ql, qr));
    }
    int q4(int ql, int qr) {
        if (l > qr || r < ql) return INF2; 
        if (ql <= l && r <= qr) return v4; 
        return op2(lc->q4(ql, qr), rc->q4(ql, qr)); 
    }
};
segtree mem[2000005];int memsz = 0;
segtree* segtree::getmem() { return &mem[memsz++]; }
void solve() {
    int n, k, q;
    cin >> n >> k >> q;
    vector<int> a(n);
    for (int &r : a) cin >> r;
    vector<int> c(2 * n), v(n);
    multiset<int> s;
    for (int i = 0; i < k; i++) c[a[i] - i + n - 1]++;
    for (int r : c) s.insert(r);
    v[k - 1] = k - *s.rbegin();
    for (int i = k; i < n; i++) {
        int x = a[i] - i + n - 1, y = a[i - k] - i + k + n - 1;
        c[x]++;
        s.erase(s.find(c[x] - 1));
        s.insert(c[x]);
        c[y]--;
        s.erase(s.find(c[y] + 1));
        s.insert(c[y]);
        v[i] = k - *s.rbegin();
    }
    vector<int> ans(q);
    vector<vector<pii>> w(n); 
    segtree co(0, n+2), lb(0, n+2), e(0,n+2),e2(0,n+2); 
    vector<int> rb(n); 
    stack<int> t; 
    for (int i = 0; i < q; i++) {
        int l,r; cin >> l >> r; 
        w[l+k-2].push_back({i,r-1}); 
    }
    for (int i = n-1; ~i; i--) {
        e.add(i,v[i],i,i*i); 
        int j=min(n,e.qrr(i,v[i])); 
        rb[i]=j; 
        e.add(j-1,-v[i],i,i*i);
        e2.add(j,v[i]*(j-i),i);
        while (!t.empty()) {
            int x=t.top(); 
            if (v[x]<v[i]) break;
            t.pop(); 
            co.add(rb[x],v[x]*(rb[x]-x)*(x-i),0); 
            lb.add(x,v[x]*(x-i),x);
            lb.add(rb[x]-1,-v[x]*(x-i),x); 
            e.add(x,-v[x],x,x*x);
            e.add(rb[x]-1,v[x],x,x*x);
            e2.add(rb[x],-v[x]*(rb[x]-x),x); 
        }
        t.push(i); 
        int l=i;
        for (auto [p,r]:w[i]) {
            int x=e.q2(l,r), y=e.q3(l,r), z=e.q4(l,r);
            int f=y*(r+1)-z, g=x*(r+1)-y; 
            int lx=lb.q2(l,r), ly=lb.q3(l,r); 
            ans[p]=co.q2(l,r+1)+lx*(r+1)-ly+e2.q3(l,r+1)-e2.q2(l,r+1)*(i-1)+f-g*(i-1);
        }
    }
    for (int r:ans) cout << r << "\n";
}

int32_t main() {
	ios::sync_with_stdio(0); cin.tie(0);
	int t = 1; cin >> t;
	while (t--) solve();
}
--------------------------------------------------
Problem ID: 2009G2
Editorial Content:
2009G2 - Yunli's Subarray Queries (hard version)
Prologue
First, read the solution to the easy version of the problem to compute the answer for every window of $$$k$$$. Let $$$c_i=f([a_i, ..., a_{i+k-1}])$$$. Now, the problem simplifies to finding
$$$\sum_{j=l}^{r-k+1} ( \min_{i=l}^{j} c_i)$$$
Solution 1 (Lazy Segment Tree, Offline)
We will answer the queries offline in decreasing order of $$$l$$$. We maintain a lazy segment tree. We have a variable $$$x$$$ sweeping from $$$n-k$$$ to $$$0$$$. As the variable sweeps leftwards, in node $$$i$$$ of the segment tree, we keep track of $$$\min_{j=x}^{i}c_i$$$.
To decrease the value of $$$x$$$, we note that the range $$$[x-1, y]$$$ in the segment tree will be set to $$$c_{x-1}$$$, where $$$y$$$ is the largest value such that $$$c_y>c_{x-1}$$$ but $$$c_{y+1}\leq c_{x-1}$$$ (or $$$y=n-1$$$). To find the $$$y$$$ for each $$$x$$$, we may either walk/binary search in the segment tree, or use a monotonic stack.
Code (C++) (vgoofficial)
#include "bits/stdc++.h"
#define int long long

template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {
    os << "[ ";
    for (const auto& elem : vec) {
        os << elem << " ";
    }
    os << "]";
    return os;
}

using namespace std;

int getAns(int& k, multiset<int>& ms) { return k - (*ms.rbegin()); }
struct SegTree {
    int n;
    vector<int> tree, setLazy, begin, end;
    void prop(int i) {
        if (setLazy[i] != -100) {
            setLazy[2 * i + 1] = setLazy[2 * i] = setLazy[i];
            tree[2 * i] = tree[2 * i + 1] =
                setLazy[i] * (end[2 * i + 1] - begin[2 * i + 1] + 1);
            setLazy[i] = -100;
        }
    }
    SegTree(int nn) {
        n = 1;
        while (n < nn) n *= 2;
        tree.resize(2 * n);
        setLazy.resize(2 * n, -100);
        begin.resize(2 * n);
        end.resize(2 * n);
        for (int i = n; i < 2 * n; i++) {
            begin[i] = end[i] = i - n;
        }
        for (int i = n - 1; i > 0; i--) {
            begin[i] = begin[2 * i];
            end[i] = end[2 * i + 1];
        }
    }
    void rangeSet(int i, int amt, int lo, int hi) {
        if (i < n) prop(i);
        if (begin[i] == lo && end[i] == hi) {
            tree[i] = amt * (hi - lo + 1);
            setLazy[i] = amt;
            return;
        }
        if (begin[2 * i] <= hi && end[2 * i] >= lo) {
            rangeSet(2 * i, amt, lo, min(hi, end[2 * i]));
        }
        if (begin[2 * i + 1] <= hi && end[2 * i + 1] >= lo) {
            rangeSet(2 * i + 1, amt, max(lo, begin[2 * i + 1]), hi);
        }
        tree[i] = tree[2 * i] + tree[2 * i + 1];
    }
    int query(int i, int lo, int hi) {
        if (i < n) prop(i);
        if (begin[i] == lo && end[i] == hi) return tree[i];
        int ans = 0;
        if (begin[2 * i] <= hi && end[2 * i] >= lo) {
            ans += query(2 * i, lo, min(end[2 * i], hi));
        }
        if (begin[2 * i + 1] <= hi && end[2 * i + 1] >= lo) {
            ans += query(2 * i + 1, max(lo, begin[2 * i + 1]), hi);
        }
        return ans;
    }
};
signed main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k, q;
        cin >> n >> k >> q;
        vector<int> v(n);
        for (int i = 0; i < n; i++) {
            cin >> v[i];
            v[i] = v[i] - i;
        }
        vector<int> ans(n);  // ans[i] is answer from i to i+k-1
        map<int, int> mp;
        multiset<int> active;
        for (int i = 0; i < k; i++) {
            if (mp[v[i]] == 0) {
                mp[v[i]] = 1;
                active.insert(1);
            } else {
                active.erase(active.find(mp[v[i]]));
                mp[v[i]]++;
                active.insert(mp[v[i]]);
            }
        }
        ans[0] = getAns(k, active);
        for (int i = k; i < n; i++) {
            // erase v[i-k]
            active.erase(active.find(mp[v[i - k]]));
            mp[v[i - k]]--;
            if (mp[v[i - k]] != 0) active.insert(mp[v[i - k]]);

            if (mp[v[i]] == 0) {
                mp[v[i]] = 1;
                active.insert(1);
            } else {
                active.erase(active.find(mp[v[i]]));
                mp[v[i]]++;
                active.insert(mp[v[i]]);
            }
            ans[i - k + 1] = getAns(k, active);
        }
        vector<array<int, 3>> queries(q);
        vector<int> an(q);
        for (int i = 0; i < q; i++) {
            queries[i][2] = i;
            cin >> queries[i][0] >> queries[i][1];
            queries[i][0]--;
            queries[i][1]--;
            queries[i][0] *= -1;
        }
        sort(begin(queries), end(queries));
        for (int i = 0; i < q; i++) queries[i][0] *= -1;
        SegTree st(n);
        st.rangeSet(1, ans[n - k], n - k, n - k);
        int cur = n - k;
        stack<pair<int, int>> s;
        s.push({ans[n - k], n - k});
        for (int i = 0; i < q; i++) {
            while (cur != queries[i][0]) {
                cur--;
                int here = cur;
                while (s.size() && s.top().first > ans[cur]) {
                    here = s.top().second;
                    s.pop();
                }
                s.push({ans[cur], here});
                st.rangeSet(1, ans[cur], cur, here);
            }
            an[queries[i][2]] =
                st.query(1, queries[i][0], queries[i][1] - k + 1);
        }
        for (auto x : an) cout << x << endl;
    }
}
Solution 2 (Binary Lifting, Online)
Let $$$p_i$$$ be the smallest value $$$j>i$$$ such that $$$c_j<c_i.$$$ We can calculate these values using a monotonic stack and iterating through $$$c$$$ backwards. If such $$$j$$$ does not exist, then we let $$$p_i=n.$$$ Then $$$f(h,i)=c_i$$$ for all $$$i\le h-k+1<p_i.$$$ Further, $$$f(h,i)=c_{p_i}$$$ for $$$p_i\le h-k+1<p_{p_i},$$$ and so on.
Now, let $$$w(0,i)=i,$$$ and $$$w(h,i)=p_{w(h-1,i)}$$$ for $$$h>0.$$$ To calculate the answer for a query $$$(l,r),$$$ consider the largest value of $$$j$$$ such that $$$w(j,l)\le r.$$$ Then we can take the sum $$$c_{w(j,l)}\cdot(r-w(j,l)+1)+\sum_{i=1}^jc_{w(i-1,l)}\cdot(w(i,l)-w(i-1,l)).$$$
Now it remains to quickly calculate this sum. We can use binary lifting to solve this. Specifically, we create an $$$n\times20$$$ data table where $$$d[i][j]=\sum_{h=1}^{2^j}c_{w(h-1,i)}\cdot(w(h,i)-w(h-1,i)),$$$ if $$$w(2^j,i)$$$ exists, and $$$-1$$$ otherwise. We can precompute this table recursively, as $$$d[i][0]=c_i\cdot(w(1,i)-i)$$$ and $$$d[i][j]=d[i][j-1]+d[w(2^{j-1},i)][j-1].$$$
Then, to answer queries, we iterate $$$j$$$ from $$$19$$$ to $$$0,$$$ and if $$$w(2^j,l)\le r,$$$ we add $$$d[l][j]$$$ to our answer, and set $$$l=w(2^j,l).$$$ At the end, we add $$$c_l\cdot(r-l+1)$$$ to our answer.
Code (C++) (awesomeguy856)
#include <bits/stdc++.h>
#define int long long
#define pii pair<int, int>
#define fi first
#define se second
using namespace std;
void solve() {
    int n, k, q;
    cin >> n >> k >> q;
    vector<int> a(n);
    for (int &r : a) cin >> r;
    vector<int> c(3 * n), v(n);
    multiset<int> s;
    for (int i = 0; i < k; i++) c[a[i] - i + n - 1]++;
    for (int r : c) s.insert(r);
    v[k - 1] = k - *s.rbegin();
    for (int i = k; i < n; i++) {
        int x = a[i] - i + n - 1, y = a[i - k] - i + k + n - 1;
        c[x]++;
        s.erase(s.find(c[x] - 1));
        s.insert(c[x]);
        c[y]--;
        s.erase(s.find(c[y] + 1));
        s.insert(c[y]);
        v[i] = k - *s.rbegin();
    }
    vector<int> l(n, -1);
    stack<pii> t;
    for (int i = k - 1; i < n; i++) {
        while (!t.empty()) {
            if (t.top().se <= v[i]) break;
            l[t.top().fi] = i;
            t.pop();
        }
        t.push({i, v[i]});
    }
    vector<vector<pii>> w(n, vector<pii>(20, {-1, -1}));
    for (int i = n - 1; i >= k - 1; i--) {
        w[i][0].se = l[i];
        if (l[i] < 0) {
            w[i][0].fi = (n - i) * v[i];
            continue;
        }
        w[i][0].fi = (l[i] - i) * v[i];
        for (int j = 1; j < 20; j++) {
            if (w[w[i][j - 1].se][j - 1].se < 0) break;
            w[i][j].se = w[w[i][j - 1].se][j - 1].se;
            w[i][j].fi = w[i][j - 1].fi + w[w[i][j - 1].se][j - 1].fi;
        }
    }
    while (q--) {
        int l, r, ans = 0;
        cin >> l >> r;
        l--;
        r--;
        l += k - 1;
        for (int j = 19; ~j; j--) {
            if (w[l][j].se < 0) continue;
            if (w[l][j].se > r) continue;
            ans += w[l][j].fi;
            l = w[l][j].se;
        }
        cout << ans + v[l] * (r - l + 1) << "\n";
    }
}
int32_t main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int t;
    cin >> t;
    while (t--) solve();
}
--------------------------------------------------
Problem ID: 2009G1
Editorial Content:
2009G1 - Yunli's Subarray Queries (easy version)
Solution
We first make the sequence $$$b_i=a_i-i$$$ for all $$$i$$$. Now, if $$$b_i=b_j$$$, then $$$i$$$ and $$$j$$$ are in correct relative order.
Now, to solve the problem, we precompute the answer for every window of $$$k$$$, and then each query is a lookup. We use a sliding window, maintaining a multiset of frequencies of values of $$$b$$$ in the current window. To move from the window $$$[i\ldots i+k-1]$$$ to $$$i+1 \ldots i+k$$$, we lower the frequency of $$$b_i$$$ by $$$1$$$, and increase the frequency of $$$b_{i+k}$$$ by $$$1$$$.
Code (C++) (yash_9a3b)
#include "bits/stdc++.h"
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,sse,sse2")
#define fast ios_base::sync_with_stdio(0) , cin.tie(0) , cout.tie(0)
#define endl '\n'
#define int long long
#define f first
#define mp make_pair
#define s second
using namespace std;

void solve(){
    int n, k, q; cin >> n >> k >> q;
    int a[n + 1]; for(int i = 1; i <= n; i++) cin >> a[i];
    map <int,int> m;
    multiset <int> tot;
    for(int i = 1; i <= n; i++) tot.insert(0);
    for(int i = 1; i < k; i++){
        tot.erase(tot.find(m[a[i] - i]));
        m[a[i] - i]++;
        tot.insert(m[a[i] - i]);
    }
    int ret[n + 1];
    for(int i = k; i <= n; i++){
        tot.erase(tot.find(m[a[i] - i]));
        m[a[i] - i]++;
        tot.insert(m[a[i] - i]);
        int p = i - k + 1;
        ret[p] = k - *tot.rbegin();
        tot.erase(tot.find(m[a[p] - p]));
        m[a[p] - p]--;
        tot.insert(m[a[p] - p]);
    }
    while(q--){
        int l, r ; cin >> l >> r;
        cout << ret[l] << endl;
    }
    tot.clear();
    m.clear();
}

signed main()
{
    fast;
    int t;
    cin >> t;
    while(t--){
        solve();
    }
}
--------------------------------------------------
Problem ID: 2009F
Editorial Content:
2009F - Firefly's Queries
Solution
Let's duplicate the array $$$a$$$ and concatenate it with itself. Now, $$$a$$$ should have length $$$2n$$$ and $$$a_i = a_{i-n}$$$ for all $$$n < i \leq 2n$$$. Now, the $$$j$$$'th element of the $$$i$$$'th rotation is $$$a_{i+j-1}$$$.
It can be shown for any integer $$$x$$$, it belongs in rotation $$$\lfloor \frac{x-1}{n} \rfloor + 1$$$ and at position $$$(x-1) \mod n + 1$$$. Let $$$rl$$$ denote the rotation for $$$l$$$ and $$$rr$$$ denote the rotation for $$$r$$$. If $$$rr - rl > 1$$$, we are adding $$$rr-rl-1$$$ full arrays to our answer. The leftovers is just the suffix of rotation $$$rl$$$ starting at position $$$l$$$ and the prefix of rotation of $$$rr$$$ starting at position $$$r$$$. This can be done with prefix sums. You may need to handle $$$rl=rr$$$ separately.
Code (C++) (awesomeguy856)
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int main() {
    int t;
    cin >> t;
    while (t--) {
        ll n, q;
        cin >> n >> q;
        vector<ll> a(n), ps(1);
        for (ll &r : a) {
            cin >> r;
            ps.push_back(ps.back() + r);
        }
        for (ll &r : a) {
            ps.push_back(ps.back() + r);
        }
        while (q--) {
            ll l, r;
            cin >> l >> r;
            l--; r--;
            ll i = l / n, j = r / n;
            l %= n; r %= n;
            cout << ps[n] * (j - i + 1) - (ps[i + l] - ps[i]) - (ps[j + n] - ps[j + r + 1]) << "\n";
        }
    }
}
--------------------------------------------------
Problem ID: 2009E
Editorial Content:
2009E - Klee's SUPER DUPER LARGE Array!!!
Solution
We can rewrite $$$x$$$ as $$$|a_1+\dots+a_i-(a_{i+1}+\dots+a_n)|$$$. Essentially, we want to minimize the absolute value difference between the sums of the prefix and the suffix. With absolute value problems. it's always good to consider the positive and negative cases separately. We will consider the prefix greater than the suffix separately with the less than case.
We can use binary search to search for the greatest $$$i$$$ such that $$$a_1 + \dots + a_i \leq a_{i+1} + \dots + a_n$$$. Note that here, the positive difference is minimized. If we move to $$$i+1$$$, then the negative difference is minimized (since the sum of prefix will now be less than the sum of suffix). The answer is the minimum absolute value of both cases.
To evaluate $$$a_1 + \dots + a_i$$$ fast, we can use the sum of arithmetic sequence formula.
Code (Python) (ntarsis30)
from collections import Counter
def val(mid):
    val1 = (mid+k-1+k)*mid//2
    val2 = (k+n-1+k)*n//2 - val1
    return val1,val2
for _ in range(int(input())):
    n,k = map(int,input().split())
    lo = 1
    hi = n
    curr = 1
    while lo <= hi:
        mid = (lo+hi)//2
        a,b = val(mid)
        if b>a:
            curr = mid
            lo = mid+1
        else:
            hi = mid-1
    a1,b1 = val(curr)
    a2,b2 = val(curr+1)
    print(min(b1-a1,a2-b2))
Code (Python) (Non-origination)
import sys
input=sys.stdin.readline

from math import floor,sqrt

f=lambda x: (2*x*x + x*(4*k-2) + (n-n*n-2*k*n))//2

t=int(input())
for _ in range(t):
    n,k=map(int,input().split())
    D=4*k*k + 4*k*(n-1) + (2*n*n-2*n+1)
    i=(floor(sqrt(D))-(2*k-1))//2
    ans=min(abs(f(i)),abs(f(i+1)))
    print(ans)
--------------------------------------------------
Problem ID: 2009D
Editorial Content:
2009D - Satyam and Counting
Solution
Initially, the obvious case one might first consider is an upright right triangle (specifically, the triangle with one of its sides parallel to the $$$y$$$-axis). This side can only be made with two points in the form $$$(x, 0)$$$ and $$$(x,1)$$$. We only need to search third point. Turns out, the third point can be any other unused vertex! If the third point has $$$y = 0$$$, then it will be an upright triangle, but if the third point has $$$y = 1$$$, it will simply be upside down.
One of the other case is in the form of $$$(x,0), (x+1,1), (x+2, 0)$$$. Let's see why this is a right triangle. Recall that in right triangle, the sum of the squares of two of the sides must equal to the square of the third side. The length between the first and the second point is $$$\sqrt 2$$$ because it is the diagonal of $$$1$$$ by $$$1$$$ unit block. Similarily, the second and third point also has length $$$\sqrt 2$$$. Obviously, the length between the first and third point is $$$2$$$. Since we have $$$\sqrt 2^2 + \sqrt 2^2 = 2^2$$$, this is certainly a right triangle. Of course, we can flip the $$$y$$$ values of each point and it will still be a valid right triangle, just upside down.
Code (Python) (ntarsis30)
from collections import Counter
for _ in range(int(input())):
    n = int(input())
    nums = []
    for i in range(n):
        x,y = map(int,input().split())
        nums.append((x,y))
    ans = 0
    b = Counter(x[0] for x in nums)
    check = set(nums)
    for i in b:
        if b[i]==2: ans += n-2
    for p in check:
        if (p[0]-1,p[1]^1) in check and (p[0]+1,p[1]^1) in check: 
            ans +=1
    print(ans)
--------------------------------------------------
Problem ID: 2009C
Editorial Content:
2009C - The Legend of Freya the Frog
Solution
Consider the $$$x$$$ and $$$y$$$ directions separately and calculate the jumps we need in each direction. The number of jumps we need in the $$$x$$$ direction is $$$\lceil \frac{x}{k} \rceil$$$ and similarily $$$\lceil \frac{y}{k} \rceil$$$ in the $$$y$$$ direction. Now let's try to combine them to obtain the total number of jumps. Let's consider the following cases:
$$$\lceil \frac{y}{k} \rceil \geq \lceil \frac{x}{k} \rceil$$$. In this case, there will need to be $$$\lceil \frac{y}{k} \rceil - \lceil \frac{x}{k} \rceil$$$ extra jumps in the $$$y$$$ direction. While Freya performs these extra jumps, she will choose $$$d = 0$$$ for the $$$x$$$ direction. In total, there will need to be $$$2 \cdot \lceil \frac{y}{k} \rceil$$$ jumps.
$$$\lceil \frac{x}{k} \rceil > \lceil \frac{y}{k} \rceil$$$. We can use the same reasoning as the previous case, but there's a catch. Since Freya is initially facing the $$$x$$$ direction, for the last jump, she does not need to jump in the $$$y$$$ direction. In total, there will need to be $$$2 \cdot \lceil \frac{x}{k} \rceil - 1$$$ jumps.
Code (Python) (ntarsis30)
for _ in range(int(input())):
    x,y,k = map(int,input().split())
    print(max(2*((x+k-1)//k)-1,2*((y+k-1)//k)))
--------------------------------------------------
Problem ID: 2009B
Editorial Content:
2009B - osu!mania
Solution
Implement the statement. Iterate from $$$n-1$$$ to $$$0$$$ and use the .find() method in std::string in C++ (or .index() in python) to find the '#' character.
Code (Python) (chromate00)
import sys
input=lambda:sys.stdin.readline().rstrip()

for i in range(int(input())):
    n=int(input())
    print(*reversed([input().index("#")+1 for i in range(n)]))
--------------------------------------------------
Problem ID: 2009A
Editorial Content:
2009A - Minimize!
Solution
We choose $$$c$$$ between $$$a$$$ and $$$b$$$ $$$(a \leq c \leq b)$$$. The distance is $$$(c - a) + (b - c) = b - a$$$. Note that the distance does not depend on the the position $$$c$$$ at all.
Code (Python) (ntarsis30)
for _ in range(int(input())):
    a,b = map(int,input().split())
    print(b-a)
--------------------------------------------------
Problem ID: 2008H
Editorial Content:
2008H - Sakurako's Test
Tutorial
Tutorial is loading...
Solution in C++
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int t=1;
    cin>>t;
    for(int i=1;i<=t;i++)
    {
        int n,m;
        cin>>n>>m;
        vector<int>a(n);
        vector<int>c(n+1,0ll);
        for(int i=0;i<n;i++)
        {
            cin>>a[i];
            c[a[i]]++;
        }
        for(int i=1;i<=n;i++)
        {
            c[i]+=c[i-1];
        }
        int res[n+1]={0};
        for(int x=1;x<=n;x++)
        {
            int l=0,r=x;
            while(l<r)
            {
                int mid=(l+r)/2;
                int cnt=c[mid];
                for(int k=1;k*x<=n;k++)
                {
                    cnt+=c[min(k*x+mid,n)]-c[k*x-1];
                }
                if(cnt-1>=n/2)
                {
                    r=mid;
                }
                else
                {
                    l=mid+1;
                }
            }
            res[x]=l;
        }
        while(m--)
        {
            int x;
            cin>>x;
            cout<<res[x]<<" ";
        }
        cout<<endl;
    }
}
Solution in Python
for _ in range(int(input())):
    n, m = map(int, input().split())
    a = list(map(int, input().split()))
    c = [0] * (n + 1)
    
    for i in range(n):
        c[a[i]] += 1
    
    for i in range(1, n + 1):
        c[i] += c[i - 1]
    
    res = [0] * (n + 1)
    
    for x in range(1, n + 1):
        l, r = 0, x
        while l < r:
            mid = (l + r) // 2
            cnt = c[mid]
            for k in range(1, n // x + 1):
                cnt += c[min(k * x + mid, n)] - c[k * x - 1]
            if cnt - 1 >= n // 2:
                r = mid
            else:
                l = mid + 1
        res[x] = l
    
    for _ in range(m):
        x = int(input())
        print(res[x])
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 2008G
Editorial Content:
2008G - Sakurako's Task
Tutorial
Tutorial is loading...
Solution in C++
#include <bits/stdc++.h>

using namespace std;

int main(){
    int t;
    cin>>t;
    while(t--)
    {
        int n,k;
        cin>>n>>k;
        long long a[n+1],g=0,mx=0;
        for(int i=0;i<n;i++)
        {
            cin>>a[i];
            g=__gcd(g,a[i]);
            mx=max(mx,a[i]);
        }
        if(g==0)
        {
            cout<<k<<endl;
            continue;
        }
        sort(a,a+n);
        int q=-g;
        if(n!=1)
        {
            for(int i=0;i<n;i++)
            {
                q+=g;
                a[i]=q;
            }
        }
        a[n]=1e16;
        long long lst=-1;
        for(int i=0;i<=n;i++)
        {
            if(k<=a[i]-lst-1)
            {
                break;
            }
            k-=max(a[i]-lst-1,0ll);
            lst=a[i];
        }
        cout<<lst+k<<endl;
    }
}
Solution in Python
import math

t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    g = 0
    mx = 0
    for i in range(n):
        g = math.gcd(g, a[i])
        mx = max(mx, a[i])
    if g == 0:
        print(k)
        continue
    a.sort()
    q = -g
    if n != 1:
        for i in range(n):
            q += g
            a[i] = q
    a.append(10**16)
    lst = -1
    for i in range(n + 1):
        if k <= a[i] - lst - 1:
            break
        k -= max(a[i] - lst - 1, 0)
        lst = a[i]
    print(lst + k)
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 2008F
Editorial Content:
2008F - Sakurako's Box
Tutorial
Tutorial is loading...
Solution in C++
#include <bits/stdc++.h>

using namespace std;
constexpr int mod=1e9+7;

long long binpow(long long a,long long b)
{
    if(b==0)
    {
        return 1;
    }
    if(b%2)
    {
        return (a*binpow(a,b-1))%mod;
    }
    return binpow((a*a)%mod,b/2);
}

int main(){
    int t;
    cin>>t;
    while(t--)
    {
        long long n;
        cin>>n;
        long long a[n],sum=0,sumsq=0;
        for(int i=0;i<n;i++)
        {
            cin>>a[i];
            sum+=a[i];sum%=mod;
            sumsq+=a[i]*a[i];
            sumsq%=mod;
        }
        sum*=sum;sum%=mod;
        sum=(sum-sumsq+mod)%mod;
        sum=(sum*binpow(2,mod-2))%mod;
        long long cnt=n*(n-1)/2;cnt%=mod;
        cout<<(sum%mod)*binpow(cnt,mod-2)%mod<<endl;
    }
}
Solution in Python
import sys; input = sys.stdin.readline
for i in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    ans = 0
    s = 0
    mod = int(1e9 + 7)
    for i in range(n): s += a[i]
    s %= mod
    for i in range(n):
        s -= a[i]
        ans = (ans + a[i] * s) % mod
    ans = (ans * pow(n * (n - 1) // 2, mod - 2, mod)) % mod
    print(ans)
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 2008E
Editorial Content:
2008E - Alternating String
Tutorial
Tutorial is loading...
Solution in C++
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        string s;
        cin>>s;
        int res=s.size();
        if(n%2==0)
        {
            vector<int>v[2]={vector<int>(26),vector<int>(26)};
            for(int i=0;i<n;i++)
            {
                v[i%2][s[i]-'a']++;
            }
            for(int i=0;i<2;i++)
            {
                int mx=0;
                for(int j=0;j<26;j++)
                {
                    mx=max(mx,v[i][j]);
                }
                res-=mx;
            }
            cout<<res<<endl;
        }
        else
        {
            vector<int>pref[2]={vector<int>(26),vector<int>(26)};
            vector<int>suf[2]={vector<int>(26),vector<int>(26)};
            for(int i=n-1;i>=0;i--)
            {
                suf[i%2][s[i]-'a']++;
            }
            for(int i=0;i<n;i++)
            {
                suf[i%2][s[i]-'a']--;
                int ans=n;
                for(int k=0;k<2;k++)
                {
                    int mx=0;
                    for(int j=0;j<26;j++)
                    {
                        mx=max(mx,suf[1-k][j]+pref[k][j]);
                    }
                    ans-=mx;
                }
                res=min(res,ans);
                pref[i%2][s[i]-'a']++;
            }
            cout<<res<<endl;
        }
    }
}
Solution in Python
t = int(input())
for _ in range(t):
    n = int(input())
    s = input()
    res = len(s)
    if n % 2 == 0:
        v = [[0] * 26 for _ in range(2)]
        for i in range(n):
            v[i % 2][ord(s[i]) - ord('a')] += 1
        for i in range(2):
            mx = max(v[i])
            res -= mx
        print(res)
    else:
        pref = [[0] * 26 for _ in range(2)]
        suf = [[0] * 26 for _ in range(2)]
        for i in range(n - 1, -1, -1):
            suf[i % 2][ord(s[i]) - ord('a')] += 1
        for i in range(n):
            suf[i % 2][ord(s[i]) - ord('a')] -= 1
            ans = n
            for k in range(2):
                mx = 0
                for j in range(26):
                    mx = max(mx, suf[1 - k][j] + pref[k][j])
                ans -= mx
            res = min(res, ans)
            pref[i % 2][ord(s[i]) - ord('a')] += 1
        print(res)
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 2008D
Editorial Content:
2008D - Sakurako's Hobby
Tutorial
Tutorial is loading...
Solution in C++
#include <bits/stdc++.h>

using namespace std;

int main(){
    int t;
    cin>>t;
    while(t--)
    {
        long long n;
        cin>>n;
        long long p[n+1]={0},b[n+1]={0};
        int us[n+1]={0};
        for(int i=1;i<=n;i++)
        {
            cin>>p[i];
        }
        string s;
        cin >> s;
        for(int i=1;i<=n;i++)
        {
            if(us[i])continue;
            int sz=0;
            while(!us[i])
            {
                us[i]=1;
                sz += s[i - 1] == '0';
                i=p[i];
            }
            while(us[i]!=2)
            {
                b[i]=sz;
                us[i]=2;
                i=p[i];
            }
        }
        for(int i=1;i<=n;i++)
        {
            cout<<b[i]<<" ";
        }
        cout<<endl;
    }
}
Solution in Python
t = int(input())
for _ in range(t):
    n = int(input())
    b = [0] * (n + 1)
    us = [0] * (n + 1)
    p = [k-1 for k in map(int, input().split())]
    s = input()
    for i in range(0, n):
        if us[i]:
            continue
        sz = 0
        while not us[i]:
            us[i] = 1
            sz += s[i] == '0'
            i = p[i]
        while us[i] != 2:
            b[i] = sz
            us[i] = 2
            i = p[i]
    print(" ".join(map(str, b[:-1])))
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 2008C
Editorial Content:
2008C - Longest Good Array
Tutorial
Tutorial is loading...
Solution in C++
#include <bits/stdc++.h>

using namespace std;

int main(){
    int t;
    cin>>t;
    while(t--)
    {
        long long a,b;
        cin>>a>>b;
        b-=a;
        long long l=2,r=1000000000;
        while(l<r)
        {
            long long m=(l+r)/2;
            if(m*(m-1)/2<=b)
            {
                l=m+1;
            }
            else
            {
                r=m;
            }
        }
        cout<<l-1<<endl;
    }
}
Solution in Python
for _ in range(int(input())): 
    a, b = map(int, input().split())
    i = 0
    while a + i <= b:
        a += i
        i += 1
    print(i)
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 2008B
Editorial Content:
2008B - Square or Not
Tutorial
Tutorial is loading...
Solution in C++
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        string s;
        cin>>s;
        int id=0;
        while(id<n&&s[id]=='1')
        {
            id++;
        }
        if(id==n)
        {
            if(n==4)
            {
                cout<<"Yes"<<endl;
            }
            else
            {
                cout<<"No"<<endl;
            }
        }
        else
        {
            if((id-1)*(id-1)==n)
            {
                cout<<"Yes"<<endl;
            }
            else
            {
                cout<<"No"<<endl;
            }
        }
    }
    return 0;
}
Solution in Python
for _ in range(int(input())):
    n=int(input())
    s=input()
    i=0
    while i<n and s[i]=='1':
        i+=1
    if i==n:
        if n==4:
            print("Yes")
        else:
            print("No")
        continue
    i-=1
    if i*i==n:
        print("Yes")
    else:
        print("No")
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 2008A
Editorial Content:
2008A - Sakurako's Exam
Tutorial
Tutorial is loading...
Solution in C++
#include <bits/stdc++.h>

using namespace std;

int main(){
    int t;
    cin>>t;
    while(t--)
    {
        int cnt1,cnt2;
        cin>>cnt1>>cnt2;
        if(cnt1%2)
        {
            cout<<"NO"<<endl;
        }
        else
        {
            if(cnt2%2==0)
            {
                cout<<"YES"<<endl;
            }
            else
            {
                if(cnt1==0)
                {
                    cout<<"NO"<<endl;
                }
                else
                {
                    cout<<"YES"<<endl;
                }
            }
        }
    }
}
Solution in Python
t=int(input())
for _ in range(t):
    a,b=map(int,input().split())
    if a%2==1:
        print("NO")
        continue
    if a==0 and b%2==1:
        print("NO")
        continue
    print("YES")
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 2007C
Editorial data not available.
--------------------------------------------------
Problem ID: 2007B
Editorial data not available.
--------------------------------------------------
Problem ID: 2007A
Editorial data not available.
--------------------------------------------------
Problem ID: 2006F
Editorial data not available.
--------------------------------------------------
Problem ID: 2006E
Editorial data not available.
--------------------------------------------------
Problem ID: 2006D
Editorial data not available.
--------------------------------------------------
Problem ID: 2006C
Editorial data not available.
--------------------------------------------------
Problem ID: 2006B
Editorial data not available.
--------------------------------------------------
Problem ID: 2006A
Editorial data not available.
--------------------------------------------------
Problem ID: 2005E2
Editorial Content:
2005E2 - Subtangle Game (Hard Version)
Hint 1
First solve E1.
Hint 2
Consider the following testcase -
1 2 2
2 2 1
2 3 3
If a player has to select $$$2$$$ from somewhere, they should only select $$$(1,3)$$$ or $$$(2,2)$$$ or $$$(3,1)$$$.
Selecting $$$(2,1)$$$ instead of $$$(2,2)$$$, will just increase no of possible moves for the opponent.
Hint 3
We should ignore the nos not present in A.
For each nos present X in A and each column C, we can precompute maximum R such that $$$B[R][C]=X$$$.
Hint 4
Now, we should play this game only on these indexes.
With careful implementation on can solve it in $$$O(N*M+N*L)$$$.
--------------------------------------------------
Problem ID: 2005E1
Editorial Content:
2005E1 - Subtangle Game (Easy Version)
Hint 1
Use
Minimax Algorithm
Hint 2
Let's say we know what positions a player playing $$$i+1$$$ can select and still win the game.
Can we use this information to find all the positions that a player playing $$$i$$$ move can select?
Hint 3
A player selecting $$$r,c$$$ on the move $$$i$$$ wins the game if and only if there is no position in $$$[r+1...n][c+1...m]$$$ which player playing $$$i+1$$$ move can select and win.
Hint 3
With careful implementation, one can solve the above problem in $$$O(N*M*L)$$$ time complexity.
--------------------------------------------------
Problem ID: 2005D
Editorial Content:
2005D - Alter the GCD
--------------------------------------------------
Problem ID: 2005C
Editorial Content:
2005C - Lazy Narek
Hint 1
Let's first simplify the scoring function.
Hint 2
Let's say we have fixed string $$$t$$$, you do we find the score?
Let the no of narek strings formed is $$$c$$$ and total no of chars narek is $$$t$$$.
No of chars found by chatgpt will be $$$t-5*c$$$.
The score is $$$5*c-(t-5*c) = 10*c-t$$$.
Hint 3
Another way to see this cost function is -
Chatgpt will reduce score by -1 whenever it finds any of the char narek.
We will increase by +10 whenever we complete the string narek.
Hint 4
Now, $$$dp[i][j]$$$ can be the maximum score so far such that we have processed the first $$$i$$$ string, and we have got the first $$$j$$$ chars of uncompleted narek string (which is required for +10).
--------------------------------------------------
Problem ID: 2005B2
Editorial Content:
2005B2 - The Strict Teacher (Hard Version)
Hint 1
We need the nearest teacher on the left side and right side, and then B1 solution works.
Hint 2
To find the nearest teachers, you can either use
binary search
or use
lower_bound stl
function.
--------------------------------------------------
Problem ID: 2005B1
Editorial Content:
2005B1 - The Strict Teacher (Easy Version)
Hint
Separately solve for cases when David is on left side of both the teachers, in between the teachers and right side of both the teachers.
--------------------------------------------------
Problem ID: 2005A
Editorial Content:
2005A - Simple Palindrome
Hint 1
Lets fix the count of aeiou $$$C_a,C_e,C_i,C_o,C_u$$$
What is the minimum number of subsequence palindromes?
Hint 2
No of palindromes that consist of only a is $$$2^{C_a}-1$$$ and similarly for eiou.
So lowerbound on no of palindrome is $$$2^{C_a}+2^{C_e}+2^{C_i}+2^{C_o}+2^{C_u}-5$$$
Does there exists a permutation where this lowerbound is achievable?
Hint 3
This lowerbound is achieved on strings of form aaaaaaaaaeeeeeeeeeeiiiiiiiiiioooooooooouuuuuuuuu
Hint 4
How to find optimal values of $$$C_a,C_e,C_i,C_o,C_u$$$?
Hint 5
In optimal answer $$$|C_x-C_y| \le 1$$$.
You can try to prove it using
exchange arguments technique
.
--------------------------------------------------
Problem ID: 2004G
Editorial Content:
2004G - Substring Compression
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
using namespace std;
 
const int D = 10;
const int INF = 1e9;
 
typedef array<array<int, D>, D> mat;
 
mat mul(const mat &a, const mat &b, bool fl){
	mat c;
	forn(i, D) forn(j, D) c[i][j] = INF;
	if (fl){
		forn(i, D) forn(j, D){
			c[j][i] = min(c[j][i], min(a[j][0] + b[0][i], a[j][i] + b[i][i]));
			c[j][0] = min(c[j][0], a[j][i] + b[i][0]);
		}
	}
	else{
		forn(i, D) forn(j, D){
			c[i][j] = min(c[i][j], min(a[i][0] + b[0][j], a[i][i] + b[i][j]));
			c[0][j] = min(c[0][j], a[0][i] + b[i][j]);
		}
	}
	return c;
}
 
struct minqueue{
	vector<pair<mat, mat>> st1, st2;
	
	void push(const mat &a){
		if (!st1.empty())
			st1.push_back({a, mul(st1.back().second, a, true)});
		else
			st1.push_back({a, a});
	}
	
	void pop(){
		if (st2.empty()){
			st2 = st1;
			reverse(st2.begin(), st2.end());
			st1.clear();
			assert(!st2.empty());
			st2[0].second = st2[0].first;
			forn(i, int(st2.size()) - 1)
				st2[i + 1].second = mul(st2[i + 1].first, st2[i].second, false);
		}
		st2.pop_back();
	}
	
	int get(){
		if (st1.empty()) return st2.back().second[0][0];
		if (st2.empty()) return st1.back().second[0][0];
		int ans = INF;
		forn(i, D) ans = min(ans, st2.back().second[0][i] + st1.back().second[i][0]);
		return ans;
	}
};
 
mat tran[D];
 
void init(int d){
	forn(i, D) forn(j, D) tran[d][i][j] = INF;
	for (int i = 1; i <= 9; ++i){
		tran[d][i][i] = i;
		tran[d][i][0] = i;
	}
	tran[d][0][d] = 0;
}
 
int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	for (int i = 1; i <= 9; ++i) init(i);
	int n, k;
	cin >> n >> k;
	string s;
	cin >> s;
	minqueue q;
	forn(i, n){
		q.push(tran[s[i] - '0']);
		if (i - k >= 0) q.pop();
		if (i - k >= -1) cout << q.get() << ' ';
	}
	cout << '\n';
	return 0;
}
--------------------------------------------------
Problem ID: 2004F
Editorial Content:
2004F - Make a Palindrome
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<int> a(n);
    for (auto& x : a) cin >> x;
    vector<int> p(n + 1);
    for (int i = 0; i < n; ++i) p[i + 1] = p[i] + a[i];
    map<int, int> cnt;
    long long ans = 0;
    for (int len = 0; len <= n; ++len) {
      for (int i = 0; i <= n - len; ++i) {
        int s = p[i] + p[i + len];
        ans += len;
        ans -= 2 * cnt[s];
        ans -= (s % 2 == 1 || !binary_search(p.begin(), p.end(), s / 2));
        cnt[s] += 1;
      }
    }
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 2004E
Editorial Content:
2004E - Not a Nim Problem
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
const int MOD = 998244353;
 
const int N = int(1e7) + 43;
 
int lp[N + 1];
vector<int> pr;
int idx[N + 1];
 
void precalc()
{
	for (int i = 2; i <= N; i++) 
	{
		if (lp[i] == 0) 
		{
			lp[i] = i;
			pr.push_back(i);
		}
		for (int j = 0; j < pr.size() && pr[j] <= lp[i] && i * 1ll * pr[j] <= N; ++j)
			lp[i * pr[j]] = pr[j];
	}
	for (int i = 0; i < pr.size(); i++)
		idx[pr[i]] = i + 1; 
}
 
int get(int x)
{
	if(x == 1) return 1;
 	x = lp[x];
 	if(x == 2)
 		return 0;
 	else return idx[x]; 		
}
 
void solve()
{             
	int n;
	scanf("%d", &n);
	int res = 0;
	for(int i = 0; i < n; i++)
	{
	 	int x;
	 	scanf("%d", &x);
	 	res ^= get(x);
	}
	if(res) puts("Alice");
	else puts("Bob");
}
 
int main()
{
 	precalc();
 	int t;
 	scanf("%d", &t);
 	for(int i = 0; i < t; i++) solve();
}
--------------------------------------------------
Problem ID: 2004D
Editorial Content:
2004D - Colored Portals
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
const int INF = 1e9;
const string vars[] = {"BG", "BR", "BY", "GR", "GY", "RY"};
 
int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    int n, q;
    cin >> n >> q;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
      char s[5];
      cin >> s;
      a[i] = find(vars, vars + 6, s) - vars;
    }
    vector<vector<int>> lf(n), rg(n);
    for (int o = 0; o < 2; ++o) {
      vector<int> last(6, -INF);
      for (int i = 0; i < n; ++i) {
        last[a[i]] = (o ? n - i - 1 : i);
        (o ? rg[n - i - 1] : lf[i]) = last;
      }
      reverse(a.begin(), a.end());
    }
    while (q--) {
      int x, y;
      cin >> x >> y;
      --x; --y;
      int ans = INF;
      for (int j = 0; j < 6; ++j) {
        if (a[x] + j != 5 && j + a[y] != 5) {
          ans = min(ans, abs(x - lf[x][j]) + abs(lf[x][j] - y));
          ans = min(ans, abs(x - rg[x][j]) + abs(rg[x][j] - y));
        }
      }
      if (ans > INF / 2) ans = -1;
      cout << ans << '\n';
    }
  }
}
--------------------------------------------------
Problem ID: 2004C
Editorial Content:
2004C - Splitting Items
Tutorial
Tutorial is loading...
Solution (adedalic)
fun main() {
    repeat(readln().toInt()) {
        val (n, k) = readln().split(" ").map { it.toInt() }
        val a = readln().split(" ").map { it.toInt() }.sortedDescending().toIntArray()

        var score = 0L
        var rem = k
        for (i in a.indices) {
            if (i % 2 == 0) {
                score += a[i]
            }
            else {
                val needed = minOf(rem, a[i - 1] - a[i])
                a[i] += needed
                rem -= needed
                score -= a[i]
            }
        }
        println(score)
    }
}
--------------------------------------------------
Problem ID: 2004B
Editorial Content:
2004B - Game with Doors
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  int t;
  cin >> t;
  while (t--) {
    int l, r, L, R;
    cin >> l >> r >> L >> R;
    int inter = min(r, R) - max(l, L) + 1;
    int ans = inter - 1;
    if (inter <= 0) {
      ans = 1;
    } else {
      ans += (l != L);
      ans += (r != R);
    }
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 2004A
Editorial Content:
2004A - Closest Point
Tutorial
Tutorial is loading...
Solution (BledDest)
t = int(input())
for i in range(t):
    n = int(input())
    x = list(map(int, input().split()))
    if n > 2 or x[0] + 1 == x[-1]:
        print('NO')
    else:
        print('YES')
--------------------------------------------------
Problem ID: 2003F
Editorial data not available.
--------------------------------------------------
Problem ID: 2003E2
Editorial data not available.
--------------------------------------------------
Problem ID: 2003E1
Editorial data not available.
--------------------------------------------------
Problem ID: 2003D2
Editorial data not available.
--------------------------------------------------
Problem ID: 2003D1
Editorial data not available.
--------------------------------------------------
Problem ID: 2003C
Editorial data not available.
--------------------------------------------------
Problem ID: 2003B
Editorial data not available.
--------------------------------------------------
Problem ID: 2003A
Editorial data not available.
--------------------------------------------------
Problem ID: 2002H
Editorial Content:
2002H — Counting 101
Hint 1
Try to solve Problem 101 with any approach.
Hint 2
Can you express the states in the solution for Problem 101 with some simple structures? Maybe dp of dp?
Hint 3
Try finding some unnecessary states and pruning them, to knock a $$$n$$$ off the complexity.
Tutorial
We analyse Problem 101 first. A dp solution will be, let $$$f_{l,r,v}$$$ be the minimum number of elements left after some operations, if we only consider elements in $$$a[l:r]$$$, without creating any elements $$$>v$$$. If $$$\max(a[l:r])<v$$$, then the answer is $$$1$$$ if $$$r-l+1$$$ is odd, and $$$2$$$ otherwise. We simply repeatedly perform operations with middle element as the center. It is easy to see that this is optimal.
If $$$\max(a[l:r])=v$$$, then $$$a[l:r]$$$ will be partitioned into blocks by elements equal to $$$v$$$. Denote the length of the blocks as $$$y_1,y_2,\cdots,y_l$$$. Let $$$b_i$$$ be the number of operations that has the $$$i$$$-th element with value $$$v$$$ as its center.
We can perform a dp as follows: let $$$g_{i,j}$$$ be the minimum number of elements left if we have already considered the first $$$i$$$ blocks, and $$$b_i=j$$$.
When adding a new block, we need to know several things:
$$$[l^\prime,r^\prime]$$$, the minimum/maximum number of elements of the new block after some operations, without creating an element greater than $$$v-1$$$.
$$$j_2$$$, the value of $$$b_{i+1}$$$.
The transition of the dp will be: $$$g_{i+1,j_2}=g_{i,j_1}+cost(j_1+j_2,l^\prime,r^\prime)$$$, where $$$cost(j,l,r)$$$ is defined as follows:
$$$ cost(j,l,r)=\left\{ \begin{aligned} +\infty,&&j>r\\ 0,&&l\le j\le r, j\equiv l\pmod2\\ 1,&&j\le r,j\not\equiv l\pmod2\\ 2,&&j<l, j\equiv l\pmod2\\ \end{aligned} \right. $$$
The $$$cost$$$ function follows from the case where $$$\max(a)<v$$$.
Now, we have a solution to Problem 101. We now consider generalizing it to Counting 101.
We make some observations regarding the structure of $$$g$$$. If you printed a table of $$$g$$$, you would discover that for each $$$g_i$$$, if you subtract the minimum element from all $$$g_{i,j}$$$ in this row, you will get something like: $$$[\cdots,2,1,2,1,2,1,0,1,0,1,0,1,0,1,2,1,2,\cdots]$$$.
We can prove this by induction and some casework, which is omitted for brevity. If a $$$g_i$$$ satisfies this property, then we can express it with a triple $$$(l,r,mn)$$$, where $$$mn$$$ is the minimum element of $$$g_i$$$, and $$$l,r$$$ are the minimum/maximum $$$j$$$ such that $$$g_{i,j}=mn$$$.
Now that we can express the structure of each $$$g_i$$$ with a triple $$$(l,r,mn)$$$, we can run a dp of dp. Our state will be $$$dp_{i,v,l,r,mn}$$$, where $$$i$$$ is the current length, $$$v$$$ is the upper bound, and $$$(l,r,mn)$$$ describes the current $$$g$$$. For each transition, we need to enumerate $$$l^\prime,r^\prime$$$, and the new $$$(l,r,mn)$$$ can be found in $$$O(1)$$$ with some casework. This gives us an $$$O(n^6m)$$$ solution.
Now to optimize the solution. We optimize the solution by reducing the number of viable states. Suppose we have a state $$$+(l,r,mn)$$$, we claim, that the answer will remain the same if we replace it with $$$+(l,\infty,mn)+(l\bmod2,r,mn)-(l\bmod2,\infty,mn)$$$.
We prove this by examining their behaviour when we add any number of blocks after them. If the answer remains unchanged for any blocks we can add, then the claim stands. Suppose we are at $$$g_i$$$, and we will add a sequence of blocks $$$S$$$ after $$$g_i$$$. The final answer can be found by running a backwards dp similar to $$$g$$$, on $$$\text{rev}(S)$$$, and merging with $$$g_i$$$ in the middle.
If we denote the backwards dp as $$$g^\prime$$$, then the answer will be $$$\min(g_j+g^\prime_j)$$$ over all $$$j$$$. It can be shown after some brief casework (using $$$g$$$'s structure), that there exists an optimal $$$j$$$ where $$$g_{i,j}$$$ is the minimum of $$$g_i$$$, thus the answer is just a range (with a certain parity) min of $$$g^\prime$$$, plus $$$mn$$$. Because $$$g^\prime$$$ also follow $$$g$$$'s structure, any range will be first decreasing, then increasing. It can be shown with these properties, $$$\min(g^\prime[l:r])=\min(g^\prime[l:\infty])+\min(g^\prime[l\bmod2:r])-\min(g^\prime[l\bmod2:\infty])$$$. Thus, our answer will not change when substituting the states.
After substituting, the total number of different $$$l,r$$$ pairs will be $$$O(n)$$$, which yields an $$$O(n^5m)$$$ solution.
The solution can also be optimized to $$$O(n^4m)$$$ using Lagrange Interpolation, but it actually runs slower than $$$O(n^5m)$$$ because of large constants (or bad implementation by setters).
Solution (orzdevinwang)
#include <bits/stdc++.h>
#pragma comment(linker, "/stack:200000000")
#pragma GCC optimize("Ofast")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
#define L(i, j, k) for(int i = (j); i <= (k); ++i)
#define R(i, j, k) for(int i = (j); i >= (k); --i)
#define ll long long
#define vi vector <int>
#define sz(a) ((int) (a).size())
#define me(f, x) memset(f, x, sizeof(f))
#define ull unsigned long long
#define pb emplace_back
using namespace std;
const int N = 133, mod = 1e9 + 7;
struct mint {
    int x;
    inline mint(int o = 0) {
        x = o;
    }
    inline mint &operator = (int o) {
        return x = o, *this;
    }
    inline mint &operator += (mint o) {
        return (x += o.x) >= mod && (x -= mod), *this;
    }
    inline mint &operator -= (mint o) {
        return (x -= o.x) < 0 && (x += mod), *this;
    }
    inline mint &operator *= (mint o) {
        return x = (ll) x * o.x % mod, *this;
    }
    inline mint &operator ^= (int b) {
        mint w = *this;
        mint ret(1);

        for (; b; b >>= 1, w *= w)
            if (b & 1)
                ret *= w;

        return x = ret.x, *this;
    }
    inline mint &operator /= (mint o) {
        return *this *= (o ^= (mod - 2));
    }
    friend inline mint operator + (mint a, mint b) {
        return a += b;
    }
    friend inline mint operator - (mint a, mint b) {
        return a -= b;
    }
    friend inline mint operator * (mint a, mint b) {
        return a *= b;
    }
    friend inline mint operator / (mint a, mint b) {
        return a /= b;
    }
    friend inline mint operator ^ (mint a, int b) {
        return a ^= b;
    }
};
inline mint qpow(mint x, int y = mod - 2) {
    return x ^ y;
}
mint fac[N], ifac[N], inv[N];
void init(int x) {
    fac[0] = ifac[0] = inv[1] = 1;
    L(i, 2, x) inv[i] = (mod - mod / i) * inv[mod % i];
    L(i, 1, x) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * inv[i];
}
mint C(int x, int y) {
    return x < y || y < 0 ? 0 : fac[x] * ifac[y] * ifac[x - y];
}
inline mint sgn(int x) {
    return (x & 1) ? mod - 1 : 1;
}

int n, m;
mint f[N][N];
mint g[N][N];
mint h1[N][N][N];
mint h2[N][N][N];
mint pw[N][N];
int ans[N][N][N];
int main() {
    ios :: sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    n = 130, m = 30;
    // n = m = 10;
    L(i, 0, max(n, m)) {
        pw[i][0] = 1;
        L(j, 1, max(n, m)) pw[i][j] = pw[i][j - 1] * i;
    }
    f[0][0] = 1;
    int c1 = 0, c2 = 0;
    L(test, 1, m) {
        me(g, 0);
        int up = n;
        L(i, 0, up + 1) L(j, 0, i) L(l, 0, i) h1[i][j][l] = h2[i][j][l] = 0;
        h2[0][0][0] = 1;
        L(i, 0, up + 1) {
            L(j, 0, i) L(l, 0, i) h1[i][j][l & 1] -= h1[i][j][l];
            L(j, 0, i) {
                for (int l = (i - j) & 1; l <= i; l += 2)
                    if (h1[i][j][l].x) {
                        L(k, 0, up - i) {
                            if (l > k) {
                                int tr = k - !(l & 1);

                                if (tr < 0)
                                    h2[i + k + 1][j + 3][0] += h1[i][j][l] * pw[test - 1][k];
                                else
                                    h2[i + k + 1][j + 2][tr] += h1[i][j][l] * pw[test - 1][k];
                            } else {
                                h2[i + k + 1][j + 1][k - l] += h1[i][j][l] * pw[test - 1][k];
                            }
                        }
                    }

                for (int r = (i - j) & 1; r <= i; r += 2)
                    if (h2[i][j][r].x) {
                        int l = r & 1;
                        L(k, 0, up - i) {
                            if (l > k) {
                                int tr = k - !(r & 1);

                                if (tr < 0)
                                    h2[i + k + 1][j + 3][0] += h2[i][j][r] * pw[test - 1][k];
                                else
                                    h2[i + k + 1][j + 2][tr] += h2[i][j][r] * pw[test - 1][k];
                            } else {
                                h2[i + k + 1][j + 1][k - l] += h2[i][j][r] * pw[test - 1][k];

                                L(d, r + 1, k) if (f[k][d].x)
                                    h1[i + k + 1][j + 1][d - r] += h2[i][j][r] * f[k][d];
                            }
                        }
                    }
            }
        }
        // cout << "H = " << h[1][1][0][0].x << endl;
        L(i, 1, up + 1)
        L(j, 1, i) {

            L(l, 0, i) if (h1[i][j][l].x) {
                if (!l)
                    g[i - 1][j - 1] += h1[i][j][l];
                else
                    g[i - 1][j - 1 + (l % 2 == 0 ? 2 : 1)] += h1[i][j][l];
            }

            L(r, 0, i) if (h2[i][j][r].x) {
                if (!(r & 1))
                    g[i - 1][j - 1] += h2[i][j][r];
                else
                    g[i - 1][j - 1 + (r % 2 == 0 ? 2 : 1)] += h2[i][j][r];
            }
        }
        L(i, 1, up) {
            mint vl = 0;

            if (i == 1)
                vl = test;
            else if (i % 2 == 1) {
                vl += pw[test - 1][i];
                L(p, 1, i - 2) {
                    int l = p, r = i - p - 1;

                    if (l > r)
                        swap(l, r);

                    L(j, 1, l) {
                        vl += f[r][j] * pw[test - 1][l];
                    }
                }
            }

            g[i][1] = vl;
            mint sum = 0;
            L(j, 1, i) sum += g[i][j];
            int pos = (i & 1) ? 3 : 2;
            g[i][pos] += pw[test][i] - sum;
        }
        swap(f, g);

        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                ans[test][i][j] = f[i][j].x;
            }
        }
    }
    // cout << "clock = " << clock() << endl;
    int T;
    cin >> T;

    while (T--) {
        int N, M;
        cin >> N >> M;
        L(i, 0, (N - 1) / 2)
        cout << ans[M][N][N - i * 2] << " ";
        cout << '\n';
    }

    return 0;
}
--------------------------------------------------
Problem ID: 2002G
Editorial Content:
2002G — Lattice Optimizing
Hint 1
Meet in the middle with a twist.
Hint 2
Union of sets is hard. Disjoint union of sets is easy.
Tutorial
The problem hints strongly at meet in the middle, at each side, there will be $$$O(2^n)$$$ paths. The twist is on merging: we are given two sequence of sets $$$S_1,S_2,\cdots$$$ and $$$T_1,T_2,\cdots$$$, we have to find the maximum $$$\textrm{MEX}(S_i\cup T_j)$$$.
If we enumerate over the maximum MEX $$$P$$$, we only need to check whether there exists two sets such that $$$\{ 0,1,\cdots,P-1\} \subseteq S_i\cup T_j$$$.
Instead of meeting at $$$n$$$, we perform meet in the middle at the partition of $$$Bn$$$ and $$$(2-B)n$$$. For each $$$S_i$$$, we put all its subsets $$$S^\prime_i$$$ into a hashmap. When checking MEX $$$P$$$, we iterate over all $$$T_j$$$, and check whether $$$\{ 0,1,\cdots,P-1\} -T_j$$$ is in the hashmap. This gives us a $$$O((2^{2Bn}+2^{(2-B)n})\cdot n)$$$ solution, which is optimal at $$$B=\frac23$$$, where the complexity is $$$O(2^{\frac43}\cdot n)$$$.
We can substitute enumerating $$$P$$$ with binary search, yielding $$$O(2^{\frac43n}\cdot\log n)$$$, or checking whether $$$P$$$ can be increased each time, yielding $$$O(2^{\frac43n})$$$.
Instead of hashmaps, you can also insert all $$$S$$$ and $$$T$$$'s into a trie, and run a brute force dfs to search for MEX $$$P$$$. It can be proven that the complexity is also $$$O(2^{\frac43n}\cdot n)$$$.
The intended solution is $$$O(2^{\frac43 n})$$$, however solutions that have slightly higher complexity can pass with good optimizations.
Time complexity: $$$O(2^{\frac43n})$$$.
Solution
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int D[111][111], R[111][111], n;
const int P = 30000019;
struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
} HH;
int sta[P], top;
struct uset {
    struct edge {
        pair<int, ll> v;
        int next;
        edge() {} edge(pair<int, ll> _v, int _next) {
            v = _v;
            next = _next;
        }
    } e[20000011];
    int head[P], sz;
    uset() {
        memset(head, -1, sizeof(head));
        sz = 0;
    }
    void insert(pair<int, ll> x) {
        int u = HH(x.second * n + x.first) % P;
        sta[++top] = u;

        for (int i = head[u]; ~i; i = e[i].next)
            if (e[i].v == x)
                return;

        e[++sz] = edge(x, head[u]);
        head[u] = sz;
    }
    bool find(pair<int, ll> x) {
        int u = HH(x.second * n + x.first) % P;

        for (int i = head[u]; ~i; i = e[i].next)
            if (e[i].v == x)
                return 1;

        return 0;
    }
} st;
int B;
void dfs1(int x, int y, ll S, int tp) {
    if (x + y == B) {
        st.insert({x, S});
        return;
    }

    if (y < n) {
        dfs1(x, y + 1, S, 0);
        dfs1(x, y + 1, S | 1ll << R[x][y], -1);
    }

    if (x < n) {
        if (tp != 0)
            dfs1(x + 1, y, S, 1);

        dfs1(x + 1, y, S | 1ll << D[x][y], -1);
    }
}
int ans = 0;
void dfs2(int x, int y, ll S) {
    if (x + y == B) {
        int res = 0;

        while (ans <= 2 * n - 2) {
            if (st.find({x, (~S) & (1ll << (ans + 1)) - 1}))
                ans++;
            else
                break;
        }

        return;
    }

    if (x > 1)
        dfs2(x - 1, y, S | 1ll << D[x - 1][y]);

    if (y > 1)
        dfs2(x, y - 1, S | 1ll << R[x][y - 1]);
}
void solve() {
    while (top)
        st.head[sta[top--]] = -1;

    st.sz = 0;
    ans = 0;
    scanf("%d", &n);

    for (int i = 1; i < n; ++i)
        for (int j = 1; j <= n; ++j)
            scanf("%d", D[i] + j);

    for (int i = 1; i <= n; ++i)
        for (int j = 1; j < n; ++j)
            scanf("%d", R[i] + j);

    B = 2 * n / 3 + 2;
    dfs1(1, 1, 0, -1);
    dfs2(n, n, 0);
    printf("%d\n", ans);
}
int main() {
    int T;
    scanf("%d", &T);

    while (T--)
        solve();

    return 0;
}
Solution (trie, LipArcanjo)
#include <bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define int long long
void dbg_out() {
    cerr << endl;
}
template <typename H, typename... T>
void dbg_out(H h, T... t) {
    cerr << ' ' << h;
    dbg_out(t...);
}
#define dbg(...) { cerr << #__VA_ARGS__ << ':'; dbg_out(__VA_ARGS__); }
using ll = long long;
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

const int MAXN = 3e7 + 5;
const int MOD = 1e9 + 7; //998244353;
const int INF = 0x3f3f3f3f;
const ll INF64 = ll(4e18) + 5;

int D[40][40];
int R[40][40];

int L;

int32_t trie[MAXN][2];
int n;
int li = 1;
void add(int x) {
    int at = 0;
    int K = 2 * n - 2;

    for (int i = 0; i <= K; i++) {
        int id = (x >> i) & 1;

        if (trie[at][id] == 0) {
            trie[at][id] = li++;
        }

        at = trie[at][id];
    }
}

void limpa() {
    for (int i = 0; i < li; i++) {
        trie[i][0] = trie[i][1] = 0;
    }

    li = 1;
}

int query(int at, int x, int dep) {
    int id = (x >> dep) & 1;

    if (id == 0) {
        if (trie[at][1]) {
            return query(trie[at][1], x, dep + 1);
        }

        return dep;
    }

    int ans = dep;

    if (trie[at][0])
        ans = max(ans, query(trie[at][0], x, dep + 1));

    if (trie[at][1])
        ans = max(ans, query(trie[at][1], x, dep + 1));

    while ((x >> ans) & 1)
        ans++;

    return ans;
}

void rec_in(int i, int j, int tar1, int tar2, int v) {
    if (i > tar1 || j > tar2)
        return;

    if (i == tar1 && j == tar2) {
        add(v);
    }

    int right = v | (1ll << R[i][j]);
    int down = v | (1ll << D[i][j]);
    rec_in(i + 1, j, tar1, tar2, down);
    rec_in(i, j + 1, tar1, tar2, right);
}

int ANS = 0;
void rec_out(int i, int j, int tar1, int tar2, int v) {
    if (i < tar1 || j < tar2)
        return;

    if (i == tar1 && j == tar2) {
        ANS = max(ANS, query(0, v, 0));
        return;
    }

    int left = v | (1ll << R[i][j - 1]);
    int up = v | (1ll << D[i - 1][j]);
    rec_out(i - 1, j, tar1, tar2, up);
    rec_out(i, j - 1, tar1, tar2, left);
}

void solve() {
    ANS = 0;

    for (int i = 1; i <= li; i++)
        trie[i][0] = trie[i][1] = 0;

    li = 1;
    cin >> n;
    L = 4 * n / 3;

    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n; j++) {
            cin >> D[i][j];
        }
    }

    if (L > n) {
        L--;
    }

    if (L > n) {
        L--;
    }

    if (L > n) {
        L--;
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - 1; j++) {
            cin >> R[i][j];
        }
    }

    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (i + j == L) {
                limpa();
                rec_in(0, 0, i, j, 0);
                rec_out(n - 1, n - 1, i, j, 0);
            }

    cout << ANS << '\n';

}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int t = 1;
    cin >> t;

    while (t--) {
        solve();
    }

    return 0;
}
--------------------------------------------------
Problem ID: 2002F2
Editorial Content:
2002F2 — Court Blue (Hard Version)
Hint
Try generalizing the solution of F1.
Hint (alternate version)
Write anything and pray that it will pass because of number theory magic.
Tutorial
We generalize the solution in F1. Let $$$p$$$ be the largest prime $$$\le m$$$ and $$$q$$$ be the largest prime $$$\le\min(n,p-1)$$$. The problem is that there might be $$$\gcd(q,i)\neq1$$$ for some $$$p+1\le i\le m$$$, thus invalidating our previous analysis.
To solve this, we simply choose $$$q$$$ to be the largest integer such that $$$q\le n$$$ and $$$\gcd(q,i)=1$$$ for all $$$p+1\le i\le m$$$. An asymptotic analysis of this solution is as follows:
As the length of $$$[p+1,m]$$$ is $$$O(P(m))$$$, and each of these integers have at most $$$O(\log_nm)$$$ prime divisors of $$$O(m)$$$ magnitude, which means that if we only restrict $$$q$$$ to primes, we will have to skip at most $$$O(P(n)\log_nm)$$$ primes to find the largest $$$q$$$. As the density of primes is $$$O(\frac1{P(n)})$$$, the asymptotic of $$$n-q$$$ will be $$$O(P(m)\log_nm\cdot P(n))=O(P(m)^2)$$$, our actual $$$q$$$ (which is not restricted to primes) will not be worse than this. Thus, our total area will be $$$O(P(m)^3)$$$, times the gcd complexity gives us an $$$O(P(m)^3\log m)$$$ solution. However, the actual area is much lower than this.
Under the constraints of the problem, when forcing $$$p,q$$$ to take primes, the maximum area is $$$39960$$$, and the sum of the $$$10^3$$$ largest areas is $$$3.44\times10^7$$$. The actual solution will not be worse than this.
Because we only need to check whether $$$\gcd(x,y)=1$$$, the complexity can actually be optimized to $$$O(P(m)^3)$$$ with some sieves. Namely, iterating over prime divisors $$$d$$$ of $$$[p,m]$$$ and $$$[q,n]$$$ and marking all cells which has $$$d$$$ as its common divisor.
This solution is by far from optimal. We invite you to continue optimizing your solutions and try to minimize the number of cells visited in each query :)
Time complexity: $$$O(P(m)^3\log m)$$$
Select solutions from paticipants and testers
Solution 1
Keep $$$p$$$ the same, set $$$q$$$ to $$$p-L$$$ and only keep reachable cells in $$$[p,n]\times [q,m]$$$. $$$L$$$ is some constant ($$$100$$$ should work).
We found this solution during testing, tried, and failed to hack it.
Solution 2
Keep $$$p$$$ the same, do dfs from each cell $$$(n,p),(n-1,p),\cdots$$$, prioritizing increasing $$$W_L$$$ over increasing $$$W_F$$$, and stop the process the first time you reach any cell $$$(x,m)$$$, take the maximum of all cells visited.
This should not be worse than the intended solution, and actually runs quite fast.
Solution 3
Simply take all cells in $$$[n-L,n]\times [m-L,m]$$$ and mark everything outside as reachable. $$$L=50$$$ works.
We found this solution the day before the round, we don't know how to hack it either.
UPD
: $$$L=50$$$ was hacked. Hats off to the hacker.
Solution 4
Do dfs with pruning. Run dfs starting at $$$(n,m)$$$, return when the cell is $$$(p,i)$$$ (i.e. obviously reachable because of primes), or when the value of the cell is smaller than the current answer. Add some memorization and it passes.
Select solutions from paticipants and testers
Solution 1
Keep $$$p$$$ the same, set $$$q$$$ to $$$p-L$$$ and only keep reachable cells in $$$[p,n]\times [q,m]$$$. $$$L$$$ is some constant ($$$100$$$ should work).
We found this solution during testing, tried, and failed to hack it.
Solution 2
Keep $$$p$$$ the same, do dfs from each cell $$$(n,p),(n-1,p),\cdots$$$, prioritizing increasing $$$W_L$$$ over increasing $$$W_F$$$, and stop the process the first time you reach any cell $$$(x,m)$$$, take the maximum of all cells visited.
This should not be worse than the intended solution, and actually runs quite fast.
Solution 3
Simply take all cells in $$$[n-L,n]\times [m-L,m]$$$ and mark everything outside as reachable. $$$L=50$$$ works.
We found this solution the day before the round, we don't know how to hack it either.
UPD
: $$$L=50$$$ was hacked. Hats off to the hacker.
Solution 4
Do dfs with pruning. Run dfs starting at $$$(n,m)$$$, return when the cell is $$$(p,i)$$$ (i.e. obviously reachable because of primes), or when the value of the cell is smaller than the current answer. Add some memorization and it passes.
Solution 1
Keep $$$p$$$ the same, set $$$q$$$ to $$$p-L$$$ and only keep reachable cells in $$$[p,n]\times [q,m]$$$. $$$L$$$ is some constant ($$$100$$$ should work).
We found this solution during testing, tried, and failed to hack it.
Solution 2
Keep $$$p$$$ the same, do dfs from each cell $$$(n,p),(n-1,p),\cdots$$$, prioritizing increasing $$$W_L$$$ over increasing $$$W_F$$$, and stop the process the first time you reach any cell $$$(x,m)$$$, take the maximum of all cells visited.
This should not be worse than the intended solution, and actually runs quite fast.
Solution 3
Simply take all cells in $$$[n-L,n]\times [m-L,m]$$$ and mark everything outside as reachable. $$$L=50$$$ works.
We found this solution the day before the round, we don't know how to hack it either.
UPD
: $$$L=50$$$ was hacked. Hats off to the hacker.
Solution 4
Do dfs with pruning. Run dfs starting at $$$(n,m)$$$, return when the cell is $$$(p,i)$$$ (i.e. obviously reachable because of primes), or when the value of the cell is smaller than the current answer. Add some memorization and it passes.
Solution
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

const int N = 2e7 + 5;
bool ntp[N];
bool bad[405][405];
int pos[N];
int prime[2000005], mn[N], cnt;
void sieve(int n) {
    int i, j;

    for (i = 2; i <= n; i++) {
        if (!ntp[i])
            prime[++cnt] = i, mn[i] = i;

        for (j = 1; j <= cnt && i * prime[j] <= n; j++) {
            mn[i * prime[j]] = prime[j];
            ntp[i * prime[j]] = 1;

            if (!(i % prime[j]))
                break;
        }
    }
}
int gcd(int x, int y) {
    return x ? gcd(y % x, x) : y;
}
bool no(int l, int r, int k) {
    while (k > 1) {
        int x = mn[k];

        while (k % x == 0)
            k /= x;

        if (((l + x - 1) / x) * x <= r)
            return 0;
    }

    return 1;
}

int main() {
    sieve(20000000);
    int i, j = 0, T, n, m, a, b, u, v, g = 0, S = 0, px, py, qwq = 0;
    ll ans;
    prime[0] = 1;

    for (i = 2; i <= 20000000; i++) {
        while (j < cnt && prime[j + 1] <= i)
            j++;

        pos[i] = j;
    }

    scanf("%d", &T);

    while (T--) {
        scanf("%d%d%d%d", &n, &m, &a, &b);

        if (n < m) {
            swap(n, m);
            swap(a, b);
        }

        u = prime[pos[n]];
        v = m;

        while (v && !no(u, n, v))
            v--;

        ans = 0;
        px = py = 0;

        for (i = u; i <= n; i++)
            for (j = v; j <= m && j <= i; j++) {
                bad[i - u + 1][j - v + 1] = ((bad[i - u][j - v + 1] && bad[i - u + 1][j - v]) || gcd(i, j) > 1);

                if (!bad[i - u + 1][j - v + 1]) {
                    ans = max(ans, (ll)a * i + (ll)b * j);

                    if ((ll)a * i + (ll)b * j == ans) {
                        px = i;
                        py = j;
                    }

                    if (i <= m)
                        ans = max(ans, (ll)a * j + (ll)b * i);
                }
            }

        qwq = max(qwq, (n - px) + (m - py));
        printf("%lld\n", ans);
    }
    return 0;
}
Solution (dfs)
#include <bits/stdc++.h>
#define ll long long
#define N 20000011
using namespace std;
int t, n, m, a, b;
bool is[N];
int pr[N / 10];
int gcd(int a, int b) {
    while (b)
        a %= b, swap(a, b);

    return a;
}
ll ans = 0;
bool vis[1011][1011];
pair<int, int> vv[200011];
int vn, c;
bool flg = 0;
inline ll V(int i, int j) {
    return i <= n ? 1ll * max(i, j) * max(a, b) + 1ll * min(i, j) * min(a, b) : 1ll * i * b + 1ll * j * a;
}
void dfs(int i, int j) {
    ++c;
    bool mk = gcd(i, j) == 1;

    if (!mk)
        return;

    ans = max(ans, V(i, j));
    vis[m - i][n - j] = 1;
    vv[++vn] = {i, j};

    if (j < n && !vis[m - i][n - j - 1])
        dfs(i, j + 1);

    if (i == m || flg) {
        flg = 1;
        return;
    }

    if (i < m && !vis[m - i - 1][n - j])
        dfs(i + 1, j);
}
int main() {
    is[0] = is[1] = 1;

    for (int i = 2; i < N; ++i) {
        if (!is[i])
            pr[++pr[0]] = i;

        for (int j = 1; j <= pr[0] && i * pr[j] < N; ++j) {
            is[i * pr[j]] = 1;

            if (i % pr[j] == 0)
                break;
        }
    }

    scanf("%d", &t);

    while (t--) {
        scanf("%d%d%d%d", &n, &m, &a, &b);
        int p;

        if (m <= 10)
            p = 1;
        else {
            p = m;

            while (is[p])
                --p;
        }

        vn = 0;
        ans = 0;
        flg = 0;
        c = 0;

        for (int i = min(n, p - (p > 1));; --i) {
            assert(i > 0);
            ans = max(ans, V(p, i));

            if (p < m)
                dfs(p + 1, i);
            else
                break;

            if (flg)
                break;
        }

        for (int i = 1; i <= vn; ++i)
            vis[m - vv[i].first][n - vv[i].second] = 0;

        printf("%lld\n", ans);
    }

    return 0;
}
--------------------------------------------------
Problem ID: 2002F1
Editorial Content:
2002F1 — Court Blue (Easy Version)
Hint 1
Primes are powerful.
Hint 2
Prime gaps are small.
Tutorial
We view the problem as a walk on grid, starting at $$$(1,1)$$$. WLOG, we suppose $$$l>f$$$, thus only cells $$$(a,b)$$$ where $$$a<b$$$ would be considered.
Notice that when $$$n$$$ is large enough, the largest prime $$$p\le n$$$ satisfies $$$2p>n$$$. As such, all cells $$$(p,i)$$$ where $$$i<p$$$ will be unblocked and reachable.
However, we've only bounded one side of the final result. We take this a step further, let $$$q$$$ be the second-largest prime $$$q\le n$$$. By the same logic, we assume that $$$2q>n$$$. As such, all cells $$$(i,q)$$$, where $$$p\le i\le n$$$ will be unblocked and reachable.
Thus, we have constructed an area where the optimal solution must be, with its dimensions bounded by $$$n-p$$$ and $$$n-q$$$. We just need to run any brute force solution (dfs with memorization or dp) on this area to find the result.
If we assume the asymptotic of prime gap is $$$O(P(n))$$$, this yields a $$$O(n\cdot P(n)^2\cdot\log P(n))$$$ solution, where the $$$\log\log n$$$ is from taking the gcd of two numbers which differ by $$$O(P(n))$$$. This can also be optimized to $$$O(n\cdot P(n)^2)$$$ by preprocessing gcd.
We added the constraints that $$$n$$$'s are pairwise distinct to avoid forcing participants to write memorizations. In fact, under the constraints of the problem, the maximum area is $$$39201$$$, and the sum of the $$$10^3$$$ largest areas is $$$2.36\times10^7$$$.
Time complexity: $$$O(P(n)^2\log P(n))/O(P(n)^2)$$$
Solution
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

const int N = 2e7 + 5;
bool ntp[N];
int di[405][405];
bool bad[405][405];
int pos[N], g = 0, m = 3;
int prime[2000005], cnt = 0;
void sieve(int n) {
    int i, j;

    for (i = 2; i <= n; i++) {
        if (!ntp[i])
            prime[++cnt] = i;

        for (j = 1; j <= cnt && i * prime[j] <= n; j++) {
            ntp[i * prime[j]] = 1;

            if (!(i % prime[j]))
                break;
        }
    }
}
int gcd(int x, int y) {
    if (!x)
        return y;

    if (x <= g && y <= g)
        return di[x][y];

    return gcd(y % x, x);
}

int main() {
    sieve(2e7);
    int i, j = 1, T, n, a, b, c, u, v;
    ll ans;

    for (i = 3; i <= 2e7; i++) {
        while (j < cnt - 1 && prime[j + 2] <= i)
            j++;

        g = max(g, i - prime[j] + 1);

        if (prime[j] * 2 <= i)
            m = i;

        pos[i] = j;
    }

    for (i = 0; i <= g; i++)
        for (j = 0; j <= g; j++)
            if (!i)
                di[i][j] = j;
            else
                di[i][j] = di[j % i][i];

    scanf("%d", &T);

    while (T--) {
        scanf("%*d%d%d%d", &n, &a, &b);

        if (n <= m)
            u = v = 1;
        else {
            u = prime[pos[n] + 1];
            v = prime[pos[n]];
        }

        ans = 0;

        for (i = u; i <= n; i++)
            for (j = v; j <= i; j++) {
                bad[i - u + 1][j - v + 1] = (gcd(i, j) > 1 || (bad[i - u][j - v + 1] && bad[i - u + 1][j - v]));

                if (!bad[i - u + 1][j - v + 1])
                    ans = max(ans, max((ll)a * i + (ll)b * j, (ll)a * j + (ll)b * i));
            }

        printf("%lld\n", ans);
    }

    return 0;
}
--------------------------------------------------
Problem ID: 2002E
Editorial Content:
2002E — Cosmic Rays
Hint 1
Consider an incremental solution.
Hint 2
Use stacks.
Tutorial
The problems asks for the answer for every prefix, which hints at an incremental solution.
To add a new pair to the current prefix, we need to somehow process the new block merging with old ones. Thus, we should use some structure to store the information on the last block over time.
Namely, we use a stack to keep track of all blocks that became the last. For each block, we keep two values: its color $$$c$$$ and its lifetime $$$l$$$ (the times it takes for the block to disappear).
When inserting a new block, we pop all blocks that would be shadowed by the current one (i.e. with lifetime shorter than the current block), and merging blocks with the same $$$a$$$. When merging two blocks with length $$$x$$$ and $$$z$$$, and the maximum lifetime of blocks between them is $$$y$$$, $$$y\le\min(x,z)$$$ should hold, and the new block will have lifetime $$$x+z-y$$$.
For more details, please refer to the solution code.
There also exists $$$O(n\log n)$$$ solutions using ordered sets or heaps.
Time complexity: $$$O(n)$$$.
Solution
#include <bits/stdc++.h>
#define N 1000011
#define ll long long
#define pii pair<ll,int>
#define s1 first
#define s2 second
using namespace std;
int t, n, b[N];
ll a[N];
pii s[N];
int sn;
int main() {
    scanf("%d", &t);

    while (t--) {
        scanf("%d", &n);

        for (int i = 1; i <= n; ++i)
            scanf("%lld%d", a + i, b + i);

        sn = 0;
        ll x = 0;

        for (int i = 1; i <= n; ++i) {
            ll mx = 0;

            while (sn) {
                if (s[sn].s2 == b[i])
                    a[i] += s[sn--].s1 - mx;
                else if (s[sn].s1 <= a[i])
                    mx = max(mx, s[sn--].s1);
                else
                    break;
            }

            ++sn;
            s[sn] = pii(a[i], b[i]);
            x = max(x, s[sn].s1);
            printf("%lld ", x);
        }

        putchar(10);
    }

    return 0;
}
Solution (priority_queue)
#include <bits/stdc++.h>
#define ll long long
#define N 3000011
#define pii pair<ll,int>
#define s1 first
#define s2 second
using namespace std;
int t, n, prv[N], nxt[N], b[N];
ll a[N];
priority_queue<pair<ll, int>> pq, del;
ll sum = 0, ans[N];
int main() {
    scanf("%d", &t);

    while (t--) {
        scanf("%d", &n);

        for (int i = 1; i <= n; ++i)
            scanf("%lld%d", a + i, b + i);

        while (!pq.empty())
            pq.pop();

        while (!del.empty())
            del.pop();

        nxt[0] = 1;
        prv[n + 1] = n;

        for (int i = 1; i <= n; ++i)
            pq.push({-a[i], i}), prv[i] = i - 1, nxt[i] = i + 1;
        ll tim = 0;
        int lst = 1;

        for (int _ = 1; _ <= n; ++_) {
            while (!del.empty() && pq.top() == del.top())
                pq.pop(), del.pop();

            pii p = pq.top();
            pq.pop();
            int id = p.s2;
            tim = -p.s1;

            if (nxt[id] <= n && b[id] == b[nxt[id]]) {
                a[nxt[id]] += tim;
                pq.push({-a[nxt[id]], nxt[id]});
            }

            if (prv[id] && nxt[id] <= n && b[prv[id]] == b[nxt[id]]) {
                del.push({-a[nxt[id]], nxt[id]});
                a[nxt[id]] -= tim;
            }

            prv[nxt[id]] = prv[id];
            nxt[prv[id]] = nxt[id];

            while (lst < nxt[0])
                ans[lst++] = tim;
        }

        for (int i = 1; i <= n; ++i)
            printf("%lld ", ans[i]);

        putchar(10);
    }

    return 0;
}
--------------------------------------------------
Problem ID: 2002D2
Editorial Content:
2002D2 — DFS Checker (Hard Version)
Hint
Try to find some easy checks that can be maintained.
Tutorial
The problem revolves around finding a check for dfs orders that's easy to maintain. We have discovered several such checks, a few checks and their proofs are described below, any one of these checks suffices to tell whether a dfs order is valid.
Check 1
For every $$$u$$$, all of its children $$$v$$$ satisfies $$$[pos_v,pos_v+siz_v-1]\subseteq[pos_u,pos_u+siz_u-1]$$$. We can maintain this check by keeping track of the number of $$$u$$$ which violates this condition, and check for each $$$u$$$ using sets, when checking, we need only check the child with the minimum $$$pos_v$$$ and maximum $$$pos_v+siz_v-1$$$.
Proof: We prove by induction. When $$$u$$$'s children only consists of leaves, it is easy to see that this check ensures $$$[pos_u,pos_u+siz_u-1]$$$ is a valid dfs order of the subtree of $$$u$$$. Then, we can merge the subtree of $$$u$$$ into a large node with size $$$siz_u$$$, and continue the analysis above.
Check 2
Check 2: First we check $$$p_1=1$$$. Then, for each pair of adjacent elements $$$p_i,p_{i+1}$$$, $$$fa(p_{i+1})$$$ must be an ancestor of $$$p_i$$$, where $$$fa(u)$$$ denotes the father of node $$$u$$$. We can maintain this check by keeping track of the number of $$$u$$$ which violates this condition, and check for each $$$i$$$ by checking whether $$$p_i$$$ is in the subtree of $$$fa(p_{i+1})$$$.
Proof: For any subtree $$$u$$$, we take any $$$p_i,p_{i+1}$$$ such that $$$p_i$$$ does not belong in subtree $$$u$$$, but $$$p_{i+1}$$$ does. It follows that $$$p_{i+1}=u$$$, since only the subtree of $$$fa(u)$$$ has nodes that does not belong in subtree $$$u$$$. From this, we can gather that each subtree will be entered at most once (and form a continuous interval), and that the first visited node will be $$$u$$$, which is sufficient to say that $$$p$$$ is a dfs order.
Time complexity: $$$O((n+q)\log n)/O(n+q)$$$.
Check 1
For every $$$u$$$, all of its children $$$v$$$ satisfies $$$[pos_v,pos_v+siz_v-1]\subseteq[pos_u,pos_u+siz_u-1]$$$. We can maintain this check by keeping track of the number of $$$u$$$ which violates this condition, and check for each $$$u$$$ using sets, when checking, we need only check the child with the minimum $$$pos_v$$$ and maximum $$$pos_v+siz_v-1$$$.
Proof: We prove by induction. When $$$u$$$'s children only consists of leaves, it is easy to see that this check ensures $$$[pos_u,pos_u+siz_u-1]$$$ is a valid dfs order of the subtree of $$$u$$$. Then, we can merge the subtree of $$$u$$$ into a large node with size $$$siz_u$$$, and continue the analysis above.
Check 2
Check 2: First we check $$$p_1=1$$$. Then, for each pair of adjacent elements $$$p_i,p_{i+1}$$$, $$$fa(p_{i+1})$$$ must be an ancestor of $$$p_i$$$, where $$$fa(u)$$$ denotes the father of node $$$u$$$. We can maintain this check by keeping track of the number of $$$u$$$ which violates this condition, and check for each $$$i$$$ by checking whether $$$p_i$$$ is in the subtree of $$$fa(p_{i+1})$$$.
Proof: For any subtree $$$u$$$, we take any $$$p_i,p_{i+1}$$$ such that $$$p_i$$$ does not belong in subtree $$$u$$$, but $$$p_{i+1}$$$ does. It follows that $$$p_{i+1}=u$$$, since only the subtree of $$$fa(u)$$$ has nodes that does not belong in subtree $$$u$$$. From this, we can gather that each subtree will be entered at most once (and form a continuous interval), and that the first visited node will be $$$u$$$, which is sufficient to say that $$$p$$$ is a dfs order.
Solution (Check 1)
#include <bits/stdc++.h>
#define ll long long
#define lc(x) ((x) << 1)
#define rc(x) ((x) << 1 | 1)
#define ru(i, l, r) for (int i = (l); i <= (r); i++)
#define rd(i, r, l) for (int i = (r); i >= (l); i--)
#define mid ((l + r) >> 1)
#define pii pair<int, int>
#define mp make_pair
#define fi first
#define se second
#define sz(s) (int)s.size()
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>
using namespace std;
#define maxn 500005
mt19937 Rand(chrono::steady_clock::now().time_since_epoch().count());
int read() {
    int x = 0, w = 0; char ch = getchar();
    while(!isdigit(ch)) w |= ch == '-', ch = getchar();
    while(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
    return w ? -x : x;
}
int n, Q, fa[maxn], p[maxn], q[maxn], siz[maxn];
set<int> son[maxn];
int chk(int x) {
    return son[x].empty() ? 1 : (q[x] < *son[x].begin() && *--son[x].end() + siz[p[*--son[x].end()]] <= q[x] + siz[x]);
}
void solve() {
    n = read(), Q = read();
    ru(i, 1, n) siz[i] = 1, son[i].clear();
    ru(i, 2, n) fa[i] = read();
    rd(i, n, 2) siz[fa[i]] += siz[i];
    ru(i, 1, n) son[fa[p[i] = read()]].insert(i), q[p[i]] = i;
    int cnt = 0;
    ru(i, 1, n) cnt += chk(i);
    while(Q--) {
        int i = read(), j = read(), x = p[i], y = p[j];
        set<int> s; s.insert(x), s.insert(y), s.insert(fa[x]), s.insert(fa[y]);
        for (auto x: s) if(x) cnt -= chk(x);
        son[fa[x]].erase(i), son[fa[y]].erase(j);
        swap(p[i], p[j]), swap(q[x], q[y]);
        son[fa[x]].insert(j), son[fa[y]].insert(i);
        for (auto x: s) if(x) cnt += chk(x);
        puts(cnt == n ? "YES" : "NO");
    }
}
int main() {
    int T = read();
    while(T--) solve();
    return 0;
}
Solution (Check 2, LipArcanjo)
#include <bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define int long long
void dbg_out() { cerr << endl; }
template <typename H, typename... T>
void dbg_out(H h, T... t) { cerr << ' ' << h; dbg_out(t...); }
#define dbg(...) { cerr << #__VA_ARGS__ << ':'; dbg_out(__VA_ARGS__); }
using ll = long long;
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
 
const int MAXN = 3e5 + 5;
const int MOD = 1e9+7; //998244353;
const int INF = 0x3f3f3f3f;
const ll INF64 = ll(4e18) + 5;
 
 
vector<int> g[MAXN];
 
int tin[MAXN];
int tout[MAXN];
int id[MAXN];
int par[MAXN];
int T = 0;
void dfs(int u, int p){
	id[u] = tin[u] = tout[u] = T++;
	for(auto v : g[u]) if(v != p){
		dfs(v,u);
		par[v] = u;
		tout[u] = tout[v];
	}
}
 
void solve(){
	int n,q;
	cin >> n >> q;
	vector<int> p(n+1);
	for(int i = 0; i <= n; i++) g[i].clear();
	T = 0;
	for(int i = 2; i <= n; i++){
		int pi;
		cin >> pi;
		g[pi].push_back(i);
	}
	for(int i = 1; i <= n; i++){
		cin >> p[i];
	}
	dfs(1,1);
	int cnt = 0;
	auto ok = [&](int i){
		if(p[i] == 1){
			if(i == 1) return 1;
			return 0;
		}
		int ant = p[i-1];
		if(par[p[i]] == ant) return 1;
		if(tin[ant] != tout[ant]) return 0;
		int pa = par[p[i]];
		if(tin[ant] < tin[pa] || tin[ant] > tout[pa]) return 0;
		return 1;
	};
	for(int i = 1; i <= n; i++){
		cnt += ok(i);
	}
	for(int qw = 0; qw < q; qw++){
		int x,y;
		cin >> x >> y;
		set<int> in;
		in.insert(x);
		in.insert(y);
		if(x-1 >= 1) in.insert(x-1);
		if(x+1 <= n) in.insert(x+1);
		if(y-1 >= 1) in.insert(y-1);
		if(y+1 <= n) in.insert(y+1);
		for(auto v : in){
			cnt -= ok(v);
		}
		swap(p[x],p[y]);
		for(auto v : in){
			cnt += ok(v);
		}
		cout << (cnt == n ? "YES": "NO") << '\n';
	}
	
}
 
signed main(){
 
    ios::sync_with_stdio(false); cin.tie(NULL);
 
    int t = 1;
    cin >> t;
    while(t--){
        solve();
    }
 
    return 0;
}
--------------------------------------------------
Problem ID: 2002D1
Editorial Content:
2002D1 — DFS Checker (Easy Version)
--------------------------------------------------
Problem ID: 2002C
Editorial Content:
2002C — Black Circles
Hint
The problem can't be that hard, find some simple strategy.
Tutorial
We consider a simple strategy: walk towards the goal in a straight line.
If some circle reaches the goal first, it is obvious that we have no chance of succeeding, no matter what path we take.
Otherwise, it can be proven that we will not pass any circles on our way to the goal.
Suppose we start at $$$A$$$, our goal is $$$B$$$, and we got intercepted by some circle $$$C$$$ at the point $$$D$$$. It follows that $$$CD=AD$$$. According to the triangle inequality, $$$CD>CB-DB$$$ should hold. Thus, we have $$$CB-DB\le AD$$$, which means $$$CB\le AB$$$, proof by contradiction.
Time complexity: $$$O(n)$$$.
Solution
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int t, n, x[100011], y[100011], xs, ys, xt, yt;
ll dis(int x1, int y1, int x2, int y2) {
    return 1ll * (x2 - x1) * (x2 - x1) + 1ll * (y2 - y1) * (y2 - y1);
}
int main() {
    scanf("%d", &t);

    while (t--) {
        scanf("%d", &n);

        for (int i = 1; i <= n; ++i)
            scanf("%d%d", x + i, y + i);

        scanf("%d%d%d%d", &xs, &ys, &xt, &yt);
        bool ok = 1;

        for (int i = 1; i <= n; ++i) {
            if (dis(xt, yt, x[i], y[i]) <= dis(xt, yt, xs, ys)) {
                ok = 0;
                break;
            }
        }

        printf(ok ? "YES\n" : "NO\n");
    }

    fclose(stdin);
    fclose(stdout);
    return 0;
}
--------------------------------------------------
Problem ID: 2002B
Editorial Content:
2002B — Removals Game
Hint
Find some conditions that Bob need to win.
Tutorial
A general idea is that it is very difficult for Bob to win. We make some observations regarding the case where Bob wins. It is intuitive to see that for any subarray $$$[A_l,A_{l+1},\cdots,A_r]$$$, the elements' positions in $$$B$$$ must also form an interval. If $$$A[l:r]$$$ does not form an interval in $$$B$$$, Alice can simply remove elements until only $$$A[l:r]$$$ is left, no matter how Bob plays, there must now be an element in $$$A$$$ but not in $$$B$$$ because of our previous condition. Alice can then remove everything other than this element to win.
From here, it is easy to prove by induction that for Bob to win, either $$$A=B$$$ or $$$A=\textrm{rev}(B)$$$.
Time complexity: $$$O(n)$$$.
Solution
#include <bits/stdc++.h>
#define ll long long
#define lc(x) ((x) << 1)
#define rc(x) ((x) << 1 | 1)
#define ru(i, l, r) for (int i = (l); i <= (r); i++)
#define rd(i, r, l) for (int i = (r); i >= (l); i--)
#define mid ((l + r) >> 1)
#define pii pair<int, int>
#define mp make_pair
#define fi first
#define se second
#define sz(s) (int)s.size()
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>
using namespace std;
mt19937 Rand(chrono::steady_clock::now().time_since_epoch().count());
int read() {
    int x = 0, w = 0;
    char ch = getchar();

    while (!isdigit(ch))
        w |= ch == '-', ch = getchar();

    while (isdigit(ch))
        x = x * 10 + ch - '0', ch = getchar();

    return w ? -x : x;
}
int main() {
    int T = read();

    while (T--) {
        int n = read();
        vector<int> a, b;
        ru(i, 1, n) a.push_back(read());
        ru(i, 1, n) b.push_back(read());

        if (a == b) {
            printf("Bob\n");
            continue;
        }

        reverse(a.begin(), a.end());

        if (a == b) {
            printf("Bob\n");
            continue;
        }

        printf("Alice\n");
    }

    return 0;
}
--------------------------------------------------
Problem ID: 2002A
Editorial Content:
2002A — Distanced Coloring
Hint 1
Consider the case with $$$n=m=k$$$.
Hint 2
Generalize the solution for all $$$n,m,k$$$.
Tutorial
It can be shown that for any $$$k\times k$$$ subgrid, the colors we use must be pairwise distinct. Thus, we have an lower bound of $$$\min(n,k)\cdot\min(m,k)$$$. We can show that this lower bound is indeed achievable by coloring the upper-left $$$\min(n,k)\cdot\min(m,k)$$$ subgrid with distinct colors, and copy-pasting it to fill the rest of the grid.
Time complexity: $$$O(1)$$$.
Solution
#include <bits/stdc++.h>
using namespace std;
int t, n, m, k;
int main() {
    scanf("%d", &t);

    while (t--) {
        scanf("%d%d%d", &n, &m, &k);
        printf("%d\n", min(n, k)*min(m, k));
    }

    return 0;
}
--------------------------------------------------
Problem ID: 2001E2
Editorial Content:

--------------------------------------------------
Problem ID: 2001E1
Editorial Content:
2001E1 — Deterministic Heap (Easy Version)
Video
--------------------------------------------------
Problem ID: 2001D
Editorial Content:
2001D — Longest Max Min Subsequence
Video
--------------------------------------------------
Problem ID: 2001C
Editorial Content:
2001C — Guess The Tree
Video
--------------------------------------------------
Problem ID: 2001B
Editorial Content:
2001B — Generate Permutation
Video
--------------------------------------------------
Problem ID: 2001A
Editorial Content:
2001A — Make All Equal
Video
--------------------------------------------------
Problem ID: 2000H
Editorial Content:
2000H - Ksyusha and the Loaded Set
Tutorial
Tutorial is loading...
Solution
#pragma GCC optimize("O3,unroll-loops")
 
#include <bits/stdc++.h>
 
#define endl '\n'
 
using namespace std;
 
typedef pair<int, int> ipair;
 
#define INF 1'000'000'009
#define MAXN 200200
#define MAXMEM 5'000'000
#define MAXLEN 2'000'100
 
#define X first
#define Y second
 
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
 
struct node {
    node *lv = nullptr, *rv = nullptr;
    ipair key;
    int prior;
    int minl = INF;
    
    node(const ipair& key) : key(key), prior(rng()), minl(key.Y) {}
};
 
static inline int minl(node *v) {
    return (v == nullptr ? INF : v->minl);
}
 
static inline void upd(node *v) {
    v->minl = min(v->key.Y, min(minl(v->lv), minl(v->rv)));
}
 
node *merge(node *s1, node *s2) {
    if (s1 == nullptr) return s2;
    if (s2 == nullptr) return s1;
    if (s1->prior > s2->prior) {
        s1->rv = merge(s1->rv, s2);
        upd(s1);
        return s1;
    } else {
        s2->lv = merge(s1, s2->lv);
        upd(s2);
        return s2;
    }
}
 
pair<node*, node*> split(node* &v, ipair x) {
    if (v == nullptr) {
        return {nullptr, nullptr};
    }
    if (v->key < x) {
        auto [s1, s2] = split(v->rv, x);
        v->rv = s1;
        upd(v);
        return {v, s2};
    } else {
        auto [s1, s2] = split(v->lv, x);
        v->lv = s2;
        upd(v);
        return {s1, v};
    }
}
 
int n, m;
int arr[MAXN];
node *mem = (node*)calloc(MAXMEM, sizeof(*mem));
node *mpos = mem;
node *root;
set<int> M;
 
// [l..r)
void add_seg(int l, int r) {
    if (l >= r) return;
    ipair p {r - l, l};
    auto [s1, s2] = split(root, p);
    node *v = mpos++;
    *v = node(p);
    root = merge(merge(s1, v), s2);
}
 
void rem_dek(node* &v, const ipair& x) {
    if (v == nullptr) return;
    if (v->key == x) {
        v = merge(v->lv, v->rv);
        if (v) upd(v);
        return;
    }
    if (v->key < x) rem_dek(v->rv, x);
    else rem_dek(v->lv, x);
    upd(v);
}
 
// [l..r)
void rem_seg(int l, int r) {
    if (l >= r) return;
    ipair p {r - l, l};
    rem_dek(root, p);
}
 
void add_val(int x) {
    auto it = M.lower_bound(x);
    int clsl = (it == M.begin() ? 0 : *prev(it));
    int clsr = (it == M.end() ? INF : *it);
    rem_seg(clsl + 1, clsr);
    add_seg(clsl + 1, x);
    if (clsr != INF) add_seg(x + 1, clsr);
    M.insert(x);
}
 
void rem_val(int x) {
    auto it = M.lower_bound(x);
    int clsl = (it == M.begin() ? 0 : *prev(it));
    int clsr = (next(it) == M.end() ? INF : *next(it));
    rem_seg(clsl + 1, x);
    rem_seg(x + 1, clsr);
    if (clsr != INF) add_seg(clsl + 1, clsr);
    M.erase(x);
}
 
int query(int k) {
    if (M.empty()) return 1;
    auto [s1, s2] = split(root, make_pair(k, -1));
    fprintf(stderr, "AMOGUS: %p, %p\n", s1, s2);
    int ans = min(*M.rbegin() + 1, minl(s2));
    root = merge(s1, s2);
    return ans;
}
 
void init() {
    root = nullptr;
    mpos = mem;
    M = {arr, arr + n};
    add_seg(1, *M.begin());
    for (auto it = M.begin(); next(it) != M.end(); ++it)
        add_seg(*it + 1, *next(it));
}
 
signed main() {
    int t; cin >> t;
    while (t--) {
        cin >> n;
        for (int i = 0; i < n; ++i)
            cin >> arr[i];
        init();
        cin >> m;
        for (int j = 0; j < m; ++j) {
            char tp; cin >> tp;
            int x, k;
            switch (tp) {
            case '+':
                cin >> x;
                add_val(x);
                break;
            case '-':
                cin >> x;
                rem_val(x);
                break;
            case '?':
                cin >> k;
                cout << query(k) << " ";
                break;
            }
        }
        cout << endl;
    }
}
--------------------------------------------------
Problem ID: 2000G
Editorial Content:
2000G - Call During the Journey
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <set>
 
using namespace std;
 
void solve() {
    int n, m;
    cin >> n >> m;
    int t0, t1, t2;
    cin >> t0 >> t1 >> t2;
    vector<vector<vector<int>>> g(n);
    for (int i = 0; i < m; ++i) {
        int u, v, l1, l2;
        cin >> u >> v >> l1 >> l2;
        u--, v--;
        g[u].push_back({v, l1, l2});
        g[v].push_back({u, l1, l2});
    }
    set<pair<int, int>> prq;
    prq.insert({t0, n - 1});
    for (int i = 0; i + 1 < n; ++i) {
        prq.insert({-1e9, i});
    }
    vector<int> dist(n, -1e9);
    dist[n - 1] = t0;
    while (!prq.empty()) {
        auto p = *prq.rbegin();
        prq.erase(p);
        int d = p.first, u = p.second;
        for (auto e: g[u]) {
            int v = e[0], l1 = e[1], l2 = e[2];
            int d1 = (d - l1 >= t2 || d <= t1) ? d - l1 : d - l2;
            if(d1 == d - l2) d1 = max(d1, t1 - l1);
            if (dist[v] < d1) {
                prq.erase({dist[v], v});
                dist[v] = d1;
                prq.insert({d1, v});
            }
        }
    }
    cout << (dist[0] >= 0 ? dist[0] : -1) << '\n';
}
 
int main() {
    int t;
    cin >> t;
    for (int i = 0; i < t; ++i) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2000F
Editorial Content:
2000F - Color Rows and Columns
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <algorithm>
#include <vector>
 
using namespace std;
 
void solve() {
    int n, k;
    cin >> n >> k;
    vector<int> a(n), b(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i] >> b[i];
    }
    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 1e9));
    dp[0][0] = 0;
    for (int i = 0; i < n; ++i) {
        int x = a[i], y = b[i];
        int xy = x + y;
        int cost = 0;
        for (int j = 0; j <= xy; ++j) {
            for (int j1 = 0; j1 + j <= k; ++j1) {
                dp[i + 1][j1 + j] = min(dp[i + 1][j1 + j], dp[i][j1] + cost);
            }
            if (j < xy) {
                if (x >= y) {
                    x--, cost += y;
                } else {
                    y--, cost += x;
                }
            }
        }
    }
    cout << (dp[n][k] == 1e9 ? -1 : dp[n][k]) << '\n';
}
 
int main() {
    int t;
    cin >> t;
    for (int i = 0; i < t; ++i) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2000E
Editorial Content:
2000E - Photoshoot for Gorillas
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
#define int long long
 
using namespace std;
 
#define MAXW 200200
#define MAXNM 200200
 
int n, m, k, w, p;
int arr[MAXW], prr[MAXNM];
 
static inline int calcc(int i, int j) {
    int upr = min(i, n - k);
    int leftr = min(j, m - k);
    int upl = max(-1LL, i - k);
    int leftl = max(-1LL, j - k);
    return (upr - upl) * (leftr - leftl);
}
 
void build() {
    sort(arr, arr + w);
    reverse(arr, arr + w);
    p = 0;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            prr[p++] = calcc(i, j);
    sort(prr, prr + p);
    reverse(prr, prr + p);
}
 
int solve() {
    int sum = 0;
    for (int i = 0; i < w; ++i)
        sum += prr[i] * arr[i];
    return sum;
}
 
signed main() {
    int t; cin >> t;
    while (t--) {
        cin >> n >> m >> k >> w;
        for (int i = 0; i < w; ++i)
            cin >> arr[i];
        build();
        cout << solve() << endl;
    }
}
--------------------------------------------------
Problem ID: 2000D
Editorial Content:
2000D - Right Left Wrong
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    a = [0]
    for x in input().split():
        x = int(x)
        a.append(a[-1] + x)
    s = input()
    ans = 0
    l = 0
    r = n - 1
    while r > l:
        while l < n and s[l] == 'R':
            l += 1
        while r >= 0 and s[r] == 'L':
            r -= 1
        if l < r:
            ans += a[r + 1] - a[l]
            l += 1
            r -= 1
    print(ans)
 
t = int(input())
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 2000C
Editorial Content:
2000C - Numeric String Template
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    m = int(input())
    for _ in range(m):
        m_1 = {}
        m_2 = {}
        s = input().strip()
        if len(s) != n:
            print("NO")
            continue
 
        ok = True
        for j in range(n):
            if s[j] not in m_1 and a[j] not in m_2:
                m_1[s[j]] = a[j]
                m_2[a[j]] = s[j]
            elif (s[j] in m_1 and m_1[s[j]] != a[j]) or (a[j] in m_2 and m_2[a[j]] != s[j]):
                ok = False
                break
        print("YES" if ok else "NO")
 
t = int(input())
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 2000B
Editorial Content:
2000B - Seating in a Bus
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
void solve(){
    int n;
    cin >> n;
    vector<int>a(n);
    for(auto &i : a) cin >> i;
    int left = a[0], right = a[0];
    for(int i = 1; i < n; i++){
        if(a[i] + 1 == left) left = a[i];
        else if(a[i] - 1 == right) right = a[i];
        else {
            cout << "NO\n";
            return;
        }
    }
    cout << "YES\n";
}
 
int main(){
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 2000A
Editorial Content:
2000A - Primary Task
Tutorial
Tutorial is loading...
Solution
for _ in range(int(input())):
    a = int(input())
    if 102 <= a <= 109 or 1010 <= a <= 1099:
        print("YES")
    else:
        print("NO")
--------------------------------------------------
Problem ID: 1999G2
Editorial Content:
1999G2 — Ruler (hard version)
Video
--------------------------------------------------
Problem ID: 1999G1
Editorial Content:
1999G1 — Ruler (easy version)
Video
--------------------------------------------------
Problem ID: 1999F
Editorial Content:
1999F — Expected Median
Video
--------------------------------------------------
Problem ID: 1999E
Editorial Content:
1999E — Triple Operation
Video
--------------------------------------------------
Problem ID: 1999D
Editorial Content:
1999D — Slavic's Exam
Video
--------------------------------------------------
Problem ID: 1999C
Editorial Content:
1999C — Showering
Video
--------------------------------------------------
Problem ID: 1999B
Editorial Content:
1999B — Card Game
Video
--------------------------------------------------
Problem ID: 1999A
Editorial Content:
1999A — A+B Again?
Video
--------------------------------------------------
Problem ID: 1998E2
Editorial Content:
1998E2 - Eliminating Balls With Merging (Hard Version)
Hint 1
For each element $$$j$$$ there is a range $$$(L_j,R_j)$$$ in which it can be present as last elemt.
Hint 2
Modify the Solve function to now return what is the minimum index $$$L_j$$$, instead of boolean earlier.
Basically find minimum $$$L_j$$$ such that element $$$j$$$ can become $$$\sum A_1+A_2+...A_{Lj}$$$
Hint 3
Also for each index $$$i$$$ precalcute how much right it can go.
Use this to calculate $$$R_j$$$ based on $$$L_j$$$.
Hint 4
Otherway around you can also return this range in your solve function.
--------------------------------------------------
Problem ID: 1998E1
Editorial Content:
1998E1 - Eliminating Balls With Merging (Easy Version)
Hint 1
Notice that at any point all the elements are sum of continous subarray.
Hint 2
Define a function solve(L,R) which returns true, if we can convert element with weight $$$\sum A_L+A_{L+1}+....+A_{R}$$$ into an element with weight $$$\sum A$$$
Hint 3
Use greedy, for fixed index $$$L$$$ and $$$R$$$, find a minimum $$$nxtL$$$ such that $$$\sum A_{nxtL} + A_{nxtL+1} + ... + A_{L-1} \le A_L+A_{L+1}+....+A_{R}$$$, make a direct jump to $$$nxtL,R$$$ segment.
Hint 4
Do similar for $$$nxtR$$$, and memorise all the answer of solve function.
--------------------------------------------------
Problem ID: 1998D
Editorial Content:

--------------------------------------------------
Problem ID: 1998C
Editorial Content:
1998C - Perform Operations to Maximize Score
--------------------------------------------------
Problem ID: 1998B
Editorial Content:
1998B - Minimize Equal Sum Subarrays
Hint 1
Sum of all elements will be equal in both permutations.
So no of such $$$(i,j)$$$ is atleast 1.
Can you find a permutation $$$Q$$$ such that this count remains 1?
Hint 2
Set $$$Q_i = 1$$$ if $$$P_i = N$$$,
Set $$$Q_i = 1 + P_i$$$ if $$$P_i < N$$$, otherwise
Hint 3
Set $$$Q_i = P_{(i+1) \mod N}$$$
--------------------------------------------------
Problem ID: 1998A
Editorial Content:
1998A - Find K Distinct Points with Fixed Center
Idea
Chose $$$A_1 = (K*X_C,K*Y_C)$$$.
The remaining points such that sum of x coordinates and y coordinates is 0.
--------------------------------------------------
Problem ID: 1997F
Editorial Content:
1997F - Chips on a Line
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
const int MOD = 998244353;
 
int add(int x, int y)
{
 	x += y;
 	while(x >= MOD) x -= MOD;
 	while(x < 0) x += MOD;
 	return x;
}
 
int mul(int x, int y)
{
 	return (x * 1ll * y) % MOD;
}
 
int main()
{
 	int n, x, m;
 	cin >> n >> x >> m;
 	vector<int> fib = {0, 1};
 	for(int i = 2; i <= 30; i++)
 		fib.push_back(fib[i - 1] + fib[i - 2]);
 
 
 	int max_sum = fib[x] * n;
 	vector<vector<int>> dp(max_sum + 1, vector<int>(n + 1));
 	dp[0][0] = 1;
 	for(int i = 1; i <= x; i++)
 		for(int j = 0; j < max_sum; j++)
 			for(int k = 0; k < n; k++)
 			{
 			 	if(j + fib[i] <= max_sum)
 			 		dp[j + fib[i]][k + 1] = add(dp[j + fib[i]][k + 1], dp[j][k]);
 			}
	
	vector<int> cost(max_sum + 1, 1e9);
	cost[0] = 0;
	for(int j = 1; j <= max_sum; j++)
		for(int i = 1; i <= 30; i++)
			if(j >= fib[i])
				cost[j] = min(cost[j], cost[j - fib[i]] + 1);
 
	int ans = 0;
	for(int i = 0; i <= max_sum; i++)
		if(cost[i] == m)
			ans = add(ans, dp[i][n]);
	cout << ans << endl;
}
--------------------------------------------------
Problem ID: 1997E
Editorial Content:
1997E - Level Up
Tutorial
Tutorial is loading...
Solution 1 (awoo)
#include <bits/stdc++.h>
#include "ext/pb_ds/assoc_container.hpp"
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
using namespace __gnu_pbds;
using namespace std;
 
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
 
struct query{
	int i, j;
};
 
int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	int n, m;
	cin >> n >> m;
	vector<int> a(n);
	forn(i, n) cin >> a[i];
	vector<vector<query>> q(n + 1);
	forn(j, m){
		int i, x;
		cin >> i >> x;
		--i;
		q[x].push_back({i, j});
	}
	forn(i, n + 1){
		sort(q[i].begin(), q[i].end(), [](const query &a, const query &b){
			return a.i > b.i;
		});
	}
	vector<int> ord(n);
	iota(ord.begin(), ord.end(), 0);
	sort(ord.begin(), ord.end(), [&](int i, int j){
		return a[i] > a[j];
	});
	
	vector<int> cur(n + 1);
	vector<char> ans(m);
	ordered_set<int> alive(ord.begin(), ord.end());
	for (int lvl = 1; lvl <= n; ++lvl){
		for (int k = 1; k <= n; ++k){
			if (cur[k] >= n) break;
			int x = alive.order_of_key(cur[k]);
			int nxt = x + k - 1 >= int(alive.size()) ? n : *alive.find_by_order(x + k - 1);
			while (!q[k].empty() && q[k].back().i <= nxt){
				ans[q[k].back().j] = (a[q[k].back().i] >= lvl);
				q[k].pop_back();
			}
			cur[k] = nxt + 1;
		}
		while (!ord.empty() && a[ord.back()] == lvl){
			alive.erase(ord.back());
			ord.pop_back();
		}
	}
	
	for (auto x : ans) cout << (x ? "YES" : "NO") << '\n';
	return 0;
}
Solution 2 (awoo)
#include <bits/stdc++.h>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
using namespace std;
 
struct query{
	int i, j;
};
 
int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	int n, m;
	cin >> n >> m;
	vector<int> a(n);
	forn(i, n) cin >> a[i];
	vector<vector<query>> q(n + 1);
	forn(j, m){
		int i, x;
		cin >> i >> x;
		--i;
		q[x].push_back({i, j});
	}
	forn(i, n + 1) sort(q[i].begin(), q[i].end(), [](const query &a, const query &b){
		return a.i > b.i;
	});
	
	int P = min(1000, n + 1);
	
	vector<char> ans(m);
	for (int k = 1; k < P; ++k){
		int cur = 1;
		int cnt = 0;
		forn(i, n){
			bool fl = false;
			if (a[i] >= cur){
				++cnt;
				fl = true;
				if (cnt == k){
					++cur;
					cnt = 0;
				}
			}
			while (!q[k].empty() && q[k].back().i == i){
				ans[q[k].back().j] = fl;
				q[k].pop_back();
			}
		}
	}
	
	vector<int> sum1(n), sum2(n);
	int p2 = ceil(sqrt(n + 2));
	
	auto add = [&](int i){
		int bl = i / p2;
		for (int j = bl + 1; j * p2 < n; ++j)
			++sum1[j];
		for (int j = i; j < (bl + 1) * p2 && j < n; ++j)
			++sum2[j];
	};
	
	int mx = n / P + 5;
	vector<vector<int>> pos(mx);
	forn(i, n){
		if (a[i] < mx)
			pos[a[i]].push_back(i);
		else
			add(i);
	}
	for (auto &it : pos) reverse(it.begin(), it.end());
	
	for (int k = P; k <= n; ++k){
		while (true){
			int mn = n;
			int who = -1;
			forn(lvl, mx) if (!pos[lvl].empty()){
				int i = pos[lvl].back();
				if (mn < i) continue;
				int cnt = sum1[i / p2] + sum2[i];
				if (a[i] >= cnt / k + 1){
					mn = i;
					who = lvl;
				}
			}
			if (who == -1) break;
			add(mn);
			pos[who].pop_back();
		}
		for (auto it : q[k]){
			int lvl = a[it.i];
			ans[it.j] = (lvl >= mx || pos[lvl].empty() || pos[lvl].back() > it.i);
		}
	}
	
	for (auto x : ans) cout << (x ? "YES" : "NO") << '\n';
	return 0;
}
--------------------------------------------------
Problem ID: 1997D
Editorial Content:
1997D - Maximize the Root
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
const int INF = 1e9;
 
int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<int> a(n);
    for (auto& x : a) cin >> x;
    vector<vector<int>> g(n);
    for (int i = 1; i < n; ++i) {
        int p;
        cin >> p;
        g[p - 1].push_back(i);
    }
    
    auto check = [&](auto&& self, int v, int x) -> bool {
      if (x > INF) return false;
      bool isLeaf = true;
      if (v) x += max(0, x - a[v]);
      for (auto u : g[v]) {
        isLeaf = false;
        if (!self(self, u, x)) return false;
      }
      return (!isLeaf || x <= a[v]);
    };
    
    int l = 1, r = INF;
    while (l <= r) {
      int mid = (l + r) / 2;
      if (check(check, 0, mid)) {
        l = mid + 1;
      } else {
        r = mid - 1;
      }
    }
    
    cout << a[0] + l - 1 << '\n';
  }
}
--------------------------------------------------
Problem ID: 1997C
Editorial Content:
1997C - Even Positions
Tutorial
Tutorial is loading...
Solution (adedalic)
import java.util.LinkedList
 
fun main() {
    repeat(readln().toInt()) {
        val n = readln().toInt()
        val s = readln()
 
        var ans = 0L
        val bracketPositions = LinkedList<Int>()
        for (i in s.indices) {
            var c = s[i]
            if (c == '_') {
                c = if (bracketPositions.isEmpty()) '(' else ')'
            }
            if (c == ')') {
                ans += i - bracketPositions.pollLast()
            }
            else
                bracketPositions.addLast(i)
        }
        println(ans)
    }
}
--------------------------------------------------
Problem ID: 1997B
Editorial Content:
1997B - Make Three Regions
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<string> s(2);
    for (auto& x : s) cin >> x;
    int ans = 0;
    for (int i = 1; i < n - 1; ++i) {
      bool ok = true;
      ok &= (s[0][i] == '.' && s[1][i] == '.');
      ok &= (s[0][i - 1] != s[1][i - 1]);
      ok &= (s[0][i + 1] != s[1][i + 1]);
      ok &= (s[0][i - 1] == s[0][i + 1]);
      ans += ok;
    }
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1997A
Editorial Content:
1997A - Strong Password
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
void solve()
{
	string s;
	cin >> s;
	int n = s.size();
	int idx = -1;
	for(int i = 0; i + 1 < n; i++)
		if(s[i] == s[i + 1])
			idx = i;
	if(idx == -1)
	{
		if(s.back() == 'a') cout << (s + "b") << endl;
		else cout << (s + "a") << endl;
	}
	else
	{
		string t = "a";
		if(s[idx] == 'a') t = "b";
		cout << s.substr(0, idx + 1) + t + s.substr(idx + 1) << endl;
	}
}
 
int main()
{
	int t;
	cin >> t;
	for(int i = 0; i < t; i++)
		solve();
}
--------------------------------------------------
Problem ID: 1996G
Editorial Content:
1996G - Penacony
Hint 1
Delete one road, now path between any pair of friends is unique. Try to count paths which do not lie between any pair of friends.
Hint 2
Given an array A, and multiple queries $$$L_i$$$ and $$$R_i$$$. Can you find the minimum value in this range, and how many times it appears?
Video editorial
Daily Chat QnA
--------------------------------------------------
Problem ID: 1996F
Editorial Content:
1996F - Bomb
Hint 1
Greedy, always take the index with maximum value of $$$A-i$$$
Hint 2
Binary search FTW
Hint 3
Binary search on the value you will add in $$$k^{th}$$$ operation.
Video editorial
--------------------------------------------------
Problem ID: 1996E
Editorial Content:
1996E - Decode
Easy version
Count no of substrings with equal 0s and 1s
Hint 1
Replace all 0 with -1. Now all segments with equal 0 and 1 have zero sum.
Hint 2
Instead of counting segments inside each range. For each substring with zero sum, count segments it is a part of.
Video editorial
--------------------------------------------------
Problem ID: 1996D
Editorial Content:
1996D - Fun
Hint 1
Bruteforce works, now analyse why it works.
Hint 2
Sum of Harmonic series
Video editorial
--------------------------------------------------
Problem ID: 1996C
Editorial Content:
1996C - Sort
Hint
Prefix Sum
Video editorial
--------------------------------------------------
Problem ID: 1996B
Editorial Content:
1996B - Scale
Idea
Just print all index $$$A[i*K][j*K]$$$
Video editorial
--------------------------------------------------
Problem ID: 1996A
Editorial Content:
1996A - Legs
Hint
Greedily take Cow as long as you can.
Video editorial
--------------------------------------------------
Problem ID: 1995E2
Editorial Content:
1995E2 - Let Me Teach You a Lesson (Hard Version)
Hint 0
Read the first two hints to E1.
Hint 1
There are $$$4 n$$$ possible desks in total. One of them will be the minimal desk and another one will be the maximal. What is the common-used technique for such problems?
Answer to Hint 1
Sort them and then use two pointers.
Hint 2
The data structure you need is very famous.
Solution
(Read the hints.) Assign a boolean matrix $$$2 \times 2$$$ to each of the desks. Rows correspond to the first knight at the desk (two rows for each of the events "the knight was swapped" / "the knight was not swapped"), columns correspond to the second one. The value in the intersection is true if under current restrictions (minimum and maximum) both events can happen, i.e. the result on the desk is between minimum and maximum.
What is a (boolean) multiplication of matrices from $$$d_l$$$ to $$$d_r$$$?
Answer
The matrix where the rows correspond to the knight $$$2 d_l - 1$$$ and the columns correspond to the knight $$$2 d_r$$$.
To determine whether it's possible to swap the knights under current restrictions you can just multiply all the matrices and check if there are ones on the main diagonal. Now using two pointers and a segment tree on these matrices you can solve the problem (basically, when you leave some option for a desk in the sorted array of options, you change one of the values of this matrix from $$$1$$$ to $$$0$$$, and vice versa).
Answer
The matrix where the rows correspond to the knight $$$2 d_l - 1$$$ and the columns correspond to the knight $$$2 d_r$$$.
Code
272212685
--------------------------------------------------
Problem ID: 1995E1
Editorial Content:
1995E1 - Let Me Teach You a Lesson (Easy Version)
Hint 1
Consider cases of odd and even $$$n$$$. Which one is simpler?
Answer to Hint 1
Even. In this case you can solve the problem for the opposite desks independently. From now on $$$n$$$ is odd.
Why independently?
Let a desk have knights with intelligence $$$a$$$, $$$b$$$ and the opposite one with $$$c$$$, $$$d$$$. Since $$$(a + b) + (c + d) = (a + c) + (b + d)$$$, the minimal total intelligence on these desks is greater iff the maximal total intelligence is less.
Why independently?
Let a desk have knights with intelligence $$$a$$$, $$$b$$$ and the opposite one with $$$c$$$, $$$d$$$. Since $$$(a + b) + (c + d) = (a + c) + (b + d)$$$, the minimal total intelligence on these desks is greater iff the maximal total intelligence is less.
Hint 2
If you reorder desks/knights in a way that you swap neighbors (i.e. $$$2$$$ with $$$3$$$, $$$4$$$ with $$$5$$$, ..., $$$2 n$$$ with $$$1$$$) instead of opposite knights, it'll probably become easier to think about this problem. We will use this notation from now on.
Hint 3
You're allowed to run in $$$O(n^2)$$$. Wouldn't it have sense to fix some entity and solve in linear time for fixed entity?
Answer to Hint 3
Fix the minimal (maximal) desk and the knights who are sitting at it (if the original knights were swapped or not). You'll need to find the minimal maximum on a desk for $$$4 n$$$ such cases.
Hint 4
DP.
Solution
(Read the hints.) Let the fixed desk have index $$$k$$$. Let $$$dp_{i, b}$$$ (where $$$i$$$ is the index of the desk and $$$b$$$ is $$$0$$$ / $$$1$$$ which indicates whether the knight $$$2 i$$$ was swapped) be the minimal maximum that can be achieved on a segment from $$$k$$$ to $$$i$$$ (satisfying bit $$$b$$$ and the fact that the desk $$$k$$$ is actually minimal). Then you can easily make transitions $$$dp_{i, 0}, dp_{i, 1} \to dp_{i + 1, 0}, dp_{i + 1, 1}$$$. In the end you'll just need to check $$$dp_{k - 1, b'}$$$ where $$$b'$$$ indicates whether the knight $$$2 * k - 1$$$ was swapped in our choice.
(All the indices for the desks are taken modulo $$$n$$$ and all the indices for the knights are taken modulo $$$2 n$$$.)
Time complexity: $$$O(n^2)$$$, but the constant is large and $$$O(n^2\log n)$$$ solutions with binary search are unlikely to pass.
Code
272207462
--------------------------------------------------
Problem ID: 1995D
Editorial Content:
1995D - Cases
Hint 1
If letter is chosen as an ending to some case, each occurrence of this letter may in the text can be considered an ending?
Hint 2
The length of the word is something too complex. How can you simplify the restriction?
Answer to Hint 2
The final letter must be an ending of some case and among any $$$k$$$ consecutive letters there must be at least one ending.
Hint 3
Now you don't need the text because you can store bitmasks instead of substrings of length $$$k$$$. To calculate the bitmasks you can use prefix sums for each of the characters (it will take $$$O(cn)$$$ overall).
Hint 4
Now you need to find a bitmask with a minimal number of ones which intersects all the stored bitmasks.
Hint 5
Identify "bad" bitmask instead of "good" ones.
Solution
(Read the hints.) $$$b$$$ is bad if there exists stored $$$a$$$ such that $$$a \text{&} b = 0$$$ which is equivalent to $$$b$$$ being a submask of $$$\text{~}a$$$. All such b can be found using simple dp on bitmasks. The rest $$$b$$$ are good.
Time complexity: $$$O(c n + c 2^c)$$$
Code
272218277
--------------------------------------------------
Problem ID: 1995C
Editorial Content:
1995C - Squaring
Hint
How many times we need to apply the operation to index $$$i$$$, so that $$$a[i - 1] \leq a[i]$$$? Let's call it $$$op[i]$$$
It's easy to calculate these values in no time.
Can we just accumulate them?
Answer to Hint
We almost can. But, let's take $$$[4, 2, 4]$$$ as an example. op[2] = 1, but we don't want to do anything with a[3].
So, sometimes $$$a[i - 1] \le a[i]$$$ and we may not want touch a[i] at all, even if something was applied before it.
So, should we consider making $$$op[i] < 0$$$ for some $$$i$$$?
Solution Integer
Let's set $$$op[i]$$$ to the number of operation we need to apply to index $$$i$$$ so that $$$a[i - 1] \leq a[i]$$$.
But, if $$$a[i - 1] \ll a[i]$$$, let's set it to the negative number of times that we can apply the operation to $$$a[i - 1]$$$ so that $$$a[i - 1] \leq a[i]$$$ still holds.
Now let's just calculate the prefix sum $$$\texttt{prefix_op}$$$, don't forget to do $$$\max(0, \texttt{prefix_op}[i])$$$. The sum of values in $$$\texttt{prefix_op}$$$ is the answer.
Solution Float
Let's try to go to the logarithmic space to get rid of too big numbers.
$$$\log(x * x) = 2\log(x)$$$
So, if we replace each value with its logarithm, the operation of squaring becomes multiplying by 2.
But this is not good enough, since we may need to do the operation thousands of times, $$$2^{1000}$$$ is too big, it doesn't fit into any floating point.
So, let's just repeat our trick and go to the log-log space
$$$\log(2 * y) = \log(y) + \log(2)$$$
Now we see that the operation turns into just adding $$$\log(2)$$$. We can afford doing that thousands and millions of times.
Let's deine $$$b[i] = \log{\log{a[i]}}$$$
So now, we can just go with a for-loop and do $$$\displaystyle{\left\lceil\frac{b[i] - b[i - 1]}{\log(2)}\right\rceil}$$$ opeartions with $$$i$$$-th element, updating $$$b[i]$$$ accordingly.
Since initially $$$b[i] \leq \log(10^6) \leq 20 \log(2)$$$, we can maintain the invariant that $$$b[i] \leq (20 + i)\log(2)$$$ since after applying an operation to $$$b[i]$$$ we can't exceed $$$b[i - 1]$$$ by more than $$$\log(2)$$$. It means that the final numbers in the log-log space won't exceed $$$(n + 20)\log(2)$$$. We can maintain $$$O(n)$$$ arithmetics using double without any problems.
Code Integer
272174772
--------------------------------------------------
Problem ID: 1995B2
Editorial Content:
1995B2 - Bouquet (Hard Version)
Hint
Maybe there is a way to change bruteforce into checking optimal values for counts of $$$x, x + 1$$$? Maybe there are only few types of optimal bouquets for $$$x, x + 1$$$?
Solution
We already have a list of $$$c_x$$$. We can use hash map to be able to check for any $$$c_x$$$ by $$$x$$$.
We again will try to assemble the bouquet only with flowers with $$$x, x + 1$$$ petals. We set $$$k1 = min(c_{x}, \left\lfloor\frac{m}{x}\right\rfloor)$$$. Then we have $$$coins = m - k1 * x$$$. Let's set $$$k2 = min(c_{x + 1}, \left\lfloor\frac{coins}{x + 1}\right\rfloor)$$$. Then we have $$$coins = m - (k1 * x + k2 * (x + 1))$$$. Let's substitute flower with $$$x$$$ petals with flower with $$$x + 1$$$ petals as many times as we can. This can be done $$$r = min(k1, c_{x + 1} - k2, coins)$$$ times, as each operation will require us 1 coin, 1 flower in the bouquet with $$$x$$$ petals and one 1 flower with $$$x + 1$$$ petals not in the bouquet. In total we can get $$$(k1 - r) * x + (k2 + r) * (x + 1)$$$ petals.
This assembling is optimal. Here is why. Suppose that we have $$$0 \le b1 \le c_{x}$$$ flowers with $$$x$$$ petals and $$$0 \le b2 \le c_{x + 1}$$$ flowers with $$$x + 1$$$ petals and greater total value of $$$b1 * x + b2 * (x + 1)$$$. We already know that $$$b1 \le k1$$$ by choosing of $$$k1$$$. If $$$k1 - r < b1$$$, then we can ''undo'' our operation $$$r + b1 - k1$$$ times, sum is still not greater than $$$m$$$, and we know that now there can't be more than $$$k2 + r + b1 - k1$$$ flowers with $$$x + 1$$$ petals, as otherwise we didn't chose optimal $$$k2$$$. If $$$k2 + r < b2$$$, then $$$r \ne c_{x + 1} - k2$$$, if $$$r = k1$$$ then it is just the case when we have only flowers with $$$x + 1$$$ petals which will be considered in case $$$x + 1, x + 2$$$, if $$$r = coins$$$ then $$$m = (k1 - r) * x + (k2 + r) * (x + 1)$$$ and we already found the maximum. So $$$b2 \le k2 + r$$$ and $$$b1 \le k1 - r$$$ and $$$b1 * x + b2 * (x + 1)$$$ is not better than optimal.
Total time complexity is $$$O(n)$$$.
Code
272263882
--------------------------------------------------
Problem ID: 1995B1
Editorial Content:
1995B1 - Bouquet (Easy Version)
Hint
For each number of petals, we can bruteforce the answer for $$$x, x + 1$$$
Solution
First, we can aggregate number of flowers with $$$x$$$ petals into $$$c_{x}$$$ (for example, sort the array and then create array of pairs $$$(x, c_{x})$$$, where $$$c_{x}$$$ is the length of segment with elements equal to $$$x$$$).
Note that $$$\sum_{x} c_{x} = n$$$. Also note that for every $$$x$$$ we won't need more than $$$\left\lfloor\frac{m}{x}\right\rfloor$$$ flowers (otherwise total number of petals will exceed $$$m$$$).
Then we iterate through all $$$x$$$. Suppose that we want to assemble a bouquet with $$$x, x + 1$$$ petals. We can bruteforce the amount of flowers with $$$x$$$ petals in $$$O(c_{x})$$$. If we have $$$0 \le k_1 \le min(c_{x}, \left\lfloor\frac{m}{x}\right\rfloor)$$$ flowers with $$$x$$$ petals, we already have $$$k_1 * x$$$ petals. There are still $$$m - k_1 * x$$$ coins which we can spend for flowers with $$$x + 1$$$ petals. There are at most $$$k_2 = min(c_{x + 1}, \left\lfloor\frac{m - k_1 * x}{x + 1}\right\rfloor)$$$ flowers with $$$x + 1$$$ petal we can buy. So we need to find maximum over all such $$$k_1 * x + k_2 * (x + 1)$$$.
Total complexity is $$$O(\sum_{x} c_{x}) = O(n)$$$ for finding the maximum and $$$O(n \log n)$$$ for sorting.
Code
272263831
--------------------------------------------------
Problem ID: 1995A
Editorial Content:
1995A - Diagonals
Hint
How many described diagonals are there in total? How many cells do they contain?
Answer to Hint
In total we have $$$2 n - 1$$$ diagonals. There is only one diagonal that contains $$$n$$$ cells, two containing $$$n - 1$$$ cells, ..., and two containing only one cell each (namely passing through $$$(1, n)$$$ and $$$(n, 1)$$$).
Solution
Obviously, in this case, it is worth filling the largest diagonal with chips, then two that are smaller in size, and so on. The asymptotics turns out to be $$$O(n)$$$.
Code
272176453
--------------------------------------------------
Problem ID: 1994H
Editorial Content:

--------------------------------------------------
Problem ID: 1994G
Editorial Content:
1994G — Minecraft
--------------------------------------------------
Problem ID: 1994F
Editorial Content:
1994F — Stardew Valley
--------------------------------------------------
Problem ID: 1994E
Editorial Content:
1994E — Wooden Game
--------------------------------------------------
Problem ID: 1994D
Editorial Content:
1994D — Funny Game
--------------------------------------------------
Problem ID: 1994C
Editorial Content:
1994C — Hungry Games
--------------------------------------------------
Problem ID: 1994B
Editorial Content:
1994B — Fun Game
--------------------------------------------------
Problem ID: 1994A
Editorial Content:
1994A — Diverse Game
--------------------------------------------------
Problem ID: 1993F2
Editorial Content:
1993F2 - Dyn-scripted Robot (Hard Version)
Solution
The idea of this version is almost the same as F1: counting the number of pairs $$$(i, j)$$$ that satisfies:
$$$ix_n + x_j\equiv 0\pmod{2W}$$$, and
$$$iy_n + y_j\equiv 0\pmod{2H}$$$
However, as $$$k$$$ is increased to $$$10^{12}$$$ we cannot brute-force the same way as the previous version. Luckily, there is a more efficient way. We need to modify these equivalences a bit:
$$$ix_n \equiv -x_j\pmod{2W}$$$ $$$(*)$$$
$$$iy_n \equiv -y_j\pmod{2H}$$$
As we can see, these two equivalences have the same format $$$ia \equiv b\pmod{M}$$$. To solve this equivalence for $$$i$$$, one way to hang around is to divide $$$a$$$, $$$b$$$ and $$$M$$$ by $$$\gcd(a, M)$$$. If $$$b$$$ is not divisible, there is no solution! Otherwise, we come up with:
$$$i \equiv ba^{-1}\pmod{M}$$$
Where $$$a^{-1}$$$ is the
modular inverse
of $$$a$$$. We can always calculate it because the condition $$$\gcd(a, M)=1$$$ is satisfied.
Let's define $$$g=\gcd(2W, x_n)$$$, $$$c_x = -\frac{x_j}g\left(\frac{x_n}g\right)^{-1}$$$ and $$$W'=\frac{2W}{g}$$$ (similar for $$$c_y$$$ and $$$H'$$$). Then, the solutions of the equivalences at $$$(*)$$$ are:
$$$i\equiv c_x\pmod{W'}$$$
$$$i\equiv c_y\pmod{H'}$$$
This system of equivalences can be solved using
Chinese Remainder Theorem
. After some calculations, we come up with:
$$$i=c_x + zW'$$$ ($$$z$$$ is a non-negative integer).
$$$zW'\equiv c_y-c_x\pmod{H'}$$$ $$$(**)$$$
$$$(**)$$$ can be solved for $$$z$$$ the same way as $$$(*)$$$. Now we know the solution is $$$i \equiv c_x + zW' \pmod{lcm(W', H')}$$$, the last thing to do is to count number of such value doesn't exceed $$$k-1$$$ and we're done!
Time complexity: $$$O(Nlog(W))$$$
Code (C++)
#include <bits/stdc++.h>
using namespace std;


using ll = long long;

namespace CRT {    
    // v * inv(v, M) = 1 (mod M)
    ll inv(ll v, ll M) {
        ll a = 1, b = 0;
        for (ll x = v, y = M; x != 0; ) {
            swap(a, b -= y/x * a);
            swap(x, y -= y/x * x);
        }
        return b + (b<0) * M;
    }

    // Minimum x that ax = b (mod c)
    ll solve_1(ll a, ll b, ll c) {
        ll g = gcd(a, c);
        if (b % g != 0) return -1;
        return b/g * inv(a/g, c/g) % (c/g);
    }

    // Minimum x that x%b = a and x%d = c
    ll solve_2(ll a, ll b, ll c, ll d) {
        ll t = (c-a)%d;
        if (t < 0) t += d;
        ll k = solve_1(b, t, d);
        return k==-1 ? -1 : a + k*b;
    }
}


const int N = 1e6 + 5;

ll n, k, w, h;
ll x[N], y[N];

int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);

    int tc; cin >> tc;
    while (tc--) {
        string s;
        cin >> n >> k >> w >> h >> s;

        for (int i = 1; i <= n; i++) {
            x[i] = x[i-1] + (s[i-1] == 'R') - (s[i-1] == 'L');
            y[i] = y[i-1] + (s[i-1] == 'U') - (s[i-1] == 'D');
            x[i] += (x[i] < 0) * 2*w - (x[i] >= 2*w) * 2*w;
            y[i] += (y[i] < 0) * 2*h - (y[i] >= 2*h) * 2*h;
        }

        ll ww = 2*w / gcd(x[n], 2*w);
        ll hh = 2*h / gcd(y[n], 2*h);
        ll ans = 0, l = lcm(ww, hh);

        for (int i = 1; i <= n; i++) {
            ll cx = CRT::solve_1(x[n], 2*w - x[i], 2*w);
            ll cy = CRT::solve_1(y[n], 2*h - y[i], 2*h);
            if (cx == -1 || cy == -1) continue;

            ll result = CRT::solve_2(cx, ww, cy, hh);
            if (result != -1 && result < k) {
                ans += (k - result - 1) / l + 1;
            }
        }

        cout << ans << '\n';
    }
}
--------------------------------------------------
Problem ID: 1993F1
Editorial Content:
1993F1 - Dyn-scripted Robot (Easy Version)
Hint 1
Let the robot moves freely (no modification on the script).
Hint 2
The new path of the robot is the "mirrored" version of how the robot must go.
General idea
Imagine we have two robots, let's call them Alex and Bob. Alex is the one who follows the instruction well, but Bob doesn't (if he tries to move outside the box, he keeps going without modifying the script). Then, you follow the path of each robot that is moving. How do you think their paths differ from each other?
Yes! Suppose at some moment they reach the top side of the box at the same time. Suddenly, Bob wants to move up while Alex know the discipline and modify the script before executing the command and move down. Then, each of them is $$$1$$$ unit away from the top side of the box. If Bob keeps moving up, Alex keep moving down. In case Bob changes his mind and move down then this time Alex changes her mind and move up.
What do we learn from this? They move like two objects facing each other through a mirror. Actually there are four mirror of them, placing at the four sides of the box.
Now, let's say Bob moves up so much that Alex follows the script and reaches the top side and the bottom side as well. Because of that, she has to change the script once again and start moving up like Bob.
When Alex reaches the bottom side at point $$$(x, 0)$$$, then Bob should be at point $$$(x, 2H)$$$ (prove it yourself!). If Bob keeps moving up to the point $$$(x, 4H), (x, 6H), or (x, 8H), \dots$$$, at these moment Alex will also be at point $$$(x, 0)$$$. That being said, Alex's position is $$$(x, 0)$$$ then Bob's position must be $$$(x, y)$$$ where y is a multiple of $$$2H$$$.
This idea is exactly the same as if Bob were moving sideways (left or right). As we only care about the number of times Alex's position is $$$(0, 0)$$$, we know that if we don't change the script at all, the position of the robot must be $$$(x, y)$$$ where $$$x$$$ is a multiple of $$$2W$$$, and $$$y$$$ is a multiple of $$$2H$$$.
Solution
So apparently, we need to calculate the number of times the robot reaches $$$(x, y)$$$, where $$$x$$$ is a multiple of $$$2W$$$ and $$$y$$$ is a multiple of $$$2H$$$ (see the general idea above).
Let's call $$$t_k = (x_k, y_k)$$$ how much the robot moves (in direction) after executing the first $$$k$$$ commands of the script. Then: $$$t_0 = (0, 0)$$$ and $$$t_k$$$ can be calculated through $$$t_{k-1}$$$ and $$$s_k$$$.
The robot will execute the script $$$k$$$ times and the script contains $$$n$$$ commands, so we have $$$nk$$$ positions to check out. Each position can be represented by: $$$(x, y) = it_n + t_j = (ix_n + x_j, iy_n + y_j)$$$ (where $$$0\le i\le k-1$$$ and $$$1\le j\le n$$$). Besides, we need:
$$$x\equiv 0\pmod{2W} \Longrightarrow ix_n + x_j\equiv 0\pmod{2W} \Longrightarrow x_j\equiv -ix_n\pmod{2W}$$$
$$$y\equiv 0\pmod{2H} \Longrightarrow iy_n + y_j\equiv 0\pmod{2H} \Longrightarrow y_j\equiv -iy_n\pmod{2H}$$$
Lastly, we can traverse all possible $$$i$$$ from $$$0$$$ to $$$k-1$$$ and count the number of $$$j$$$ that satisfies the above equivalence. One possible way to do this is to use a map to count each element in the array $$$t_1, t_2, \dots, t_n$$$. Summing all the counts will give the answer for this problem.
Time complexity: $$$O((n + k)\log n)$$$
Code (C++)
#include <bits/stdc++.h>
using namespace std;
 
using ll = long long;
const int N = 1e6 + 5;
 
string s;
ll n, k, w, h;
ll tx[2*N], ty[2*N];
map<pair<ll, ll>, ll> cnt;
 
int main() {
    cin.tie(0)->sync_with_stdio(0);
    
    int t;
    cin >> t;
 
    while (t--) {
        cin >> n >> k >> w >> h >> s;
 
        cnt.clear();
        ll x = 0, y = 0;
 
        for (int i = 0; i < n; i++) {
            if (s[i] == 'L') x--;
            if (s[i] == 'R') x++;
            if (s[i] == 'D') y--;
            if (s[i] == 'U') y++;

            x = (x + 2*w) % (2*w);
            y = (y + 2*h) % (2*h);
            cnt[{x, y}]++;
        }
 
        ll ans = 0;
        for (int i = 0; i < k; i++) {
            ll vx = (-i*x%(2*w) + 2*w)%(2*w);
            ll vy = (-i*y%(2*h) + 2*h)%(2*h);
            ans += cnt[{vx, vy}];
        }

        cout << ans << '\n';
    }
}
--------------------------------------------------
Problem ID: 1993E
Editorial Content:
1993E - Xor-Grid Problem
Hint 1
Try applying an operation on the same row twice. Does it change the matrix significantly?
Hint 2
Now apply operations on two different rows. Does the second row (that the operation is applied) look familiar?
Solution
First, let's extend the original matrix by one unit in rows and columns (which means there's an additional $$$(n+1)$$$-th row and $$$(m+1)$$$-th column). Then, assign $$$a[i][m+1] = f(i)$$$ (xorsum of the $$$i$$$-th row) and $$$a[n+1][j] = g(j)$$$ (xorsum of the $$$j$$$-th column). That way, the operation is simplified as follows:
The first-type operation becomes swapping the $$$i$$$-th row with the $$$(n+1)$$$-th row.
The second-type operation becomes swapping the $$$j$$$-th column with the $$$(m+1)$$$-th column.
Why?
As we know, the first-type operation is to select any row $$$i$$$, then assign $$$a[i][j] = g(j)$$$ for all index $$$j$$$. But after the matrix extension, the value of $$$g(j)$$$ is also $$$a[n+1][j]$$$ so it means replacing the $$$i$$$-th row with the $$$(n+1)$$$-th one.
But we also need to care about the new value of $$$g(j)$$$ for future operations right? Surprisingly, the new value of $$$g(j)$$$ is nowhere strange, just the old value of element $$$a[i][j]$$$ being replaced right before! This takes advantage of the fact that if we perform the operation on the same row twice, the row become unchanged. After swapping two rows, the value of $$$a[n+1][j]$$$ then again become $$$g(j)$$$ of the new matrix.
The change of the second-type operation can be proven the same way.
That way, the matrix can be constructed by the permutation of rows, and the permutation of columns (as we can swap them however we want). After all operations, let's say the rows ordered from the top to the bottom are $$$r_1, r_2, \dots, r_{n+1}$$$. Similarly, the columns ordered from the left to the right are $$$c_1, c_2, \dots, c_{m+1}$$$.
Next thing to consider is: $$$\text{beauty(a)} = R + C$$$ — the beauty of the matrix, where:
$$$R = \sum\limits_{i=1}^n \sum\limits_{j=2}^m \big|a[i][j] - a[i][j-1]\big|$$$ — sum of adjacent cells on the same row.
$$$C = \sum\limits_{j=1}^m \sum\limits_{i=2}^n \big|a[i][j] - a[i-1][j]\big|$$$ — sum of adjacent cells on the same column.
Note that we include
neither
the $$$(n+1)$$$-th row
nor
the $$$(m+1)$$$-th column when calculating $$$R$$$ and $$$C$$$. That being said, after all operations, the $$$r_{n+1}$$$-th row and the $$$c_{m+1}$$$-th column is excluded and do not make any effect in further calculations anymore.
After that, we calculate two arrays:
$$$dr[u][v] = $$$ sum of differences between $$$u$$$-th row and $$$v$$$-th row.
$$$dc[u][v] = $$$ sum of differences between $$$u$$$-th column and $$$v$$$-th column.
Then, we'll rewrite the formulas of $$$R$$$ and $$$C$$$ as: $$$R = \sum\limits_{i=2}^n dr[r_{i-1}][r_i]$$$ and $$$C = \sum\limits_{i=2}^m dc[c_{i-1}][c_i]$$$. From now on, calculating $$$R$$$ and $$$C$$$ is as easy as solving the
Travelling Salesman Problem
: finding a good permutation $$$r_1, \dots, r_n$$$ that produces the minimum $$$R$$$, and a good permutation $$$c_1, \dots, c_n$$$ that produces the minimum $$$C$$$. At the end, by summing $$$R + C$$$ we got the $$$\text{beauty}$$$ for a fixed excluded row and column for the matrix $$$a$$$.
Time complexity: $$$O((n+1)(m+1)^22^{m+1} + (m+1)(n+1)^22^{n+1})$$$, or just $$$O(n^32^n)$$$.
Why?
As we know, the first-type operation is to select any row $$$i$$$, then assign $$$a[i][j] = g(j)$$$ for all index $$$j$$$. But after the matrix extension, the value of $$$g(j)$$$ is also $$$a[n+1][j]$$$ so it means replacing the $$$i$$$-th row with the $$$(n+1)$$$-th one.
But we also need to care about the new value of $$$g(j)$$$ for future operations right? Surprisingly, the new value of $$$g(j)$$$ is nowhere strange, just the old value of element $$$a[i][j]$$$ being replaced right before! This takes advantage of the fact that if we perform the operation on the same row twice, the row become unchanged. After swapping two rows, the value of $$$a[n+1][j]$$$ then again become $$$g(j)$$$ of the new matrix.
The change of the second-type operation can be proven the same way.
Code (C++)
#include <bits/stdc++.h>
using namespace std;
 
const int N = 16;
 
int n, m;
int a[N][N];
 
int fr[N][N], fc[N][N];
int w[N][N], dp[N][1<<N];
 
int main() {
    cin.tie(0)->sync_with_stdio(0);
    
    int t;
    cin >> t;
 
    while (t--) {
        cin >> n >> m;
 
        for (int i = 0; i <= n; i++) a[i][m] = 0;
        for (int j = 0; j <= m; j++) a[n][j] = 0;
 
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                cin >> a[i][j];
                a[i][m] ^= a[i][j];
                a[n][j] ^= a[i][j];
                a[n][m] ^= a[i][j];
            }
        }
 
        int fullmask_n = (1 << (n+1)) - 1;
        int fullmask_m = (1 << (m+1)) - 1;
 
        for (int rmv = 0; rmv <= m; rmv++) {
            for (int i = 0; i <= n; i++) {
                for (int j = i + 1; j <= n; j++) {
                    w[i][j] = 0;
                    for (int l = 0; l <= m; l++) {
                        if (rmv == l) continue;
                        w[i][j] += abs(a[i][l] - a[j][l]);
                    }
                    w[j][i] = w[i][j];
                }
            }
 
            for (int i = 0; i <= n; i++) {
                fill(dp[i], dp[i] + fullmask_n, INT_MAX);
                dp[i][1 << i] = 0;
            }
 
            for (int mask = 0; mask <= fullmask_n; mask++) {
                for (int last = 0; last <= n; last++) {
                    if (~mask >> last & 1) continue;
                    if (__builtin_popcount(mask) == n) continue;
 
                    for (int next = 0; next <= n; next++) {
                        if (mask >> next & 1) continue;
 
                        int new_mask = mask | 1 << next;
                        dp[next][new_mask] = min(
                            dp[next][new_mask],
                            dp[last][mask] + w[last][next]
                        );
                    }
                }
            }
 
            for (int i = 0; i <= n; i++) {
                fr[i][rmv] = INT_MAX;
                int mask = fullmask_n ^ 1 << i;
 
                for (int last = 0; last <= n; last++) {
                    fr[i][rmv] = min(fr[i][rmv], dp[last][mask]);
                }
            }
        }
 
        for (int rmv = 0; rmv <= n; rmv++) {
            for (int i = 0; i <= m; i++) {
                for (int j = i + 1; j <= m; j++) {
                    w[i][j] = 0;
                    for (int l = 0; l <= n; l++) {
                        if (rmv == l) continue;
                        w[i][j] += abs(a[l][i] - a[l][j]);
                    }
                    w[j][i] = w[i][j];
                }
            }
 
            for (int i = 0; i <= m; i++) {
                fill(dp[i], dp[i] + fullmask_m, INT_MAX);
                dp[i][1 << i] = 0;
            }
 
            for (int mask = 0; mask <= fullmask_m; mask++) {
                for (int last = 0; last <= m; last++) {
                    if (~mask >> last & 1) continue;
                    if (__builtin_popcount(mask) == m) continue;
 
                    for (int next = 0; next <= m; next++) {
                        if (mask >> next & 1) continue;
 
                        int new_mask = mask | 1 << next;
                        dp[next][new_mask] = min(
                            dp[next][new_mask],
                            dp[last][mask] + w[last][next]
                        );
                    }
                }
            }
 
            for (int i = 0; i <= m; i++) {
                fc[rmv][i] = INT_MAX;
                int mask = fullmask_m ^ 1 << i;
 
                for (int last = 0; last <= m; last++) {
                    fc[rmv][i] = min(fc[rmv][i], dp[last][mask]);
                }
            }
        }
 
        int ans = INT_MAX;
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                ans = min(ans, fr[i][j] + fc[i][j]);
            }
        }
 
        cout << ans << '\n';
    }
}
--------------------------------------------------
Problem ID: 1993D
Editorial Content:
1993D - Med-imize
Hint 1
Is there any method to calculate median without sorting?
Hint 2
Is there any relationship between the original array with the final array?
Solution
Note: in order to explain this solution easier, we'll suppose all arrays are 0-indexed.
If $$$n \le k$$$, we don't have to remove any segment since the statement only tell us to do it while the length of $$$a$$$ is greater than $$$k$$$. That way, the median of $$$a$$$ is fixed. Let's find a way to calculate this value
without
sorting the array.
Given an integer $$$x$$$. If $$$x$$$ is less than or equal to the median of $$$a$$$, then suppose we sort $$$a$$$ in increasing order, $$$x$$$ is somewhat to the left of $$$med(a)$$$. That means the number of elements greater than or equal to $$$x$$$ is more than the number of elements less than $$$x$$$. Using this observation, we can create another array $$$b$$$ of the same size as $$$a$$$, such that $$$b[i] = 1$$$ if $$$a[i] \ge x$$$, otherwise $$$b[i] = -1$$$. The trick here is if $$$sum(b) > 0$$$, then the condition $$$x \le med(a)$$$ is satisfied. Using this trick, we can easily binary search the median of $$$a$$$ by fixing value of $$$x$$$, checking if $$$sum(b) > 0$$$ and adjusting the value range of $$$med(a)$$$.
How about $$$n>k$$$. In this case, we'll keep using the same strategy as above. That is: fix the value of $$$x$$$, find a way to delete segments of $$$a$$$ so that the array $$$b$$$ has largest sum, check if that sum is greater than $$$0$$$ and adjust the value range of the answer.
Note that each time we delete a segment, the size of $$$a$$$ is reduced by $$$k$$$. We do that until $$$|a|\le k$$$. Let's call the final array $$$a$$$ after deleting segments $$$a'$$$. After some calculation, we come up with $$$|a'| = ((n-1)\bmod k) + 1$$$.
Also, it can be seen that the elements $$$a'[0], \dots, a'[m-1]$$$ (where $$$m = |a'|$$$) always originate from the elements $$$a[i_0], \dots, a[i_{m-1}]$$$ such that $$$i_0\equiv 0\pmod k, i_1\equiv 1\pmod k, \dots, i_{m-1}\equiv m-1\pmod k$$$.
Why?
Suppose we want to delete the segment $$$[i, i+k-1]$$$ from $$$a$$$. This operation shift all the elements from the right by $$$k$$$ units to the left, which means the indexes are subtracted by $$$k$$$ units. But if we only care about the indexes modulo $$$k$$$ before and after deleting the segments, shifting $$$k$$$ units doesn't change their modulos at all.
With all above observations, we come up with the following DP formula to find the optimal segment deletions:
$$$dp[0] = b[0]$$$
If $$$i\equiv 0\pmod k$$$ and $$$i > 0$$$, then $$$dp[i] = max(dp[i-k], b[i])$$$
Otherwise $$$dp[i] = dp[i-1] + b[i]$$$. If $$$i > k$$$ then maximize $$$dp[i]$$$ by $$$dp[i-k]$$$
Then, the maximum sum of $$$b$$$ in the optimal deletions equals to $$$dp[n-1]$$$.
Time complexity: $$$O(n\log max(a))$$$.
Why?
Suppose we want to delete the segment $$$[i, i+k-1]$$$ from $$$a$$$. This operation shift all the elements from the right by $$$k$$$ units to the left, which means the indexes are subtracted by $$$k$$$ units. But if we only care about the indexes modulo $$$k$$$ before and after deleting the segments, shifting $$$k$$$ units doesn't change their modulos at all.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

const int N = 500005;

int n, k, a[N];
int dp[N], b[N];

bool check(int med) {
    for (int i = 0; i < n; i++) {
        if (a[i] >= med) {
            b[i] = 1;
        } else {
            b[i] = -1;
        }
    }

    dp[0] = b[0];
    for (int i = 1; i < n; i++) {
        if (i%k == 0) {
            dp[i] = max(dp[i-k], b[i]);
        } else {
            dp[i] = dp[i-1] + b[i];
            if (i > k) {
                dp[i] = max(dp[i], dp[i-k]);
            }
        }
    }

    return dp[n-1] > 0;
}

int main() {
    cin.tie(0)->sync_with_stdio(0);

    int t; cin >> t;
    while (t--) {
        cin >> n >> k;

        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }

        int lo = 1, hi = 1e9;
        while (lo <= hi) {
            int mid = lo + hi >> 1;
            if (check(mid)) {
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }

        cout << hi << '\n';
    }
}
--------------------------------------------------
Problem ID: 1993C
Editorial Content:
1993C - Light Switches
Hint 1
Try to find the segments of moments when a light is on.
Hint 2
Select this segment from each light. The answer should be the intersection of all of them.
Solution
As soon as a chip is installed, it changes the light's status every $$$k$$$ minutes.
Let's first list the segments of the moments when a light is on if we install a chip at moment $$$x$$$:
$$$x\rightarrow x+k-1$$$
$$$x+2k\rightarrow x+3k-1$$$
$$$x+4k\rightarrow x+5k-1$$$
$$$\dots$$$
Have you seen the pattern yet? Apparently each segment in the list (except the first one) is actually the segment before it, shifted by $$$2k$$$ minutes. This also means that if we divide by $$$2k$$$ and take the remainder at both ends of each segment, all these segments become equal. With that, let's call $$$(a_i\bmod 2k, (a_i+k-1)\bmod 2k)$$$ the segment of the $$$i$$$-th chip.
Our problem is thus simplified to: find the smallest integer $$$s$$$ such that:
$$$max(a) \le s$$$
$$$s\bmod 2k$$$ appears in every segments of all chips.
In order to satisfy the first condition, it seems if we figure out some $$$r = s\bmod 2k$$$ that satisfy the second condition, we may come up with:
$$$s = max(a) + ((r - max(a))\bmod 2k)$$$
Next, in order for a segment to contain $$$r$$$, this inequality must be satisfied: $$$r-k+1 \le a_i \le r \pmod{2k}$$$. This is because a light is on only for at most $$$k$$$ minutes (before it gets turned off), so it must come not long before the moment $$$r$$$. Let's call $$$d[z]$$$ the number of chips that has $$$a_i \equiv z \pmod{2k}$$$, then in order for all lights to be on at moment $$$s$$$, the condition is:
$$$\sum \limits_{z=r-k+1}^{r} d[z] = n$$$
This idea can be implemented using two-pointer technique, that traverse all $$$r$$$ from $$$0$$$ to $$$2k-1$$$. As there can be many possible values of $$$r$$$, we only take one that produces $$$s$$$ with minimum value. Be careful when handling signs in problems with modules to avoid unnecessary errors.
Time complexity: $$$O(n)$$$.
Code (C++)
#include <bits/stdc++.h>
using namespace std;
 
 
const int N = 2e5 + 5;
 
int n, k, d[2*N];
 
int main() {
    cin.tie(0)->sync_with_stdio(0);
    
    int t;
    cin >> t;
 
    while (t--) {
        cin >> n >> k;
 
        int mx = -1;
        fill(d, d + 2*k, 0);
 
        for (int i = 0; i < n; i++) {
            int x;
            cin >> x;
            assert(x >= 1);
            d[x % (2*k)]++;
            mx = max(mx, x);
        }
 
        int cnt = 0;
        int ans = INT_MAX;
        for (int i = 0; i <= k - 2; i++) {
            cnt += d[i];
        }
 
        for (int l = 0, r = k-1; l < 2*k; l++, r++) {
            if (r >= 2*k) r -= 2*k;
 
            if (cnt += d[r]; cnt == n) {
                int wait = (r-mx) % (2*k);
                if (wait < 0) wait += 2*k;
                ans = min(ans, mx + wait);
            }
 
            cnt -= d[l];
        }
 
        if (ans == INT_MAX) {
            ans = -1;
        }
        cout << ans << '\n';
    }
}
--------------------------------------------------
Problem ID: 1993B
Editorial Content:
1993B - Parity and Sum
Hint 1
Find a way to make all the elements even. Then odd.
Hint 2
In the worst case, the number of operations required is the number of even elements + 1. Why?
Solution
First, if all elements already have the same parity, we don't need to do perform any operation.
Next, if the array contains both $$$even$$$ and $$$odd$$$ numbers. In this case, it is impossible to convert all elements to $$$even$$$ numbers.
Why?
If we apply an operation on:
two $$$odd$$$ elements, one of them remains $$$odd$$$.
two elements of distinct parities, one of them is replaced with their sum, which is an $$$odd$$$ number.
This implies even if we want to change an $$$odd$$$ element to $$$even$$$ number, it fails in both ways possible.
So we just want to convert all of them to $$$odd$$$ numbers. Now come the greedy part:
$$$even + even = even \longrightarrow$$$ it doesn't reduce the number of $$$even$$$ elements, so skip it.
$$$odd + odd = even \longrightarrow$$$ this creates another $$$even$$$ number, indeed very awful.
$$$even + odd = odd \longrightarrow$$$ this is great, but only if the sum replaces the $$$even$$$ one (which means $$$even < odd$$$).
Let's find the largest $$$odd$$$ element and call it $$$s$$$. Then traverse each $$$even$$$ elements $$$t$$$ in non-decreasing order and apply an operation on $$$s$$$ and $$$t$$$:
If $$$t < s$$$, $$$s+t$$$ becomes largest odd number. Thus, we set $$$s := s+t$$$. This reduce the number of even element by $$$1$$$.
If $$$t > s$$$, before we do this operation, we need to do another on $$$s$$$ and the largest even element to make $$$s$$$ the largest in the array. Note that this case only happens at most once.
As a result, the answer is the number of even elements (plus $$$1$$$ if the second case occurs).
Time complexity: $$$O(n\log n)$$$.
Why?
If we apply an operation on:
two $$$odd$$$ elements, one of them remains $$$odd$$$.
two elements of distinct parities, one of them is replaced with their sum, which is an $$$odd$$$ number.
This implies even if we want to change an $$$odd$$$ element to $$$even$$$ number, it fails in both ways possible.
Code (python)
t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))

    s = -1
    v = []
    for x in a:
        if x%2 == 0:
            v.append(x)
        elif x > s:
            s = x
    v.sort()

    if s == -1 or v == []:
        print(0)
        continue
    
    ans = len(v)
    for t in v:
        if t < s:
            s += t
        else:
            ans += 1
            break

    print(ans)
--------------------------------------------------
Problem ID: 1993A
Editorial Content:
1993A - Question Marks
Hint
What is the pattern of Tim's answer sheet that can give him maximum score?
Solution
Let's say there are $$$n$$$ problems take $$$A$$$ as the answer, therefore he can only get $$$n$$$ points with the answer $$$A$$$. The same is correct for $$$B$$$, $$$C$$$ and $$$D$$$. Therefore, the maximum score can be achieved is $$$min(n, A) + min(n, B) + min(n, C) + min(n, D)$$$.
Time complexity: $$$O(4n)$$$
Code (python)
t = int(input())
for _ in range(t):
    n = int(input())
    s = input()

    print(sum(min(n, s.count(c)) for c in "ABCD"))
--------------------------------------------------
Problem ID: 1992G
Editorial Content:
1992G - Ultra-Meow
Tutorial
We will iterate over the size of the set $$$k$$$ and its $$$\text{MEOW}$$$, $$$m$$$. If $$$2k \geqslant n$$$, then the set $$$x$$$ will fill all the remaining numbers up to $$$n$$$, and there may still be some larger than $$$n$$$ in it, so the $$$MEOW$$$ of all such sets will be $$$2k+1$$$, and there will be a total of $$$C(n, k)$$$ such sets for each $$$k$$$. If $$$2k < n$$$, $$$m$$$ lies in the interval from $$$k+1$$$ to $$$2k+1$$$. Notice that there can be exactly $$$m - 1 - k$$$ numbers before $$$m$$$, and correspondingly $$$2k + 1 - m$$$ numbers to the right of $$$m$$$, so the answer needs to be added with $$$C_{m - 1}^{m - 1 - k} \cdot C_{n - m}^{2k + 1 - m} \cdot m$$$.
Asymptotic complexity of the solution: $$$O(n^2)$$$.
Solution (C++)
#include <iostream>

using namespace std;

const int mod = 1e9 + 7;

int add(int a, int b) {
    if (a + b >= mod)
        return a + b - mod;
    return a + b;
}

int sub(int a, int b) {
    if (a < b)
        return a + mod - b;
    return a - b;
}

int mul(int a, int b) {
    return (int)((1ll * a * b) % mod);
}

int binpow(int a, int pw) {
    int b = 1;
    while (pw) {
        if (pw & 1)
            b = mul(b, a);
        a = mul(a, a);
        pw >>= 1;
    }
    return b;
}

int inv(int a) {
    return binpow(a, mod - 2);
}

const int N = 15000;
int f[N], r[N];

void precalc() {
    f[0] = 1;
    for (int i = 1; i < N; i++)
        f[i] = mul(f[i - 1], i);
    r[N - 1] = inv(f[N - 1]);
    for (int i = N - 2; i > -1; i--)
        r[i] = mul(r[i + 1], i + 1);
}

int C(int n, int k) {
    if (n < 0 || k < 0 || n < k)
        return 0;
    return mul(f[n], mul(r[k], r[n - k]));
}

inline void solve() {
    int n;
    cin >> n;
    int ans = 1;
    for (int k = 1; k <= n; k++) {
        if (2 * k >= n) {
            ans = add(ans, mul(2 * k + 1, C(n, k)));
            continue;
        }
        for (int m = k + 1; m <= 2 * k + 1; m++) {
            int c = mul(C(m - 1, m - 1 - k), C(n - m, 2 * k + 1 - m));
            ans = add(ans, mul(mul(C(m - 1, m - 1 - k), C(n - m, 2 * k + 1 - m)), m));
        }
    }
    cout << ans << '\n';
}

signed main() {
    int T = 1;
    cin >> T;
    precalc();
    while(T--)
        solve();
    return 0;
}
--------------------------------------------------
Problem ID: 1992F
Editorial Content:
1992F - Valuable Cards
Tutorial
Let's consider the greedy algorithm ``take as long as you can''. Let's prove that it works. In any optimal division, if we take the first segment of non-maximum length, we will not violate the criteria if we transfer one element from the second segment to the first. Therefore, the given greedy algorithm is correct.
Now let's figure out how to quickly understand if the segment can be extended. First, find all divisors of the number $$$x$$$. If the number $$$a_i$$$ is not a divisor of it, then it cannot be included in any set of numbers whose product is equal to $$$x$$$, so we can simply add it to the segment. If $$$a_i$$$ is a divisor, we need to somehow learn to understand whether it, in combination with some other divisors, gives the number $$$x$$$ on the segment. We will maintain a set of divisors that are products of some numbers in the segment. To update the set when adding $$$a_i$$$, we will go through all the divisors of this set and for each divisor $$$d$$$ add $$$d \cdot a_i$$$ to the set. If we added the number $$$x$$$ to the set, $$$a_i$$$ will already be in the next segment and we need to clear the set.
P. S.: About implementation details and runtime. If you maintain the set in a set structure, then we get a runtime of $$$O(n \cdot d(x) \cdot \log(d(x)))$$$, where $$$d(x)$$$ is the number of divisors of $$$x$$$. Instead of a set, you can use, for example, a global array $$$used$$$ of size $$$10^5 + 1$$$, as well as maintain a vector of reachable divisors. Using these structures, you can achieve a runtime of $$$O(n \cdot d(x))$$$.
Solution (C++)
#include <iostream>
#include <vector>

using namespace std;

const int A = 1e6 + 1;
bool used[A];
bool divs[A];

void solve() {
	int n, x;
	cin >> n >> x;
	vector<int> a(n);
	vector<int> vecDivs;
	for (int d = 1; d * d <= x; d++) {
		if (x % d == 0) {
			divs[d] = true;
			vecDivs.push_back(d);
			if (d * d < x) {
			    vecDivs.push_back(x / d);
				divs[x / d] = true;
			}
		}
	}
	for (int i = 0; i < n; i++)
		cin >> a[i];
	int ans = 1;
	used[1] = true;
	vector<int> cur{ 1 };
	for (int i = 0; i < n; i++) {
		if (!divs[a[i]])
			continue;
		vector<int> ncur;
		bool ok = true;
		for (int d : cur)
			if (1ll * d * a[i] <= x && divs[d * a[i]] && !used[d * a[i]]) {
				ncur.push_back(d * a[i]);
				used[d * a[i]] = true;
				if (d * a[i] == x)
					ok = false;
			}
		for (int d : ncur)
			cur.push_back(d);
		if (!ok) {
			ans++;
			for (int d : cur)
				used[d] = false;
			used[1] = true;
			used[a[i]] = true;
			cur = vector<int>{ 1, a[i] };
		}
	}
	for (int d : vecDivs) {
	    divs[d] = false;
	    used[d] = false;
	}
	cout << ans << '\n';
}

signed main() {
    int T;
    cin >> T;
    while (T--)
	    solve();
	return 0;
}
--------------------------------------------------
Problem ID: 1992E
Editorial Content:
1992E - Novice's Mistake
Tutorial
Notice that $$$n * a - b$$$ is strictly less than $$$10^6$$$, i.e., it has no more than $$$6$$$ digits. The number of characters in the strange calculation $$$n * a - b$$$ is equal to $$$|n| * a - b$$$, where $$$|n|$$$ is the number of digits in n. Let's iterate over the value of $$$a$$$, and then determine the boundaries $$$minB$$$ and $$$maxB$$$ for it, such that $$$|n| * a > maxB$$$ and $$$|n| * a - minB \le 6$$$. Then: \begin{cases} minB = |n| * a- 6 \\ maxB = |n| * a- 1 \end{cases} Let's iterate over all $$$b$$$ from $$$minB$$$ to $$$maxB$$$. To quickly check the strange calculation, let's only find its first $$$|n| * a - b$$$ digits. This way, we can find all suitable pairs $$$(a, b)$$$.
Solution complexity: $$$O(a)$$$.
Solution (Python)
for _ in range(int(input())):
    n = int(input())
    sn = str(n)
    lenN = len(str(n))
    ans = []
    for a in range(1, 10001):
        minB = max(1, lenN * a - 5)
        maxB = lenN * a
        for b in range(minB, maxB):
            x = n * a - b
            y = 0
            for i in range(lenN * a - b):
                y = y * 10 + int(sn[i % lenN])
            if x == y:
                ans.append((a, b))
    print(len(ans))
    for p in ans:
        print(*p)
--------------------------------------------------
Problem ID: 1992D
Editorial Content:
1992D - Test of Love
Tutorial
In this problem, there are two main solutions: dynamic programming and greedy algorithm.
Dynamic programming solution: $$$dp_i$$$ $$$-$$$ the minimum number of meters that need to be swum to reach the $$$i$$$-th cell. The base case of the dynamic programming is $$$dp_0 = 0$$$. Then, the update rule is: \begin{equation*} dp_i = \text{minimum of} \begin{cases} dp_{i-1} + 1& \text{if } A_i = \text{'W'} \\ min(dp_j) & \text{for all } j, \text{where:} \max(0, i — m) \le j < i \text{ and } A_j = \text{'L'} \end{cases} \end{equation*} Solution complexity: $$$O(nm)$$$.
Greedy algorithm solution: If we can jump, we want to jump to the shore if possible. If we can't, we want to jump to any log ahead to jump from it later. If we can't, we jump as far as possible to avoid crocodiles and swim as little as possible.
Solution complexity: $$$O(n)$$$.
Solution (greedy)
def run() -> None:
    n,m,k = map(int, input().split())
    A = input()
    logs = [i for i in range(n) if A[i] == "L"]
    logs.append(n+1)
    i = -1
    next_log = 0
    while i < n-1:
        if m >= logs[next_log] - i:
            i = logs[next_log]
        else:
            i+=m
            if i > n-1:
                print("YES")
                return
            while i < n and i < logs[next_log]:
                if A[i] != "C" and k > 0:
                    i+=1
                    k-=1
                else:
                    print("NO")
                    return
        next_log +=1
    print("YES")
 
for _ in range(int(input())):
    run()
Solution (DP)
#include <bits/stdc++.h>
using namespace std;
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, m, k; 
        cin >> n >> m >> k;
        string s;
        cin >> s;
        vector<int> dp(n + 2, -1);
        dp[0] = k;
        for (int i = 1; i <= n + 1; i++) {
            if (i != n + 1 && s[i - 1] == 'C') 
                continue;
            for (int t = 1; t <= m; t++)
                if (i - t >= 0 && (i - t == 0 || s[i - t - 1] == 'L'))
                    dp[i] = max(dp[i], dp[i - t]);
            if (i > 1 && s[i - 2] == 'W') 
                dp[i] = max(dp[i], dp[i - 1] - 1);
        }
        if (dp[n + 1] >= 0) 
            cout << "YES\n";
        else 
            cout << "NO\n";
    }
}
--------------------------------------------------
Problem ID: 1992C
Editorial Content:
1992C - Gorilla and Permutation
Tutorial
Let $$$p$$$ be some permutation. Let's look at the contribution of the number $$$p_i$$$ to the sum $$$\sum_{i=1}^n {f(i)}$$$. If it is less than $$$k$$$, the contribution is $$$0$$$, otherwise the contribution is $$$p_i \cdot (n - i + 1)$$$. Similarly, let's look at the contribution of $$$p_i$$$ to the sum $$$\sum_{i=1}^n {g(i)}$$$. If it is greater than $$$m$$$, the contribution is $$$0$$$, otherwise it is $$$p_i \cdot (n - i + 1)$$$. Since $$$m < k$$$, each number gives a contribution greater than $$$0$$$ in at most one sum. Therefore, it is advantageous to place numbers not less than $$$k$$$ at the beginning, and numbers not greater than $$$m$$$ at the end. Also, numbers not less than $$$k$$$ should be in descending order to maximize the sum of $$$f(i)$$$. Similarly, numbers not greater than $$$m$$$ should be in ascending order to minimize the sum of $$$g(i)$$$.
For example, you can construct such a permutation: $$$n, n - 1, \ldots, k, m + 1, m + 2, \ldots, k - 1, 1, 2, \ldots, m$$$. It is easy to see that $$$\sum_{i=1}^n f(i)$$$ cannot be greater for any other permutation, and $$$\sum_{i=1}^n g(i)$$$ cannot be less for any other permutation, so our answer is optimal.
Solution complexity: $$$O(n)$$$.
Solution (Python)
for _ in range(int(input()):
    n,m,k = map(int,input().split())
    print(*range(n,m,-1), *range(1,m))
--------------------------------------------------
Problem ID: 1992B
Editorial Content:
1992B - Angry Monk
Tutorial
Let's say we want to connect two casseroles with lengths $$$x$$$ and $$$y$$$. We can disassemble one of them into pieces of length $$$1$$$ and then attach them to the casserole of size $$$y$$$. In total, we will perform $$$2x - 1$$$ operations. Since we want to connect $$$k$$$ pieces, at least $$$k - 1$$$ of them will have to be disassembled and then attached to something. If we attach something to a piece, there is no point in disassembling it, because to disassemble it, we will need to remove these pieces as well. Therefore, we want to choose a piece to which we will attach all the others. It will be optimal to choose a piece with the maximum size and attach everything to it. Thus, the answer is $$$2 \cdot (n - mx) - k + 1$$$, where $$$mx$$$ $$$-$$$ the length of the maximum piece.
Solution complexity: $$$O(n)$$$.
Solution (C++)
#include <bits/stdc++.h>
using namespace std;
signed main() {
    int T;
    cin >> T;
    while (T--){
        int n, k;
        cin >> n >> k;
        vector<int> s(k);
        int m = -1;
        for (int i = 0; i < k; i++){
            cin >> s[i];
            m = max(m, s[i]);
        }
        cout << 2 * (n - m) - k + 1 << '\n';
    }
}
Solution (Python)
for _ in range(int(input())):
    n,k = map(int,input().split())
    mx = max(map(int, input().split()))
    print((n - mx) * 2 - (k - 1))
--------------------------------------------------
Problem ID: 1992A
Editorial Content:
1992A - Only Pluses
Tutorial
Let's prove why it's always better to add to the smallest number, let $$$a \le b \le c$$$, then compare the three expressions: $$$(a+1)\times b \times c$$$, $$$a \times (b+1) \times c$$$, and $$$a \times b \times (c+1)$$$. Remove the common part $$$a \times b \times c$$$, and we get: $$$b \times c$$$, $$$a \times c$$$, $$$a \times b$$$.
$$$b \times c \ge a \times c$$$, since $$$a \le b$$$, similarly, $$$b \times c \ge a \times b$$$, since $$$a \le c$$$. Therefore, we can simply find the minimum $$$5$$$ times and add one to it. And thus, obtain the answer.
Another, primitive approach is to simply iterate through what we will add to $$$a$$$, $$$b$$$, and $$$c$$$ with three loops.
Since we can only add $$$5$$$ times, the time complexity of the solution is $$$O(1)$$$.
Solution (Python)
for _ in range(int(input())):
    arr = sorted(list(map(int,input().split())))
    for i in range(5):
        arr[0]+=1
        arr.sort()
    print(arr[0] * arr[1] * arr[2])
--------------------------------------------------
Problem ID: 1991I
Editorial Content:

--------------------------------------------------
Problem ID: 1991H
Editorial Content:

--------------------------------------------------
Problem ID: 1991G
Editorial Content:

--------------------------------------------------
Problem ID: 1991F
Editorial Content:
1991F - Triangle Formation
Hint
The answer is always YES, if $$$R-L > C$$$ for some $$$C$$$
Video editorial
Daily Chat QnA
--------------------------------------------------
Problem ID: 1991E
Editorial Content:
1991E - Coloring Game
Hint 1
What should be alice strategy?
Hint 2
Alice should always chose color 1 and 2.
Hint 3
When can Bob color all the vertices using 2 colors?
Hint 4
Bob can color all the vertices using just 2 colors if graph is
Bipartite graph
Hint 5
Play as Bob if graph is
Bipartite graph
and Alice otherwise.
Video editorial
--------------------------------------------------
Problem ID: 1991D
Editorial Content:
1991D - Prime XOR Coloring
Hint 1
The answer is always <= 4.
Hint 2
If $$$u$$$ and $$$v$$$ both have same remainder when divided by 4, then $$$u \oplus v$$$ is a multiple of $$$4$$$.
Video editorial
Bonus: How to write checker for D?
XOR Convolution
--------------------------------------------------
Problem ID: 1991C
Editorial Content:
1991C - Absolute Zero
Hint
Can you decrease maximum by half in one operation?
Video editorial
--------------------------------------------------
Problem ID: 1991B
Editorial Content:
1991B - AND Reconstruction
Idea
Find minimum possible value of each $$$A_i$$$, then check if it gives you $$$B$$$
Video editorial
--------------------------------------------------
Problem ID: 1991A
Editorial Content:
1991A - Maximize the Last Element
Video editorial
--------------------------------------------------
Problem ID: 1990F
Editorial Content:

--------------------------------------------------
Problem ID: 1990E2
Editorial Content:

--------------------------------------------------
Problem ID: 1990E1
Editorial Content:

--------------------------------------------------
Problem ID: 1990D
Editorial Content:

--------------------------------------------------
Problem ID: 1990C
Editorial Content:

--------------------------------------------------
Problem ID: 1990B
Editorial Content:

--------------------------------------------------
Problem ID: 1990A
Editorial Content:

--------------------------------------------------
Problem ID: 1989F
Editorial Content:
1989F — Simultaneous Coloring
--------------------------------------------------
Problem ID: 1989E
Editorial Content:
1989E — Distance to Different
--------------------------------------------------
Problem ID: 1989D
Editorial Content:
1989D — Smithing Skill
--------------------------------------------------
Problem ID: 1989C
Editorial Content:
1989C — Two Movies
--------------------------------------------------
Problem ID: 1989B
Editorial Content:
1989B — Substring and Subsequence
--------------------------------------------------
Problem ID: 1989A
Editorial Content:
1989A — Catch the Coin
--------------------------------------------------
Problem ID: 1988F
Editorial Content:

--------------------------------------------------
Problem ID: 1988E
Editorial Content:
1988E — Range Minimum Sum
--------------------------------------------------
Problem ID: 1988D
Editorial Content:
1988D — The Omnipotent Monster Killer
--------------------------------------------------
Problem ID: 1988C
Editorial Content:
1988C — Increasing Sequence with Fixed OR
--------------------------------------------------
Problem ID: 1988B
Editorial Content:
1988B — Make Majority
--------------------------------------------------
Problem ID: 1988A
Editorial Content:
1988A — Split the Multiset
--------------------------------------------------
Problem ID: 1987H
Editorial Content:

--------------------------------------------------
Problem ID: 1987G2
Editorial Content:

--------------------------------------------------
Problem ID: 1987G1
Editorial Content:

--------------------------------------------------
Problem ID: 1987F2
Editorial Content:
1987F2 — Interesting Problem (Hard Version)
--------------------------------------------------
Problem ID: 1987F1
Editorial Content:

--------------------------------------------------
Problem ID: 1987E
Editorial Content:
1987E — Wonderful Tree!
--------------------------------------------------
Problem ID: 1987D
Editorial Content:
1987D — World is Mine
--------------------------------------------------
Problem ID: 1987C
Editorial Content:
1987C — Basil's Garden
--------------------------------------------------
Problem ID: 1987B
Editorial Content:
1987B — K-Sort
--------------------------------------------------
Problem ID: 1987A
Editorial Content:
1987A — Upload More RAM
--------------------------------------------------
Problem ID: 1986G2
Editorial Content:

--------------------------------------------------
Problem ID: 1986G1
Editorial Content:

--------------------------------------------------
Problem ID: 1986F
Editorial Content:
1986F — Non-academic Problem
--------------------------------------------------
Problem ID: 1986E
Editorial Content:
1986E — Beautiful Array
--------------------------------------------------
Problem ID: 1986D
Editorial Content:
1986D — Mathematical Problem
--------------------------------------------------
Problem ID: 1986C
Editorial Content:
1986C — Update Queries
--------------------------------------------------
Problem ID: 1986B
Editorial Content:
1986B — Matrix Stabilization
--------------------------------------------------
Problem ID: 1986A
Editorial Content:
1986A — X Axis
--------------------------------------------------
Problem ID: 1985H2
Editorial Content:
1985H2 - Maximize the Largest Component (Hard Version)
Solution
For each row $$$r$$$ and column $$$c$$$, we need to find the size of the component formed by filling both row $$$r$$$ and column $$$c$$$ (i.e. the size of the component
containing
row $$$r$$$ and column $$$c$$$ if we set all cells in both row $$$r$$$ and column $$$c$$$ to be $$$\texttt{#}$$$).
Extending the reasoning in H1, for some row $$$r$$$ and column $$$c$$$, consider the sum of:
The number of $$$\texttt{.}$$$ in row $$$r$$$ or column $$$c$$$ since these cells will be set to $$$\texttt{#}$$$. Let $$$F_{r,c}$$$ denote this value for some row $$$r$$$ and column $$$c$$$.
The sum of sizes of components containing a cell in either row $$$r-1$$$, $$$r$$$, or $$$r+1$$$ (i.e. components that are touching row $$$r$$$). This is since these components will be part of the component containing row $$$r$$$ and column $$$c$$$. Let $$$R_r$$$ denote this value for some row $$$r$$$.
The sum of sizes of components containing a cell in either column $$$c-1$$$, $$$c$$$, or $$$c+1$$$ (i.e. components that are touching column $$$c$$$). This is since these components will be part of the component containing row $$$r$$$ and column $$$c$$$. Let $$$C_c$$$ denote this value for some column $$$c$$$.
However, components that contain a cell in either row $$$r-1$$$, $$$r$$$, or $$$r+1$$$ as well as in either column $$$c-1$$$, $$$c$$$, or $$$c+1$$$ will be
overcounted
(since it will be counted in both terms $$$2$$$ and $$$3$$$) (you can think of it as components touching both row $$$r$$$ and column $$$c$$$). Thus, we need to subtract the sum of sizes of components that contain a cell in either row $$$r-1$$$, $$$r$$$, or $$$r+1$$$ as well as in either column $$$c-1$$$, $$$c$$$, or $$$c+1$$$. Let $$$B_{r,c}$$$ denote this for some row $$$r$$$ and column $$$c$$$.
Then the size of the component formed by filling both row $$$r$$$ and column $$$c$$$ will be $$$F_{r,c}+R_r+C_c-B_{r,c}$$$ and we want to find the maximum value of this.
Let's try to calculate these values efficiently. Consider some component.
Let $$$s$$$ be its size.
Let $$$r_{min}$$$ and $$$r_{max}$$$ denote the minimum and maximum row of a cell in the component. This means that the component contains cells with rows $$$r_{min},r_{min+1},...,r_{max}$$$.
Let $$$c_{min}$$$ and $$$c_{max}$$$ denote the minimum and maximum column of a cell in the component. This means that the component contains cells with columns $$$c_{min},c_{min+1},...,c_{max}$$$.
All these values can be found with a dfs. We then do the following updates:
Add $$$s$$$ to $$$R_{r_{min}-1},R_{r_{min}},\ldots,R_{r_{max}+1}$$$. This can be done naively or with prefix sums.
Add $$$s$$$ to $$$C_{c_{min}-1},C_{c_{min}},\ldots,C_{c_{max}+1}$$$. This can be done naively or with prefix sums.
Add $$$s$$$ to the subrectangle of $$$B$$$ with top left at ($$$r_{min}-1,c_{min}-1$$$) and bottom right at ($$$r_{max}+1,c_{max}+1$$$). This can be done with 2D prefix sums. (Note that doing this naively will pass because of low constant factor and the fact that we could not cut this solution without cutting slow correct solutions.)
We do this for each component. Also, calculating $$$F_{r,c}$$$ can be done by looking at the number of $$$\texttt{.}$$$ in row $$$r$$$, column $$$c$$$, and checking whether we overcounted a $$$\texttt{.}$$$ at ($$$r,c$$$). In all, this solution runs in $$$\mathcal{O}(nm)$$$ time.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

int n, m, minR, maxR, minC, maxC, sz, ans; vector<int> R, C, freeR, freeC; 
vector<vector<int>> RC; vector<vector<bool>> vis; vector<vector<char>> A;

void dfs(int i, int j){
    if (i <= 0 or i > n or j <= 0 or j > m or vis[i][j] or A[i][j] == '.')
        return;
    
    vis[i][j] = true;

    sz++;
    minR = min(minR, i);
    maxR = max(maxR, i);
    minC = min(minC, j);
    maxC = max(maxC, j);

    dfs(i - 1, j);
    dfs(i + 1, j);
    dfs(i, j - 1);
    dfs(i, j + 1);
}

void solve(){
    cin >> n >> m;

    R.assign(n + 5, 0);
    C.assign(m + 5, 0);
    freeR.assign(n + 5, 0);
    freeC.assign(m + 5, 0);
    RC.assign(n + 5, vector<int>(m + 5, 0));
    vis.assign(n + 5, vector<bool>(m + 5, false));
    A.assign(n + 5, vector<char>(m + 5, ' '));

    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            cin >> A[i][j];

            if (A[i][j] == '.'){
                freeR[i]++;
                freeC[j]++;
            }
        }
    }
    
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            if (vis[i][j] or A[i][j] == '.')
                continue;

            // Reset
            sz = 0;
            minR = 1e9;
            maxR = -1e9;
            minC = 1e9;
            maxC = -1e9;

            dfs(i, j);

            // Expand by 1 since adjacent cells also connect
            minR = max(minR - 1, 1);
            maxR = min(maxR + 1, n);
            minC = max(minC - 1, 1);
            maxC = min(maxC + 1, m);
            
            // Update prefix sums
            R[minR] += sz;
            R[maxR + 1] -= sz;

            C[minC] += sz;
            C[maxC + 1] -= sz;

            RC[minR][minC] += sz;
            RC[maxR + 1][minC] -= sz;
            RC[minR][maxC + 1] -= sz;
            RC[maxR + 1][maxC + 1] += sz;
        }
    }

    for (int i = 1; i <= n; i++)
        R[i] += R[i - 1];

    for (int i = 1; i <= m; i++)
        C[i] += C[i - 1];

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            RC[i][j] += RC[i - 1][j] + RC[i][j - 1] - RC[i - 1][j - 1];
    
    ans = 0;

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            ans = max(ans, (R[i] + C[j] - RC[i][j]) + (freeR[i] + freeC[j] - (A[i][j] == '.')));
    
    cout << ans << "\n";
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0);
    int tc;
    cin >> tc;

    while (tc--)
        solve();
}
--------------------------------------------------
Problem ID: 1985H1
Editorial Content:
1985H1 - Maximize the Largest Component (Easy Version)
Solution
Let's first solve the problem if we can only select and fill
rows
. Columns can be handled in the exact same way.
For each row $$$r$$$, we need to find the size of the component formed by filling row $$$r$$$ (i.e. the size of the component
containing
row $$$r$$$ if we set all cells in row $$$r$$$ to be $$$\texttt{#}$$$).
The size of the component
containing
row $$$r$$$ if we set all cells in row $$$r$$$ to be $$$\texttt{#}$$$ will be the
sum
of:
The number of $$$\texttt{.}$$$ in row $$$r$$$ since these cells will be set to $$$\texttt{#}$$$. Let $$$F_r$$$ denote this value for some row $$$r$$$.
The sum of sizes of components containing a cell in either row $$$r-1$$$, $$$r$$$, or $$$r+1$$$ (i.e. components that are touching row $$$r$$$). This is since these components will be part of the component containing row $$$r$$$. Let $$$R_r$$$ denote this value for some row $$$r$$$.
The challenge is computing the second term quickly. For some component, let $$$s$$$ be the size of the component and let $$$r_{min}$$$ and $$$r_{max}$$$ denote the minimum and maximum row of a cell in the component. This means that the component will contain cells with rows $$$r_{min},r_{min+1},...,r_{max}$$$. Note that we can find these values with a dfs. Since the component will contribute $$$s$$$ to rows in $$$[r_{min}-1,r_{min},\ldots r_{max}+1]$$$, we add $$$s$$$ to $$$R_{r_{min}-1},R_{r_{min}},\ldots,R_{r_{max}+1}$$$. This can be done naively or with prefix sums.
We find the maximum $$$F_r+R_r$$$ and then handle columns in the same way. This solution runs in $$$\mathcal{O}(nm)$$$ time.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

int n, m, minR, maxR, minC, maxC, sz, ans; vector<int> R, C, freeR, freeC; 
vector<vector<bool>> vis; vector<vector<char>> A;

void dfs(int i, int j){
    if (i <= 0 or i > n or j <= 0 or j > m or vis[i][j] or A[i][j] == '.')
        return;
    
    vis[i][j] = true;

    sz++;
    minR = min(minR, i);
    maxR = max(maxR, i);
    minC = min(minC, j);
    maxC = max(maxC, j);

    dfs(i - 1, j);
    dfs(i + 1, j);
    dfs(i, j - 1);
    dfs(i, j + 1);
}

void solve(){
    cin >> n >> m;

    R.assign(n + 5, 0);
    C.assign(m + 5, 0);
    freeR.assign(n + 5, 0);
    freeC.assign(m + 5, 0);
    vis.assign(n + 5, vector<bool>(m + 5, false));
    A.assign(n + 5, vector<char>(m + 5, ' '));

    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            cin >> A[i][j];

            if (A[i][j] == '.'){
                freeR[i]++;
                freeC[j]++;
            }
        }
    }
    
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            if (vis[i][j] or A[i][j] == '.')
                continue;

            // Reset
            sz = 0;
            minR = 1e9;
            maxR = -1e9;
            minC = 1e9;
            maxC = -1e9;

            dfs(i, j);

            // Expand by 1 since adjacent cells also connect
            minR = max(minR - 1, 1);
            maxR = min(maxR + 1, n);
            minC = max(minC - 1, 1);
            maxC = min(maxC + 1, m);
            
            // Update prefix sums
            R[minR] += sz;
            R[maxR + 1] -= sz;

            C[minC] += sz;
            C[maxC + 1] -= sz;
        }
    }

    ans = 0;

    for (int i = 1; i <= n; i++){
        R[i] += R[i - 1];
        ans = max(ans, freeR[i] + R[i]);
    }
    for (int i = 1; i <= m; i++){
        C[i] += C[i - 1];
        ans = max(ans, freeC[i] + C[i]);
    }

    cout << ans << "\n";
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0);
    int tc;
    cin >> tc;

    while (tc--)
        solve();
}
--------------------------------------------------
Problem ID: 1985G
Editorial Content:
1985G - D-Function
Solution
To satisfy $$$D(k \cdot n) = k \cdot D(n)$$$, each digit $$$d$$$ in $$$n$$$ must become $$$k \cdot d$$$ after multiplying $$$n$$$ by $$$k$$$. In other words, none of $$$n$$$'s digits can carry over to the next digit upon multiplication. From this, we can deduce that each digit in $$$n$$$ must be less than or equal to $$$\lfloor \frac{9}{k} \rfloor$$$. Only thing left is to count all such numbers in the range of $$$10^l$$$ inclusive and $$$10^r$$$ exclusive.
Every number below $$${10}^r$$$ has $$$r$$$ or less digits. For numbers with less than $$$r$$$ digits, let's pad the beginning with zeroes until it becomes a $$$r$$$ digit number (for example, if $$$r = 5$$$, then $$$69$$$ becomes $$$00069$$$). This allows us to consider numbers with less than $$$r$$$ digits the same way as numbers with exactly $$$r$$$ digits. For each digit, we have $$$\lfloor \frac{9}{k} \rfloor + 1$$$ choices (including zero), and there are $$$r$$$ digits, so the total number of numbers that satisfies the constraint below $$${10}^r$$$ is $$$(\lfloor \frac{9}{k} \rfloor + 1)^r$$$.
To get the count of numbers in range, it suffices to subtract all valid numbers less than $$$10^l$$$. Therefore, the answer is $$$(\lfloor \frac{9}{k} \rfloor + 1)^r - (\lfloor \frac{9}{k} \rfloor + 1)^l$$$. To exponentiate fast, we can use
modular exponentiation
.
Code (Python)
MOD = int(1e9+7)
t = int(input())
for _ in range(t):
    l, r, k = map(int, input().split())
    print((pow(9 // k + 1, r, MOD) - pow(9 // k + 1, l, MOD) + MOD) % MOD)
--------------------------------------------------
Problem ID: 1985F
Editorial Content:
1985F - Final Boss
About Hacks
Unfortunately, there was a lot of hacks on this problem, and we're sorry for it. Since our intended solution is not binary search, we didn't really take overflow using binary search seriously. I (
cry
) prepared this problem and I only took into account about overflow with big cooldown, but I forgot overflow can happen on attacks as well. I apologize and we will do better next time!
Solution
Since the sum of $$$h$$$ is bounded by $$$2 \cdot 10^5$$$, and each attack deals at least $$$1$$$ damage. If we assume every turn we can make at least one attack, the sum of turns to kill the boss in every test case is bounded by $$$2 \cdot 10^5$$$. This means that we can afford to simulate each turn where we make at least one attack.
But what if we cannot make an attack on this turn? Since the cooldown for each attack can be big, we cannot increment turns one by one. We must jump to the next turn we can make an attack. This can be done by retrieving the first element of a sorted set, where the set stores pairs {$$$t$$$, $$$i$$$} which means {next available turn you can use this attack, index of this attack} for all $$$i$$$. Here, we can set the current turn to $$$t$$$ and use all attacks in the set with first element in the pair equal to $$$t$$$. Remember to insert the pair to {$$$c_i + t$$$, $$$i$$$} back into the set after processing the attacks.
The time complexity is $$$\mathcal{O}(h \log n)$$$.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
	int t; cin >> t;
	while(t--){
		int h, n; cin >> h >> n;
		vector<int> a(n), c(n);
		for(int& i: a) cin >> i;
		for(int& i: c) cin >> i;
		set<pair<long long, int>> S;
		for(int i = 0; i < n; i++){
			S.insert({1, i});
		}
		long long last_turn = 1;
		while(h > 0){
			auto [turn, i] = *S.begin();
			S.erase(S.begin());
			last_turn = turn;
			h -= a[i];
			S.insert({turn + c[i], i});
		}
		cout << last_turn << "\n";
	}
}

// comment "tomato" if you see this comment
Bonus
Try to solve this if $$$1 \le h \le 10^9$$$.
Solution
We can do this by binary searching for the answer. For some time $$$t$$$, we know that we can perform an attack of cooldown $$$c$$$ exactly $$$\lfloor \frac{t - 1}{c} \rfloor + 1$$$ times. The total damage we will do in time $$$t$$$ will be:
$$$ \displaystyle \sum_{i=1}^{n}{a_i\left( \lfloor\frac{t - 1}{c_i}\rfloor + 1 \right)} $$$
So we binary search for the first $$$t$$$ such that the total damage we do in time $$$t$$$ is greater than or equal to $$$h$$$. This runs in $$$\mathcal{O(n \log {(h \cdot \max c_i)})}$$$. Be careful of long long overflow!
Code (C++)
#include <bits/stdc++.h>
using namespace std;

#define ll long long

void solve(){
    ll h, n;
    cin >> h >> n;

    vector<ll> A(n), C(n);

    for (ll &i : A)
        cin >> i;
    for (ll &i : C)
        cin >> i;
    
    auto chk = [&](ll t){
        ll dmg = 0;
        for (int i = 0; i < n and dmg < h; i++){
            ll cnt = (t - 1) / C[i] + 1;

            if (cnt >= h)
                return true;

            dmg += cnt * A[i];
        }
        return dmg >= h;
    };

    ll L = 1, H = 1e12;

    while (L < H){
        ll M = (L + H) / 2;
        chk(M) ? H = M : L = M + 1;
    }
    cout << L << "\n";
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    int tc;
    cin >> tc;

    while (tc--)
        solve();
}
Solution
We can do this by binary searching for the answer. For some time $$$t$$$, we know that we can perform an attack of cooldown $$$c$$$ exactly $$$\lfloor \frac{t - 1}{c} \rfloor + 1$$$ times. The total damage we will do in time $$$t$$$ will be:
$$$ \displaystyle \sum_{i=1}^{n}{a_i\left( \lfloor\frac{t - 1}{c_i}\rfloor + 1 \right)} $$$
So we binary search for the first $$$t$$$ such that the total damage we do in time $$$t$$$ is greater than or equal to $$$h$$$. This runs in $$$\mathcal{O(n \log {(h \cdot \max c_i)})}$$$. Be careful of long long overflow!
Code (C++)
#include <bits/stdc++.h>
using namespace std;

#define ll long long

void solve(){
    ll h, n;
    cin >> h >> n;

    vector<ll> A(n), C(n);

    for (ll &i : A)
        cin >> i;
    for (ll &i : C)
        cin >> i;
    
    auto chk = [&](ll t){
        ll dmg = 0;
        for (int i = 0; i < n and dmg < h; i++){
            ll cnt = (t - 1) / C[i] + 1;

            if (cnt >= h)
                return true;

            dmg += cnt * A[i];
        }
        return dmg >= h;
    };

    ll L = 1, H = 1e12;

    while (L < H){
        ll M = (L + H) / 2;
        chk(M) ? H = M : L = M + 1;
    }
    cout << L << "\n";
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    int tc;
    cin >> tc;

    while (tc--)
        solve();
}
--------------------------------------------------
Problem ID: 1985E
Editorial Content:
1985E - Secret Box
Solution
Since the side lengths of $$$S$$$ has to multiply to $$$k$$$, all three side lengths of $$$S$$$ has to be divisors of $$$k$$$. Let's denote the side lengths of $$$S$$$ along the $$$x$$$, $$$y$$$, and $$$z$$$ axes as $$$a$$$, $$$b$$$, and $$$c$$$ respectively. For $$$S$$$ to fit in $$$B$$$ , $$$a \leq x$$$, $$$b \leq y$$$, and $$$c \leq z$$$ must hold. Because of the low constraints, we can afford to loop through all possible values of $$$a$$$ and $$$b$$$, and deduce that $$$c=\frac{k}{a \cdot b}$$$ (make sure $$$c \leq z$$$ and $$$c$$$ is an integer). To get the amount of ways we can place $$$S$$$, we can just multiply the amount of shifting space along each axes, and that just comes down to $$$(x−a+1) \cdot (y−b+1) \cdot (z−c+1)$$$. The answer is the maximum among all possible values of $$$a$$$, $$$b$$$, and $$$c$$$ .
The time complexity is $$$\mathcal{O}(n^2)$$$ where $$$n$$$ is at most $$$2000$$$.
Code (C++)
#include <iostream>
using namespace std;
using ll = long long;

int main(){
	int t; cin >> t;
	while(t--){
		ll x, y, z, k; cin >> x >> y >> z >> k;
		ll ans = 0;
		for(int a = 1; a <= x; a++){
			for(int b = 1; b <= y; b++){
				if(k % (a * b)) continue;
				ll c = k / (a * b);
				if(c > z) continue;
				ll ways = (ll)(x - a + 1) * (y - b + 1) * (z - c + 1);
				ans = max(ans, ways);
			}
		}
		cout << ans << "\n";
	}
}
--------------------------------------------------
Problem ID: 1985D
Editorial Content:
1985D - Manhattan Circle
Solution
Note that the manhattan circle is always in a diamond shape, symmetric from the center. Let's take notice of some special characteristics that can help us. One way is to find the top and bottom points of the circle. Note that these points will have columns at the center of the circle, so here we can acquire the value of $$$k$$$. To find $$$h$$$, since the circle is symmetric, it is just the middle of the rows of the top and bottom points.
Note that we never needed to find the value of $$$r$$$.
Code (C++)
#include <bits/stdc++.h>
using namespace std;
const int INF = 1e9;

int main(){
	int t; cin >> t;
	while(t--){
		int n, m; cin >> n >> m;
		vector<vector<char>> g(n, vector<char>(m));
		for(int i = 0; i < n; i++){
			for(int j = 0; j < m; j++){
				cin >> g[i][j];
			}
		}
		pair<int, int> top = {INF, INF}, bottom = {-INF, -INF};
		for(int i = 0; i < n; i++){
			for(int j = 0; j < m; j++){
				if(g[i][j] == '#'){
					top = min(top, {i, j});
					bottom = max(bottom, {i, j});
				}
			}
		}
		assert(top.second == bottom.second);
		cout << (top.first + bottom.first) / 2 + 1 << " " << top.second + 1 << endl;
	}
}
--------------------------------------------------
Problem ID: 1985C
Editorial Content:
1985C - Good Prefixes
Solution
The only element that can be the sum of all other elements is the maximum element, since all elements are positive. Therefore, for each prefix $$$i$$$ from $$$1$$$ to $$$n$$$, check if $$$sum(a_1, a_2, ..., a_i) - max(a_1, a_2, ..., a_i) = max(a_1, a_2, ..., a_i)$$$. The sum and max of prefixes can be tracked with variables outside the loop.
Code (C++)
#include <iostream>
using namespace std;

int main(){
	int t; cin >> t;
	while(t--){
		int n; cin >> n;
		int a[n];
		for(int i = 0; i < n; i++)
			cin >> a[i];
		long long sum = 0;
		int mx = 0, ans = 0;;
		for(int i = 0; i < n; i++){
			sum += a[i];
			mx = max(mx, a[i]);
			if(sum - mx == mx) 
				ans++;
		}
		cout << ans << endl;
	}
}
--------------------------------------------------
Problem ID: 1985B
Editorial Content:
1985B - Maximum Multiple Sum
Solution
To maximize the number of multiples of $$$x$$$ less than $$$n$$$, it optimal to choose a small $$$x$$$, in this case, $$$2$$$. The only exception is $$$n = 3$$$, where it is optimal to choose $$$3$$$ instead, since both $$$2$$$ and $$$3$$$ have only one multiple less than $$$3$$$.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
	int t; cin >> t;
	while(t--){
		int n; cin >> n;
		cout << (n == 3 ? 3 : 2) << endl;
 	}
}
--------------------------------------------------
Problem ID: 1985A
Editorial Content:
1985A - Creating Words
Solution
To swap the first character of the strings, you can use the built-in method std::swap in C++, or for each string, separate the first character from the rest of the string and concatenate it with the other string.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
	int t; cin >> t;
	while(t--){
		string a, b; cin >> a >> b;
		swap(a[0], b[0]);
		cout << a << " " << b << endl;
	}
}
--------------------------------------------------
Problem ID: 1984H
Editorial Content:
1984H - Tower Capturing
Hint 1
Are there any useless points?
Hint 2
Draw all triangles that contain all points inside their circumcircle. What do you notice?
Solution
Claim.
We can't ever pick a tower inside the convex hull.
Proof.
A circle can only contain all the points if the points on the circle are on the convex hull; otherwise, the circle will necessarily split the convex hull into two parts, one of which is outside.
It follows that if our initial two towers aren't on the convex hull, the answer is $$$0$$$. Also, we can safely ignore all points in the convex hull, since we'll capture them anyway, as the convex hull is the union of all triangles whose vertices are vertices of the convex hull. From now on we'll only consider points on the convex hull.
Now comes the key claim of the problem.
Claim.
Call a triangle
covering
if its circumcircle contains all the points. Draw all covering triangles. We claim that these triangles form a triangulation of the convex hull.
Proof.
Recall that a triangulation is a set of triangles with pairwise non-intersecting interiors whose union is the polygon. There are two parts to the proof:
the triangles are pairwise non-intersecting.
their union is the polygon.
Let's prove them separately.
First we'll prove point (1) directly.
Consider two circles through points $$$ABC$$$ and $$$DEF$$$. Of course, the convex hull needs to lie in the intersection of the two circles. In particular, the circle through $$$ABC$$$ must contain the points $$$DEF$$$, while the circle through $$$DEF$$$ must contain the points $$$ABC$$$. It follows that the two circumcircles (say, $$$\Omega$$$ and $$$\Psi$$$ respectively) have the following property:
the points $$$A$$$, $$$B$$$, $$$C$$$ lie on an arc of $$$\Omega$$$ inside $$$\Psi$$$, and
the points $$$D$$$, $$$E$$$, $$$F$$$ lie on an arc of $$$\Psi$$$ inside $$$\Omega$$$.
The claim follows. Formally, we can define $$$U$$$ and $$$V$$$ as the intersection points of $$$\Omega$$$ and $$$\Psi$$$. Then if we walk along the digon $$$UV$$$ (whose edges are arcs of $$$\Omega$$$ and $$$\Psi$$$), we will pass through $$$A$$$, $$$B$$$, $$$C$$$ along one of the arcs, and $$$D$$$, $$$E$$$, $$$F$$$ on the other. This means that there is some closed convex loop passing through the points $$$A$$$, $$$B$$$, $$$C$$$ before $$$D$$$, $$$E$$$, $$$F$$$, implying those two triangles don't intersect. The proof remains the same even if some of $$$A$$$, $$$B$$$, $$$C$$$, $$$D$$$, $$$E$$$, $$$F$$$ overlap.
Now we'll move on to the proof of (2). Consider any covering triangle $$$ABC$$$. WLOG suppose $$$AB$$$ is not an edge of the convex hull. Consider the points in the halfplane of $$$AB$$$ not containing $$$C$$$, and let $$$C'$$$ be the point among these such that $$$\angle AC'B$$$ is minimized. Then it follows that $$$ABC'$$$ is also covering. It's easy to see why this works and why $$$C'$$$ is unique by the inscribed angle theorem.
As a result, given any covering triangle, we can recursively triangulate the regions it cuts off by a chord. Thus, inductively, the whole polygon will be triangulated. We are done with the proof.
Note that this implies our original three towers in the problem must form a covering triangle, since we create a covering triangle after every operation; thus, at the end of these operations, all but possibly one of these triangles is covering (the "possibly one" is the initial triangle). But such a covering triangulation exists and is unique, as shown, so our initial triangle in fact must be covering.
Now on to the actual operations present in the problem. Using them, we can "construct" the triangulation one step at a time using operations like the one mentioned. Of course, the triangulation is unique, so the only change we can do is the order in which we construct the triangles.
Consider the dual tree of the triangulation (that is, make a vertex for each triangle and an edge between those vertices corresponding to two triangles that share a diagonal of the convex hull). In an operation, we attach a leaf to any vertex, and in the end we end up with the final dual tree. Note that we can start growing the tree at either triangle adjacent to our original diagonal; that is, if our original points are $$$A$$$ and $$$B$$$, then we need to consider rooting our tree at either $$$T_1$$$ or $$$T_2$$$, where those are the two triangles that contain the edge $$$AB$$$ (note that $$$T_2$$$ may not exist).
Let's reverse time. Then given the final tree (rooted at either $$$T_1$$$ or $$$T_2$$$), in an operation we prune a leaf (a leaf here is a vertex with no children). How many ways can we prune all the leaves?
This is a standard dynamic programming problem, since at each step we need to prune all of our children before we prune ourselves. In particular, if the sizes of our childrens' subtrees are $$$s_1, \dots, s_k$$$, then our answer is $$$\binom{s_1 + \dots + s_k}{s_1, \dots, s_k} \cdot \prod_{i=1}^{k} \mathrm{ans}(\mathrm{child}_i)$$$. This DP runs in $$$\mathcal{O}(n)$$$ time, so it is not a problem to compute.
We can easily compute the triangulation in $$$\mathcal{O}(n^2)$$$ time as follows: given an edge $$$PQ$$$, we need to find the point $$$R$$$ in a halfplane such that $$$(PQR)$$$ covers all points, and as mentioned before, by the inscribed angle theorem this is precisely the point $$$R$$$ such that $$$PQR'$$$ is minimized. So you can find it with an $$$\mathcal{O}(n)$$$ sweep and add the new edges to our triangulation.
Therefore the solution runs in $$$\mathcal{O}(n^2)$$$, but the validator takes $$$\mathcal{O}(n^3)$$$ to check. We accepted slower solutions in $$$\mathcal{O}(n^3)$$$ as well, and even $$$\mathcal{O}(n^4)$$$ with a decent constant factor (which are relatively hard to cut).
A note about implementation: I'm not very good at it, so my code below is a bit messy. Also, to keep the computations in integers, I needed to use big integers at exactly one point, but it's not so bad: you only need to implement big integer multiplication and comparison, which I shamelessly stole from
jeroenodb
. You may not need to use it, and can pass using floating-point numbers.
Code (C++)
#include <bits/stdc++.h>

using namespace std;

const int MAX = 200007;
const int MOD = 998244353;

struct bignum {
    static constexpr long long B = 1LL<<30;
    static constexpr int N = 6;
    array<long long, N> b = {};
    bignum() {}
    bignum(long long a) {
        b[2] = (a / B) / B;
        b[1] = (a / B) % B;
        b[0] = a % B;
    }
    bignum operator*(const bignum& o) {
        bignum res;
        for (int i = 0; i < N; i++) {
		    for (int j = 0; j + i < N; j++) {
		        res.b[i + j] += b[i] * o.b[j];
		        for (int k = i + j; k + 1 < N; k++) {
		            auto tmp = res.b[k] / B;
		            res.b[k + 1] += tmp;
		            res.b[k] -= tmp * B;
		        }
		    }
		}
        return res;
    }
    bool operator<=(const bignum& o) const {
        if (b == o.b) return true;
        return lexicographical_compare(b.rbegin(),b.rend(),o.b.rbegin(),o.b.rend());
    }
};

template <class T> int sgn(T x) { return (x > 0) - (x < 0); }
template<class T>
struct Point {
	typedef Point P;
	T x, y;
	explicit Point(T x=0, T y=0) : x(x), y(y) {}
	bool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }
	bool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }
	P operator+(P p) const { return P(x+p.x, y+p.y); }
	P operator-(P p) const { return P(x-p.x, y-p.y); }
	P operator*(T d) const { return P(x*d, y*d); }
	P operator/(T d) const { return P(x/d, y/d); }
	T dot(P p) const { return x*p.x + y*p.y; }
	T cross(P p) const { return x*p.y - y*p.x; }
	T cross(P a, P b) const { return (a-*this).cross(b-*this); }
	T dist2() const { return x*x + y*y; }
	double dist() const { return sqrt((double)dist2()); }
	// angle to x-axis in interval [-pi, pi]
	double angle() const { return atan2(y, x); }
	P unit() const { return *this/dist(); } // makes dist()=1
	P perp() const { return P(-y, x); } // rotates +90 degrees
	P normal() const { return perp().unit(); }
	// returns point rotated 'a' radians ccw around the origin
	P rotate(double a) const {
		return P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }
	friend ostream& operator<<(ostream& os, P p) {
		return os << "(" << p.x << "," << p.y << ")"; }
	friend istream& operator>>(istream& is, P& p) {
		return is >> p.x >> p.y; }
};

typedef Point<long long> P;
vector<P> convexHull(vector<P> pts) {
	if (pts.size() <= 1) return pts;
	sort(pts.begin(), pts.end());
	vector<P> h(pts.size()+1);
	int s = 0, t = 0;
	for (int it = 2; it--; s = --t, reverse(pts.begin(), pts.end()))
		for (P p : pts) {
			while (t >= s + 2 && h[t-2].cross(h[t-1], p) <= 0) t--;
			h[t++] = p;
		}
	return {h.begin(), h.begin() + t - (t == 2 && h[0] == h[1])};
}

int n, t;
long long inv[MAX], fact[MAX], invfact[MAX];
vector<P> v;

void orient(P &a, P &b, P &c) {
	// move points a, b, c to be in counterclockwise order
	long long val = (b - a).cross(c - a);
	assert(val != 0);
	if (val < 0) {swap(a, c);} 
}

pair<long long, long long> angleComp(P a, P b, P c) {
	// get a (scaled) value of f(cos(angle ABC))
	P ab = a - b, cb = c - b;
	long long dt = ab.dot(cb);
	dt *= dt;
	int sgn = (ab.dist2() + cb.dist2() >= (a - c).dist2() ? 1 : -1);
	return make_pair(sgn * dt, ab.dist2() * cb.dist2());
}

bool inCircle(P a, P b, P c, P d) {
	// is D in (or on) (ABC)?
	orient(a, b, c);
	P ad = a - d, bd = b - d, cd = c - d;
	return (
		ad.dist2() * (bd.x * cd.y - bd.y * cd.x) -
		bd.dist2() * (ad.x * cd.y - ad.y * cd.x) +
		cd.dist2() * (ad.x * bd.y - ad.y * bd.x)
	) >= 0;
}

pair<bool, int> check(int l, int r) {
	int start = l, finish = r;
	if (finish < start) {finish += n;}
	pair<long long, long long> best = make_pair(-MOD, 1);
	int w = -1;
	for (int i = start + 1; i < finish; i++) {
		pair<long long, long long> val = angleComp(v[l], v[i % n], v[r]);
		bignum v1 = bignum(val.first) * bignum(best.second);
		bignum v2 = bignum(val.second) * bignum(best.first);
		if (!(v1 <= v2)) {
			best = val;
			w = i % n;
		}
	}
	if (w == -1) {
		// cout << v[l] << ' ' << v[r] << " empty?\n";
		return make_pair(true, -1);
	}
	// cout << v[l] << ' ' << v[r] << " connects to " << v[w] << "?\n";
	for (P Q : v) {
		if (!inCircle(v[l], v[w], v[r], Q)) {return make_pair(false, -1);}
	}
	return make_pair(true, w);
}

void reset(int n) {
	v.clear();
	// for (int i = 0; i < n + 5; i++) {
		// g[i].clear();
		// child[i].clear();
	// }
	t = 1;
}

void solve() {
	cin >> n;
	reset(n);
	vector<P> pts(n);
	for (int i = 0; i < n; i++) {
		cin >> pts[i];
	}
	vector<P> us{pts[0], pts[1]};
	vector<int> us_vals;
	v = convexHull(pts);
	n = v.size();
	for (auto P : us) {
		int i = 0; bool hit = false;
		for (auto Q : v) {
			if (P == Q) {us_vals.push_back(i); hit = true;}
			i++;
		}
		if (!hit) {cout << 0 << '\n'; return;}
	}
	if (v.size() <= 3) {cout << 1 << '\n'; return;}
	queue<pair<pair<int, int>, int>> q;
	vector<int> child[MAX];
	q.push(make_pair(make_pair(us_vals[0], us_vals[1]), -1));
	q.push(make_pair(make_pair(us_vals[1], us_vals[0]), -1));
	while (!q.empty()) {
		auto p = q.front();
		q.pop();
		pair<bool, int> resp = check(p.first.first, p.first.second);
		if (!resp.first) {cout << 0 << '\n'; return;}
		if (resp.second == -1) {continue;}
		q.push(make_pair(make_pair(p.first.first, resp.second), t));
		q.push(make_pair(make_pair(resp.second, p.first.second), t));
		if (p.second != -1) {
			child[p.second].push_back(t);
		}
		t++;
	}
	// for (int i = 1; i <= n - 2; i++) {
		// cout << i << ": ";
		// for (int j : child[i]) {cout << j << ' ';}
		// cout << '\n';
	// }
	bool edge_case = true; // both 1 and 2 are roots
	for (int j : child[1]) {
		if (j == 2) {edge_case = false;} // only 1 is root
	}
	
	vector<long long> dp(n + 7);
	vector<int> sz(n + 7);
	
	auto cnt = [&](auto self, int v) -> int {
		if (sz[v] != -1) {return sz[v];}
		int res = 1;
		if (!child[v].empty()) {
			for (int u : child[v]) {
				res += self(self, u);
			}
		}
		sz[v] = res;
		return res;
	};
	
	auto f = [&](auto self, int v) -> long long {
		if (dp[v] != -1LL) {return dp[v];}
		long long res = 1LL;
		if (!child[v].empty()) {
			res = (res * fact[cnt(cnt, v) - 1]) % MOD;
			for (int u : child[v]) {
				res = (res * self(self, u)) % MOD;
				res = (res * invfact[cnt(cnt, u)]) % MOD;
			}
		}
		dp[v] = res;
		return res;
	};

	if (edge_case) {child[1].push_back(2);}
	
	fill(dp.begin(), dp.end(), -1LL);
	fill(sz.begin(), sz.end(), -1);
	long long res = f(f, 1);
	
	if (edge_case) {
		child[1].erase(remove(child[1].begin(), child[1].end(), 2), child[1].end());
		child[2].push_back(1);
		fill(dp.begin(), dp.end(), -1LL);
		fill(sz.begin(), sz.end(), -1);
		res = (res + f(f, 2)) % MOD;
	}
	
	cout << res << '\n';
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	inv[0] = inv[1] = 1;
	for (int i = 2; i < MAX; i++) {
		inv[i] = MOD - (long long)(MOD / i) * inv[MOD % i] % MOD;
	}
	fact[0] = fact[1] = 1; invfact[0] = invfact[1] = 1;
	for (int i = 2; i < MAX; i++) {
		fact[i] = (fact[i - 1] * (long long)i) % MOD;
		invfact[i] = (invfact[i - 1] * inv[i]) % MOD;
	}
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1984G
Editorial Content:
1984G - Magic Trick II
Hint 1
Solve what the maximum $$$k$$$ will be for different types of arrays.
Hint 2
The maximum is always close to $$$n$$$.
Solution
There exists two trivial cases. If array is already sorted, $$$k = n$$$. If array is cyclic shift of sorted array, $$$k = n - 1$$$. Now, $$$k = n - 2$$$ and $$$k = n - 3$$$ is sufficient to sort any array.
Let's assume $$$n$$$ is odd first, and construct an answer in the general case with $$$k = n - 2$$$. Because $$$k$$$ is so large, our operations are limited in choices. If we represent the array as a cyclic array with a divider representing the end of the array, an operation can be seen as two choices:
Move the divider $$$2$$$ positions in any direction.
Swap the two numbers around the divider, then move the divider by $$$1$$$ position in any direction.
With this representation, the construction becomes quite easy. Because $$$n$$$ is odd, we can use the first type of operation to put the divider wherever we want. Then, using the second type of operation, if our divider is on the right side of a specific number, we can move it all the way to the right by swapping, then moving the divider right by $$$1$$$ position.
Because we are able to do this, we can bubble sort. For each number, position the divider in $$$O(n)$$$ moves, then move it to the very right in another $$$O(n)$$$ moves. There are $$$n$$$ numbers total, so this takes a total of around $$$2n^2$$$ operations, less if optimized.
What if $$$n$$$ is even? In this case $$$k = n - 2$$$ is not always guaranteed to work. The motivation for seeing this can come from the fact that you can't place the divider anywhere just by using type $$$1$$$ operations.
As a lower bound, we know that $$$k = n - 3$$$ will always work. We can use operations to move the largest number to the very end, then we basically have an array of length $$$n - 1$$$ with $$$k = n - 3$$$, which is the odd case we presented earlier.
So, when can we use $$$k = n - 2$$$ in the even case? Let's consider the number of inversions in the array at any given time. If $$$n$$$ is even, then $$$k = n - 2$$$ is also even, meaning that the parity of the number of inversions will never change with operations. Thus, since a sorted array will have no inversions, we cannot use $$$k = n - 2$$$ if the initial array had an odd number of inversions.
If we have an even number of inversions, we can sort in a similar manner. Except, now, if the inversion constraint prevents moving the divider to the immediate right of our current number with only type $$$1$$$ operations, we can use a few type $$$2$$$ operations to fix the position of the divider (many possible strategies for this, one possible way is shown in the implementation). Overall, this should also take around $$$2n^2$$$ operations total.
Code (C++)
#include <iostream>
#include <vector>
using namespace std;
 
#define pii pair<int, int>
 
bool sorted(vector<int> arr, int n) {
  for (int i = 1; i < n; ++i) if (arr[i] < arr[i - 1]) return false;
  return true;
}
 
bool cyclic(vector<int> arr, int n) {
  for (int i = 1; i < n; ++i) if (arr[i] % n != (arr[i - 1] + 1) % n) return false;
  return true;
}
 
void solve() {
  int n; cin >> n;
  vector<int> arr(n); for (int i = 0; i < n; ++i) cin >> arr[i];
  if (sorted(arr, n)) {
    cout << n << "\n0\n";
    return;
  }
  if (cyclic(arr, n)) {
    cout << n - 1 << '\n';
    int pos;
    for (pos = 0; pos < n; ++pos) if (arr[pos] == 1) break;
    cout << pos << '\n';
    for (int i = 0; i < pos; ++i) {
      cout << "2 1\n";
    }
    return;
  }
  vector<pii> ops;
  if (n % 2 == 0) {
    int inv = 0;
    for (int i = 0; i < n; ++i) for (int j = i + 1; j < n; ++j) if (arr[i] > arr[j]) ++inv;
    if (inv & 1) {
      int pos;
      for (pos = 0; pos < n; ++pos) if (arr[pos] == n) break;
      if (pos < 3) {
        for (int i = 0; i <= pos; ++i) ops.push_back({2, 1});
        vector<int> tmp = arr;
        for (int i = 0; i < n - 2; ++i) arr[i] = tmp[(i + pos + 1) % (n - 2)];
      }
      for (pos = 0; pos < n; ++pos) if (arr[pos] == n) break;
      for (int i = pos; i < n - 1; ++i) ops.push_back({3, 4});
      vector<int> tmp = arr;
      for (int i = 2; i < n; ++i) arr[i] = tmp[((i + pos - 3) % (n - 2)) + 2];
      --n;
    }
  }
  cout << n - 2 << '\n';
  int div = 0;
  for (int i = n; i > 0; --i) {
    int pos;
    for (pos = 0; pos < n; ++pos) if (arr[pos] == i) break;
    pos += 1;
    if (pos == i) continue;
    if (div % 2 != pos % 2) {
      if (n & 1) {
        while (div < n) {
          ops.push_back({3, 1});
          div += 2;
        }
        div %= n;
      } else {
        while (div != pos - 1) {
          if (div < pos - 1) {
            ops.push_back({3, 1});
            div += 2;
          } else {
            ops.push_back({1, 3});
            div -= 2;
          }
        }
        if (pos > 1) {
          ops.push_back({2, 3});
          swap(arr[(div + n - 1) % n], arr[div]);
          div = (div + n - 1) % n;
          --pos;
        }
        ops.push_back({3, 1});
        div += 2;
        ops.push_back({2, 3});
        swap(arr[(div + n - 1) % n], arr[div]);
        div = (div + n - 1) % n;
      }
    }
    while (div != pos) {
      if (div < pos) {
        ops.push_back({3, 1});
        div += 2;
      } else {
        ops.push_back({1, 3});
        div -= 2;
      }
    }
    for (int j = pos; j < i; ++j) {
      ops.push_back({2, 1});
      swap(arr[div - 1], arr[div]);
      ++div;
    }
  }
  if (div % 2 == 1) {
    while (div < n) {
      ops.push_back({3, 1});
      div += 2;
    }
    div %= n;
  }
  while (div > 0) {
    ops.push_back({1, 3});
    div -= 2;
  }
  cout << ops.size() << '\n';
  for (pii p : ops) {
    cout << p.first << ' ' << p.second << '\n';
  }
}
 
int main() {
  ios_base::sync_with_stdio(false); cin.tie(NULL);
  int t; cin >> t;
  for (int i = 0; i < t; ++i) solve();
  return 0;
}
--------------------------------------------------
Problem ID: 1984F
Editorial Content:
1984F - Reconstruction
Hint 1
Solve for no question marks in the string first.
Hint 2
Add a $$$0$$$ on both sides of $$$a$$$ and $$$b$$$, and add a $$$\texttt{P}$$$ before the start of the string and a $$$\texttt{S}$$$ after the string. Now you are guaranteed to have a $$$\texttt{PS}$$$ somewhere in the string. How does this help?
Answer
You know the sum of the array.
Answer
You know the sum of the array.
Hint 3
Look at adjacent elements in $$$b$$$, and its corresponding characters in the string, and see if you can determine anything about $$$a$$$.
Hint 4
Go back to the original problem, with question marks. We do not know the sum now, but how many possible ones can there be?
Solution
How to solve with no question marks?
To simplify things, let's extend all arrays both ways by 1 element. In array $$$a$$$ and $$$b$$$, we can keep both values at $$$0$$$, and in the string $$$s$$$, we can assign the left value to "$$$\texttt{P}$$$" and the right value to "$$$\texttt{S}$$$" (the other values will still be satisfied -- why?)
Now, somewhere within the string, we are guaranteed to see the combination "$$$\texttt{PS}$$$" because we now have a string that starts with "$$$\texttt{P}$$$" and ends with "$$$\texttt{S}$$$", therefore it must transition somewhere in between.
Notice, if we add the values in $$$b$$$ of the "$$$\texttt{PS}$$$", we can gather the sum of the array.
Now, solving becomes simpler. We can focus on adjacent elements in the array. Say we are currently examining indices $$$i$$$ and $$$i + 1$$$. There are four cases:
We are currently at a "$$$\texttt{PP}$$$". We then know $$$b_i + a_{i+1} = b_{i+1}$$$, so $$$a_{i+1}$$$ is now known.
We are currently at a "$$$\texttt{PS}$$$". Again, this must be the sum. All we have to do here is check that our sum is correct.
We are currently at an "$$$\texttt{SP}$$$". Here, we have $$$b_{i} + b_{i+1} - SUM = a_i + a_{i+1}$$$ (why?). Our left side is known, and the only requirement on the right side is that both $$$a_i$$$ and $$$a_{i+1}$$$ have to have a magnitude of at most $$$m$$$. Thus, to make their maximum magnitude as small as possible, we make them as close as possible to each other. If the left side is $$$x$$$, we assign $$$a_i = \text{floor}(x / 2)$$$, and $$$a_{i+1} = x - a_i$$$.
We are currently at an "$$$\texttt{SS}$$$". This is similar to the first case, as we know that $$$b_i = a_i + b_{i+1}$$$. Thus, $$$a[i]$$$ will be known.
If $$$a_i$$$ is always possible, then we know our answer exists.
Thus, this solves a version without question marks. For the version with question marks, we can only try to guess what the sum of the entire array is, since we don't know where "$$$\texttt{PS}$$$" might be for sure every time. There are only $$$n$$$ possibilities — the sum of every pair of adjacent numbers in $$$b$$$.
For every possibility, we can run a
dp[i][j]
where we are currently at index $$$i$$$ and the last character within "$$$\texttt{P}$$$" and "$$$\texttt{S}$$$" in string $$$s$$$ used was $$$j$$$. This dynamic programming will run in linear time because of constant-time transitions and linear amount of states. Note that this is only possible due to the independent nature of adjacent pairs as described earlier.
With this DP, we can calculate how many paths are possible, adding to our answer.
Time complexity $$$O(n^2)$$$
Code (C++)
#include <iostream>
#include <vector>
#include <cstring>
#include <assert.h>
#include <set>
using namespace std;
 
#define ll long long
 
const int INF = 998244353;
// const int BOUND = 1e9;
 
void solve() {
  int n; cin >> n;
  int BOUND; cin >> BOUND;
  string s; cin >> s;
  s = "P" + s + "S";
  vector<ll> b(n + 2);
  for (int i = 0; i < n; ++i) cin >> b[i + 1];
  ll ans = 0;
  set<ll> done;
  for (int i = 0; i < n + 1; ++i) {
    ll sum = b[i] + b[i + 1];
    if (done.count(sum)) continue;
    int dp[n + 2][2];
    for (int j = 0; j < n + 2; ++j) for (int k = 0; k < 2; ++k) dp[j][k] = -1;
    // ["P", "S"]
    dp[0][0] = 1;
    for (int j = 1; j < n + 2; ++j) {
      bool tr[2]; tr[0] = tr[1] = true;
      if (s[j] == 'P') tr[1] = false;
      else if (s[j] == 'S') tr[0] = false;
      if (abs(b[j] - b[j - 1]) <= BOUND) {
        for (int k = 0; k < 2; ++k)
          if (dp[j - 1][k] > -1 && tr[k]) dp[j][k] = dp[j - 1][k];
      }
      if (dp[j - 1][0] > -1 && tr[1] && sum == b[j] + b[j - 1]) {
        // "P" -> "S":
        if (dp[j][1] < 0) dp[j][1] = 0;
        dp[j][1] = (dp[j][1] + dp[j - 1][0]) % INF;
      }
      if (dp[j - 1][1] > -1 && tr[0]) {
        // "S" -> "P":
        ll add = b[j] + b[j - 1] - sum;
        ll large = max(abs(add / 2), abs(add - add / 2));
        if (large <= BOUND) {
          if (dp[j][0] < 0) dp[j][0] = 0;
          dp[j][0] = (dp[j][0] + dp[j - 1][1]) % INF;
        }
      }
    }
    if (dp[n + 1][1] < 0) continue;
    ans = (ans + dp[n + 1][1]) % INF;
    done.insert(sum);
  }
  cout << ans << '\n';
}
 
int main() {
  ios::sync_with_stdio(false); cin.tie(NULL);
  int t; cin >> t;
  for (int i = 0; i < t; ++i) solve();
  return 0;
}
--------------------------------------------------
Problem ID: 1984E
Editorial Content:
1984E - Shuffle
Solution
Excluding the root, the maximum number of leaves we have is the maximum independent set (MIS) of the rest of the tree. Why? First of all, after rooting tree $$$T_2$$$, no two adjacent nodes can both be leaves. This is because, no matter which one you choose to add to $$$T_2$$$ first, it must be the ancestor of the other one. Thus, the first chosen node will not be a leaf. Furthermore, any chosen MIS of nodes can all become leaves. This is because we can essentially choose to add all of the nodes not in the MIS first to the tree, leaving all of the remaining nodes to be childless nodes, making them all leaves.
To find the answer, we want to find the maximum MIS of all subtrees that are missing one leaf. The answer will be one greater than this maximum MIS due to the root of $$$T_2$$$ being also a leaf.
There are multiple dynamic programming approaches to compute this efficiently, including rerooting and performing dynamic programming on tree edges.
Time complexity: $$$O(n)$$$ or $$$O(n \log{n})$$$, depending on implementation.
Code (C++)
#include <iostream>
#include <vector>
#include <map>
using namespace std;
 
#define pii pair<int, int>
 
int n;
vector<vector<int>> adj;
vector<pii> edges;
map<pii, int> mp;
 
vector<vector<int>> dp;
vector<vector<int>> from;
vector<int> miss;
 
void dfs(int e) {
  if (dp[0][e] >= 0 || dp[1][e] >= 0) return;
  int p = edges[e].first, v = edges[e].second;
  dp[0][e] = 0, dp[1][e] = 1;
  if (miss[v] < 0) {
    for (int u : adj[v]) {
      if (u == p) continue;
      int ne = mp[{v, u}];
      dfs(ne);
      from[0][v] += max(dp[1][ne], dp[0][ne]);
      from[1][v] += dp[0][ne];
    }
    miss[v] = p;
  }
  if (miss[v] != p && miss[v] != n) {
    int ne = mp[{v, miss[v]}];
    dfs(ne);
    from[0][v] += max(dp[1][ne], dp[0][ne]);
    from[1][v] += dp[0][ne];
    miss[v] = n;
  }
  if (miss[v] == n) {
    int nne = mp[{v, p}];
    dp[0][e] += from[0][v] - max(dp[1][nne], dp[0][nne]);
    dp[1][e] += from[1][v] - dp[0][nne];
  } else if (miss[v] == p) {
    dp[0][e] += from[0][v];
    dp[1][e] += from[1][v];
  }
}
 
void solve() {
  cin >> n;
  adj.clear(), edges.clear();
  adj.resize(n), edges.resize(2 * n - 2);
  for (int i = 0; i < n - 1; ++i) {
    int a, b; cin >> a >> b; --a, --b;
    adj[a].push_back(b);
    adj[b].push_back(a);
    edges[2 * i] = {a, b};
    edges[2 * i + 1] = {b, a};
    mp[{a, b}] = 2 * i;
    mp[{b, a}] = 2 * i + 1;
  }
  from = vector<vector<int>>(2, vector<int>(n));
  miss = vector<int>(n, -1);
  dp = vector<vector<int>>(2, vector<int>(2 * n - 2, -1));
  for (int i = 0; i < 2 * n - 2; ++i) dfs(i);
  int ans = 0;
  for (int i = 0; i < n; ++i) {
    if (adj[i].size() != 1) continue;
    int e = mp[{i, adj[i][0]}];
    ans = max(ans, 1 + max(dp[0][e], dp[1][e]));
  }
  cout << ans << '\n';
}
 
int main() {
  ios_base::sync_with_stdio(false); cin.tie(NULL);
  int t; cin >> t;
  for (int i = 0; i < t; ++i) solve();
  return 0;
}
--------------------------------------------------
Problem ID: 1984D
Editorial Content:
1984D - ''a'' String Problem
Hint 1
What does $$$t$$$ have to include?
Solution
Special case: the string consists of only "$$$\texttt{a}$$$", then answer is $$$n - 1$$$.
Otherwise, $$$t$$$ has to contain a character that is not "$$$\texttt{a}$$$". Let's consider one approach of counting. Let's force all $$$t$$$ to start with the first non-a character, and see how many work.
To see if one of these strings $$$t$$$ will work, we can start with $$$i = 0$$$. As long as $$$i$$$ does not point to the end of the string, we can find the next non-a character in $$$s$$$, and then see if the next $$$|t|$$$ characters in $$$s$$$ matches $$$t$$$. The last check mentioned can be done through hashing or using the Z-function. If it doesn't, this value of $$$t$$$ doesn't work. Otherwise, we update $$$i$$$ to the new current position and continue checking.
Now, if we find a string $$$t$$$ that does work, we need to count its contribution to the answer. We can just add $$$1$$$, but obviously not all working $$$t$$$ will start with a non-a character. Instead, we can find the minimum unused "$$$\texttt{a}$$$"s before all of the substrings equal to $$$t$$$ (call this $$$m$$$), and the current $$$t$$$ will be able to extend out up to $$$m$$$ "$$$\texttt{a}$$$"s at the beginning of the string. Thus, the contribution is $$$m + 1$$$ to the answer.
How fast is this? Because we are checking at most one string $$$t$$$ of each length, and the check itself can be made to take $$$O(\frac{n}{|t|})$$$, we have a total time complexity of $$$O(n\log{n})$$$ due to harmonic sums.
Code (C++)
#include <iostream>
#include <vector>
#include <climits>
#include <set>
using namespace std;
 
#define ll long long
 
vector<int> z_function(string s) {
  int n = s.size();
  vector<int> z(n);
  int l = 0, r = 0;
  for(int i = 1; i < n; ++i) {
    if (i < r) z[i] = min(r - i, z[i - l]);
    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];
    if (i + z[i] > r) l = i, r = i + z[i];
  }
  return z;
}
 
void solve() {
  int n; // cin >> n;
  string s; cin >> s;
  n = s.length();
  vector<int> nona(n, n);
  for (int i = n - 1; i >= 0; --i) {
    if (s[i] != 'a') nona[i] = i;
    else if (i + 1 < n) nona[i] = nona[i + 1];
  }
  if (nona[0] == n) {
    cout << n - 1 << '\n';
    return;
  }
  string s2 = "";
  int i1 = nona[0];
  for (int i = i1; i < n; ++i) s2 += s[i];
  vector<int> z = z_function(s2);
  ll ans = 0;
  for (int len = 1; i1 + len <= n; ++len) {
    int cur = i1 + len;
    int mn = i1;
    bool works = true;
    while (cur < n) {
      if (nona[cur] == n) break;
      int bt = nona[cur] - cur;
      mn = min(mn, bt);
      cur += bt;
      if (z[cur - i1] < len) {
        works = false;
        break;
      }
      cur += len;
    }
    if (works) ans += mn + 1;
  }
  cout << ans << '\n';
}
 
int main() {
  int t; cin >> t;
  for (int i = 0; i < t; ++i) solve();
  return 0;
}
--------------------------------------------------
Problem ID: 1984C2
Editorial Content:
1984C2 - Magnitude (Hard Version)
Hint 1
How many times do we need to pick option $$$2$$$?
Hint 2
We only need to pick it once. How can we calculate the final value for every position we can pick?
Solution (Easy Version)
We only need to pick option $$$2$$$ once. Why? Assume we picked option $$$2$$$ more than once, and consider the last two times it was picked. Both of these must occur when $$$c + a_i$$$ is negative, otherwise there is no reason to pick option $$$2$$$ over option $$$1$$$. Thus, if we chose option $$$1$$$ the first of these times instead of option $$$2$$$, that would cause the value of $$$c$$$ before the second operation to decrease. Because it was negative, this increases the magnitude, and thus it was more optimal to choose option $$$1$$$ for the first operation.
Because we only need to use option $$$2$$$ once, we can brute force where we use that operation and compute the final value of $$$c$$$ with prefix sums.
Solution (Hard Version)
Read the solution to the easy version first.
Let's think a bit more. Where do we actually end up using option $$$2$$$? We only use option $$$2$$$ when our prefix sum up to this point is minimum in the whole array.
Now, focus on each individual "important" use of option $$$2$$$ (where it actually makes a difference from option $$$1$$$), Let's say it is done at index $$$i$$$. Let's consider indices before. Since the operation at index $$$i$$$ is the only important option $$$2$$$, any option $$$2$$$'s we use before must not have been different from option $$$1$$$ (meaning that the value of $$$c + a_j$$$ has to be non-negative). Thus, we have the choice of using option $$$2$$$ or option $$$1$$$ at any index $$$j < i$$$ where the prefix sum is non-negative. Let's say there exists $$$x$$$ unique values of $$$j$$$.
Now, let's consider indices after. Since index $$$i$$$ is at a minimum prefix sum, that guarantees that all indices after will never have a lower value of $$$c$$$ than what $$$c$$$ is after doing the operation at index $$$i$$$. Thus, since we use option 2 at index $$$i$$$, we can use any of the two options moving forward. Thus, any index $$$j > i$$$ has two choices on which option to pick. Let's say there exists $$$y$$$ unique values of $$$j$$$.
The contribution of index $$$i$$$ to the answer is then $$$2^{x + y}$$$.
Special case: the prefix sum never becomes negative. What is the answer then?
Code (C++)
Easy Version
#include <iostream>
#include <vector>
#include <climits>
using namespace std;
 
#define ll long long
 
void solve() {
  int n; cin >> n;
  vector<int> arr(n); for (int i = 0; i < n; ++i) cin >> arr[i];
  ll sum = 0, mn = 0;
  for (int i = 0; i < n; ++i) sum += arr[i], mn = min(mn, sum);
  cout << sum - 2 * mn << '\n';
}
 
int main() {
  ios_base::sync_with_stdio(false); cin.tie(NULL);
  int t; cin >> t;
  for (int i = 0; i < t; ++i) solve();
  return 0;
}
Hard Version
#include <iostream>
#include <vector>
#include <climits>
using namespace std;
 
#define ll long long
 
const ll MAX_N = 400001;
const ll MOD = 998244353;
 
vector<ll> p2(MAX_N);
 
void solve() {
  int n; cin >> n;
  vector<int> arr(n); for (int i = 0; i < n; ++i) cin >> arr[i];
  ll sum = 0, mn = 0, ans = 0, abses = 0;
  for (int i = 0; i < n; ++i) sum += arr[i], mn = min(mn, sum);
  if (mn == 0) {
      cout << p2[n] << '\n';
      return;
  }
  sum = 0;
  for (int i = 0; i < n; ++i) {
    sum += arr[i];
    if (sum == mn) {
      ans = (ans + p2[n - i - 1 + abses]) % MOD;
    }
    if (sum >= 0) ++abses;
  }
  cout << ans << '\n';
}
 
int main() {
  ios_base::sync_with_stdio(false); cin.tie(NULL);
  p2[0] = 1;
  for (int i = 1; i < MAX_N; ++i) p2[i] = 2 * p2[i - 1] % MOD;
  int t; cin >> t;
  for (int i = 0; i < t; ++i) solve();
  return 0;
}
Easy Version
#include <iostream>
#include <vector>
#include <climits>
using namespace std;
 
#define ll long long
 
void solve() {
  int n; cin >> n;
  vector<int> arr(n); for (int i = 0; i < n; ++i) cin >> arr[i];
  ll sum = 0, mn = 0;
  for (int i = 0; i < n; ++i) sum += arr[i], mn = min(mn, sum);
  cout << sum - 2 * mn << '\n';
}
 
int main() {
  ios_base::sync_with_stdio(false); cin.tie(NULL);
  int t; cin >> t;
  for (int i = 0; i < t; ++i) solve();
  return 0;
}
Hard Version
#include <iostream>
#include <vector>
#include <climits>
using namespace std;
 
#define ll long long
 
const ll MAX_N = 400001;
const ll MOD = 998244353;
 
vector<ll> p2(MAX_N);
 
void solve() {
  int n; cin >> n;
  vector<int> arr(n); for (int i = 0; i < n; ++i) cin >> arr[i];
  ll sum = 0, mn = 0, ans = 0, abses = 0;
  for (int i = 0; i < n; ++i) sum += arr[i], mn = min(mn, sum);
  if (mn == 0) {
      cout << p2[n] << '\n';
      return;
  }
  sum = 0;
  for (int i = 0; i < n; ++i) {
    sum += arr[i];
    if (sum == mn) {
      ans = (ans + p2[n - i - 1 + abses]) % MOD;
    }
    if (sum >= 0) ++abses;
  }
  cout << ans << '\n';
}
 
int main() {
  ios_base::sync_with_stdio(false); cin.tie(NULL);
  p2[0] = 1;
  for (int i = 1; i < MAX_N; ++i) p2[i] = 2 * p2[i - 1] % MOD;
  int t; cin >> t;
  for (int i = 0; i < t; ++i) solve();
  return 0;
}
--------------------------------------------------
Problem ID: 1984C1
Editorial Content:
1984C1 - Magnitude (Easy Version)
--------------------------------------------------
Problem ID: 1984B
Editorial Content:
1984B - Large Addition
Hint 1
What must the first (largest) digit be?
Hint 2
What must the other non-unit digits be?
Hint 3
What must the last digit be?
Solution
Because every digit is large, every two digits being added together will carry to the next digit. The two addends have the same length, so the sum must be one greater in length, with the largest digit equal to $$$1$$$.
For all other digits except for the units digit, we have the value to be the sum of two large digits, plus $$$1$$$ being carried over from the previous column. This makes the acceptable range of values be from $$$1$$$ to $$$9$$$, inclusive.
For the units digit, there is no previous column to carry over a $$$1$$$, so the acceptable range of values is from $$$0$$$ to $$$8$$$, inclusive.
Code (C++)
#include <iostream>
using namespace std;
 
#define ll long long
 
void solve() {
  ll n; cin >> n;
  n = n - n % 10 + (n % 10 + 1) % 10;
  while (n > 9) {
    if (n % 10 == 0) {
      cout << "NO\n";
      return;
    }
    n /= 10;
  }
  cout << (n == 1 ? "YES\n" : "NO\n");
}
 
int main() {
  ios_base::sync_with_stdio(false); cin.tie(NULL);
  int t; cin >> t;
  for (int i = 0; i < t; ++i) solve();
  return 0;
}
--------------------------------------------------
Problem ID: 1984A
Editorial Content:
1984A - Strange Splitting
Hint 1
When is it impossible?
Answer
When $$$a = [x, x \dots x]$$$ for some $$$x$$$.
Answer
When $$$a = [x, x \dots x]$$$ for some $$$x$$$.
Hint 2
Only color one element red to make the range $$$0$$$. Which one do you pick to make the blue range different?
Solution
Read the hints.
It is impossible to color the array when all the elements are the same, because the range for the red and blue elements will always be $$$0$$$.
Otherwise, notice there will always be at least $$$2$$$ distinct values in the array. This means there is a way to get a positive range for the blue elements, by taking the maximum value and the minimum value and coloring them blue. This works because $$$n \geq 3$$$, so there is at least one element left.
Since we can get a positive range, we can then try to get the red elements to have a range of $$$0$$$, by coloring exactly one value red. So, we can color any $$$a_i$$$ for $$$2 \leq i \leq n - 1$$$ red since it will not affect the positive range we constructed for the blue elements. For simplicity sake, our solution chooses $$$i = 2$$$. Then, the remaining elements can be colored blue.
Therefore, our final solution is to check if it is impossible, or color $$$a_2$$$ red and the rest blue.
Code (C++)
#include <iostream>
using namespace std;
int main(){
    int T; cin >> T;

    while (T--) {

        int n; cin >> n;

        vector<int> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }

        if (a[0] == a[n - 1]) {
            cout << "NO" << "\n";
        }
        else {
            cout << "YES" << "\n";
            string s(n, 'R'); 
            s[1] = 'B';
            cout << s << "\n";

        }

        
    }
}
--------------------------------------------------
Problem ID: 1983G
Editorial Content:
1983G - Your Loss
Hints
Hint 1
Try looking at the problem bit by bit.
Hint 2
What does the contribution of a particular bit over a path look like?
Hint 3
Can you think of some simpler queries you can easily solve the problem for?
Hint 4
Root the tree.
Hint 5
For a query from a node $$$u$$$ to its ancestor $$$v$$$, the countribution from the counting term $$$(0,1,2,3, \ldots)$$$ changes for the first time at an ancestor at a jump of a power of two.
Hint 6
Let $$$dp[u][k]$$$ be the contribution of bit $$$k$$$ to the query from $$$u$$$ to the root.
Hint 7
Keep track of a few additional nodes for each query. Read hint 5 again.
Hint 1
Try looking at the problem bit by bit.
Hint 2
What does the contribution of a particular bit over a path look like?
Hint 3
Can you think of some simpler queries you can easily solve the problem for?
Hint 4
Root the tree.
Hint 5
For a query from a node $$$u$$$ to its ancestor $$$v$$$, the countribution from the counting term $$$(0,1,2,3, \ldots)$$$ changes for the first time at an ancestor at a jump of a power of two.
Hint 6
Let $$$dp[u][k]$$$ be the contribution of bit $$$k$$$ to the query from $$$u$$$ to the root.
Hint 7
Keep track of a few additional nodes for each query. Read hint 5 again.
Solution
Tutorial is loading...
Implementation (C++)
269315826
--------------------------------------------------
Problem ID: 1983F
Editorial Content:
1983F - array-value
Hint
Hint 1
Can we fix an upper bound to count the number of subarrays having xor-pair less than that?
Hint 2
We can use binary search to fix an upper bound and calculate all subarrays with xor-pair less than the given value.
Hint 3
In order to count the number of subarrays we can use a popular data-structure used for a lot of xor-operations.
Hint 4
We can binary search on the upper bound and use tries to count the number of subarrays with xor-pair less than given value. This way we can find the kth-smallest value.
Hint 1
Can we fix an upper bound to count the number of subarrays having xor-pair less than that?
Hint 2
We can use binary search to fix an upper bound and calculate all subarrays with xor-pair less than the given value.
Hint 3
In order to count the number of subarrays we can use a popular data-structure used for a lot of xor-operations.
Hint 4
We can binary search on the upper bound and use tries to count the number of subarrays with xor-pair less than given value. This way we can find the kth-smallest value.
Solution
Tutorial is loading...
Implementation (C++)
269305957
--------------------------------------------------
Problem ID: 1983E
Editorial Content:
1983E - I Love Balls
Solution
Tutorial is loading...
Implementation (C++)
269329340
--------------------------------------------------
Problem ID: 1983D
Editorial Content:
1983D - Swap Dilemma
Hint
Hint 1
Can we convert this complicated operation to something simpler?
Hint 2
We can convert the operation to basically swapping adjacent elements and it still works. Try to prove why?
Hint 3
Swapping adjacent elements in a distinct array is basically trying to equate two permutations using adjacent swaps. When is it possible?
Hint 4
Inversions in a permutation
Hint 1
Can we convert this complicated operation to something simpler?
Hint 2
We can convert the operation to basically swapping adjacent elements and it still works. Try to prove why?
Hint 3
Swapping adjacent elements in a distinct array is basically trying to equate two permutations using adjacent swaps. When is it possible?
Hint 4
Inversions in a permutation
Solution
Tutorial is loading...
Implementation (C++)
269303026
--------------------------------------------------
Problem ID: 1983C
Editorial Content:
1983C - Have Your Cake and Eat It Too
Solution
Tutorial is loading...
Implementation (C++)
269329204
--------------------------------------------------
Problem ID: 1983B
Editorial Content:
1983B - Corner Twist
Hint
Hint 1
$$$1 + 2 \equiv 0 \pmod{3}$$$.
Hint 2
Can you notice something that does not change, an invariant?
Hint 1
$$$1 + 2 \equiv 0 \pmod{3}$$$.
Hint 2
Can you notice something that does not change, an invariant?
Solution
Tutorial is loading...
Implementation (C++)
269329137
--------------------------------------------------
Problem ID: 1983A
Editorial Content:
1983A - Array Divisibility
Hints
Hint 1
Think simple.
Hint 2
If $$$a$$$ and $$$b$$$ both are divisible by $$$c$$$ then, $$$a + b$$$ will also be divisible by $$$c$$$.
Hint 1
Think simple.
Hint 2
If $$$a$$$ and $$$b$$$ both are divisible by $$$c$$$ then, $$$a + b$$$ will also be divisible by $$$c$$$.
Solution
Tutorial is loading...
Implementation (C++)
269328935
--------------------------------------------------
Problem ID: 1982F
Editorial Content:
1982F - Sorting Problem Again
Hint
If you maintain a set of such indexes $$$i$$$ that $$$a_{i} <a_{i - 1}$$$, then can this help in any way?
Tutorial
Tutorial is loading...
Solution (FelixArg)
#include <bits/stdc++.h>
 
using namespace std;
 
const int inf = 1000000007;
 
struct SegTree{
	vector<int> mn, mx;
	int n;
	SegTree(int _n): n(_n){
		mx.assign(2 * n, -inf);
		mn.resize(2 * n, inf);
	}
 
	void upd(int pos, int val){
		mx[pos + n] = val;
		mn[pos + n] = val;
		pos = (pos + n) >> 1;
		for (;pos > 0; pos >>= 1){
			mx[pos] = max(mx[pos << 1], mx[(pos << 1) | 1]);
			mn[pos] = min(mn[pos << 1], mn[(pos << 1) | 1]);
		}
	}
 
	pair<int,int> get(int l, int r){
		pair<int,int> res = {-inf, inf};
		l += n;
		r += n + 1;
		for (;l < r; l >>= 1, r >>= 1){
			if (l & 1) {
				res.first = max(res.first, mx[l]);
				res.second = min(res.second, mn[l++]);
			}
			if (r & 1) {
				res.first = max(res.first, mx[--r]);
				res.second = min(res.second, mn[r]);
			}			
		}
		return res;
	}
};
 
void solve(){
	int n;
	cin >> n;
	vector<int> a(n);
	for (int i = 0; i < n; i++){
		cin >> a[i];
	}
 
	SegTree tree(n);
	set<int> st;
	for (int i = 0; i < n; i++){
		tree.upd(i, a[i]);
		if (i > 0 && a[i] < a[i - 1]){
			st.insert(i);
		}
	}
 
	function<int(int, int)> find_pref = [&](int pos, int x){
		if (pos < 0){
			return 0;
		}
		int l = 0, r = pos;
		while(l <= r){
			int m = l + (r - l) / 2;
			if (a[m] > x){
				r = m - 1;
			}
			else{
				l = m + 1;
			}
		}
		return r + 1;
	};
 
	function<int(int, int)> find_suff = [&](int pos, int x){
		if (pos >= n){
			return n - 1;
		}
		int l = pos, r = n - 1;
		while(l <= r){
			int m = l + (r - l) / 2;
			if (a[m] >= x){
				r = m - 1;
			}
			else{
				l = m + 1;
			}
		}
		return r;
	};
 
	function<void()> query = [&](){
		if (st.empty()){
			cout << -1 << ' ' << -1 << '\n';
			return;
		}
		int l = *st.begin() - 1;
		int r = *(--st.end());
 
		auto [mx, mn] = tree.get(l, r);
 
		cout << find_pref(l - 1, mn) + 1 << ' ' << find_suff(r + 1, mx) + 1 << '\n';
	};
 
	query();
	int q;
	cin >> q;
	for (int i = 0; i < q; i++){
		int pos, val;
		cin >> pos >> val;
		pos--;
		if (pos > 0 && a[pos] < a[pos - 1]){
			st.erase(pos);
		}
		if (pos + 1 < n && a[pos + 1] < a[pos]){
			st.erase(pos + 1);
		}
		a[pos] = val;
		tree.upd(pos, val);
		if (pos > 0 && a[pos] < a[pos - 1]){
			st.insert(pos);
		}
		if (pos + 1 < n && a[pos + 1] < a[pos]){
			st.insert(pos + 1);
		}
		query();
	}
}
 
int main()
{
#ifdef FELIX
	auto _clock_start = chrono::high_resolution_clock::now();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int tests = 1;
	cin >> tests;
	for (int test = 0; test < tests; test++){
		solve();
	}
#ifdef FELIX
	cerr << "Executed in " << chrono::duration_cast<chrono::milliseconds>(
		chrono::high_resolution_clock::now()
			- _clock_start).count() << "ms." << endl;
#endif
	return 0;
}
--------------------------------------------------
Problem ID: 1982E
Editorial Content:
1982E - Number of k-good subarrays
Hint
Try using the divide-and-conquer approach.
Tutorial
Tutorial is loading...
Solution (FelixArg)
#include <bits/stdc++.h>
 
using namespace std;
 
const int MOD = 1000000007;
 
map<pair<long long, int>, tuple<int, long long, long long>> mem;
 
tuple<int, long long, long long> calc(long long n, int k){
	if (k < 0){
		return tuple{0, 0ll, 0ll};
	}
	if (n == 1){
		return tuple{1, 1ll, 1ll};
	}
	int bit = 63 - __builtin_clzll(n);
	long long mid = (1ll << bit);
	if (mid == n){
		mid >>= 1;
		if (mem.count({n, k})){
			return mem[{n, k}];
		}
	}
	auto [f1, s1, e1] = calc(mid, k);
	auto [f2, s2, e2] = calc(n - mid, k - 1);
 
	int sub1 = (e1 % MOD) * ((e1 + 1) % MOD) % MOD * 500000004 % MOD;
	f1 = (f1 * 1ll - sub1 + MOD) % MOD;
	int sub2 = (s2 % MOD) * ((s2 + 1) % MOD) % MOD * 500000004 % MOD;
	f2 = (f2 * 1ll - sub2 + MOD) % MOD;
 
	long long p = (e1 + s2) % MOD;
	int f_cur = (f1 * 1ll + f2 + (p * 1ll * ((p + 1) % MOD) % MOD * 500000004 % MOD)) % MOD;
	long long s_cur = s1;
	long long e_cur = e2;
	if (s1 == e1 && s1 != 0){
		s_cur = (s1 + s2);
	}
	if (s2 == e2 && s2 != 0){
		e_cur = (e1 + e2);
	}
	if ((mid << 1) == n){
		mem[{n, k}] = tuple{f_cur, s_cur, e_cur};
	}
	return tuple{f_cur, s_cur, e_cur};
};
 
void solve(){
	long long n;
	int k;
	cin >> n >> k;
	cout << get<0>(calc(n, k)) << '\n';
}
 
int main()
{
#ifdef FELIX
	auto _clock_start = chrono::high_resolution_clock::now();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
 
	int tests = 1;
	cin >> tests;
	for (int test = 0; test < tests; test++){
		solve();
	}
 
#ifdef FELIX
	cerr << "Executed in " << chrono::duration_cast<chrono::milliseconds>(
		chrono::high_resolution_clock::now()
			- _clock_start).count() << "ms." << endl;
#endif
	return 0;
}
--------------------------------------------------
Problem ID: 1982D
Editorial Content:
1982D - Beauty of the mountains
Hint 1
How does the difference between heights change if we choose a specific submatrix?
Hint 2
It is worth reducing the problem to a mathematical construction. Maybe something from number theory can help?
Tutorial
Tutorial is loading...
Solution (FelixArg)
import math
 
def solve():
    n, m, k = map(int, input().split())
    a = [[int(x) for x in input().split()] for j in range(n)]
    s = [input() for i in range(n)]
    pref = [[0 for i in range(m + 1)] for j in range(n + 1)]
    diff = 0
    for i in range(n):
        cur = 0
        for j in range(m):
            if s[i][j] == '1':
                cur += 1
                diff += a[i][j]
            else:
                diff -= a[i][j]
            pref[i + 1][j + 1] = pref[i][j + 1] + cur
    if diff == 0:
        print("YES")
        return
    g = 0
    for i in range(n - k + 1):
        for j in range(m - k + 1):
            f = pref[i + k][j + k] - pref[i + k][j] - pref[i][j + k] + pref[i][j]
            f = abs(k * k - 2 * f)
            g = math.gcd(g, f)
    if g == 0 or diff % g != 0:
        print("NO")
    else:
        print("YES")
 
 
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        solve()
--------------------------------------------------
Problem ID: 1982C
Editorial Content:
1982C - Boring Day
Hint 1
All the numbers $$$a_{i}$$$ are positive, can it help somehow?
Hint 2
Try using dynamic programming.
Tutorial
Tutorial is loading...
Solution 1 (FelixArg)
#include <bits/stdc++.h>
 
using namespace std;
 
const int inf = 1000000007;
 
void solve(){
	int n, l, r;
	cin >> n >> l >> r;
	vector<int> a(n);
	for (int i = 0; i < n; i++){
		cin >> a[i];
	}
 
	vector<long long> pref(n + 1);
	for (int i = 0; i < n; i++){
		pref[i + 1] = pref[i] + a[i];
	}
 
	vector<int> dp(n + 1);
	int s = 0;
	int j = -1;
	for (int i = 0; i < n; i++){
		dp[i + 1] = max(dp[i + 1], dp[i]);
		if (j < i){
			j = i;
			s = 0;
		}
		while(j < n && s < l){
			s += a[j++];
		}
		if (s >= l && s <= r){
			dp[j] = max(dp[j], dp[i] + 1);
		}
		s -= a[i];
	}
 
	cout << dp[n] << '\n';
}
 
int main()
{
#ifdef FELIX
	auto _clock_start = chrono::high_resolution_clock::now();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int tests = 1;
	cin >> tests;
	for (int test = 0; test < tests; test++){
		solve();
	}
#ifdef FELIX
	cerr << "Executed in " << chrono::duration_cast<chrono::milliseconds>(
		chrono::high_resolution_clock::now()
			- _clock_start).count() << "ms." << endl;
#endif
	return 0;
}
Solution 2 (74TrAkToR)
t = int(input())
for T in range(t):
	n, l, r = map(int, input().split())
	a = [int(x) for x in input().split()]
	ans = 0
	cur = 0
	L, R = 0, 0
	while L < n:
		while R < n and cur < l:
			cur += a[R]
			R += 1
		if l <= cur and cur <= r:
			ans += 1
			L = R
			cur = 0
		else:
			cur -= a[L]
			L += 1
	print(ans)
--------------------------------------------------
Problem ID: 1982B
Editorial Content:
1982B - Collatz Conjecture
Tutorial
Tutorial is loading...
Solution (FelixArg)
#include <bits/stdc++.h>
 
using namespace std;
 
void solve(){
	long long x, y, k;
	cin >> x >> y >> k;
	while (k > 0 && x != 1) {
		long long ost = (x / y + 1) * y - x;
                ost = max(1ll, ost);
                ost = min(ost, k);
                x += ost;
		while (x % y == 0) {
			x /= y;
		}
		k -= ost;
	}
	cout << x + k % (y - 1) << '\n';
}
 
int main()
{
#ifdef FELIX
	auto _clock_start = chrono::high_resolution_clock::now();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
 
	int tests = 1;
	cin >> tests;
	for (int test = 0; test < tests; test++){
		solve();
	}
 
#ifdef FELIX
	cerr << "Executed in " << chrono::duration_cast<chrono::milliseconds>(
		chrono::high_resolution_clock::now()
			- _clock_start).count() << "ms." << endl;
#endif
	return 0;
}
--------------------------------------------------
Problem ID: 1982A
Editorial Content:
1982A - Soccer
Tutorial
Tutorial is loading...
Solution (74TrAkToR)
t = int(input())
for T in range(t):
	la, lb = map(int, input().split())
	ra, rb = map(int, input().split())
	if la > lb:
		la, lb, ra, rb = lb, la, rb, ra
	if la < lb and rb < ra:
		print("NO")
	else:
		print("YES")
--------------------------------------------------
Problem ID: 1981F
Editorial Content:
1981F - Turtle and Paths on a Tree
Hint 1
Try some dp that takes $$$O(n^2)$$$ time.
Hint 2
What's the maximum MEX in the optimal good set of paths?
Solution 1
Tutorial is loading...
Solution 2
Read the $$$O(n^2)$$$ part of Solution 1 first.
Consider using a segment tree to maintain the dp values. The transitions for $$$u$$$ with at most one child are easy to maintain, so we only need to consider the case with two children.
First, use a segment tree to maintain the minimum value of $$$f_{u,i} + i$$$, so $$$\text{minx}$$$ and $$$\text{miny}$$$ can be computed. The value of $$$f_{u,a_u}$$$ can be set to $$$+\infty$$$ by a point update.
Ignoring how to compute $$$k$$$ for now, in the end, all $$$f_{x,i}$$$ are incremented by $$$\text{miny}$$$, all $$$f_{y,i}$$$ are incremented by $$$\text{minx}$$$, and the segment trees are merged. Finally, all $$$f_{u,i}$$$ are taken as the minimum with $$$k$$$.
To compute $$$k$$$, which is $$$\min\limits_{i \neq a_u} (f_{x,i} + f_{y,i} + i)$$$, we can use a similar segment tree merging method, quickly computing this as we recursively descend to the leaf nodes of the segment tree. Additionally, we need to maintain the minimum value of $$$f_{u,i}$$$.
Time complexity: $$$\mathcal{O}(n \log n)$$$ per test case.
Code for Solution 1
#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))
 
using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;
 
const int maxn = 25050;
const int inf = 0x3f3f3f3f;
 
int n, m, a[maxn], f[maxn][4000];
vector<int> G[maxn];
 
void dfs(int u) {
	if (G[u].empty()) {
		for (int i = 1; i <= m; ++i) {
			f[u][i] = (i == a[u] ? inf : 0);
		}
		return;
	}
	if ((int)G[u].size() == 1) {
		int x = G[u][0];
		dfs(x);
		int mn = inf;
		for (int i = 1; i <= m; ++i) {
			if (i != a[u]) {
				mn = min(mn, f[x][i] + i);
			}
		}
		if (u == 1) {
			printf("%d\n", mn);
			return;
		}
		for (int i = 1; i <= m; ++i) {
			f[u][i] = (i == a[u] ? inf : min(f[x][i], mn));
		}
		return;
	}
	int x = G[u][0], y = G[u][1], mnx = inf, mny = inf, k = inf;
	dfs(x);
	dfs(y);
	for (int i = 1; i <= m; ++i) {
		if (i != a[u]) {
			mnx = min(mnx, f[x][i] + i);
			mny = min(mny, f[y][i] + i);
			k = min(k, f[x][i] + f[y][i] + i);
		}
	}
	k = min(k, mnx + mny);
	if (u == 1) {
		printf("%d\n", k);
		return;
	}
	for (int i = 1; i <= m; ++i) {
		f[u][i] = (i == a[u] ? inf : min({f[x][i] + mny, f[y][i] + mnx, k}));
	}
}
 
void solve() {
	scanf("%d", &n);
	m = min(n + 1, 3863);
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &a[i]);
		vector<int>().swap(G[i]);
	}
	for (int i = 2, p; i <= n; ++i) {
		scanf("%d", &p);
		G[p].pb(i);
	}
	dfs(1);
}
 
int main() {
	int T = 1;
	scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}
Code for Solution 2
#include<bits/stdc++.h>
using namespace std;
namespace my_std{
	#define ll long long
	#define bl bool
	ll my_pow(ll a,ll b,ll mod){
		ll res=1;
		if(!b) return 1;
		while(b){
			if(b&1) res=(res*a)%mod;
			a=(a*a)%mod;
			b>>=1;
		}
		return res;
	}
	ll qpow(ll a,ll b){
		ll res=1;
		if(!b) return 1;
		while(b){
			if(b&1) res*=a;
			a*=a;
			b>>=1;
		}
		return res;
	}
	#define db double
	#define pf printf
	#define pc putchar
	#define fr(i,x,y) for(register ll i=(x);i<=(y);i++)
	#define pfr(i,x,y) for(register ll i=(x);i>=(y);i--)
	#define go(u) for(ll i=head[u];i;i=e[i].nxt)
	#define enter pc('\n')
	#define space pc(' ')
	#define fir first
	#define sec second
	#define MP make_pair
	#define il inline
	#define inf 1e18
	#define random(x) rand()*rand()%(x)
	#define inv(a,mod) my_pow((a),(mod-2),(mod))
	il ll read(){
		ll sum=0,f=1;
		char ch=0;
		while(!isdigit(ch)){
			if(ch=='-') f=-1;
			ch=getchar();
		}
		while(isdigit(ch)){
			sum=sum*10+(ch^48);
			ch=getchar();
		}
		return sum*f;
	}
	il void write(ll x){
		if(x<0){
			x=-x;
			pc('-');
		}
		if(x>9) write(x/10);
		pc(x%10+'0');
	}
	il void writeln(ll x){
		write(x);
		enter;
	}
	il void writesp(ll x){
		write(x);
		space;
	}
}
using namespace my_std;
#define LC tree[x].lc
#define RC tree[x].rc
ll t,n,a[25025],ch[25025][2],ans=inf;
ll rt[25025],tot=0;
struct node{
	ll minn1,minn2,lz,lzmin,lc,rc;
	il void addtag(ll v,ll vmin,ll l){
		minn1=min(minn1+v,vmin);
		minn2=min(minn2+v,vmin+l);
		lz+=v;
		lzmin=min(lzmin+v,vmin);
	}
}tree[1000010];
il void pushup(ll x){
	tree[x].minn1=min(tree[LC].minn1,tree[RC].minn1);
	tree[x].minn2=min(tree[LC].minn2,tree[RC].minn2);
}
il ll newnode(){
	tree[++tot]=(node){(ll)inf,(ll)inf,0,(ll)inf,0,0};
	return tot;
}
il void pushdown(ll x,ll l,ll r){
	if(!LC) LC=newnode();
	if(!RC) RC=newnode();
	ll mid=(l+r)>>1;
	tree[LC].addtag(tree[x].lz,tree[x].lzmin,l);
	tree[RC].addtag(tree[x].lz,tree[x].lzmin,mid+1);
	tree[x].lz=0;
	tree[x].lzmin=inf;
}
void upd(ll &x,ll l,ll r,ll pos){
	if(!x) x=newnode();
	if(l==r){
		tree[x].minn1=tree[x].minn2=inf;
		return;
	}
	ll mid=(l+r)>>1;
	pushdown(x,l,r);
	if(pos<=mid) upd(LC,l,mid,pos);
	else upd(RC,mid+1,r,pos);
	pushup(x);
}
void add(ll &x,ll l,ll r,ll ql,ll qr,ll v){
	if(!x) x=newnode();
	if(ql<=l&&r<=qr){
		tree[x].addtag(v,(ll)inf,l);
		return;
	}
	ll mid=(l+r)>>1;
	pushdown(x,l,r);
	if(ql<=mid) add(LC,l,mid,ql,qr,v);
	if(mid<qr) add(RC,mid+1,r,ql,qr,v);
	pushup(x);
}
void mdf(ll &x,ll l,ll r,ll ql,ll qr,ll v){
	if(!x) x=newnode();
	if(ql<=l&&r<=qr){
		tree[x].addtag(0,v,l);
		return;
	}
	ll mid=(l+r)>>1;
	pushdown(x,l,r);
	if(ql<=mid) mdf(LC,l,mid,ql,qr,v);
	if(mid<qr) mdf(RC,mid+1,r,ql,qr,v);
	pushup(x);
}
ll merge(ll x,ll y,ll l,ll r){
	if(!LC&&!RC){
		tree[y].addtag(0,tree[x].minn1,l);
		return y;
	}
	if(!tree[y].lc&&!tree[y].rc){
		tree[x].addtag(0,tree[y].minn1,l);
		return x;
	}
	ll mid=(l+r)>>1;
	pushdown(x,l,r);
	pushdown(y,l,r);
	LC=merge(LC,tree[y].lc,l,mid);
	RC=merge(RC,tree[y].rc,mid+1,r);
	pushup(x);
	return x;
}
ll query(ll x,ll y,ll l,ll r){
	if(!LC&&!RC) return tree[x].minn1+tree[y].minn2;
	if(!tree[y].lc&&!tree[y].rc) return tree[y].minn1+tree[x].minn2;
	ll mid=(l+r)>>1,res=inf;
	pushdown(x,l,r);
	pushdown(y,l,r);
	res=min(res,query(LC,tree[y].lc,l,mid));
	res=min(res,query(RC,tree[y].rc,mid+1,r));
	return res;
}
void dfs(ll u){
	if(!ch[u][0]){
		mdf(rt[u],1,n+1,1,n+1,0);
		if(a[u]<=(n+1)) upd(rt[u],1,n+1,a[u]);
		if(u==1) ans=0;
	}
	else if(!ch[u][1]){
		dfs(ch[u][0]);
		rt[u]=rt[ch[u][0]];
		if(a[u]<=(n+1)) upd(rt[u],1,n+1,a[u]);
		ll minn=tree[rt[u]].minn2;
		mdf(rt[u],1,n+1,1,n+1,minn);
		if(a[u]<=(n+1)) upd(rt[u],1,n+1,a[u]);
		if(u==1) ans=minn;
	}
	else{
		ll x=ch[u][0],y=ch[u][1];
		dfs(x);
		dfs(y);
		if(a[u]<=(n+1)){
			upd(rt[x],1,n+1,a[u]);
			upd(rt[y],1,n+1,a[u]);
		}
		ll minx=tree[rt[x]].minn2,miny=tree[rt[y]].minn2,k=min(query(rt[x],rt[y],1,n+1),minx+miny);
		add(rt[x],1,n+1,1,n+1,miny);
		add(rt[y],1,n+1,1,n+1,minx);
		rt[u]=merge(rt[x],rt[y],1,n+1);
		mdf(rt[u],1,n+1,1,n+1,k);
		if(a[u]<=(n+1)) upd(rt[u],1,n+1,a[u]);
		if(u==1) ans=k;
	}
}
il void clr(){
	fr(i,1,n) ch[i][0]=ch[i][1]=rt[i]=0;
	tot=0;
	ans=inf;
}
int main(){
	t=read();
	while(t--){
		n=read();
		fr(i,1,n) a[i]=read();
		fr(i,2,n){
			ll x=read();
			if(!ch[x][0]) ch[x][0]=i;
			else ch[x][1]=i;
		}
		dfs(1);
		writeln(ans);
		clr();
	}
}
/*
1
5
3 2 2 1 1
1 1 2 2
ans:
4 
*/
--------------------------------------------------
Problem ID: 1981E
Editorial Content:
1981E - Turtle and Intersected Segments
Hint 1
Stop thinking about Boruvka.
Hint 2
Most of the edges in the graph are useless.
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<int, int> pii;

const int maxn = 1000100;

int n, lsh[maxn], tot, fa[maxn];
pii b[maxn];

struct node {
	int l, r, x;
} a[maxn];

struct edg {
	int u, v, d;
	edg(int a = 0, int b = 0, int c = 0) : u(a), v(b), d(c) {}
} E[maxn];

int find(int x) {
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

inline bool merge(int x, int y) {
	x = find(x);
	y = find(y);
	if (x != y) {
		fa[x] = y;
		return 1;
	} else {
		return 0;
	}
}

void solve() {
	tot = 0;
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		cin >> a[i].l >> a[i].r >> a[i].x;
		lsh[++tot] = a[i].l;
		lsh[++tot] = (++a[i].r);
	}
	int m = 0;
	sort(lsh + 1, lsh + tot + 1);
	tot = unique(lsh + 1, lsh + tot + 1) - lsh - 1;
	for (int i = 1; i <= n; ++i) {
		a[i].l = lower_bound(lsh + 1, lsh + tot + 1, a[i].l) - lsh;
		a[i].r = lower_bound(lsh + 1, lsh + tot + 1, a[i].r) - lsh;
		b[++m] = mkp(a[i].l, i);
		b[++m] = mkp(a[i].r, -i);
	}
	set<pii> S;
	sort(b + 1, b + m + 1);
	int tt = 0;
	for (int i = 1; i <= m; ++i) {
		int j = b[i].scd;
		if (j > 0) {
			auto it = S.insert(mkp(a[j].x, j)).fst;
			if (it != S.begin()) {
				int k = prev(it)->scd;
				E[++tt] = edg(j, k, abs(a[j].x - a[k].x));
			}
			if (next(it) != S.end()) {
				int k = next(it)->scd;
				E[++tt] = edg(j, k, abs(a[j].x - a[k].x));
			}
		} else {
			j = -j;
			S.erase(mkp(a[j].x, j));
		}
	}
	for (int i = 1; i <= n; ++i) {
		fa[i] = i;
	}
	sort(E + 1, E + tt + 1, [&](const edg &a, const edg &b) {
		return a.d < b.d;
	});
	ll ans = 0, cnt = 0;
	for (int i = 1; i <= tt; ++i) {
		if (merge(E[i].u, E[i].v)) {
			++cnt;
			ans += E[i].d;
		}
	}
	cout << (cnt == n - 1 ? ans : -1) << '\n';
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int T = 1;
	cin >> T;
	while (T--) {
		solve();
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1981D
Editorial Content:
1981D - Turtle and Multiplication
Hint 1
$$$a_i$$$ should take different primes.
Hint 2
Transform it into a graph problem.
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<int, int> pii;

const int maxn = 4000100;
const int N = 1000000;

int n, a[maxn], pr[maxn], tot, stk[maxn], top;
bool vis[maxn];

inline void init() {
	for (int i = 2; i <= N; ++i) {
		if (!vis[i]) {
			pr[++tot] = i;
		}
		for (int j = 1; j <= tot && i * pr[j] <= N; ++j) {
			vis[i * pr[j]] = 1;
			if (i % pr[j] == 0) {
				break;
			}
		}
	}
	mems(vis, 0);
}

inline bool check(int x) {
	if (x & 1) {
		return x + 1 + x * (x - 1) / 2 >= n;
	} else {
		return x * (x - 1) / 2 - x / 2 + 2 + x >= n;
	}
}

vector<pii> G[10000];

void dfs(int u) {
	while (G[u].size()) {
		pii p = G[u].back();
		G[u].pop_back();
		if (vis[p.scd]) {
			continue;
		}
		vis[p.scd] = 1;
		dfs(p.fst);
	}
	stk[++top] = pr[u];
}

void solve() {
	scanf("%d", &n);
	int l = 1, r = 10000, ans = -1;
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (check(mid)) {
			ans = mid;
			r = mid - 1;
		} else {
			l = mid + 1;
		}
	}
	for (int i = 1; i <= ans; ++i) {
		vector<pii>().swap(G[i]);
	}
	int tot = 0;
	for (int i = 1; i <= ans; ++i) {
		for (int j = i; j <= ans; ++j) {
			if (ans % 2 == 0 && i % 2 == 0 && i + 1 == j) {
				continue;
			}
			G[i].pb(j, ++tot);
			G[j].pb(i, tot);
		}
	}
	for (int i = 1; i <= tot; ++i) {
		vis[i] = 0;
	}
	top = 0;
	dfs(1);
	reverse(stk + 1, stk + top + 1);
	for (int i = 1; i <= n; ++i) {
		printf("%d%c", stk[i], " \n"[i == n]);
	}
}

int main() {
	init();
	int T = 1;
	scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1981C
Editorial Content:
1981C - Turtle and an Incomplete Sequence
Hint 1
Figure out the case where $$$a'_1 \ne -1, a'_n \ne -1$$$ and $$$a'_2 = a'_3 = \cdots = a'_{n - 1} = -1$$$ first.
Hint 2
Imagine a full binary tree. Consider the sequence as a walk on the full binary tree.
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

const int maxn = 200100;

int n, a[maxn];

inline vector<int> path(int x, int y) {
	vector<int> L, R;
	while (__lg(x) > __lg(y)) {
		L.pb(x);
		x >>= 1;
	}
	while (__lg(y) > __lg(x)) {
		R.pb(y);
		y >>= 1;
	}
	while (x != y) {
		L.pb(x);
		R.pb(y);
		x >>= 1;
		y >>= 1;
	}
	L.pb(x);
	reverse(R.begin(), R.end());
	for (int x : R) {
		L.pb(x);
	}
	return L;
}

void solve() {
	scanf("%d", &n);
	int l = -1, r = -1;
	vector<int> vc;
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &a[i]);
		if (a[i] != -1) {
			if (l == -1) {
				l = i;
			}
			r = i;
			vc.pb(i);
		}
	}
	if (l == -1) {
		for (int i = 1; i <= n; ++i) {
			printf("%d%c", (i & 1) + 1, " \n"[i == n]);
		}
		return;
	}
	for (int i = l - 1; i; --i) {
		a[i] = (((l - i) & 1) ? a[l] * 2 : a[l]);
	}
	for (int i = r + 1; i <= n; ++i) {
		a[i] = (((i - r) & 1) ? a[r] * 2 : a[r]);
	}
	for (int _ = 1; _ < (int)vc.size(); ++_) {
		int l = vc[_ - 1], r = vc[_];
		vector<int> p = path(a[l], a[r]);
		if (((int)p.size() & 1) != ((r - l + 1) & 1) || r - l + 1 < (int)p.size()) {
			puts("-1");
			return;
		}
		for (int i = 0; i < (int)p.size(); ++i) {
			a[l + i] = p[i];
		}
		for (int i = l + (int)p.size(), o = 1; i <= r; ++i, o ^= 1) {
			a[i] = (o ? a[i - 1] * 2 : a[i - 1] / 2);
		}
	}
	for (int i = 1; i <= n; ++i) {
		printf("%d%c", a[i], " \n"[i == n]);
	}
}

int main() {
	int T = 1;
	scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1981B
Editorial Content:
1981B - Turtle and an Infinite Sequence
Hint 1
Consider each bit separately.
Hint 2
Calculate the time when the $$$d$$$-th bit of $$$a_n$$$ becomes $$$1$$$.
Solution 1
Tutorial is loading...
Solution 2
The answer is the bitwise OR of the range $$$[\max(0, n - m), n + m]$$$. Let's figure out how to calculate the bitwise OR of the range $$$[l, r]$$$.
We can consider each bit separately. If the $$$d$$$-th bit of $$$l$$$ is $$$1$$$ or the $$$d$$$-th bit of $$$r$$$ is $$$1$$$, then the $$$d$$$-th bit of the answer is $$$1$$$.
Otherwise, if $$$\left\lfloor\frac{l}{2^{d + 1}}\right\rfloor \ne \left\lfloor\frac{r}{2^{d + 1}}\right\rfloor$$$, then the $$$d$$$-th bit has been flipped at least twice from $$$l$$$ to $$$r$$$, so in this case the $$$d$$$-th bit of the answer is also $$$1$$$.
Time complexity: $$$O(\log (n + m))$$$ per test case.
Code for Solution 1
#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

void solve() {
	ll n, m;
	scanf("%lld%lld", &n, &m);
	ll ans = 0;
	for (int i = 0; i <= 30; ++i) {
		ll x = n & ((1LL << (i + 1)) - 1);
		ll t = (1LL << i) - x;
		if (n >= (1LL << i)) {
			t = min(t, x + 1);
		}
		if (x >= (1LL << i) || t <= m) {
			ans |= (1LL << i);
		}
	}
	printf("%lld\n", ans);
}

int main() {
	int T = 1;
	scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}
Code for Solution 2
#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

void solve() {
	ll n, m;
	scanf("%lld%lld", &n, &m);
	ll l = max(0LL, n - m), r = n + m, ans = 0;
	for (int i = 31; ~i; --i) {
		if ((l & (1LL << i)) || (r & (1LL << i)) || (l >> (i + 1)) != (r >> (i + 1))) {
			ans |= (1LL << i);
		}
	}
	printf("%lld\n", ans);
}

int main() {
	int T = 1;
	scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1981A
Editorial Content:
1981A - Turtle and Piggy Are Playing a Game
Hint 1
What is Piggy's optimal strategy?
Hint 2
What does $$$2l \le r$$$ mean?
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;

int main() {
	int T;
	scanf("%d", &T);
	while (T--) {
		int l, r;
		scanf("%d%d", &l, &r);
		printf("%d\n", __lg(r));
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1980G
Editorial Content:
1980G - Yasya and the Mysterious Tree
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
 
struct trie {
    int l, c;
    vector<array<int, 2>> node;
    vector<int> cnt;
    trie(int l, int max_members) : l(l), c(0), node((l + 2) * max_members + 3), cnt((l + 2) * max_members + 3) {}
    void add(int x) {
        int cur = 0;
        for (int i = l; i >= 0; --i) {
            bool has_bit = (1 << i) & x;
            if (!node[cur][has_bit]) {
                node[cur][has_bit] = ++c;
            }
            cur = node[cur][has_bit];
            ++cnt[cur];
        }
    }
    void remove(int x) {
        int cur = 0;
        for (int i = l; i >= 0; --i) {
            bool has_bit = (1 << i) & x;
            if (!node[cur][has_bit]) {
                node[cur][has_bit] = ++c;
            }
            cur = node[cur][has_bit];
            --cnt[cur];
        }
    }
    int find_max(int x) {
        int cur = 0, ans = 0;
        for (int i = l; i >= 0; --i) {
            bool has_bit = (1 << i) & x;
            if (node[cur][!has_bit] && cnt[node[cur][!has_bit]]) {
                ans += 1 << i;
                cur = node[cur][!has_bit];
            }
            else {
                cur = node[cur][has_bit];
            }
        }
        return ans;
    }
};
 
const int N = 2e5 + 2;
int x[N];
bitset<N> dp;
vector<array<int, 2>> e[N];
 
void dfs(int c, int p) {
    for (auto [i, w] : e[c]) {
        if (i == p) {
            continue;
        }
        dp[i] = !dp[c];
        x[i] = x[c] ^ w;
        dfs(i, c);
    }
}
 
void solve() {
    int n, m, gx = 0;
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        e[i].clear();
    }
    for (int i = 1, u, v, w; i < n; ++i) {
        cin >> u >> v >> w;
        e[u].push_back({v, w});
        e[v].push_back({u, w});
    }
    dfs(1, 0);
    vector<trie> t(2, trie(30, n));
    for (int i = 1; i <= n; ++i) {
        t[dp[i]].add(x[i]);
    }
    while (m--) {
        char c;
        cin >> c;
        if (c == '^') {
            int y;
            cin >> y;
            gx ^= y;
        }
        else {
            int a, b;
            cin >> a >> b;
            t[dp[a]].remove(x[a]);
            int same_group = t[dp[a]].find_max(x[a] ^ b);
            int diff_group = t[1 - dp[a]].find_max(x[a] ^ b ^ gx);
            t[dp[a]].add(x[a]);
            cout << max(same_group, diff_group) << "\n";
        }
    }
}
 
int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1980F2
Editorial Content:
1980F2 - Field Division (hard version)
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
#define int long long
#define pb emplace_back
#define mp make_pair
#define x first
#define y second
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
 
typedef long double ld;
typedef long long ll;
 
using namespace std;
 
mt19937 rnd(time(nullptr));
 
const ll inf = 1e9 + 1;
const ll M = 998244353;
const ld pi = atan2(0, -1);
const ld eps = 1e-6;
 
bool cmp(pair<int, int> &a, pair<int, int> &b){
    if(a.x != b.x) return a.x > b.x;
    return a.y < b.y;
}
 
void solve(int tc){
    int n, m, k;
    cin >> n >> m >> k;
    vector<pair<int, int>> a(k);
    map<pair<int, int>, int> idx;
    for(int i = 0; i < k; ++i){
        cin >> a[i].x >> a[i].y;
        idx[a[i]] = i;
    }
    idx[{0, 0}] = k++;
    a.emplace_back(0, 0);
    sort(all(a), cmp);
    vector<int> ans(k);
    vector<int> total(k + 1), cur(k + 1, m + 1), last(k + 1, n);
    for(int i = 1; i <= k; ++i){
        auto e = a[i - 1];
        total[i] = total[i - 1];
        cur[i] = cur[i - 1];
        last[i] = last[i - 1];
        if(cur[i] > e.y) {
            ans[idx[e]] = 1;
            total[i] += (cur[i] - 1) * (last[i] - e.x);
            cur[i] = e.y;
            last[i] = e.x;
        }
    }
    cout << total[k] << "\n";
    for(int i = 1; i <= k; ++i){
        auto e = a[i - 1];
        if(ans[idx[e]] == 0)continue;
        int tot = total[i - 1];
        int cr = cur[i - 1];
        int lst = last[i - 1];
        for(int j = i + 1; j <= k; ++j){
            auto ee = a[j - 1];
            if(cr > ee.y){
                tot += (cr - 1) * (lst - ee.x);
                cr = ee.y;
                lst = ee.x;
            }
            if(ans[idx[ee]] == 1){
                ans[idx[e]] = tot - total[j];
                break;
            }
        }
    }
    ans.pop_back();
    for(int e: ans) cout << e << " ";
}
 
bool multi = true;
 
signed main() {
    int t = 1;
    if (multi)cin >> t;
    for (int i = 1; i <= t; ++i) {
        solve(i);
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1980F1
Editorial Content:
1980F1 - Field Division (easy version)
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
#define int long long
#define pb emplace_back
#define mp make_pair
#define x first
#define y second
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
 
typedef long double ld;
typedef long long ll;
 
using namespace std;
 
mt19937 rnd(time(nullptr));
 
const ll inf = 1e9 + 1;
const ll M = 998244353;
const ld pi = atan2(0, -1);
const ld eps = 1e-6;
 
bool cmp(pair<int, int> &a, pair<int, int> &b){
    if(a.x != b.x) return a.x > b.x;
    return a.y < b.y;
}
 
void solve(int tc){
    int n, m, k;
    cin >> n >> m >> k;
    vector<pair<int, int>> a(k);
    map<pair<int, int>, int> idx;
    for(int i = 0; i < k; ++i){
        cin >> a[i].x >> a[i].y;
        idx[a[i]] = i;
    }
    sort(all(a), cmp);
    vector<int> ans(k);
    int total = 0;
    int cur = m + 1;
    int last = n;
    for(auto e: a){
        if(cur > e.y) {
            ans[idx[e]] = 1;
            total += (cur - 1) * (last - e.x);
            cur = e.y;
            last = e.x;
        }
    }
    total += (cur - 1) * last;
    cout << total << "\n";
    for(int e: ans) cout << e << " ";
}
 
bool multi = true;
 
signed main() {
    int t = 1;
    if (multi)cin >> t;
    for (int i = 1; i <= t; ++i) {
        solve(i);
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1980E
Editorial Content:
1980E - Permutation of Rows and Columns
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
 
using namespace std;
 
typedef long long ll;
typedef vector<int> vi;
typedef vector<vi> vvi;
 
vi read_ints(int n) {
    vi res(n);
    for (int i = 0; i < n; ++i) {
        cin >> res[i];
    }
    return res;
}
 
vvi read_matrix(int n, int m) {
    vvi res(n);
    for (int i = 0; i < n; ++i) {
        res[i] = read_ints(m);
    }
    return res;
}
 
void solve() {
    int n, m;
    cin >> n >> m;
    vvi a = read_matrix(n, m), b = read_matrix(n, m);
    int nm = n * m;
    vi pos1i(nm), pos2i(nm), pos1j(nm), pos2j(nm);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            int x = a[i][j] - 1;
            int y = b[i][j] - 1;
            pos1i[x] = pos2i[y] = i;
            pos1j[x] = pos2j[y] = j;
        }
    }
    vector<set<int>> pi(nm), pj(nm);
    for (int x = 0; x < nm; ++x) {
        int i1 = pos1i[x], i2 = pos2i[x];
        int j1 = pos1j[x], j2 = pos2j[x];
        pi[i1].insert(i2);
        pj[j1].insert(j2);
    }
    for (int x = 0; x < nm; ++x) {
        if (pi[x].size() > 1 || pj[x].size() > 1) {
            cout << "NO\n";
            return;
        }
    }
    cout << "YES\n";
}
 
int main() {
    int t;
    cin >> t;
    for (int _ = 0; _ < t; ++_) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1980D
Editorial Content:
1980D - GCD-sequence
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
 
bool good(vector<int>&b){
    int g = __gcd(b[0], b[1]);
    for(int i = 1; i < int(b.size()) - 1; i++){
        int cur_gcd = __gcd(b[i], b[i + 1]);
        if(g > cur_gcd) return false;
        g = cur_gcd;
    }
    return true;
}
 
bool solve(){
    int n;
    cin >> n;
    vector<int>a(n);
    for(int i = 0; i < n; i++){
        cin >> a[i];
    }
 
    int g = -1;
    int to_del = -1;
    for(int i = 0; i < n - 1; i++){
        int cur_gcd = __gcd(a[i], a[i + 1]);
        if(cur_gcd < g){
            to_del = i;
            break;
        }
        g = cur_gcd;
    }
    if(to_del == -1) return true;
    vector<int>b0 = a, b1 = a, b2 = a;
    if(to_del > 0) b0.erase(b0.begin() + to_del - 1);
    b1.erase(b1.begin() + to_del);
    if(to_del < n - 1) b2.erase(b2.begin() + to_del + 1);
    return good(b0) || good(b1) || good(b2);
}
 
int main(){
    int t;
    cin >> t;
    while(t--){
        cout << (solve() ? "YES" : "NO") << "\n";
    }
}
--------------------------------------------------
Problem ID: 1980C
Editorial Content:
1980C - Sofia and the Lost Operations
Tutorial
Tutorial is loading...
Solution
#include <stdio.h>
#include <stdbool.h>
 
#define MAXN 200200
#define MAXM 200200
 
int n, m, k;
int arr[MAXN], brr[MAXN], drr[MAXM], buf[MAXN];
 
int cmp_i32(const void* pa, const void* pb) {
    return *(const int*)pa - *(const int*)pb;
}
 
void build() {
    k = 0;
    for (int i = 0; i < n; ++i) {
        if (arr[i] != brr[i])
            buf[k++] = brr[i];
    }
    qsort(buf, k, sizeof(*buf), cmp_i32);
}
 
bool check() {
    for (int i = 0; i < n; ++i)
        if (brr[i] == drr[m - 1])
            return true;
    return false;
}
 
bool solve() {
    if (!check()) return false;
    qsort(drr, m, sizeof(*drr), cmp_i32);
    int ib = 0, id = 0;
    while (ib < k && id < m) {
        if (buf[ib] == drr[id])
            ++ib, ++id;
        else if (buf[ib] < drr[id])
            return false;
        else ++id;
    }
    return ib == k;
}
 
int main() {
    int t; scanf("%d", &t);
    while (t--) {
        scanf("%d", &n);
        for (int i = 0; i < n; ++i)
            scanf("%d", arr + i);
        for (int i = 0; i < n; ++i)
            scanf("%d", brr + i);
        scanf("%d", &m);
        for (int j = 0; j < m; ++j)
            scanf("%d", drr + j);
        build();
        if (solve()) printf("YES\n");
        else printf("NO\n");
    }
}
--------------------------------------------------
Problem ID: 1980B
Editorial Content:
1980B - Choosing Cubes
Tutorial
Tutorial is loading...
Solution
def solve():
    n, f, k = map(int, input().split())
    f -= 1
    k -= 1
    a = list(map(int, input().split()))
    x = a[f]
    a.sort(reverse=True)
    if a[k] > x:
        print("NO")
    elif a[k] < x:
        print("YES")
    else:
        print("YES" if k == n - 1 or a[k + 1] < x else "MAYBE")
 
t = int(input())
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 1980A
Editorial Content:
1980A - Problem Generator
Tutorial
Tutorial is loading...
Solution
def solve():
    n, m = map(int, input().split())
    a = input()
    ans = 0
    for ch in range(ord('A'), ord('H')):
        ans += max(0, m - a.count(chr(ch)))
    print(ans)
    
    
for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1979F
Editorial Content:
1979F - Kostyanych's Theorem
Solution
Let's consider the following recursive algorithm. We will store the Hamiltonian path as a double-ended queue, maintaining the start and end.
In case there are only $$$1$$$ or $$$2$$$ vertices left in the graph, the problem is solved trivially.
Suppose we know that the current graph has $$$n$$$ vertices, and there are
at most
$$$(n - 2)$$$ edges missing. Then the total number of edges in such a graph is at least
$$$\frac{n(n - 1)}{2} - (n - 2) = \frac{n^2 - 3n + 4}{2}.$$$
Let all vertices in the graph have a degree of at most $$$(n - 3)$$$, then the total number of edges does not exceed
$$$\frac{n(n-3)}{2} = \frac{n^2 - 3n}{2},$$$
which is less than the stated value. Hence, we conclude that there is
at least one
vertex with a degree greater than $$$(n - 3)$$$.
If there exists a vertex $$$v$$$ with a degree of $$$(n - 2)$$$, then it is sufficient to run our recursive algorithm for the remaining graph. Since $$$v$$$ is only not connected by an edge to one vertex, $$$v$$$ is connected either to the start or the end of the maintained path in the remaining graph. Thus, we can insert the vertex $$$v$$$ either at the beginning or at the end of the path.
Otherwise, let $$$u$$$ be the vertex with a degree of $$$(n - 1)$$$. There is at least one vertex $$$w$$$ with a degree not exceeding $$$(n - 3)$$$. Remove $$$u$$$ and $$$w$$$ from the graph. Notice that the number of edges in such a graph does not exceed
$$$\frac{n^2 - 3n + 4}{2} - (n - 1) - (n - 3) + 1 = \frac{n^2 - 7n + 14}{2}$$$
$$$\frac{n^2 - 7n + 14}{2} = \frac{n^2 - 5n + 6}{2} - \frac{2n - 8}{2}$$$
$$$\frac{n^2 - 5n + 6}{2} - \frac{2n - 8}{2} = \frac{(n - 2)(n - 3)}{2} - (n - 4)$$$
$$$\frac{(n - 2)(n - 3)}{2} - (n - 4) = \frac{(n - 2)((n - 2) - 1)}{2} - ((n - 2) - 2).$$$
The invariant is preserved, so we can run the algorithm for the remaining graph. Then, we can arrange the vertices in the following order: $$$w$$$ — $$$u$$$ — $$$s$$$ — ..., where $$$s$$$ — the start of the Hamiltonian path in the remaining graph.
It remains to understand how to use queries.
Make a query $$$d = (n - 2)$$$. Let $$$u$$$ be the second number in the response to our query. If $$$u \neq 0$$$, the degree of vertex $$$v$$$ is $$$(n - 2)$$$. Run our recursive algorithm, and then compare the start and end of the obtained path with $$$u$$$.
Otherwise, if $$$u = 0$$$, it means the degree of vertex $$$v$$$ is $$$(n - 1)$$$. In this case, ask about any vertex with a low degree (this can be done with a query $$$d = 0$$$). Then simply arrange the vertices in the order mentioned above.
We will make no more than $$$n$$$ queries, and the final asymptotic will be $$$O(n)$$$.
Code
#include <bits/stdc++.h>
using namespace std;

pair <int, int> ask(int d) {
    cout << "? " << d << endl;
    int v, u;
    cin >> v >> u;
    return {v, u};
}
 
pair <int, int> get(int n, vector <int>& nxt) {
    if (n == 1) {
        int v = ask(0).first;
        return {v, v};
    }
    if (n == 2) {
        int u = ask(0).first;
        int v = ask(0).first;
        nxt[u] = v;
        return {u, v};
    }
    pair <int, int> t = ask(n - 2);
    int v = t.first;
    int ban = t.second;
    if (ban != 0) {
        pair <int, int> res = get(n - 1, nxt);
        if (ban != res.first) {
            nxt[v] = res.first;
            return {v, res.second};
        } else {
            nxt[res.second] = v;
            return {res.first, v};
        }
    } else {
        int u = ask(0).first;
        nxt[u] = v;
        pair <int, int> res = get(n - 2, nxt);
        nxt[v] = res.first;
        return {u, res.second};
    }
}
 
void solve() {
    int n;
    cin >> n;
    
    vector <int> nxt(n + 1, -1);
    pair <int, int> ans = get(n, nxt);
    
    int v = ans.first;
    cout << "! ";
    do {
        cout << v << " ";
        v = nxt[v];
    } while (v != -1);
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1979E
Editorial Content:
1979E - Manhattan Triangle
Hint
In every Manhattan triangle there are two points such that $$$|x_1 - x_2| = |y_1 - y_2|$$$.
Solution
Note this fact: in every Manhattan triangle there are two points such that $$$|x_1 - x_2| = |y_1 - y_2|$$$.
Let's start with distributing all points with their $$$(x + y)$$$ value.
For each point $$$(x; y)$$$ find point $$$(x + d / 2; y - d / 2)$$$ using lower bound method in corresponding set. Then we have to find the third point: it can be in either $$$(x + y + d)$$$ or $$$(x + y - d)$$$ diagonal. Borders at $$$x$$$ coordinate for them are $$$[x + d / 2; x + d]$$$ and $$$[x - d / 2; x]$$$ — it can be found using the same lower bound method.
Then, distribute all points with $$$(x - y)$$$ value and do the same algorithm.
Total time complexity is $$$O(n \log n)$$$.
Code
#include <bits/stdc++.h>
using namespace std;

const int MAXC = 1e5;
const int MAXD = 4e5 + 10;

set <pair <int, int>> diag[MAXD];

void solve() {
    int n, d;
    cin >> n >> d;
    
    vector <int> x(n), y(n);
    for (int i = 0; i < n; i++) {
        cin >> x[i] >> y[i];
        x[i] += MAXC;
        y[i] += MAXC;
    }
    
    bool found = false;
    {
        for (int i = 0; i < n; i++) {
            diag[x[i] + y[i]].insert({x[i], i});
        }
        for (int i = 0; i < n; i++) {
            auto it1 = diag[x[i] + y[i]].lower_bound({x[i] + d / 2, -1});
            if (it1 == diag[x[i] + y[i]].end() || it1->first != x[i] + d / 2) continue;
            if (x[i] + y[i] + d < MAXD) {
                auto it2 = diag[x[i] + y[i] + d].lower_bound({x[i] + d / 2, -1});
                if (it2 != diag[x[i] + y[i] + d].end() && it2->first <= it1->first + d / 2) {
                    cout << i + 1 << " " << it1->second + 1 << " " << it2->second + 1 << "\n";
                    found = true;
                    break;
                }
            }
            if (x[i] + y[i] - d >= 0) {
                auto it2 = diag[x[i] + y[i] - d].lower_bound({x[i] - d / 2, -1});
                if (it2 != diag[x[i] + y[i] - d].end() && it2->first <= it1->first - d / 2) {
                    cout << i + 1 << " " << it1->second + 1 << " " << it2->second + 1 << "\n";
                    found = true;
                    break;
                }
            }
        }
        for (int i = 0; i < n; i++) {
            diag[x[i] + y[i]].erase({x[i], i});
        }
    }
    if (!found) {
        for (int i = 0; i < n; i++) {
            y[i] -= 2 * MAXC;
            diag[x[i] - y[i]].insert({x[i], i});
        }
        for (int i = 0; i < n; i++) {
            auto it1 = diag[x[i] - y[i]].lower_bound({x[i] + d / 2, -1});
            if (it1 == diag[x[i] - y[i]].end() || it1->first != x[i] + d / 2) continue;
            if (x[i] - y[i] + d < MAXD) {
                auto it2 = diag[x[i] - y[i] + d].lower_bound({x[i] + d / 2, -1});
                if (it2 != diag[x[i] - y[i] + d].end() && it2->first <= it1->first + d / 2) {
                    cout << i + 1 << " " << it1->second + 1 << " " << it2->second + 1 << "\n";
                    found = true;
                    break;
                }
            }
            if (x[i] - y[i] - d >= 0) {
                auto it2 = diag[x[i] - y[i] - d].lower_bound({x[i] - d / 2, -1});
                if (it2 != diag[x[i] - y[i] - d].end() && it2->first <= it1->first - d / 2) {
                    cout << i + 1 << " " << it1->second + 1 << " " << it2->second + 1 << "\n";
                    found = true;
                    break;
                }
            }
        }
        for (int i = 0; i < n; i++) {
            diag[x[i] - y[i]].erase({x[i], i});
        }
    }
    if (!found) {
        cout << "0 0 0\n";
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1979D
Editorial Content:
1979D - Fixing a Binary String
Solution
Let's consider the block of characters at the end. Notice that their quantity cannot decrease. Let $$$x$$$ be the number of identical characters at the end; there are three possible cases:
$$$x = k$$$ — it is enough to find any block of length greater than $$$k$$$ and separate a block of length $$$k$$$ from it;
$$$x > k$$$ — obviously, there is no solution;
$$$x < k$$$ — find a block of length $$$k - x$$$ or $$$2k - x$$$ and separate a block of length $$$k - x$$$ from it.
This solution works in $$$O(n)$$$, but it is not the only correct one. Your solution may differ significantly from the one proposed.
Code
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        
        string s;
        cin >> s;
        
        int x = 0;
        for (int i = n - 1; i >= 0; i--) {
            if (s[i] == s[n - 1]) {
                x++;
            } else {
                break;
            }
        }
        
        auto check = [&]() {
            for (int i = 0; i < k; i++) {
                if (s[i] != s[0]) return false;
            }
            for (int i = 0; i + k < n; i++) {
                if (s[i] == s[i + k]) return false;
            }
            return true;
        };
        
        auto operation = [&](int p) {
            reverse(s.begin(), s.begin() + p);
            s = s.substr(p, (int)s.size() - p) + s.substr(0, p);
            if (check()) {
                cout << p << "\n";
            } else {
                cout << -1 << "\n";
            }
        };
        
        if (x == k) {
            int p = n;
            for (int i = n - 1 - k; i >= 0; i--) {
                if (s[i] == s[i + k]) {
                    p = i + 1;
                    break;
                }
            }
            operation(p);
        } else if (x > k) {
            cout << -1 << "\n";
        } else {
            bool was = false;
            for (int i = 0; i < n; i++) {
                if (s[i] != s.back()) continue;
                int j = i;
                while (j + 1 < n && s[i] == s[j + 1]) {
                    j++;
                }
                if (j - i + 1 + x == k) {
                    operation(j + 1);
                    was = true;
                    break;
                } else if (j - i + 1 - k + x == k) {
                    operation(i + k - x);
                    was = true;
                    break;
                }
                i = j;
            }
            if (!was) {
                operation(n);
            }
        }
    }
}
--------------------------------------------------
Problem ID: 1979C
Editorial Content:
1979C - Earning on Bets
Hint
Try to come up with a condition for the existence of an answer.
Solution
Let $$$S$$$ be the total amount of coins placed on all possible outcomes. Then, if the coefficient for winning is $$$k_i$$$, we have to place
more
than $$$\frac{S}{k_i}$$$ on this outcome.
We can obtain the following inequality:
$$$\sum_{i = 1}^n \frac{S}{k_i} < S.$$$
Dividing both sides by $$$S$$$, we obtain the necessary and sufficient condition for the existence of an answer:
$$$\sum_{i = 1}^n \frac{1}{k_i} < 1.$$$
This check can be performed by reducing all fractions to a common denominator. Notice that the numerators of the reduced fractions correspond to the required bets on the outcomes.
Code
#include <bits/stdc++.h>
using namespace std;

#define int long long

int gcd(int a, int b) {
    while (b != 0) {
        int tmp = a % b;
        a = b;
        b = tmp;
    }
    return a;
}
int lcm(int a, int b) {
    return a * b / gcd(a, b);
}

void solve() {
    int n;
    cin >> n;
    
    vector <int> k(n);
    for (int i = 0; i < n; i++) {
        cin >> k[i];
    }
    
    int z = 1;
    for (int i = 0; i < n; i++) {
        z = lcm(z, k[i]);
    }
    
    int suma = 0;
    for (int i = 0; i < n; i++) {
        suma += z / k[i];
    }
    
    if (suma < z) {
        for (int i = 0; i < n; i++) {
            cout << z / k[i] << " ";
        }
        cout << "\n";
    } else {
        cout << -1 << "\n";
    }
}

signed main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1979B
Editorial Content:
1979B - XOR Sequences
Hint
Look at samples.
Solution
Consider two numbers $$$v$$$ and $$$u$$$ such that $$$x \oplus v = y \oplus u$$$. Then consider the numbers $$$x \oplus (v + 1)$$$ and $$$y \oplus (u + 1)$$$. Let's look at the last bit of $$$v$$$ and $$$u$$$. Possible scenarios:
Both bits are equal to $$$0$$$ — adding one will change the bits at the same positions, therefore $$$x \oplus (v + 1) = y \oplus (u + 1)$$$;
Both bits are equal to $$$1$$$ — adding one will change the bits at the same positions and also add one to the next bit, therefore we can similarly consider the next bit;
Bits are different — adding one to the zero bit will only change one bit, while the subsequent bit of the other number will be changed. This means that $$$x \oplus (v + 1) \neq y \oplus (u + 1)$$$.
It is clear that we need to maximize the number of zeros in the maximum matching suffix of $$$u$$$ and $$$v$$$. Obviously, this number is equal to the maximum matching suffix of $$$x$$$ and $$$y$$$. Let $$$k$$$ be the length of the maximum matching suffix of $$$x$$$ and $$$y$$$, then the answer is $$$2^k$$$.
This can be calculated in $$$O(\log C)$$$ time for one test case, where $$$C$$$ is the limit on $$$x$$$ and $$$y$$$.
Code
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int a, b;
        cin >> a >> b;
        
        for (int i = 0; i < 30; i++) {
            if ((a & (1 << i)) != (b & (1 << i))) {
                cout << (1ll << i) << "\n";
                break;
            }
        }
    }
}
--------------------------------------------------
Problem ID: 1979A
Editorial Content:
1979A - Guess the Maximum
Solution
Let $$$m$$$ be the maximum among the numbers $$$a_i, a_{i + 1},\ldots, a_j$$$. Notice that there always exists such $$$k$$$ that $$$i \le k < j$$$ and $$$a_k = m$$$ or $$$a_{k + 1} = m$$$. Therefore, we can assume that Bob always chooses the pair of numbers $$$p$$$ and $$$p + 1$$$ ($$$1 \le p < n$$$) as $$$i$$$ and $$$j$$$.
Therefore you need to consider the maximums in pairs of adjacent elements and take the minimum among them. Let $$$min$$$ be the found minimum, then it is obvious that the answer is equal to $$$min - 1$$$.
Code
#include <iostream>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        int a[n];
        for (int& i : a) {
            cin >> i;
        }
        int mini = max(a[0], a[1]);
        for (int i = 1; i < n - 1; i++) {
            mini = min(mini, max(a[i], a[i + 1]));
        }
        cout << mini - 1 << "\n";
    }
}
--------------------------------------------------
Problem ID: 1978F
Editorial Content:

--------------------------------------------------
Problem ID: 1978E
Editorial Content:

--------------------------------------------------
Problem ID: 1978D
Editorial Content:

--------------------------------------------------
Problem ID: 1978C
Editorial Content:

--------------------------------------------------
Problem ID: 1978B
Editorial Content:

--------------------------------------------------
Problem ID: 1978A
Editorial Content:

--------------------------------------------------
Problem ID: 1977E
Editorial Content:
1977E - Tensor
1977E - Tensor
Tutorial
First, let's understand why 2 colors are indeed sufficient.
Notice that the reachability relation in a graph defines a
Partially Ordered Set
.
According to
Dilworth's Theorem
, the size of the maximum antichain is equal to the minimum number of chains that cover the Partially Ordered Set.
Note that the condition on the reachability of pairs of vertices within any triplet implies a constraint on the maximum size of the antichain. It is simply no more than 2. Therefore, 2 colors are indeed sufficient.
The remaining task is to understand how to explicitly construct these 2 chains.
We will build this inductively. Let's maintain 3 stacks — the last vertices painted in black, white, and red respectively. These will correspond to the chains we are building.
Suppose we have built chains on $$$n$$$ vertices and want to build them on $$$n + 1$$$:
If the white or black stacks are empty, simply add vertex $$$n+1$$$ to the empty stack.
If the red stack is empty:
Ask about the reachability of the last vertices in the white and black stacks from vertex $$$n+1$$$.
If both vertices are reachable, put vertex $$$n+1$$$ in the red stack.
If only one vertex is reachable, put vertex $$$n+1$$$ in the stack whose last vertex is reachable from $$$n+1$$$.
The case where neither vertex is reachable is impossible as it contradicts the condition.
If the red stack is not empty:
Ask about the reachability of the last vertex in the red stack from vertex $$$n+1$$$.
If it is reachable, put it in the red stack.
If it is not reachable, ask about the end of the white stack.
If the vertex at the end of the white stack is not reachable, then the vertex at the end of the black stack must be reachable, otherwise, it contradicts the problem's condition.
Color vertex $$$n+1$$$ black if the black vertex is reachable or white if the white vertex is reachable.
Recolor all vertices in the red stack to the opposite color relative to vertex $$$n+1$$$. We can do this because, by construction, all vertices in the white and black stacks are reachable from all vertices in the red stack.
Do not forget to clear the red stack.
Each time a new vertex is added, no more than 2 queries are used. Therefore, we will use no more than $$$2 \cdot n$$$ queries in total.
During the algorithm, all operations are performed in $$$O(1)$$$ time, resulting in an overall complexity of $$$O(n)$$$.
As an exercise for the reader, try to prove the lower bound on the number of queries.
Author's code
#include "bits/stdc++.h"
 
#define err(x) cerr << "["#x"]  " << (x) << "\n"
#define errv(x) {cerr << "["#x"]  ["; for (const auto& ___ : (x)) cerr << ___ << ", "; cerr << "]\n";}
#define errvn(x, n) {cerr << "["#x"]  ["; for (auto ___ = 0; ___ < (n); ++___) cerr << (x)[___] << ", "; cerr << "]\n";}
#define all(a) a.begin(), a.end()
#define pb push_back
typedef long long ll;
typedef long double ld;
using namespace std;
const int MOD = 1000000007;
mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());
 
template<typename T1, typename T2>
inline bool relaxmi(T1 &a, const T2 &b) {
    return a > b ? a = b, true : false;
}
 
template<typename T1, typename T2>
inline bool relaxma(T1 &a, const T2 &b) {
    return a < b ? a = b, true : false;
}
 
double GetTime() { return clock() / (double) CLOCKS_PER_SEC; }
 
/// Actual code starts here
const int N = 100005;
 
bool ask(int i, int j) {
    cout << "? " << j << ' ' << i << endl;
    string resp;
    cin >> resp;
    if (resp == "-1") assert(false);
    if (resp == "YES") return true;
    else return false;
}
 
void solve() {
    int n;
    cin >> n;
    vector<int> st, st2, st3;
    st = {1};
    for (int i = 2; i <= n; i++) {
        if (st2.empty()) {
            if (ask(i, st.back())) {
                st.push_back(i);
            } else {
                st2.push_back(i);
            }
        } else if (st3.empty()) {
            int ok1 = ask(i, st.back()), ok2 = ask(i, st2.back());
            if (ok1 && ok2) {
                st3.push_back(i);
            } else if (ok1) {
                st.push_back(i);
            } else if (ok2) {
                st2.push_back(i);
            } else {
                assert(false);
            }
        } else {
            if (ask(i, st3.back())) {
                st3.push_back(i);
            } else {
                if (ask(i, st.back())) {
                    st.push_back(i);
                    for (auto j: st3)
                        st2.push_back(j);
                    st3.clear();
                } else {
                    st2.push_back(i);
                    for (auto j: st3)
                        st.push_back(j);
                    st3.clear();
                }
            }
        }
    }
    if (!st3.empty()) {
        for (auto i: st3)
            st.push_back(i);
        st3.clear();
    }
    vector<int> colors(n + 1);
    for (auto i: st2)
        colors[i] = 1;
    cout << "! ";
    for (int i = 1; i <= n; i++) cout << colors[i] << ' ';
    cout << endl;
}
 
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int tt = 1;
    cin >> tt;
    while (tt--)
        solve();
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1977D
Editorial Content:
1977D - XORificator
1977D - XORificator
Hint
Try to fix the specialty of column $$$i$$$ and the presence of a one in cell $$$i, j$$$.
Tutorial
Let's assume that the value in the $$$i$$$-th row and $$$j$$$-th column is strictly one and it is the only one in the column.
Then the entire table is uniquely determined, as well as the XORificator. For each possible state of the XORificator that constructs the required table,
Let's maintain a counter. Then the state that maximizes the number of columns with exactly one 1 has the maximum counter.
To efficiently maintain the counter, it is necessary to maintain the hash of the XORificator and quickly recalculate it when moving to the next row.
The answer can be easily reconstructed by traversing the table again and counting the hash. If the desired hash is obtained, simply output the state of the XORificator.
The final time complexity is $$$O(nm \log{(nm)})$$$ or $$$O(nm)$$$ if a hash map is used.
For hashing, it is convenient to use
Zobrist hashing
.
Author's code
#include "bits/stdc++.h"
 
using namespace std;
 
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
 
void solve() {
    int n, m;
    cin >> n >> m;
    vector<vector<bool>> table(n, vector<bool>(m));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            char c;
            cin >> c;
            table[i][j] = c - '0';
        }
    }
    vector<long long> rands(n), rands2(n);
    for (int i = 0; i < n; ++i) {
        rands[i] = rnd();
        rands2[i] = rnd();
    }
    map<pair<long long, long long>, int> ans;
    int res = 0;
    pair<int, int> ind_ans = {0, 0};
    for (int j = 0; j < m; ++j) {
        long long summ = 0, summ2 = 0;
        for (int i = 0; i < n; ++i) {
            if (table[i][j]) {
                summ ^= rands[i];
                summ2 ^= rands2[i];
            }
        }
        for (int i = 0; i < n; ++i) {
            summ ^= rands[i];
            summ2 ^= rands2[i];
            ans[{summ, summ2}]++;
            if (res < ans[{summ, summ2}]) {
                res = ans[{summ, summ2}];
                ind_ans = {j, i};
            }
            summ ^= rands[i];
            summ2 ^= rands2[i];
        }
    }
    cout << res << "\n";
    string inds(n, '0');
    for (int i = 0; i < n; ++i) {
        if (table[i][ind_ans.first]) {
            if (i != ind_ans.second) {
                inds[i] = '1';
            }
        } else if (ind_ans.second == i) {
            inds[i] = '1';
        }
    }
    cout << inds << "\n";
}
 
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int tt = 1;
    cin >> tt;
    while (tt--) {
        solve();
    }
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1977C
Editorial Content:
1977C - Nikita and LCM
1977C - Nikita and LCM
Hint
Try to check if the entire array $$$a$$$ can be the answer.
Tutorial
First, let's understand if we can take the entire array $$$a$$$ as the special subsequence.
To do this, find the LCM($$$a_1, a_2, \dots, a_n$$$). If it is greater than max($$$a_1, a_2, \dots, a_n$$$), then obviously such a number is not in the subsequence, because $$$LCM \geq max$$$.
After this check, it becomes known that each $$$a_i \ | \ max(a_1, a_2, \dots, a_n)$$$.
Then we iterate over the divisors of the maximum and greedily check for the presence of a subsequence with such an LCM.
If we do this naively, it will be $$$O(\sqrt{C} + n \cdot d(C) \cdot \log(C))$$$, but this is already sufficient.
Note that we can count the occurrence of each number and check only the distinct numbers. Then the complexity will be $$$O(\sqrt{C} + d(C)^2 \cdot \log(C))$$$.
Author's code
#include "bits/stdc++.h"
 
#define err(x) cerr << "["#x"]  " << (x) << "\n"
#define errv(x) {cerr << "["#x"]  ["; for (const auto& ___ : (x)) cerr << ___ << ", "; cerr << "]\n";}
#define errvn(x, n) {cerr << "["#x"]  ["; for (auto ___ = 0; ___ < (n); ++___) cerr << (x)[___] << ", "; cerr << "]\n";}
#define all(a) a.begin(), a.end()
#define pb push_back
typedef long long ll;
typedef long double ld;
using namespace std;
const int MOD = 1000000007;
mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());
 
template<typename T1, typename T2>
inline bool relaxmi(T1 &a, const T2 &b) {
    return a > b ? a = b, true : false;
}
 
template<typename T1, typename T2>
inline bool relaxma(T1 &a, const T2 &b) {
    return a < b ? a = b, true : false;
}
 
double GetTime() { return clock() / (double) CLOCKS_PER_SEC; }
 
/// Actual code starts here
const int N = 100005;
 
int calc(vector<pair<int, int>> &t, int d) {
    int LCM = 0, cnt = 0;
    for (auto [j, c]: t) {
        if (d % j == 0) {
            if (LCM == 0) LCM = j;
            else LCM = lcm(LCM, j);
            cnt += c;
        }
    }
    if (LCM != d) cnt = 0;
    return cnt;
}
 
void solve() {
    int n;
    cin >> n;
    vector<int> v(n);
    for (auto &i: v) cin >> i;
    ll LCM = 1;
    int mx = *max_element(all(v));
    for (auto i: v) {
        LCM = lcm(LCM, i);
        if (LCM > mx) {
            cout << n << '\n';
            return;
        }
    }
    map<int, int> cnt;
    for (auto i: v) cnt[i]++;
    vector<pair<int, int>> t;
    for (auto i: cnt)
        t.push_back(i);
    int res = 0;
    for (int i = 1; i * i <= mx; i++) {
        if (mx % i == 0) {
            if (!cnt.contains(i))
                relaxma(res, calc(t, i));
            if (!cnt.contains(mx / i))
                relaxma(res, calc(t, mx / i));
        }
    }
    cout << res << '\n';
}
 
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int tt = 1;
    cin >> tt;
    while (tt--)
        solve();
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1977B
Editorial Content:
1977B - Binary Colouring
1977B - Binary Colouring
Tutorial
We will iterate over the prefix of $$$i$$$ bits and construct a correct answer for the number formed by the prefix bits of the number $$$x$$$. We are interested in considering only the one bits, as they are the only ones that affect the value of the number $$$x$$$.
If we have already placed a one at position $$$i$$$ in the answer, we need to somehow add $$$2^i$$$ to the number. To do this, we simply zero out the $$$i$$$-th bit in the answer and set it at $$$i + 1$$$ — this will add $$$2 \cdot 2^i = 2^{i+1}$$$.
Now, the $$$i$$$-th position in the answer holds $$$0$$$.
Let's consider what we placed at position $$$i-1$$$ in the answer. If it's $$$0$$$, then everything is fine; we just place $$$1$$$ at position $$$i$$$. If it's $$$1$$$, we have a situation of [1 1], which we correct by making it [-1 0 1] — placing $$$-1$$$ at $$$i-1$$$, leaving $$$0$$$ at $$$i$$$, and placing $$$1$$$ at $$$i+1$$$. This will add $$$2^i$$$ to the sum because $$$2^i + 2^{i-1} = 2^{i+1} - 2^{i-1}$$$. The remaining case is when $$$i-1$$$ holds $$$-1$$$, but this is impossible because our forward operations only place ones, and $$$-1$$$ is placed behind.
The final time complexity is $$$O(\log(x))$$$ per test case.
Author's code
#include "bits/stdc++.h"

#define all(a) a.begin(), a.end()
#define pb push_back
typedef long long ll;
using namespace std;
mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());
 
/// Actual code starts here
const int N = 100005;
 
void solve() {
    ll x;
    cin >> x;
    vector<int> res(31, 0);
    for (int i = 0; i < 30; i++) {
        if (1ll & (x >> i)) {
            if (res[i]) {
                res[i + 1] = 1;
                res[i] = 0;
            } else if (i > 0) {
                if (res[i - 1] == 1) {
                    res[i + 1] = 1;
                    res[i - 1] = -1;
                } else {
                    res[i] = 1;
                }
            } else if (i == 0) {
                res[i] = 1;
            }
        }
    }
    cout << 31 << '\n';
    for (int i = 0; i <= 30; i++) {
        cout << res[i] << ' ';
    }
    cout << '\n';
}
 
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int tt = 1;
    cin >> tt;
    while (tt--)
        solve();
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1977A
Editorial Content:
1977A - Little Nikita
1977A - Little Nikita
Tutorial
Note that one action with the cube changes the parity of the number of cubes in the tower. Therefore, if the parities of $$$n$$$ and $$$m$$$ do not match, it is impossible to build the tower. Also, if $$$n < m$$$, the tower cannot be built either. In all other cases, it is possible to build a tower of height $$$m$$$ in $$$m$$$ operations, and then add and remove a cube until the operations are exhausted.
Author's code
#include <bits/stdc++.h>
using namespace std;
 
int main () {
  ios_base::sync_with_stdio(0); cin.tie(0);
  int T;
  cin >> T;
  while (T--) {
    int n, m;
    cin >> n >> m;
    cout << (n >= m && (n%2) == (m%2) ? "Yes" : "No") << '\n';
  }
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1976F
Editorial Content:
1976F - Remove Bridges
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
using namespace std;
 
vector<int> h;
vector<vector<int>> g;
 
void dfs(int v, int p = -1){
	for (int u : g[v]) if (u != p){
		dfs(u, v);
		h[v] = max(h[v], h[u] + 1);
	}
}
 
int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	int t;
	cin >> t;
	while (t--){
		int n;
		cin >> n;
		g.assign(n, {});
		forn(i, n - 1){
			int v, u;
			cin >> v >> u;
			--v, --u;
			g[v].push_back(u);
			g[u].push_back(v);
		}
		h.assign(n, 0);
		dfs(0);
		set<pair<int, int>> cur;
		forn(i, n) cur.insert({h[i], i});
		vector<int> ans;
		int tmp = n;
		while (!cur.empty()){
			int v = cur.rbegin()->second;
			while (v != -1){
				--tmp;
				cur.erase({h[v], v});
				int pv = -1;
				for (int u : g[v]) if (h[u] == h[v] - 1){
					pv = u;
					break;
				}
				v = pv;
			}
			ans.push_back(tmp);
		}
		for (int i = 0; i < int(ans.size()); i += 2){
			cout << ans[i] << ' ';
		}
		for (int i = (int(ans.size()) + 1) / 2; i < n - 1; ++i){
			cout << 0 << ' ';
		}
		cout << '\n';
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1976E
Editorial Content:
1976E - Splittable Permutations
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
const int N = 300043;
const int MOD = 998244353;
 
int add(int x, int y)
{
	x += y;
	while(x >= MOD) x -= MOD;
	while(x < 0) x += MOD;
	return x;
}
 
int mul(int x, int y)
{
	return (x * 1ll * y) % MOD;
}
 
int nxt[N], prv[N];
bool exists[N];
 
int main()
{
	int n, q;
	scanf("%d %d", &n, &q);
	for(int i = 1; i <= n; i++) nxt[i] = prv[i] = -1;
	exists[n] = true;
	vector<int> l(q), r(q);
	for(int i = 0; i < q; i++) scanf("%d", &l[i]);
	for(int i = 0; i < q; i++) scanf("%d", &r[i]);
	for(int i = 0; i < q; i++)
	{
		int L = l[i], R = r[i];
		if(exists[L])
		{
			exists[R] = true;
			nxt[R] = nxt[L];
			if(nxt[R] != -1) prv[nxt[R]] = R;
			prv[R] = L;
			nxt[L] = R;
		}
		else
		{
			exists[L] = true;
			prv[L] = prv[R];
			if(prv[L] != -1) nxt[prv[L]] = L;
			nxt[L] = R;
			prv[R] = L;
		}
	}
	vector<int> seq;
	int start = -1;
	for(int i = 1; i <= n; i++)
		if(prv[i] == -1 && exists[i])
			start = i;
	seq.push_back(start);
	while(nxt[start] != -1)
	{
		start = nxt[start];
		seq.push_back(start);
	}
	vector<int> cnt_segments(n + 1);
	cnt_segments[seq[0]]++;
	cnt_segments[seq[q]]++;
	for(int i = 0; i < q; i++)
		cnt_segments[max(seq[i], seq[i + 1])]++;
	int ans = 1;
	int places = 0;
	for(int i = n; i >= 1; i--)
	{
		if(exists[i])
			places += cnt_segments[i];
		else
		{
			ans = mul(ans, places);
			places++;
		}
	}
	printf("%d\n", ans);
}
--------------------------------------------------
Problem ID: 1976D
Editorial Content:
1976D - Invertible Bracket Sequences
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  int t;
  cin >> t;
  while (t--) {
    string s;
    cin >> s;
    map<int, int> cnt;
    int b = 0;
    ++cnt[b];
    long long ans = 0;
    for (auto& c : s) {
      b += (c == '(' ? +1 : -1);
      ans += cnt[b];
      ++cnt[b];
      while (cnt.begin()->first * 2 < b)
        cnt.erase(cnt.begin());
    }
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1976C
Editorial Content:
1976C - Job Interview
Tutorial
Tutorial is loading...
Solution (BledDest)
for _ in range(int(input())):
    n, m = map(int, input().split())
    bounds = [n, m]
    a = []
    a.append(list(map(int, input().split())))
    a.append(list(map(int, input().split())))
    
    bad = -1
    badType = -1
    cur = [0, 0]
    ans = 0
    types = [0 for i in range(n + m + 1)]
    for i in range(n + m):
        curType = 0
        if a[0][i] < a[1][i]:
            curType = 1
        if cur[curType] == bounds[curType]:
            curType = 1 - curType
            if bad == -1:
                bad = i
                badType = 1 - curType
        types[i] = curType
        ans += a[types[i]][i]
        cur[types[i]] += 1
        
    res = []
    for i in range(n + m):
        val = ans - a[types[i]][i]
        if bad != -1 and i < bad and types[i] == badType:
            val = val + a[badType][bad] - a[1 - badType][bad] + a[1 - badType][n + m]
        else:
            val = val + a[types[i]][n + m]
        res.append(val)
    res.append(ans)
    print(*res)
--------------------------------------------------
Problem ID: 1976B
Editorial Content:
1976B - Increase/Decrease/Copy
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
using li = long long;
 
int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<li> a(n), b(n + 1);
    for (auto& x : a) cin >> x;
    for (auto& x : b) cin >> x;
    li sum = 0, ext = 1e18;
    for (int i = 0; i < n; ++i) {
      sum += abs(a[i] - b[i]);
      ext = min(ext, abs(a[i] - b[n]));
      ext = min(ext, abs(b[i] - b[n]));
      if (min(a[i], b[i]) <= b[n] && b[n] <= max(a[i], b[i]))
        ext = 0;
    }
    cout << sum + ext + 1 << '\n';
  }
}
--------------------------------------------------
Problem ID: 1976A
Editorial Content:
1976A - Verify Password
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	n = int(input())
	s = input()
	print("YES" if list(s) == sorted(s) else "NO")
--------------------------------------------------
Problem ID: 1975I
Editorial Content:
1975I - Mind Bloom
Hint 0
Play "Slay the Spire". Unfortunately, it doesn't help much.
Hint 1
It may be helpful to calculate the probability that your hand becomes empty instead of the probability that the draw pile becomes empty.
Hint 2
The intended solution is a $$$O(n^5)$$$ DP. The constant factor is small enough to run.
Solution
If all the cards in your hand is $$$0$$$, you immediately lose. Therefore, we only need to consider whether we can empty our hand by playing cards with non-$$$0$$$ value.
Consider a sequence of playing cards that will lead to use losing. The sum over the probabilities of all these losing sequences is the probability of us losing.
To simplify the process, we will consider drawing $$$x$$$ random cards from the deck as drawing a random card from the deck $$$x$$$ times.
Consider a sequence of played cards as $$$z_1, z_2, \ldots, z_k$$$ where $$$z_i$$$ is the index of the card played. Consider how $$$z_i$$$ was drawn into our hand. It is not hard to see that either:
$$$z_i$$$ was in our hand at the start
$$$z_i$$$ from drawn from card $$$a_j$$$ where $$$j$$$ is the maximum index such that $$$z_j \leq z_i$$$ and $$$j < i$$$.
From our previous observation, we can motivate the following range DP. Let $$$f(i,0/1,u,p,x)$$$ denote the a sequence of played cards with the following:
the minimum index of a card we played is $$$i$$$
whether there are any cards with value greater than $$$i$$$ that is one of the cards that were in our hand in the start
before we played this sequence, we played a card of value $$$u$$$
before we played this sequence, the deck has $$$p$$$ cards
The
net
number of cards that we draw is $$$x$$$
We will use $$$g(i,0/1,u,p,x)$$$ to help us transition quickly. It is defined as the suffix sum (on dimension $$$i$$$) of $$$f$$$.
Consider transitioning based on the card of index $$$i$$$.
We have the following transition for $$$f(*,0,*,*,*)$$$:
$$$f(i, 0, u, p, x) = \sum_{y=0}^{x-(c_i-1)} g(i+1, 0, u, p, y) \times g(i, 0, c_i, p - (c_i - 1) - y, x - (c_i - 1) - y) \times \frac {u+y} {(p-y+1)^{\underline c_i}}$$$
$$$g(i, 0, u, p, x) = g(i+1, 0, u, p, x) + f(i, 0, u, p, x)$$$
For $$$f(*,1,*,*,*)$$$, To handle the fact that there are some cards that are initially in our hands, let $$$h$$$ denote the the number of $$$j>i$$$ such that $$$s_j=1$$$.
If $$$s_i = 1$$$, we have the following transitions:
$$$f(i, 1, u, p, x) = \sum_{y=h}^{x-c_i} g(i+1, 1, u, p, y) \times g(i, 0, c_i, p - (c_i - 1) - y+h, x - c_i - y) \times \frac {1} {(p-y+1+h)^{\underline c_i}}$$$
$$$g(i, 1, u, p, x) = f(i, 1, u, p, x)$$$
If $$$s_i = 0$$$, we have the following transitions:
$$$f(i, 1, u, p, x) = \sum_{y=h}^{x-(c_i-1)} g(i+1, 1, u, p, y) \times g(i, 0, c_i, p - (c_i - 1) - y+h, x - (c_i - 1) - y) \times \frac {u+y} {(p-y+1+h)^{\underline c_i}}$$$
$$$g(i, 1, u, p, x) = g(i+1, 1, u, p, x) + f(i, 1, u, p, x)$$$
The time complexity is $$$O(n^5)$$$.
Now consider adding the cards with value $$$1$$$. It is possible that our game never terminates when we keep on drawing cards with value $$$1$$$. We will instead force that when we play a card of value $$$1$$$, we are not allowed to draw a card of value $$$1$$$. It is not hard to observe that the answer will not change.
Consider $$$dp(i,x)$$$ to be the probability that we have in our hand:
$$$i$$$ card of value $$$0$$$
$$$x$$$ card of value $$$1$$$
It is not hard to observe that for the initial state, $$$dp(i, o+x)$$$ is $$$g(1, 1, i+x, 0, m) \times \binom {i+x} i \times (m-o)^{\underline x}$$$.
Next, consider the transitions. There are only two cases, we draw a card with value $$$0$$$, or a card with value greater than $0$：
$$$dp(i, x) \times \frac 1 {w+k-i}\rightarrow dp(i + 1, x - 1)$$$
$$$\forall j+y>1, dp(i, x) \times g(1, 0, 1, n-d-i-x,j+y-1) \times \frac 1 {w+k-i} \times \binom {j+y} j \times (m-x+1)^{\underline y}\rightarrow dp(i+j, x+y-1)$$$
Finally, the answer is $$$\sum_{i=0}^k dp(i, 0) \times k^{\underline i}$$$.
The time complexity is $$$O(n^4)$$$.
Therefore, the total complexity is $$$O(n^5)$$$. If we use FFT, it can be $$$O(n^4 \log n)$$$, but it was not required in our solution and would probably make the code slower.
Furthermore, we can record $$$v$$$ instead of $$$u$$$, which means there are $$$v$$$ cards with $$$i$$$ or greater index drawn from $$$u$$$ draws. So it's not difficult to find $$$v \leq u $$$. And when $$$c_i \leq \sqrt n $$$, we have $$$v \leq u \leq c_i \leq \sqrt n $$$. And when $$$c_i > \sqrt n $$$, we have $$$v \leq \frac n {c_i - 1} \leq \sqrt n $$$, the complexity can become $$$O (n ^ {4.5}) $$$. If we use FFT, it can be $$$O (n ^ {3.5} \log n) $$$.
Let $$$k$$$ be the number of cards with value $$$0$$$. It is not hard to see that:
the size of $$$i$$$ is $$$n-k$$$
the size of $$$x$$$ is $$$k$$$
the size of $$$u$$$ is $$$n-k$$$
the size of $$$p$$$ is $$$n$$$
The number of states is $$$(n-k)^2k^2n$$$, which has a constant of $$$\frac{1}{16}$$$. We also have that $$$y \leq x$$$ and $$$u \leq c_i$$$, which both gives us another constant of $$$\frac{1}{2}$$$. Since we have a flag in our dp state, it has a factor of $$$2$$$. This gives us a constant factor of rougly $$$\frac{1}{32}$$$, which is extremely small. So it is reasonable to expect $$$O(n^5)$$$ to run about $$$1$$$ second.
Code
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;

const ll N = 120 + 5, Mod = 1e9 + 7;

inline ll power(ll x, ll y){
	ll ret = 1;
	while(y){
		if(y & 1) ret = ret * x % Mod;
		x = x * x % Mod, y >>= 1;
	}
	return ret;
}

inline ll inv(ll x){
	return power(x, Mod - 2);
}

ll n = 0, m = 0, w = 0, o = 0, d = 0, r = 0, k = 0, c[N] = {}, v[N] = {};
ll iv[N] = {}, a[N][N] = {}, b[N][N] = {}, binom[N][N] = {};
ll f[2][2][N][N][N] = {}, g[2][2][N][N][N] = {}, dp[N][N] = {};
char s[N] = {};

inline void init(){
	n = m = w = o = d = r = k = 0;
	memset(c, 0, sizeof(c)), memset(v, 0, sizeof(v)), memset(s, 0, sizeof(s));
	memset(f, 0, sizeof(f)), memset(g, 0, sizeof(g)), memset(dp, 0, sizeof(dp));
}

inline void solve(){
	scanf("%lld", &n);
	v[0] = v[1] = 1;
	for(ll i = 1 ; i <= n ; i ++){
		scanf("%lld", &c[i]);
		v[c[i]] = 1;
	}
	scanf("%s", s + 1);
	for(ll i = 1 ; i <= n ; i ++){
		if(s[i] == '0') r ++;
		if(c[i] > 1) w ++;
		else if(c[i] == 1){
			if(s[i] == '1') o ++;
			m ++;
		}
		else{
			if(s[i] == '1') d ++;
			else k ++;
		}
	}
	if(c[n] <= 1){
		for(ll i = 1 ; i <= n ; i ++) if(s[i] == '0'){
			printf("0\n");
			return;
		}
		printf("1\n");
		return;
	}
	for(ll p = 0 ; p <= n ; p ++) for(ll u = 0 ; u <= c[n] ; u ++) if(v[u]){
		f[1][0][u][p][0] = f[1][1][u][p][0] = 1;
		g[1][0][u][p][0] = g[1][1][u][p][0] = 1;
	}
	for(ll i = n, h = 0 ; c[i] > 1 ; i --){
		for(ll p = 0 ; p <= n ; p ++) for(ll u = 0 ; u <= c[i] ; u ++) if(v[u]){
			g[0][0][u][p][0] = 1;
			if(s[i] == '0') g[0][1][u][p][0] = g[1][1][u][p][0];
		}
		for(ll p = 0 ; p <= n ; p ++) for(ll u = 0 ; u <= c[i] ; u ++) if(v[u]) for(ll x = 1 ; x <= k ; x ++){
			for(ll y = 0 ; y <= x - (c[i] - 1) ; y ++) f[0][0][u][p][x] = (f[0][0][u][p][x] + (g[1][0][u][p][y] * g[0][0][c[i]][p - (c[i] - 1) - y][x - (c[i] - 1) - y] % Mod) * ((u + y) * b[p - y + 1][c[i]] % Mod)) % Mod;
			g[0][0][u][p][x] = (g[1][0][u][p][x] + f[0][0][u][p][x]) % Mod;
		}
		for(ll p = 0 ; p <= n ; p ++) for(ll u = 0 ; u <= c[i] ; u ++) if(v[u]) for(ll x = 1 ; x <= k ; x ++){
			if(s[i] == '1'){
				for(ll y = h ; y <= x - c[i] ; y ++) f[0][1][u][p][x] = (f[0][1][u][p][x] + (g[1][1][u][p][y] * g[0][0][c[i]][p - (c[i] - 1) - y + h][x - c[i] - y] % Mod) * b[p - y + 1 + h][c[i]]) % Mod;
				g[0][1][u][p][x] = f[0][1][u][p][x];
			}
			else{
				for(ll y = h ; y <= x - (c[i] - 1) ; y ++) f[0][1][u][p][x] = (f[0][1][u][p][x] + (g[1][1][u][p][y] * g[0][0][c[i]][p - (c[i] - 1) - y + h][x - (c[i] - 1) - y] % Mod) * ((u + y) * b[p - y + 1 + h][c[i]] % Mod)) % Mod;
				g[0][1][u][p][x] = (g[1][1][u][p][x] + f[0][1][u][p][x]) % Mod;
			}
		}
		for(ll p = 0 ; p <= n ; p ++) for(ll u = 0 ; u <= c[i] ; u ++) if(v[u]) for(ll x = 0 ; x <= k ; x ++){
			f[1][0][u][p][x] = f[0][0][u][p][x], f[1][1][u][p][x] = f[0][1][u][p][x];
			g[1][0][u][p][x] = g[0][0][u][p][x], g[1][1][u][p][x] = g[0][1][u][p][x];
			f[0][0][u][p][x] = f[0][1][u][p][x] = g[0][0][u][p][x] = g[0][1][u][p][x] = 0;
		}
		if(s[i] == '1') h ++;
	}
	for(ll i = 0 ; i <= k ; i ++) for(ll x = 0 ; x <= m - o ; x ++) dp[i][o + x] = g[1][1][0][r][i + x] * (binom[i + x][i] * a[m - o][x] % Mod) % Mod;
	for(ll i = 0 ; i <= k ; i ++) for(ll x = 1 ; x <= m ; x ++) if(dp[i][x]){
		if(i < k) dp[i + 1][x - 1] = (dp[i + 1][x - 1] + dp[i][x] * iv[w + k - i]) % Mod;
		for(ll j = 0 ; i + j <= k ; j ++) for(ll y = 0 ; x + y - 1 <= m ; y ++) if(j + y > 1) dp[i + j][x + y - 1] = (dp[i + j][x + y - 1] + (dp[i][x] * g[1][0][1][n - d - i - x][j + y - 1] % Mod) * (iv[w + k - i] * (binom[j + y][j] * a[m - x + 1][y] % Mod) % Mod)) % Mod;
	}
	ll ans = 1;
	for(ll i = 0 ; i <= k ; i ++) ans = (ans + (Mod - dp[i][0]) * a[k][i]) % Mod;
	printf("%lld\n", ans);
}

ll T = 0;

int main(){
	for(ll x = 0 ; x < N ; x ++){
		a[x][0] = b[x][0] = 1, iv[x] = inv(x), binom[x][0] = 1;
		for(ll y = 1 ; y <= x ; y ++){
			a[x][y] = a[x][y - 1] * (x - y + 1) % Mod, b[x][y] = inv(a[x][y]);
			binom[x][y] = (binom[x - 1][y - 1] + binom[x - 1][y]) % Mod;
		}
	}
	scanf("%lld", &T);
	for(ll i = 1 ; i <= T ; i ++) init(), solve();
	return 0;
}
Solution
Let $$$ S $$$ denote the set of cards currently in Jellyfish's hand.
We assume that $$$ a_1 = 0 $$$ and $$$ a_n \geq 2 $$$. Initially, $$$ |S| \in [1, n-1] $$$. Cases where these conditions do not hold are trivial.
We observe that Jellyfish cannot empty the draw pile if and only if she runs out of non-zero cards to play. In the following section, we compute the probability that she eventually runs out of non-zero cards.
It is clear that in any scenario where she runs out of non-zero cards, $$$ \max(S) $$$ must gradually decrease to zero. We can break down the entire process into sub-procedures, where in each sub-procedure, $$$ \max(S) $$$ decreases from $$$ i $$$ to $$$ \leq i-1 $$$, ultimately reaching zero.
Assume she is currently in a state where $$$ \max(S) = i $$$ and $$$ |S \setminus {i}| = x $$$. We denote $$$ F_{i,x,y} $$$ as the probability that she will eventually transition to a state where $$$ \max(S) \leq i-1 $$$, and in the very first state where $$$ \max(S) \leq i-1 $$$, the size of $$$ S $$$ is $$$ y $$$.
For a fixed and given pair $$$(i,x)$$$, we aim to compute all values of $$$F_{i,x,y}$$$ simultaneously.
To determine the values of $$$F_{i,x,y}$$$, consider the situation after Jellyfish plays card $$$a_i$$$. For the remaining $$$n-x$$$ cards, each card is equally likely to be one of the $$$a_i$$$ cards drawn. Therefore, for any individual card outside of the initial $$$x$$$ cards, the probability of possessing that card is $$$p = \dfrac{a_i}{n-x}$$$.
We define the initial event where Jellyfish plays card $$$a_i$$$ as the starting point of our timeline. Following this event, we consider $$$n-i+2$$$ key moments when $$$\max(S)$$$ becomes $$$\leq n$$$ for the first time, $$$\leq n-1$$$ for the first time, and so on, down to $$$\leq i+1$$$, $$$\leq i$$$, and finally $$$\leq i-1$$$ for the first time.
We denote $$$G_{j,y}$$$ as the probability that Jellyfish will eventually reach a state where $$$\max(S) \leq j$$$, and in the very first state where $$$\max(S) \leq j$$$, the size of $$$S$$$ is $$$y$$$. Initially, $$$G_{n,x + a_i} = 1$$$.
To understand the transitions of $$$G_{j,y}$$$, note that since all cards $$$\leq j$$$ (excluding the initial $$$x$$$ cards) are symmetrical, the probability of owning card $$$j$$$ is exactly $$$p=\dfrac{y-x}{j-x}$$$.
If Jellyfish does not own card $$$j$$$, then the first state where $$$\max(S) \leq j-1$$$ is simply the first state where $$$\max(S) \leq j$$$. This describes a transition of $$$G_{j-1,y} \leftarrow (1-p)G_{j,y}$$$.
If Jellyfish owns card $$$j$$$, we enumerate the number of cards $$$|S| = z$$$ in her hand when she first reaches $$$\max(S) \leq j-1$$$. The probability of this happening is $$$F_{j,y-1,z}$$$. Thus, we have $$$G_{j-1,z} \leftarrow pG_{j,y}F_{j,y-1,z}$$$.
Here’s a further explanation of why "all cards $$$\leq j$$$ (excluding the initial $$$x$$$ cards) are symmetrical": Because this state is the very first time $$$\max(S) \leq j$$$, it means that all cards played before this state and after Jellyfish initially plays $$$a_i$$$ are $$$\geq j+1$$$. From the perspective of those cards $$$\geq j+1$$$, all cards $$$\leq j$$$ (excluding the initial $$$x$$$ cards) are symmetrical.
In the end, the actual algorithm we derived for computing $$$F_{i,x,y}$$$ is quite straightforward:
Iterate through $$$j$$$ backwards from $$$n$$$ to $$$i$$$.
For each $$$G_{j,y}$$$, make two types of transitions:
$$$G_{j-1,z} \leftarrow pG_{j,y}F_{j,y-1,z}$$$, where $$$p = \dfrac{y-x}{j-x}$$$;
$$$G_{j-1,y} \leftarrow (1-p)G_{j,y}$$$.
Finally, $$$F_{i,x,y} = G_{i-1,y}$$$.
A small catch is that we could have self-loops. If $$$a_i = 1$$$, then in the final step where $$$j = i$$$, there will be some transitions where $$$F_{i,x,y} \leftarrow cF_{i,x,y}$$$. For a given $$$F_{i,x,y}$$$, if all the other known values that contribute to it sum to $$$A$$$ and all the $$$c$$$ coefficients sum to $$$C$$$, then we have $$$F_{i,x,y} = A + CF_{i,x,y}$$$. This results in $$$F_{i,x,y} = \dfrac{A}{1-C}$$$. We can address this by calculating the inverse.
It can be shown that if we also iterate through $$$x$$$ from larger to smaller values, no $$$F_{i,x,y}$$$ will use other values of $$$F_{i',x',y'}$$$ that are neither known nor equal to $$$F_{i,x,y}$$$ itself. In other words, the value of $$$F_{i,x,y}$$$ does not invoke other unknown values of $$$F_{i',x',y'}$$$.
After computing all values of $$$F_{i,x,y}$$$, we proceed to determine the final answer.
We define $$$\text{ans}_{i,x}$$$ as the average probability that Jellyfish will eventually run out of non-zero cards (thus losing the game) if she starts with all $$$s_i$$$ cards in $$$[1, i]$$$ (which she owns initially) plus an additional $$$x$$$ cards drawn randomly from the remaining $$$i - s_i$$$ cards in $$$[1, i]$$$ (which she does not own initially).
If $$$c_i = 1$$$, the transition is given by: $$$\text{ans}_{i,x}=\displaystyle\sum F_{i,x-1,y}\text{ans}_{i-1,y}$$$;
If $$$c_i = 0$$$, the transition is given by: $$$\text{ans}_{i,x}=(1-p)\text{ans}_{i-1,x}+p\displaystyle\sum F_{i,x-1,y}\text{ans}_{i-1,y}$$$, where $$$p=\dfrac{x-s_i}{i-s_i}$$$.
Finally, we compute $$$1 - \text{ans}_{n,s_n}$$$ to obtain the probability that Jellyfish will eventually win the game.
The time complexity of this approach is $$$\mathcal{O}(n^5 + n^3 \log p)$$$, and the space complexity is $$$\mathcal{O}(n^3)$$$.
It is also possible to optimize the $$$\mathcal{O}(n^5)$$$ time complexity to $$$\mathcal{O}(n^4 \sqrt{n})$$$ by using Lagrange interpolation.
To achieve this speedup, we notice that the values of $$$i$$$ and $$$x$$$ do not play a crucial role in the transition of $$$G_{j,y}$$$. Specifically, the influence of the values $$$i$$$ and $$$x$$$ on the transition of $$$G_{j,y}$$$ can be described as follows:
The initial value is $$$G_{n,x+a_i} = 1$$$.
During the transition, $$$p = \dfrac{y-x}{j-x}$$$ and $$$1-p = \dfrac{j-y}{j-x}$$$.
We can fix the value of $$$k = x + a_i$$$ and treat $$$x$$$ as a variable, maintaining a polynomial in $$$x$$$ as the value of $$$G_{j,y}$$$.
We observe that it is only necessary to keep the point values between $$$[k-1, k-\sqrt{n}]$$$ to track the polynomial accurately.
For $$$a_i > \sqrt{n}$$$, since each transition involving multiplication by $$$p$$$ will increase the value of $$$y$$$ by at least $$$a_i$$$, it is clear that the degree of the polynomial $$$G_{j,y}$$$ is at most $$$\sqrt{n}$$$. Thus, keeping track of $$$\sqrt{n}$$$ values is sufficient to restore the polynomial, and we can use linear Lagrange interpolation to obtain the point values outside these $$$\sqrt{n}$$$ points.
For $$$a_i \leq \sqrt{n}$$$, since $$$x = k - a_i$$$, we only care about the point values in the range $$$[k-1, k-\sqrt{n}]$$$. Although the polynomial restored may be inaccurate beyond this range, these point values are the ones that matter for our calculations anyway.
By applying this optimization, we effectively reduce the time complexity to $$$\mathcal{O}(n^4 \sqrt{n} + n^3 \log p)$$$.
--------------------------------------------------
Problem ID: 1975H
Editorial Content:
1975H - 378QAQ and Core
Solution
Consider the maximum character $$$m$$$ of the string $$$s$$$.
If $$$m$$$ only appears once, then obviously the string starting with it is the largest in lexicographical order. To make it the smallest, $$$m$$$ should be arranged at the end. Other characters can be arranged arbitrarily.
If $$$m$$$ appears more than twice, it can be proven that the beginning and end of the answer string must be $$$m$$$. If the beginning of the string is not $$$m$$$, moving the character at the beginning to somewhere before a non-first $$$m$$$ can make the suffix lexicographical order starting with this $$$m$$$ smaller, while the suffix lexicographical order starting with $$$m$$$ after this remains unchanged. For suffixes that do not start with $$$m$$$, they are definitely not the largest, so they do not need to be considered. If the end of the string is not $$$m$$$, first remove it, and all suffix lexicographical orders become smaller. Similarly, it can also be placed in front of a certain $$$m$$$ to reduce the lexicographical order.
In this case, the answer is always in the form of $$$ms_{1}ms_{2}m\dots ms_{t}m$$$. Where $$$s_{1},s_{2},\dots,s_{t}$$$ contain characters that are less than $$$m$$$, it could also be an empty string. Now suppose that the set $$${s_{1},s_{2},\dots,s_{t}}$$$ is determined, and consider how to arrange their order. Suppose we are currently comparing two suffixes $$$S_{i}=ms_{i}m\dots ms_{t}m$$$ and $$$S_{j}=ms_{j}m\dots ms_{t}m$$$, and suppose $$$s_{i+k}$$$ and $$$s_{j+k}$$$ are the first two substrings that appear differently. Then $$$ms_{i}m\dots ms_{i+k-1}$$$ and $$$ms_{j}m\dots ms_{j+k-1}$$$ must be equal, and the size relationship between $$$S_{i}$$$ and $$$S_{j}$$$ is the same as the size relationship between $$$ms_{i+k}$$$ and $$$ms_{j+k}$$$. In this way, all $$$ms_{i}$$$ can be sorted according to lexicographical order, and regarded as a new character, and Solving the original problem for $$$(ms1​)(ms_2)…(ms_t​)$$$ is sufficient.
Now consider how to determine the set $$${s_{1},s_{2},\dots,s_{t}}$$$. For a certain $$$s_{i}$$$, it should obviously be ordered, because this can make $$$ms_{i}$$$ smaller. There is also another property. Suppose there are $$$s_{i}=p_{i}c$$$ and $$$s_{j}$$$ such that $$$ms_{j}$$$ is the current lexicographically largest string, and $$$mp_{i}<ms_{j}$$$, where $$$c$$$ is a character less than $$$m$$$. Putting $$$c$$$ after $$$s_{j}$$$ can make the answer smaller.
The proof of the property is as follows. Without loss of generality, let $$$f_{1}=p_{i}c$$$, $$$f_{2}=p_{i}$$$, $$$f_{3}=s_{j}c$$$, $$$f_{4}=s_{j}$$$, then we have $$$mf_{2}<mf_{1}<mf_{4}$$$ and $$$f_{3}m<f_{4}m$$$. Consider the subproblem after iteration, by definition, $$$f_{4}$$$ is the largest character in the problem. If $$$f_{1}$$$ and $$$f_{4}$$$ are used, and there is an $$$f_{4}$$$ to the left of some $$$f_{1}$$$ in the optimal solution string, then replacing this $$$f_{1}$$$ and its nearest $$$f_{4}$$$ on the left with $$$f_{2}$$$ and $$$f_{3}$$$ respectively, it is easy to prove that the largest suffix will definitely become smaller or unchanged. Otherwise, all $$$f_{1}$$$ are to the left of all $$$f_{4}$$$, at this time you can arbitrarily replace some $$$f_{1}$$$ and $$$f_{4}$$$ with $$$f_{2}$$$ and $$$f_{3}$$$ respectively, it is easy to prove that the largest suffix still becomes smaller or unchanged.
Based on the above discussion, we can now give the final greedy algorithm for the problem. Suppose the largest character $$$m$$$ has $$$t+1$$$ occurrences. If $$$t=0$$$, then put the only $$$m$$$ at the end, and the other characters can be arranged arbitrarily. Otherwise, suppose there are $$$p$$$ characters less than $$$m$$$, if $$$p\le t$$$, it can be proved that there is at most one character between any two $$$m$$$. Consider $$$|s_{i}|\ge2$$$, $$$s_{j}=\varepsilon$$$ (empty string), then they meet the above properties, and it is more optimal to exchange the last character of $$$s_{i}$$$ to $$$s_{j}$$$. Therefore, $$$s_{1},\dots,s_{p}$$$ is a single character, $$$s_{p+1}=\dots=s_{t}=\varepsilon$$$, and recursively solve the subproblem. Note that to ensure time complexity, when $$$t\gg p$$$, multiple rounds of recursion need to be combined.
If $$$p>t$$$, it can be similarly proved that there will not be an $$$s_{i}$$$ that is an empty string. In addition, consider the first character of all $$$s_{i}$$$, for those among these $$$t$$$ characters that are not the largest, using the same property, it can be proved that the length of the string they are in must be $$$1$$$, and no other characters will follow. Also, since $$$s_{i}$$$ is ordered, it can be proved that the first character of all $$$s_{i}$$$ must be the smallest $$$t$$$ characters less than $$$m$$$. Next, the remaining characters will only be filled after those largest characters among these $$$t$$$ characters, and it can be similarly proved that those filled in the second position of these strings are also the smallest among the remaining characters, and so on, until all characters are used up.
Notice that the complexity of each recursion is linear, and each recursion at least halves the number of characters, so the total complexity is $$$O(n\log n)$$$.
Bonus
How to solve this problem in $$$O(n)$$$?
Code
#include<bits/stdc++.h>
using namespace std;
struct ch{
    string c;
    ch(){c = "";}
    ch(string cc){c=cc;}
    bool operator == (const ch& p)const{
        return c==p.c;
    }
    bool operator != (const ch& p)const{
        return c!=p.c;
    }
    void add(ch& p){
        c.append(p.c);
    }
};
vector<ch> solve(vector<ch> cs){
    int n = cs.size();
    int t = 0;
    if(cs.empty())return cs;
    for(int i=n-2;i>=0;i--){
        if(cs[i]!=cs[n-1])break;
        t++;
    }
    if(t==0){
        vector<ch> res;
        res.push_back(cs[n-1]);
        return res;
    }
    int p = n-(t+1);
    if(p<=t){
        vector<ch> res;
        vector<ch> nxt;
        int k = (t+1)/(p+1);
        int le = (t+1)%(p+1);
        ch m = cs[n-1];
        for(int j=1;j<k;j++){
            m.add(cs[n-1]);
        }
        for(int i=0;i<p;i++){
            ch tmp = m;
            tmp.add(cs[i]);
            nxt.push_back(tmp);
        }
        for(int i=0;i<le;i++){
            nxt.push_back(cs[n-1]);
        }
        auto nxt_solved = solve(nxt);
        for(auto i:nxt_solved)res.push_back(i);
        res.push_back(m);
        return res;
    }else{
        vector<ch> res;
        vector<ch> nxt;
        ch m = cs[n-1];
        for(int i=0;i<t;i++){
            nxt.push_back(m);
        }
        int now = 0,beg=0;
        for(int i=0;i<p;i++){
            nxt[now].add(cs[i]);
            if(now>=1){
                if(cs[i]!=cs[i-1]){
                    beg=now;
                }
            }
            now++;
            if(now>=t)now=beg;
        }
        auto nxt_solved = solve(nxt);
        for(auto i:nxt_solved)res.push_back(i);
        res.push_back(m);
        return res;
    }
}
vector<ch> trans(string s){
    vector<ch> tmp;
    for(auto i:s){
        string tmpp = "";
        tmpp+=i;
        tmp.push_back(tmpp);
    }
    return tmp;
}
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        string s;
        cin>>s;
        sort(s.begin(),s.end());
        auto tmp = trans(s);
        auto ans= solve(tmp); 
        for(auto c:ans)cout<<c.c;
        cout<<"\n";
    }
}
--------------------------------------------------
Problem ID: 1975G
Editorial Content:
1975G - Zimpha Fan Club
Hint 1
If $$$s, t$$$ both have $$$*$$$, or both don't have $$$*$$$, then it will be a simple problem. Can you try to solve this problem?
Hint 2
According to the first hint, we have discussed two cases. In the remaining cases, without loss of generality, we think that only $$$t$$$ has $$$*$$$. Suppose we write $$$t$$$ as $$$t'_0*t'_1*t'_2* \dots*t'_k$$$. Where $$$t'_i$$$ does not take $$$*$$$, assuming that $$$|t'_i| \leq 50$$$ is satisfied for all $$$i$$$, can you solve this problem?
Hint 3
There is a strictly subproblem of this problem, namely, given two strings $$$s$$$ and $$$t$$$ consisting only of characters from $$$a$$$ to $$$z$$$ and $$$-$$$, you need to find all positions in $$$s$$$ where $$$t$$$ can be matched.
This problem has a classic solution, where $$$-$$$ is set to $$$0$$$, and $$$a$$$ to $$$z$$$ are sequentially assigned values from $$$1$$$ to $$$26$$$, and then let $$$f_i = \sum_{j=1}^m [s_{i +j-1} > 0] \times [t_j > 0] (s_{i+j-1}-t_j)^2$$$, then all positions of $$$f_i = 0$$$ satisfy $$$s[i, i + m -1]$$$ can match $t$​.
Decompose the calculation formula, $$$f_i = \sum_{j=1}^m s_{i+j-1}^2+s_j^2 - 2\sum_{j=1}^m s_{i+j -1}{t_j} - \sum_{j=1}^m [s_{i+j-1} = 0] t_j^2 - \sum_{j=1}^m s_{i+j-1}^ 2[t_j=0]$$$. For $$$\sum_{j=1}^m s_{i+j-1}^2+s_j^2$$$, you can prefix and process it, and for the remaining part, you can use FFT in $$$O(n \log n )$$$ to be resolved.
What is the use of this solution in the original problem?
Solution
Read the hints.
In the following, we consider $$$n, m$$$ to be of the same order.
Consider the case where $$$s$$$ and $$$t$$$ do not contain $$$*$$$. We only need to be compared bit by bit.
Consider the case where $$$s, t$$$ both contain $$$*$$$, if the beginning of $$$s$$$ is not $$$*$$$ or the beginning of $$$t$$$ is not $$$*$$$:
If one of the first characters of $$$s$$$ and $$$t$$$ is $$$*$$$ or the first characters can match, delete the first characters of the two strings that are not $$$*$$$.
Oherwise the answer is obviously
No
.
Performing the same operation on the last characters, it is not difficult to find that it will be reduced to two strings $$$*s’$$$ and $$$t'*$$$, where $$$s'$$$ and $$$t'$$$ are arbitrary strings. Then it is not difficult to find that $$$t's'$$$ matches two strings at the same time. Therefore, as long as the head and tail can be successfully deleted, the answer must be
Yes
.
Consider the hardest case. Without loss of generality, we assume that only $$$t$$$ contains $$$*$$$, otherwise $$$s, t$$$ can be exchanged. We still delete the beginning and the end first. It is not difficult to find that thereafter $$$t$$$ can be written as $$$*t'_1*t'_2*\dots*t'_k *$$$.
Then we will have a greedy solution. We iterate $$$i$$$ from $$$1$$$ to $$$n$$$, find the first matching position of $$$t'_i$$$ in $$$s$$$ each time, and delete tthese matching characters and all preceding characters in $$$s$$$, that is, remove a prefix of $$$s$$$, and then until all matching is completed or no matching position is found in $$$s$$$.
Assume that we use FFT to brute force solve this problem every time. See Hint.3 for the specific solution, then the complexity is $$$O(nk \log n)$$$.
But it is not difficult to find that this is very wasteful. In fact, we can do this:
When matching $$$t'_i$$$, only take out the first $$$|2t'_i|$$$ characters of $$$s$$$ each time and try to match $$$t'_i$$$. Because if the match is successful, then since all positions matching $$$t'_i$$$ are deleted, it is not difficult to find that at least $$$|t'_i|$$$ characters are deleted. And if the match fails, it is not difficult to find that the first $$$|t'_i|$$$ characters of $$$s$$$ will no longer be useful and can also be deleted. Therefore we remove at least the first $$$|t'_i|$$$ characters in $$$s$$$ in complexity $$$O(|t'_i| \log |t'_i|)$$$.
Since the total length of $$$s$$$ is $$$n$$$, the total time complexity does not exceed $$$O(n \log n)$$$.
Code
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;

const ll N = (1 << 22) + 5, Mod = 2013265921, G = 31;

inline ll power(ll x, ll y){
	ll ret = 1;
	while(y){
		if(y & 1) ret = ret * x % Mod;
		x = x * x % Mod, y >>= 1;
	}
	return ret;
}

ll p[N] = {}, w[N] = {}, g[N] = {}, iv[N] = {};

inline void dft(ll n, ll a[], bool idft){
	for(ll i = 0 ; i < n ; i ++) if(i < p[i]) swap(a[i], a[p[i]]);
	for(ll m = 1 ; m < n ; m <<= 1) for(ll j = 0, k = 0 ; j < n ; j += m << 1, k ++) for(ll i = j ; i < j + m ; i ++){
		ll x = a[i], y = a[i + m];
		a[i] = x + y, a[i] >= Mod && (a[i] -= Mod);
		a[i + m] = (x - y + Mod) * w[k] % Mod;
	}
	if(!idft) return;
	reverse(a + 1, a + n);
	for(int i = 0 ; i < n ; i ++) a[i] = a[i] * iv[n] % Mod;
}

inline ll sqr(ll x){
	return x * x;
}

ll n = 0, m = 0, a[3][N] = {}, b[3][N] = {}, c[N] = {}, d[N] = {};
char s[N] = {}, t[N] = {};

inline ll work(ll L, ll R, ll l, ll r){
	ll M = 1; while(M < R - L + r - l) M <<= 1;
	w[0] = 1;
	for(ll k = 1 ; k < M ; k <<= 1){
		ll bit = M / 2 / k;
        if(k == M / 2) for(ll i = 0; i < k ; i ++) p[i + k] = p[i] | bit;
        else for(ll i = 0 ; i < k ; i ++){
            w[i + k] = w[i] * g[k] % Mod;
            p[i + k] = p[i] | bit;
        }
    }
	for(ll i = 0 ; i < M ; i ++){
		p[i] = p[i >> 1] >> 1;
		if(i & 1) p[i] |= M >> 1;
	}
	ll z = 0;
	for(ll i = 0 ; i < M ; i ++){
		c[i] = 0;
		for(ll f = 0 ; f < 3 ; f ++)  a[f][i] = b[f][i] = 0;
	}
	for(ll i = L ; i < R ; i ++){
		ll x = (s[i] == '-') ? 0 : (s[i] - 'a' + 1);
		a[0][i - L] = x ? 0 : 1, a[1][i - L] = 2 * x, a[2][i - L] = sqr(x), d[i] = sqr(x);
	}
	d[R] = 0;
	for(ll i = l ; i < r ; i ++){
		ll x = (t[i] == '-') ? 0 : (t[i] - 'a' + 1);
		b[0][r - i] = sqr(x), b[1][r - i] = x, b[2][r - i] = x ? 0 : 1, z += sqr(x);
	}
	for(ll f = 0 ; f < 3 ; f ++){
		dft(M, a[f], 0), dft(M, b[f], 0);
		for(ll i = 0 ; i < M ; i ++) c[i] = (c[i] + a[f][i] * b[f][i]) % Mod;
	}
	dft(M, c, 1);
	for(ll i = 0 ; i < r - l ; i ++) z += d[i + L];
	for(ll i = L ; i <= R - (r - l) ; z -= d[i], z += d[i + (r - l)], i ++) if(z % Mod == c[i - L + r - l]) return i;
	return -1;
}

int main(){
	for(ll i = 1 ; i < N ; i <<= 1) g[i] = power(G, Mod / 4 / i), iv[i] = power(i, Mod - 2);
	scanf("%lld %lld", &n, &m);
	scanf("%s %s", s, t);
	while(n && m && s[n - 1] != '*' && t[m - 1] != '*'){
		if(s[n - 1] != t[m - 1] && s[n - 1] != '-' && t[m - 1] != '-'){
			printf("No");
			return 0;
		}
		else n --, m --;
	}
	reverse(s, s + n), reverse(t, t + m);
	while(n && m && s[n - 1] != '*' && t[m - 1] != '*'){
		if(s[n - 1] != t[m - 1] && s[n - 1] != '-' && t[m - 1] != '-'){
			printf("No");
			return 0;
		}
		else n --, m --;
	}
	reverse(s, s + n), reverse(t, t + m);
	if(min(n, m) == 0){
		while(n && s[n - 1] == '*') n --;
		while(m && t[m - 1] == '*') m --;
		if(max(n, m) == 0) printf("Yes");
		else printf("No");
		return 0;
	}
	bool u = 0, v = 0;
	for(ll i = 0 ; i < n ; i ++) if(s[i] == '*') u = 1;
	for(ll i = 0 ; i < m ; i ++) if(t[i] == '*') v = 1;
	if(u){
		if(v){
			printf("Yes");
			return 0;
		}
		else swap(n, m), swap(s, t);
	}
	ll L = 0, R = 0;
	for(ll l = 1, r = l ; l < m ; l = r + 1, r = l){
		while(t[r] != '*') r ++;
		if(r - l) while(1){
			R = min(n, L + 2 * (r - l));
			if(R - L < r - l){
				printf("No");
				return 0;
			}
			ll h = work(L, R, l, r);
			if(h == -1) L = R - (r - l) + 1;
			else{
				L = h + r - l;
				break;
			}
		}
	}
	printf("Yes");
	return 0;
}
--------------------------------------------------
Problem ID: 1975F
Editorial Content:
1975F - Set
Hint 1
Consider enumerating each number from $$$0$$$ to $$$n-1$$$ whether it is contained by $$$S$$$, when we have enumerated the first $$$x$$$ numbers, there are only $$$2^{n-x}$$$ constraints.
Solution
Read the hints.
Consider enumerating each number from $$$0$$$ to $$$n-1$$$ whether it is contained by $$$S$$$. Suppose that the current enumeration reaches $$$i$$$, and in the remaining constraints, $$$T_1$$$ and $$$T_2$$$ are two sets, the only difference between them is whether they contain $$$i$$$ ($$$T_1$$$ contains $$$i$$$):
$$$S$$$ contains $$$i$$$. We can merge $$$T_1$$$ and $$$T_2$$$ into a new constraint $$$T'$$$ and $$$v_{T'}=(v_{T_1}»1)$$$&$$$v_{T_2}$$$.
$$$S$$$ doesn't contain $$$i$$$. We can merge $$$T_1$$$ and $$$T_2$$$ into a new constraint $$$T'$$$ and $$$v_{T'}=v_{T_1}$$$&$$$v_{T_2}$$$.
We can merge constraints quickly when the enumeration reaches a new number. And the time complexity is $$$O(n\cdot 2^n)$$$
Code
#include<bits/stdc++.h>

using namespace std;

const int N = 24, S = (1 << 20) + 5;
int n = 0, f[N][S] = {};
vector<int> ans;

inline void dfs(int s = 0, int i = 0){
	if(i < n){
		int m = 1 << (n - i - 1);
		for(int t = 0 ; t < m ; t ++) f[i + 1][t] = f[i][t] & f[i][m | t];
		dfs(s << 1, i + 1);
		for(int t = 0 ; t < m ; t ++) f[i + 1][t] = f[i][t] & (f[i][m | t] >> 1);
		dfs(s << 1 | 1, i + 1);
	}
	else if(f[n][0] & 1) ans.push_back(s);
}

int main(){
	scanf("%d", &n);
	f[0][0] = 1;
	for(int s = 1 ; s < 1 << n ; s ++) scanf("%d", &f[0][s]);
	dfs();
	printf("%d\n", int(ans.size()));
	for(int s : ans) printf("%d\n", s);
	return 0;
}
--------------------------------------------------
Problem ID: 1975E
Editorial Content:
1975E - Chain Queries
Hint 1
Suppose the tree is a rooted tree, we only need to care about the number of black child vertices of each vertex.
Hint 2
If the black vertices form a chain, there is no black vertex that has three or more black child vertices. And there is at most one black vertex that has two black child vertices.
Hint 3
If the black vertices form a chain, there is at most one black vertex whose parent vertex is white.
Solution
Read the hints.
We can maintain the number of black vertices with $$$0/1/2/3+$$$ black child vertices in $$$O(1)$$$. When we flip the color of one vertex, only it and its parent node are affected.
If the black vertices form a chain: - no black vertex that has three or more black child vertices and there is at most one black vertex that has two black child vertices. - there is at most one black vertex whose parent vertex is white. - if there is one black vertex that has two black child vertices, its parent vertex must be white.
Code
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6+10;

int f[N];
vector<int> g[N];
int col[N],num[N];
int faw,sum_two,sum_more,tot_black,xor_two;
int n;
void init(){
    sum_two=0;
    tot_black=0;
    sum_more=0;
    faw=0;
    xor_two=0;
    for(int i=1;i<=n;i++){
        g[i].clear();
        num[i]=0;
    }
}

void dfs(int x,int fa){
    f[x]=fa;
    if(col[x]==1)tot_black++;
    int sum=0;
    for(auto i:g[x]){
        if(i==fa)continue;
        dfs(i,x);
        if(col[i]==1)sum++;
    }
    if(col[fa]==0&&col[x]==1)faw++;
    if(col[x]==1){
        if(sum==2)sum_two++,xor_two^=x;
        if(sum>2)sum_more++;
    }
    num[x]=sum;
}

void flip(int x){
    col[x]^=1;
    int d = col[x]==1?1:-1;
    tot_black+=d;
    if(col[f[x]]==0)faw+=d;
    if(num[x]==2)sum_two+=d,xor_two^=x;
    if(num[x]>2)sum_more+=d;
    faw-=d*num[x];
    if(col[x]==1){
        if(col[f[x]]==1&&num[f[x]]==2)sum_two--,sum_more++,xor_two^=f[x];
        num[f[x]]++;
        if(col[f[x]]==1&&num[f[x]]==2)sum_two++,xor_two^=f[x];
    }else{
        if(col[f[x]]==1&&num[f[x]]==2)sum_two--,xor_two^=f[x];
        num[f[x]]--;
        if(col[f[x]]==1&&num[f[x]]==2){
            sum_two++;
            sum_more--;
            xor_two^=f[x];
        }
    }
}

bool check(){
    if(!tot_black)return false;
    if(sum_more||sum_two>1)return false;
    if(faw>1)return false;
    if(sum_two&&col[f[xor_two]]==1)return false;
    return true;
}

int main(){
    int t;
    scanf("%d",&t);
    while(t--){
        init();
        int q;
        scanf("%d %d",&n,&q);
        for(int i=1;i<=n;i++) cin>>col[i];
        for(int i=1;i<n;i++){
            int u,v;
            scanf("%d %d",&u,&v);
            g[u].push_back(v);
            g[v].push_back(u);
        }
        dfs(1,0);
        while(q--){
            int x;
            scanf("%d",&x);
            flip(x);
            if(check()) printf("Yes\n");
            else printf("No\n");
        }
    }
}
--------------------------------------------------
Problem ID: 1975D
Editorial Content:
1975D - Paint the Tree
Hint 1
If two pieces overlap at the beginning, can you solve the problem?
Hint 2
Consider the first time a vertex is painted blue. After this event occurs, what happens next?
Solution
Read the hints.
In subsequent movements after the first time a vertex is painted blue, we can ignore the process of painting vertices red and then painting them blue.
We call the first vertex painted blue $$$r$$$. Then it is not difficult to find that $$$P_A$$$ arrived at this vertex earlier than $$$P_B$$$. Considering all subsequent movements of $$$P_B$$$, $$$P_A$$$ can restore these movements one by one after reaching $$$r$$$, then $$$P_B$$$ will pass through all vertices have been painted red.
If we know which vertex is $$$r$$$, this will be a classic problem, assuming the distance between the farthest vertex on the tree from $$$r$$$ and $$$r$$$ is $$$d$$$, then the answer is $$$2(n-1)-d$$$. Then we consider the strategies of $$$P_A$$$ and $$$P_B$$$ at this time. The two must be close to each other, and then until the first vertex is painted blue. If another vertex is $$$r$$$, although the value of $$$d$$$ may increase, every time the value of $$$d$$$ increases by $$$1$$$, the time when $$$P_A$$$ and $$$P_B$$$ meet will also increase by at least $$$1$$$, so the answer will not decrease.
Code
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 2e5+10;
vector<int> g[N];
int dep[N],f[N],mx,n,a,b;
void dfs(int x,int fa){
    dep[x]=dep[fa]+1;
    mx = max(mx,dep[x]);
    f[x]=fa;
    for(auto i:g[x]){
        if(i==fa)continue;
        dfs(i,x);
    }
}
vector<int> move(int x,int y){
    if (dep[x] > dep[y]) swap(x, y);
    vector<int> track,ano;
    int tmp = dep[y] - dep[x], ans = 0;
    track.push_back(y);
    while(tmp--){
        y = f[y];
        track.push_back(y);
    }
    if (y == x) return track;
    ano.push_back(x);
    while (f[x] != f[y]) {
        x = f[x];
        y = f[y];
        ano.push_back(x);
        track.push_back(y);
    }
    track.push_back(f[y]);
    reverse(ano.begin(),ano.end());
    for(auto i:ano)track.push_back(i);
    return track;
}
int main(){
    int t;
    cin>>t;
    dep[0]=-1;
    while(t--){
        mx = -1;
        cin>>n;
        for(int i=1;i<=n;i++)g[i].clear();
        cin>>a>>b;
        for(int i=1;i<n;i++){
            int u,v;
            cin>>u>>v;
            g[u].push_back(v);
            g[v].push_back(u);
        }
        if(a==b){
            dfs(a,0);
            cout<<2*(n-1)-mx<<"\n";
            continue;
        }
        dfs(1,0);
        auto tr = move(a,b);
        int m = tr.size();
        if(tr[0]!=a)reverse(tr.begin(),tr.end());
        int x = tr[(m-1)/2];
        mx = -1;
        dfs(x,0);
        cout<<2*(n-1)-mx+(m-1-(m-1)/2)<<"\n";
    }
}
--------------------------------------------------
Problem ID: 1975C
Editorial Content:
1975C - Chamo and Mocha's Array
Hint 1
If a subarray of length at least $$$2$$$ contains only the same elements, we can change all elements of the array to that element by operations.
Hint 2
Suppose the answer is $$$x$$$, we can perform no more than one operation on the original array $$$a$$$ so that there is a subarray of length at least $$$2$$$ that contains only $$$x$$$.
Hint 3
If we can make all elements of a subarray become $$$x$$$ in one operation, then there must be a subarray of length $$$3$$$ with a median of $$$y$$$ ($$$y\geq x$$$).
Solution
Read the hints.
If $$$n=2$$$, the answer is the minimum element.
If $$$n\geq 3$$$, we iterate over all subarrays of length $$$3$$$, and the answer is the maximum value of the median of all subarrays of length $$$3$$$.
Code
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+10;
int a[N];
int main(){
    int n,t;
    cin>>t;
    while(t--){
        cin>>n;
        for(int i=1;i<=n;i++) 
            cin>>a[i];
        if(n==2)cout<<min(a[1],a[2])<<"\n";
        else{
            int ans = min(a[1],a[2]);
            for(int i=1;i<=n-2;i++){
                vector<int> tmp;
                for(int k=0;k<=2;k++)
                    tmp.push_back(a[i+k]);
                sort(tmp.begin(),tmp.end());
                ans = max(ans,tmp[1]);
            }
            cout<<ans<<"\n";
        }
    }
}
--------------------------------------------------
Problem ID: 1975B
Editorial Content:
1975B - 378QAQ and Mocha's Array
Hint 1
How to solve the problem if we only need to find a number $$$i$$$($$$1\leq i\leq n$$$) such that $$$a_k$$$ is divisible by $$$a_i$$$ for all $$$k$$$($$$1\leq k\leq n$$$)?
Hint 2
We only need to check whether all elements are divisible by the minimum element of the array.
Solution
Read the hints.
Suppose the minimum element of $$$a$$$ is $$$x$$$. Then we iterate over $$$a$$$, if an element is not divisible by $$$x$$$, then we add it to $$$b$$$ ($$$b$$$ is initially empty).
If $$$b$$$ is still empty after iterating $$$a$$$, the answer is yes.
If $$$b$$$ isn't empty, we check whether all elements of $$$b$$$ are divisible by the minimum element of $$$b$$$. If so, the answer is yes. Otherwise, the answer is no.
Code
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1e5+10;
int a[N];
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int fl=0;
        for(int i=1;i<=n;i++){
            cin>>a[i];
            if(a[i]==1)fl=1;
        }
        if(fl)cout<<"Yes\n";
        else{
            sort(a+1,a+1+n);
            vector<int> b;
            for(int i=2;i<=n;i++){
                if(a[i]%a[1])b.push_back(a[i]);
            }
            sort(b.begin(),b.end());
            n = b.size();
            for(int j=1;j<n;j++){
                if(b[j]%b[0]){
                    fl=1;
                    break;
                }
            }
            if(!fl)cout<<"Yes\n";
            else cout<<"No\n";
        }

    }
}
--------------------------------------------------
Problem ID: 1975A
Editorial Content:
1975A - Bazoka and Mocha's Array
Hint 1
We can't do any insertions by the operation.
Hint 2
If the answer is yes, we can make $$$a$$$ become non-decreasing in no more than one operation.
Solution
Read the hints.
If $$$a$$$ is non-decreasing initially, the answer is yes.
If $$$a$$$ isn't non-decreasing initially, we can find the smallest $$$i$$$ such that $$$a_i> a_{i+1}$$$. Then we choose $$$x=[a_1,a_2,...,a_i]$$$ and $$$y=[a_{i+1},a_{i+2},...,a_n]$$$. If the array $$$y+x$$$ is non-decreasing, the answer is yes. Otherwise, the answer is no.
Code
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+10;
int a[N];
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        for(int i=1;i<=n;i++){
            cin>>a[i];
        }
        int pos=0;
        for(int i=1;i<n;i++){
            if(a[i]>a[i+1]){
                pos=i;
                break;
            }
        }
        if(!pos)cout<<"Yes\n";
        else{
            int fl=0;
            for(int i=pos+1;i<=n;i++){
                int j=(i%n)+1;
                if(a[i]>a[j])fl=1;
            }
            if(!fl)cout<<"Yes\n";
            else cout<<"No\n";
        }
    }
}
--------------------------------------------------
Problem ID: 1974G
Editorial Content:
1974G - Money Buys Less Happiness Now
Tutorial
Tutorial is loading...
Solution
from heapq import *
for _ in range(int(input())):
    m, x = map(int, input().split())
    c = [int(x) for x in input().split()]
    budget = 0
    Q = []
    for i in c:
        if budget >= i:
            heappush(Q, -i)
            budget -= i
        elif Q and -Q[0] > i:
            budget += -heappop(Q)-i
            heappush(Q, -i)
        budget += x
    print(len(Q))
--------------------------------------------------
Problem ID: 1974F
Editorial Content:
1974F - Cutting Game
Tutorial
Tutorial is loading...
Solution
def solve(tc):
    a, b, n, m = map(int, input().split())
    ver, hor = [], []
    for i in range(n):
        x, y = map(int, input().split())
        ver.append((x, y))
        hor.append((y, x))
    deleted = set()
    hor.sort()
    ver.sort()
    ans = [0, 0]
    u, d = 1, a
    l, r = 1, b
    hl, hr = 0, n - 1
    vl, vr = 0, n - 1
    for i in range(m):
        c, k = input().split()
        k = int(k)
        if c == 'U':
            u += k
            while vl <= vr and ver[vl][0] < u:
                if ver[vl] not in deleted:
                    ans[i % 2] += 1
                    deleted.add(ver[vl])
                vl += 1
        if c == 'D':
            d -= k
            while vl <= vr and ver[vr][0] > d:
                if ver[vr] not in deleted:
                    ans[i % 2] += 1
                    deleted.add(ver[vr])
                vr -= 1
        if c == 'L':
            l += k
            while hl <= hr and hor[hl][0] < l:
                if (hor[hl][1], hor[hl][0]) not in deleted:
                    ans[i % 2] += 1
                    deleted.add((hor[hl][1], hor[hl][0]))
                hl += 1
        if c == 'R':
            r -= k
            while hl <= hr and hor[hr][0] > r:
                if (hor[hr][1], hor[hr][0]) not in deleted:
                    ans[i % 2] += 1
                    deleted.add((hor[hr][1], hor[hr][0]))
                hr -= 1
    print(ans[0], ans[1])


t = int(input())
for i in range(1, t + 1):
    solve(i)
--------------------------------------------------
Problem ID: 1974E
Editorial Content:
1974E - Money Buys Happiness
Tutorial
Tutorial is loading...
Solution
T = int(input())
big = float('inf')
for _ in range(T):
    m, x = map(int, input().split())
    c = []
    h = []
    for i in range(m):
        ci, hi = map(int, input().split())
        c.append(ci)
        h.append(hi)
    mh = sum(h)
    dp = [0] + [big] * mh
    for i in range(m):
        for j in range(mh, h[i]-1, -1):
            if dp[j-h[i]] + c[i] <= i*x:
                dp[j] = min(dp[j], dp[j-h[i]]+c[i])
    for i in range(mh, -1, -1):
        if dp[i] != big:
            print(i)
            break
--------------------------------------------------
Problem ID: 1974D
Editorial Content:
1974D - Ingenuity-2
Tutorial
Tutorial is loading...
Solution
inv = {'N':'S', 'S': 'N',
    'E': 'W', 'W': 'E'}

def solve():
    n = int(input())
    s = input()
    x, y = 0, 0
    for c in s:
        if c == 'N':
            y += 1
        if c == 'S':
            y -= 1
        if c == 'E':
            x += 1
        if c == 'W':
            x -= 1
    if x % 2 == 1 or y % 2 == 1:
        print('NO')
        return
    ans = ['R'] * n
    if x == y == 0:
        if n == 2:
            print('NO')
            return
        ans[0] = ans[s.find(inv[s[0]])] = 'H'
    else:
        for i in range(n):
            if s[i] == 'N' and y > 0:
                y -= 2
                ans[i] = 'H'
            if s[i] == 'S' and y < 0:
                y += 2
                ans[i] = 'H'
            if s[i] == 'E' and x > 0:
                x -= 2
                ans[i] = 'H'
            if s[i] == 'W' and x < 0:
                x += 2
                ans[i] = 'H'
    print(*ans, sep='')
    
    
for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1974C
Editorial Content:
1974C - Beautiful Triple Pairs
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    a = [int(x) for x in input().split()]
    cnt = dict()
    ans = 0
    for i in range(n - 2):
        triplet = (a[i], a[i + 1], a[i + 2])
        mist = [0] * 3
        mist[0] = (0, a[i + 1], a[i + 2])
        mist[1] = (a[i], 0, a[i + 2])
        mist[2] = (a[i], a[i + 1], 0)
        for trip in mist:
            ans += cnt.get(trip, 0) - cnt.get(triplet, 0)
            cnt[trip] = cnt.get(trip, 0) + 1
        cnt[triplet] = cnt.get(triplet, 0) + 1
    print(ans)
    
    
for i in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1974B
Editorial Content:
1974B - Symmetric Encoding
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    b = input()
    cnt = [0] * 26
    for c in b:
        cnt[ord(c) - ord('a')] = 1
    tmp = ''
    for i in range(26):
        if cnt[i] > 0:
            tmp += chr(ord('a') + i)
    a = ''
    for c in b:
        a += tmp[-1 - tmp.find(c)]
    print(a)
    
 
for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1974A
Editorial Content:
1974A - Phone Desktop
Tutorial
Tutorial is loading...
Solution
nt = int(input())
 
for t in range(nt):
    line = input()
    x, y = [int(q) for q in line.split()]
    mm = (y + 1) // 2
    x -= (mm * 5 * 3 - y * 2 * 2)
    x = max(x, 0)
    mm += (x + 5 * 3 - 1) // (5 * 3)
    print(mm)
--------------------------------------------------
Problem ID: 1973F
Editorial Content:

--------------------------------------------------
Problem ID: 1973E
Editorial Content:

--------------------------------------------------
Problem ID: 1973D
Editorial Content:

--------------------------------------------------
Problem ID: 1973C
Editorial Content:

--------------------------------------------------
Problem ID: 1973B
Editorial Content:

--------------------------------------------------
Problem ID: 1973A
Editorial Content:

--------------------------------------------------
Problem ID: 1972B
Editorial Content:
1972B - Coin Games
Hint 1
Is there anything that
never
/
always
changes after each operation?
Hint 2
The parity.
Tutorial
Tutorial is loading...
Solution
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x, y, z) for(int x = (y); x <= (z); ++x)
#define per(x, y, z) for(int x = (y); x >= (z); --x)
#define endl '\n'
using namespace std;
typedef long long ll;
 
int T, n;
string s;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    for(cin >> T; T; --T) {
        cin >> n >> s;
        int cntU = 0;
        for(char c : s) if(c == 'U') ++cntU;
        if(cntU & 1) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1972A
Editorial Content:
1972A - Contest Proposal
Hint 1
Only add problems when they are needed.
Tutorial
Tutorial is loading...
Solution
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x, y, z) for(int x = (y); x <= (z); ++x)
#define per(x, y, z) for(int x = (y); x >= (z); --x)
#define endl '\n'
using namespace std;
typedef long long ll;
 
const int N = 105;
 
int T, n, a[N], b[N];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    for(cin >> T; T; --T) {
        cin >> n;
        rep(i, 1, n) cin >> a[i];
        rep(i, 1, n) cin >> b[i];
        int diff = 0, ans = 0;
        rep(i, 1, n) {
            if(a[i - diff] > b[i]) {
                ++ans;
                ++diff;
            }
        }
        cout << ans << endl;
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1971H
Editorial Content:
1971H - ±1
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
 
#include <algorithm>
#include <utility>
#include <vector>
 
namespace atcoder {
namespace internal {
 
template <class E> struct csr {
    std::vector<int> start;
    std::vector<E> elist;
    csr(int n, const std::vector<std::pair<int, E>>& edges)
        : start(n + 1), elist(edges.size()) {
        for (auto e : edges) {
            start[e.first + 1]++;
        }
        for (int i = 1; i <= n; i++) {
            start[i] += start[i - 1];
        }
        auto counter = start;
        for (auto e : edges) {
            elist[counter[e.first]++] = e.second;
        }
    }
};
 
// Reference:
// R. Tarjan,
// Depth-First Search and Linear Graph Algorithms
struct scc_graph {
  public:
    scc_graph(int n) : _n(n) {}
 
    int num_vertices() { return _n; }
 
    void add_edge(int from, int to) { edges.push_back({from, {to}}); }
 
    // @return pair of (# of scc, scc id)
    std::pair<int, std::vector<int>> scc_ids() {
        auto g = csr<edge>(_n, edges);
        int now_ord = 0, group_num = 0;
        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);
        visited.reserve(_n);
        auto dfs = [&](auto self, int v) -> void {
            low[v] = ord[v] = now_ord++;
            visited.push_back(v);
            for (int i = g.start[v]; i < g.start[v + 1]; i++) {
                auto to = g.elist[i].to;
                if (ord[to] == -1) {
                    self(self, to);
                    low[v] = std::min(low[v], low[to]);
                } else {
                    low[v] = std::min(low[v], ord[to]);
                }
            }
            if (low[v] == ord[v]) {
                while (true) {
                    int u = visited.back();
                    visited.pop_back();
                    ord[u] = _n;
                    ids[u] = group_num;
                    if (u == v) break;
                }
                group_num++;
            }
        };
        for (int i = 0; i < _n; i++) {
            if (ord[i] == -1) dfs(dfs, i);
        }
        for (auto& x : ids) {
            x = group_num - 1 - x;
        }
        return {group_num, ids};
    }
 
    std::vector<std::vector<int>> scc() {
        auto ids = scc_ids();
        int group_num = ids.first;
        std::vector<int> counts(group_num);
        for (auto x : ids.second) counts[x]++;
        std::vector<std::vector<int>> groups(ids.first);
        for (int i = 0; i < group_num; i++) {
            groups[i].reserve(counts[i]);
        }
        for (int i = 0; i < _n; i++) {
            groups[ids.second[i]].push_back(i);
        }
        return groups;
    }
 
  private:
    int _n;
    struct edge {
        int to;
    };
    std::vector<std::pair<int, edge>> edges;
};
 
}  // namespace internal
 
}  // namespace atcoder
 
#include <cassert>
#include <vector>
 
namespace atcoder {
 
// Reference:
// B. Aspvall, M. Plass, and R. Tarjan,
// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean
// Formulas
struct two_sat {
  public:
    two_sat() : _n(0), scc(0) {}
    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}
 
    void add_clause(int i, bool f, int j, bool g) {
        assert(0 <= i && i < _n);
        assert(0 <= j && j < _n);
        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));
        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));
    }
    bool satisfiable() {
        auto id = scc.scc_ids().second;
        for (int i = 0; i < _n; i++) {
            if (id[2 * i] == id[2 * i + 1]) return false;
            _answer[i] = id[2 * i] < id[2 * i + 1];
        }
        return true;
    }
    std::vector<bool> answer() { return _answer; }
 
  private:
    int _n;
    std::vector<bool> _answer;
    internal::scc_graph scc;
};
 
}  // namespace atcoder
 
 
using namespace std;
using namespace atcoder;
 
void solve() {
	int n;
	cin >> n;
	int b[3][n];
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < n; j++) {
			cin >> b[i][j];
		}
	}
	two_sat ts(n);
	for (int j = 0; j < n; j++) {
		for (int i = 0; i < 3; i++) {
			int nxt = (i + 1) % 3;
			ts.add_clause(abs(b[i][j]) - 1, b[i][j] > 0, abs(b[nxt][j]) - 1, b[nxt][j] > 0);
		}
	}
	cout << (ts.satisfiable() ? "YES\n" : "NO\n");
}
 
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1971G
Editorial Content:
1971G - XOUR
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <queue>
 
using namespace std;
 
 
void solve()
{
    int n;
    cin >> n;
    vector<int> a(n);
    map<int, priority_queue<int>> mp;
    for(int i = 0; i < n; i++)
    {
        cin >> a[i];
        mp[a[i]>>2].push(-a[i]);
    }
    for(int i = 0; i < n; i++)
    {
        cout << -mp[a[i]>>2].top() << " ";
        mp[a[i]>>2].pop();
    }
    cout << endl;
}
 
int32_t main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1971F
Editorial Content:
1971F - Circle Perimeter
Tutorial
Tutorial is loading...
Solution
#include <iostream>
using namespace std;
 
void solve()
{
    long long r;
    cin >> r;
    long long height = r;
    long long ans = 0;
    for(long long i = 0; i <= r; i++)
    {
        while(i*i+height*height >= (r+1)*(r+1))
        {
            height--;
        }
        long long cop = height;
        while(i*i+cop*cop >= r*r && cop > 0)
        {
            cop--;
            ans++;
        }
    }
    cout << ans*4 << endl;
}
 
int32_t main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1971E
Editorial Content:
1971E - Find the Car
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <algorithm>
#include <vector>
#include <array>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <list>
#include <chrono>
#include <random>
#include <cstdlib>
#include <cmath>
#include <ctime>
#include <cstring>
#include <iomanip>
#include <bitset>
#include <cassert>
typedef long long  ll;
using namespace std;
 
void solve()
{
    int n, k, q;
    cin >> n >> k >> q;
    vector<long long> a(k+1), b(k+1);
    a[0] = 0;
    b[0] = 0;
    for(int i = 1; i <= k; i++)
    {
        cin >> a[i];
    }
    for(int i = 1; i <= k; i++)
    {
        cin >> b[i];
    }
    for(int i = 0; i < q; i++)
    {
        long long c;
        cin >> c;
        int l = 0, r = k;
        while(l <= r)
        {
            int mid = l+r>>1;
            if(a[mid] > c)
            {
                r = mid-1;
            }
            else
            {
                l = mid+1;
            }
        }
        if(a[r] == c)
        {
            cout << b[r] << " ";
            continue;
        }
        long long ans = b[r] + (c-a[r])*(b[r+1]-b[r])/(a[r+1]-a[r]);
        cout << ans << " ";
    }
    cout << endl;
}
 
int32_t main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1971D
Editorial Content:
1971D - Binary Cut
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200'007;
const int MOD = 1'000'000'007;
 
void solve() {
	string s;
	cin >> s;
	int res = 1;
	bool ex = false;
	for (int i = 0; i + 1 < (int)(s.size()); i++) {
		res += (s[i] != s[i + 1]);
		ex |= (s[i] == '0' && s[i + 1] == '1');
	}
	cout << res - ex << '\n';
}
 
int main() {
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1971C
Editorial Content:
1971C - Clock and Strings
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200'007;
const int MOD = 1'000'000'007;
 
void solve() {
	int a, b, c, d;
	cin >> a >> b >> c >> d;
	string s;
	for (int i = 1; i <= 12; i++) {
		if (i == a || i == b) {s += "a";}
		if (i == c || i == d) {s += "b";}
	}
	cout << (s == "abab" || s == "baba" ? "YES\n" : "NO\n");
}
 
int main() {
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1971B
Editorial Content:
1971B - Different String
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200'007;
const int MOD = 1'000'000'007;
 
void solve() {
	string s;
	cin >> s;
	bool ok = false;
	for (int i = 1; i < (int)(s.length()); i++) {
		if (s[i] != s[0]) {swap(s[i], s[0]); ok = true; break;}
	}	
	if (!ok) {
		cout << "NO\n"; return;
	}
	cout << "YES\n";
	cout << s << '\n';
}
 
int main() {
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1971A
Editorial Content:
1971A - My First Sorting Problem
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200'007;
const int MOD = 1'000'000'007;
 
void solve() {
	int x, y;
	cin >> x >> y;
	cout << min(x, y) << ' ' << max(x, y) << '\n';	
}
 
int main() {
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1970G3
Editorial data not available.
--------------------------------------------------
Problem ID: 1970G2
Editorial data not available.
--------------------------------------------------
Problem ID: 1970G1
Editorial data not available.
--------------------------------------------------
Problem ID: 1970F3
Editorial data not available.
--------------------------------------------------
Problem ID: 1970F2
Editorial data not available.
--------------------------------------------------
Problem ID: 1970F1
Editorial data not available.
--------------------------------------------------
Problem ID: 1970E3
Editorial data not available.
--------------------------------------------------
Problem ID: 1970E2
Editorial data not available.
--------------------------------------------------
Problem ID: 1970E1
Editorial data not available.
--------------------------------------------------
Problem ID: 1970D3
Editorial data not available.
--------------------------------------------------
Problem ID: 1970D2
Editorial data not available.
--------------------------------------------------
Problem ID: 1970D1
Editorial data not available.
--------------------------------------------------
Problem ID: 1970C3
Editorial data not available.
--------------------------------------------------
Problem ID: 1970C2
Editorial data not available.
--------------------------------------------------
Problem ID: 1970C1
Editorial data not available.
--------------------------------------------------
Problem ID: 1970B3
Editorial data not available.
--------------------------------------------------
Problem ID: 1970B2
Editorial data not available.
--------------------------------------------------
Problem ID: 1970B1
Editorial data not available.
--------------------------------------------------
Problem ID: 1970A3
Editorial data not available.
--------------------------------------------------
Problem ID: 1970A2
Editorial data not available.
--------------------------------------------------
Problem ID: 1970A1
Editorial data not available.
--------------------------------------------------
Problem ID: 1969F
Editorial Content:
1969F - Card Pairing
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

mt19937_64 rnd(12341234);

int n, k;
vector<int> deck;
vector<int> dp;
vector<vector<bool>> odd;
vector<bool> full_odd;
vector<long long> val;
vector<long long> hs;      

bool bad(const vector<bool>& v)
{
    for(int i = 0; i < k; i++)
        if(!v[i])
            return false;
    return true;
}

vector<bool> inv(const vector<bool>& v)
{
    vector<bool> res(k);
    for(int i = 0; i < k; i++)
        res[i] = !v[i];
    return res;
}

vector<bool> get_suffix(int l)
{
    vector<bool> v(k);                     
    for(int i = l; i < n; i++) v[deck[i]] = !v[deck[i]];
    return v;
}

int get_next(long long cur, int x)
{
    for(int i = x; i <= n; i += 2)
        if(hs[i] == cur)
            return i;
    return -1;
}                

int main()
{
    cin >> n >> k;
    deck.resize(n);
    for(int i = 0; i < n; i++) cin >> deck[i];
    for(int i = 0; i < n; i++) --deck[i];
    val.resize(k);
    for(int i = 0; i < k; i++)
        while(val[i] == 0)
            val[i] = rnd();

    int max_score = 0;
    dp.resize(n + 1);
    full_odd.resize(k);
    odd.resize(n + 1, vector<bool>(k));
    hs.resize(n + 1);
    long long cur_hash = 0;
    for(int i = 0; i < n; i++)
    {
        cur_hash ^= val[deck[i]];
        if(full_odd[deck[i]]) max_score++;
        full_odd[deck[i]] = !full_odd[deck[i]];
        odd[i + 1] = full_odd;
        hs[i + 1] = cur_hash;
    }   

    for(int i = k; i <= n; i++)
        dp[i] = 1e9;                          
    long long start = 0ll;
    for(int i = 0; i < k; i++) start ^= val[i];
    int pos = get_next(start, k);
    if(pos == -1)
    {
        cout << max_score << endl;  
    }
    else
    {
        dp[pos] = 0;
        int ans = 1e9;
        for(int p = k; p <= n; p += 2)
        {
            if(dp[p] > 1e8) continue;   
            vector<bool> suff = get_suffix(p);
            vector<int> o, e;
            for(int j = 0; j < k; j++)
                if(suff[j])
                    e.push_back(j);
                else
                    o.push_back(j);
            int es = e.size();
            int os = o.size();
            bool flag = true;
            for(int i = 0; i < os && flag; i++)
                for(int j = 0; j < i && flag; j++)
                {
                    int x = o[i];
                    int y = o[j];
                    int add = 0;         
                    long long h = hs[p] ^ val[x] ^ val[y];
                    int pos = get_next(h, p);
                    if(pos == -1)                  
                    {
                        flag = false;
                        ans = min(ans, dp[p] + add);
                    }
                    else
                        dp[pos] = min(dp[pos], dp[p] + add);
                }

            for(int i = 0; i < os && flag; i++)
                for(int j = 0; j < es && flag; j++)
                {
                    int x = o[i];
                    int y = e[j];
                    int add = 1;         
                    long long h = hs[p] ^ val[x] ^ val[y];
                    int pos = get_next(h, p);    
                    if(pos == -1)
                    {
                        flag = false;
                        ans = min(ans, dp[p] + add);
                    }
                    else
                        dp[pos] = min(dp[pos], dp[p] + add);
                }

            for(int i = 0; i < es && flag; i++)
                for(int j = 0; j < i && flag; j++)
                {
                    int x = e[i];
                    int y = e[j];
                    int add = 2;                             
                    long long h = hs[p] ^ val[x] ^ val[y];
                    int pos = get_next(h, p);
                    if(pos == -1)
                    {
                        flag = false;
                        ans = min(ans, dp[p] + add);
                    }
                    else
                        dp[pos] = min(dp[pos], dp[p] + add);
                }
        }
        cout << max_score - ans << endl;
    }       
}
--------------------------------------------------
Problem ID: 1969E
Editorial Content:
1969E - Unique Array
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

#define sz(a) int((a).size())

vector<int> t, p;

void push(int v) {
  if (v * 2 + 2 >= sz(t)) return;
  t[v * 2 + 1] += p[v]; p[v * 2 + 1] += p[v];
  t[v * 2 + 2] += p[v]; p[v * 2 + 2] += p[v];
  p[v] = 0;
}

void upd(int v, int l, int r, int L, int R, int x) {
  if (L >= R) return;
  if (l == L && r == R) {
    t[v] += x; p[v] += x;
    return;
  }
  int m = (l + r) / 2;
  push(v);
  upd(v * 2 + 1, l, m, l, min(m, R), x);
  upd(v * 2 + 2, m, r, max(m, L), R, x);
  t[v] = min(t[v * 2 + 1], t[v * 2 + 2]);
}

int get(int v, int l, int r, int L, int R) {
  if (L >= R) return 1e9;
  if (l == L && r == R) return t[v];
  int m = (l + r) / 2;
  push(v);
  return min(
    get(v * 2 + 1, l, m, l, min(m, R)),
    get(v * 2 + 2, m, r, max(m, L), R)
  );
}

void solve() {
  int n;
  cin >> n;
  vector<int> a(n);
  for (auto& x : a) cin >> x, --x;
  t = p = vector<int>(4 * n);
  vector<vector<int>> pos(n);
  int ans = 0, st = 0;
  for (int i = 0; i < n; ++i) {
    int x = a[i];
    pos[x].push_back(i);
    int k = sz(pos[x]);
    if (k > 0) upd(0, 0, n, st, pos[x][k - 1] + 1, +1);
    if (k > 1) upd(0, 0, n, st, pos[x][k - 2] + 1, -2);
    if (k > 2) upd(0, 0, n, st, pos[x][k - 3] + 1, +1);
    if (get(0, 0, n, st, i + 1) == 0) {
      ans += 1;
      st = i + 1;
    }
  }
  cout << ans << '\n';
}

int main() {
  int t;
  cin >> t;
  while (t--) solve();
}
--------------------------------------------------
Problem ID: 1969D
Editorial Content:
1969D - Shop Game
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

#define sz(a) int((a).size())
using li = long long;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n, k;
    cin >> n >> k;
    vector<int> a(n), b(n);
    for (auto& x : a) cin >> x;
    for (auto& x : b) cin >> x;
    vector<int> ord(n);
    iota(ord.begin(), ord.end(), 0);
    sort(ord.begin(), ord.end(), [&](int i, int j) {
      return b[i] > b[j];
    });
    li f = 0, p = 0;
    for (int i : ord) p += max(0, b[i] - a[i]);
    li ans = 0;
    multiset<int> s;
    if (sz(s) == k) ans = max(ans, p - f);
    for (int i : ord) {
      p -= max(0, b[i] - a[i]);
      s.insert(a[i]);
      f += a[i];
      if (sz(s) > k) {
        f -= *s.rbegin();
        s.erase(--s.end());
      }
      if (sz(s) == k) ans = max(ans, p - f);
    }
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1969C
Editorial Content:
1969C - Minimizing the Sum
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

using li = long long;
const li INF = 1e18;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n, k;
    cin >> n >> k;
    vector<li> a(n);
    for (auto& x : a) cin >> x;
    vector<vector<li>> dp(n + 1, vector<li>(k + 1, INF));
    dp[0][0] = 0;
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j <= k; ++j) {
        li mn = INF;
        for (int d = 0; j + d <= k && i + d < n; ++d) {
          mn = min(mn, a[i + d]);
          dp[i + d + 1][j + d] = min(dp[i + d + 1][j + d], dp[i][j] + (d + 1) * mn);
        }
      }
    }
    cout << *min_element(dp[n].begin(), dp[n].end()) << '\n';
  }
}
--------------------------------------------------
Problem ID: 1969B
Editorial Content:
1969B - Shifts and Sorting
Tutorial
Tutorial is loading...
Solution (adedalic)
fun main() {
    repeat(readln().toInt()) {
        val s = readln().map { it.code - '0'.code }
        val zeroes = s.count { it == 0 }
        val cnt = intArrayOf(0, 0)
        var ans = 0L
        for (c in s) {
            cnt[c]++
            if (c == 0)
                ans += if (cnt[1] > 0) 1 else 0
            else
                ans += (zeroes - cnt[0])
        }
        println(ans)
    }
}
--------------------------------------------------
Problem ID: 1969A
Editorial Content:
1969A - Two Friends
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
    n = int(input())
    p = [int(x) - 1 for x in input().split()]
    ans = 3
    for i in range(n):
        if p[p[i]] == i:
            ans = 2
    print(ans)
--------------------------------------------------
Problem ID: 1968G2
Editorial Content:
1968G2 - Division + LCP (hard version)
Hint 1
Consider the general case: $$$L=1$$$ and $$$R=n$$$.
Hint 2
You must find the answer for each $$$k$$$ in the range $$$[1,n]$$$. Consider the cases $$$k\le \sqrt{n}$$$ and $$$k\geq \sqrt{n}$$$.
Solution
Tutorial is loading...
Implementation
#include<bits/stdc++.h>
using namespace std;
vector<int>Zfunc(string& str){
	int n=str.size();
	vector<int>z(n);
	int l=0,r=0;
	for(int i=1;i<n;i++){
		if(i<=r){
			z[i]=min(r-i+1,z[i-l]);
		}
		while(i+z[i]<n&&str[z[i]]==str[i+z[i]]){
			z[i]++;
		}
		if(i+z[i]-1>r){
			l=i;
			r=i+z[i]-1;
		}
	}
	return z;
}
int f(vector<int>&z,int len){
	int n=z.size();
	int cnt=1;
	for(int i=len;i<n;){
		if(z[i]>=len){
			cnt++;
			i+=len;
		}else{
			i++;
		}
	}
	return cnt;
}
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,L,R;
		string s;
		cin>>n>>L>>R>>s;
		vector<int>z=Zfunc(s);
		const int E=ceil(sqrt(n));
		vector<int>ans(n+1);
		for(int k=1;k<=E;k++){
			int l=0,r=n+1;
			while(r-l>1){
				int mid=(l+r)/2;
				if(f(z,mid)>=k){
					l=mid;
				}else{
					r=mid;
				}
			}
			ans[k]=l;
		}
		for(int len=1;len<=E;len++){
			int k=1;
			for(int i=len;i<n;){
				if(z[i]>=len){
					k++;
					i+=len;
				}else{
					i++;
				}
			}
			ans[k]=max(ans[k],len);
		}
		for(int i=n-1;i>=1;i--){
			ans[i]=max(ans[i],ans[i+1]);
		}
		for(int i=L;i<=R;i++){
			cout<<ans[i]<<' ';
		}
		cout<<"\n";
	}
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1968G1
Editorial Content:
1968G1 - Division + LCP (easy version)
Hint 1
Binary search.
Hint 2
How to check if two strings are equal?
Solution
Tutorial is loading...
Implementation
#include<bits/stdc++.h>
using namespace std;
vector<int>Zfunc(string& str){
	int n=str.size();
	vector<int>z(n);
	int l=0,r=0;
	for(int i=1;i<n;i++){
		if(i<=r){
			z[i]=min(r-i+1,z[i-l]);
		}
		while(i+z[i]<n&&str[z[i]]==str[i+z[i]]){
			z[i]++;
		}
		if(i+z[i]-1>r){
			l=i;
			r=i+z[i]-1;
		}
	}
	return z;
}
int f(vector<int>&z,int len){
	int n=z.size();
	int cnt=1;
	for(int i=len;i<n;){
		if(z[i]>=len){
			cnt++;
			i+=len;
		}else{
			i++;
		}
	}
	return cnt;
}
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,k;
		string s;
		cin>>n>>k>>k>>s;
		vector<int>z=Zfunc(s);
		int l=0,r=n+1;
		while(r-l>1){
			int mid=(l+r)/2;
			if(f(z,mid)>=k){
				l=mid;
			}else{
				r=mid;
			}
		}
		cout<<l<<"\n";
	}
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1968F
Editorial Content:
1968F - Equal XOR Segments
Hint 1
Is it useful to divide the segment into more than three segments?
Hint 2
Use the fact, that $$$x\oplus x=0$$$ and $$$x\oplus x\oplus x=x$$$.
Hint 3
When you can divide the segment into $$$2$$$ parts?
Hint 4
When can you divide the segment into $$$3$$$ parts?
Solution
Tutorial is loading...
Implementation
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
int a[N];
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,q;
		cin>>n>>q;
		map<int,vector<int>>id;
		id[0].push_back(0);
		for(int i=1;i<=n;i++){
			cin>>a[i];
			a[i]^=a[i-1];
			id[a[i]].push_back(i);
		}
		while(q--){
			int l,r;
			cin>>l>>r;
			if(a[r]==a[l-1]){
				cout<<"YES\n";
				continue;
			}
			int pL=*--lower_bound(id[a[l-1]].begin(),id[a[l-1]].end(),r);
			int pR=*lower_bound(id[a[r]].begin(),id[a[r]].end(),l);
			cout<<(pL>pR?"YES\n":"NO\n");
		}
		if(t)cout << "\n";
	}
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1968E
Editorial Content:
1968E - Cells Arrangement
Hint 1
What is the maximal possible size of $$$\mathcal{H}$$$?
Hint 2
Can you always get that size for $$$n\geq 4$$$?
Hint 3
Consider odd and even distances independently.
Solution
Let us find an interesting pattern for $$$n\geq 4$$$.
Pattern for n=4
Pattern for n=5
Can you generalize the pattern? We put $$$n-2$$$ cells on the main diagonal. Then put two cells at $$$(n-1,n)$$$ and $$$(n,n)$$$.
But why does it work? Interesting fact, that in such way we generate all possible Manhattan distances. Odd distances are generated between cells from the main diagonal and $$$(n-1,n)$$$. Even distances are generated between cells from the main diagonal and $$$(n,n)$$$.
Pattern for n=4
Pattern for n=5
Implementation
#include<iostream>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		for(int i=1;i<=n-2;i++){
			cout<<i<<' '<<i<<"\n";
		}
		cout<<n-1<<' '<<n<<"\n"<<n<<' '<<n<<"\n";
	}
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1968D
Editorial Content:
1968D - Permutation Game
Hint 1
Consider a cycle of the permutation.
Hint 2
When it is optimal to stay on the same place till the end of the game?
Solution
Tutorial is loading...
Implementation
#include<bits/stdc++.h>
using namespace std;
long long score(vector<int>&p,vector<int>&a,int s,int k){
	int n=p.size();
	long long mx=0,cur=0;
	vector<bool>vis(n);
	while(!vis[s]&&k>0){
		vis[s]=1;
		mx=max(mx,cur+1ll*k*a[s]);
		cur+=a[s];
		k--;
		s=p[s];
	}
	return mx;
}
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,k,s1,s2;
		cin>>n>>k>>s1>>s2;
		vector<int>p(n),a(n);
		for(auto&e:p){
			cin>>e;
			e--;
		}
		for(auto&e:a){
			cin>>e;
		}
		long long A=score(p,a,s1-1,k),B=score(p,a,s2-1,k);
		cout<<(A>B?"Bodya\n":A<B?"Sasha\n":"Draw\n");
	}
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1968C
Editorial Content:
1968C - Assembly via Remainders
Hint 1
Why constraints are small?
Hint 2
Try to think about increacing $$$a_1,\dots,a_n$$$.
Hint 3
$$$((a + b)\bmod a) = b$$$ for $$$0\le b < a$$$.
Solution
Tutorial is loading...
Implementation
#include<iostream>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		int S=1000;
		cout<<S<<" ";
		for(int i=2;i<=n;i++){
			int x;
			cin>>x;
			S+=x;
			cout<<S<<" ";
		}
		cout<<"\n";
	}
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1968B
Editorial Content:
1968B - Prefiquence
Hint 1
Try to check for every $$$k$$$ if the prefix of $$$a$$$ of length $$$k$$$ is a subsequence of $$$b$$$.
Solution
Tutorial is loading...
Implementation
#include<iostream>
#include<vector>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;
		vector<char>a(n+1),b(m+1);
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		for(int i=1;i<=m;i++){
			cin>>b[i];
		}
		vector<int>dp(m+1);
		dp[1]=(a[1]==b[1]?1:0);
		for(int i=2;i<=m;i++){
			if(dp[i-1]!=n && b[i]==a[dp[i-1]+1]){
				dp[i]=dp[i-1]+1;
			}else{
				dp[i]=dp[i-1];
			}
		}
		cout<<dp[m]<<"\n";
	}
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1968A
Editorial Content:
1968A - Maximize?
Hint 1
Try to find the upper bound of $$$\gcd(x,y)+y$$$.
Hint 2
$$$\gcd(x,y)+y=\gcd(x-y,y)+y$$$.
Hint 3
$$$\gcd(x,y)+y\le x$$$. Try to find such $$$y$$$, that $$$\gcd(x,y)+y=x$$$?
Solution
Tutorial is loading...
Implementation
#include<iostream>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int x;
		cin>>x;
		cout<<x-1<<"\n";
	}
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1967F
Editorial Content:
1967F - Next and Prev
Hint 1
How to maintain $$$\sum\min(nxt_i-pre_i,x)$$$? Try $$$\sum\min(nxt_i-i,x)+\min(i-pre_i,x)$$$.
Hint 2
To maintain $$$\sum\min(nxt_i-i,x)$$$, we can use chunking. Just +1 and $$$\operatorname{chkmin}$$$.
Hint 3
To finish it, consider what we do in segment-beats.
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>
using namespace std;
 
constexpr int maxn=300010,maxq=100010,B=400;
 
int n,bn,a[maxn],b[maxn],idx[maxn],nxt[maxn],add[maxn/B+5],mxadd[maxn/B+5],mx[maxn/B+5],se[maxn/B+5],t[maxn];
long long ans[maxq];
vector<int>val[maxn/B+5],mxval[maxn/B+5],pre[maxn/B+5],mxpre[maxn/B+5],pos[maxn/B+5],ks[maxn];
 
void vAdd(int i)
{
	for(;i<=n;i+=(i&-i)) t[i]++;
}
 
int nQuery(int i)
{
	int s=0;
	for(;i;i-=(i&-i)) s+=t[i];
	return s;
}
 
void vWork()
{
	int i,j,tot=0;
	for(i=1;i<=n;i++) b[a[i]]=i;
	for(i=1;i<=n;i++)
	{
		int p=b[i],bp=(p-1)/B+1;
		val[bp].clear();
		mxval[bp].clear();
		auto radixsort=[](vector<int>&v)
		{
			if(v.empty()) return;
			static int buc[1024],res[B+5];
			auto tmp=minmax_element(v.begin(),v.end());
			int mn=*tmp.first,rg=*tmp.second-mn;
			if(!rg) return;
			int lv=__lg(rg)/2+1,len=1<<lv,i;
			memset(buc,0,len*4);
			for(int &it:v) it-=mn,buc[it&(len-1)]++;
			for(i=1;i<len;i++) buc[i]+=buc[i-1];
			for(int it:v) res[--buc[it&(len-1)]]=it;
			memset(buc,0,len*4);
			for(int it:v) buc[it>>lv]++;
			for(i=1;i<len;i++) buc[i]+=buc[i-1];
			for(i=v.size()-1;i>=0;i--) v[--buc[res[i]>>lv]]=res[i]+mn;
		};
		auto getpre=[&](vector<int>&pre,const vector<int>&ori)
		{
			pre.resize(ori.size());
			if(ori.empty()) return;
			pre[0]=ori[0];
			for(int i=1;i<(int)ori.size();i++) pre[i]=pre[i-1]+ori[i];
		};
		int lstmx=mx[bp];
		vAdd(p);
		idx[p]=nQuery(p);
		mx[bp]=nxt[p]=n*2;
		se[bp]=0;
		auto it=pos[bp].begin();
		for(;it<pos[bp].end();it++)
		{
			j=*it;
			if(j>p) break;
			nxt[j]+=add[bp];
			if(nxt[j]>lstmx) nxt[j]+=mxadd[bp];
			nxt[j]=min(nxt[j],idx[p]);
			idx[j]+=add[bp];
			if(nxt[j]>mx[bp]) se[bp]=mx[bp],mx[bp]=nxt[j];
			else if(nxt[j]>se[bp]) se[bp]=nxt[j];
		}
		it=pos[bp].insert(it,p);
		for(it++;it!=pos[bp].end();it++)
		{
			j=*it;
			nxt[j]+=add[bp];
			if(nxt[j]>lstmx) nxt[j]+=mxadd[bp];
			nxt[j]++;
			idx[j]+=add[bp]+1;
			if(nxt[j]>mx[bp]) se[bp]=mx[bp],mx[bp]=nxt[j];
			else if(nxt[j]>se[bp]) se[bp]=nxt[j];
		}
		for(int j:pos[bp])
		{
			if(nxt[j]==mx[bp]) mxval[bp].push_back(nxt[j]-idx[j]);
			else val[bp].push_back(nxt[j]-idx[j]);
		}
		add[bp]=mxadd[bp]=0;
		radixsort(val[bp]);
		getpre(pre[bp],val[bp]);
		radixsort(mxval[bp]);
		getpre(mxpre[bp],mxval[bp]);
		for(j=bp+1;j<=bn;j++) add[j]++,mx[j]++,se[j]++;
		for(j=1;j<bp;j++)
		{
			if(mx[j]<=idx[p]) continue;
			if(se[j]<idx[p])
			{
				mxadd[j]+=idx[p]-mx[j],mx[j]=idx[p];
				continue;
			}
			val[j].clear();
			mxval[j].clear();
			lstmx=mx[j];
			mx[j]=idx[p],se[j]=0;
			for(int x:pos[j])
			{
				nxt[x]+=add[j];
				idx[x]+=add[j];
				if(nxt[x]>lstmx) nxt[x]+=mxadd[j];
				if(nxt[x]>=idx[p])
				{
					nxt[x]=idx[p];
					mxval[j].push_back(nxt[x]-idx[x]);
				}
				else
				{
					if(nxt[x]>se[j]) se[j]=nxt[x];
					val[j].push_back(nxt[x]-idx[x]);
				}
			}
			add[j]=mxadd[j]=0;
			radixsort(val[j]);
			getpre(pre[j],val[j]);
			radixsort(mxval[j]);
			getpre(mxpre[j],mxval[j]);
		}
		for(int ki:ks[i])
		{
			tot++;
			for(j=1;j<=bn;j++)
			{
				auto it=lower_bound(val[j].begin(),val[j].end(),ki);
				ans[tot]+=(val[j].end()-it)*ki;
				if(it!=val[j].begin()) ans[tot]+=pre[j][it-val[j].begin()-1];
				it=lower_bound(mxval[j].begin(),mxval[j].end(),ki-mxadd[j]);
				ans[tot]+=(mxval[j].end()-it)*ki;
				if(it!=mxval[j].begin()) ans[tot]+=(it-mxval[j].begin())*mxadd[j]+mxpre[j][it-mxval[j].begin()-1];
			}
		}
	}
}
 
int main()
{
	ios::sync_with_stdio(false),cin.tie(0);
	int T;
	cin>>T;
	while(T--)
	{
    	int i,ki,tot=0;
    	cin>>n;
    	bn=(n-1)/B+1;
    	for(i=1;i<=n;i++) cin>>a[i];
    	for(i=1;i<=n;i++)
    	{
    		cin>>ki;
    		ks[i].resize(ki);
    		for(int &it:ks[i])
    		{
    			cin>>it;
    			ans[++tot]=-(i+it-1);
    		}
    	}
    	vWork();
    	reverse(a+1,a+n+1);
    	for(int x=1;x<=n;x++)
    	t[x]=0;
    	for(i=1;i<=bn;i++) mx[i]=0,se[i]=0,val[i].clear(),mxval[i].clear(),pos[i].clear();
    	vWork();
    	for(int x=1;x<=n;x++)
    	t[x]=0;
    	for(i=1;i<=bn;i++) mx[i]=0,se[i]=0,val[i].clear(),mxval[i].clear(),pos[i].clear();
    	for(i=1;i<=tot;i++) cout<<ans[i]<<'\n';
    	tot=0;
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1967E2
Editorial Content:
1967E2 - Again Counting Arrays (Hard Version)
Hint 1
Solve E1 with $$$\mathcal O(n\sqrt{n})$$$ solution first (The $$$\mathcal O(n\log^2n)$$$ solution doesn't help much in E2).
Hint 2
For a single round of inclusion-exclusion, write down the form of the answer as simple as possible.
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
 
const int MOD = 998244353;
const int N = 2e6+5;
int inv[N];
 
int inversemod(int p, int q) {
  // assumes p > 0
  // https://codeforces.com/blog/entry/23365
  return (p > 1 ? q-1LL*inversemod(q%p, p)*q/p : 1);
}
 
void add(int& x, int y) {
  x += y;
  if (x >= MOD) x -= MOD;
}
 
void sub(int& x, int y) {
  x -= y;
  if (x < 0) x += MOD;
}
 
int solve(int n, int m, int b0) {
  // let X = hit -1, Y = hit m
  // f(S) = count of sequences that end up in [0, infty] while containing the pattern S
  // g(S) = count of sequences that end up in [-infty, -1] while containing the pattern S
  // we want f() - f(X) + f(YX) - f(XYX) + f(YXYX) - f(XYXYX) + ...
  //             + g(Y) - g(XY) + g(YXY) - g(XYXY) + g(YXYXY) - ...
  vector<int> pw(n+1);
  pw[0] = 1;
  for (int i = 1; i <= n; i++) pw[i] = 1LL*pw[i-1]*(m-1) % MOD;
 
  // final ans will be sum from i = 0 to n of (n choose i) a_i
  vector<int> a(n+2);
  auto work = [&] (int c, int pw_coeff, int sgn_x) -> bool {
    // let RANGE = [-infty, -1] if sgn_x == -1 and [0, infty] if sgn_x == 1
    // for all x in RANGE such that (n+x+c)/2 is between 0 and n inclusive,
    // add pw_coeff*pw[(n+x-b0)/2] to a[(n+x+c)/2]
 
    // return 0 to signal that we are out of bounds and should exit, otherwise 1
    int l = 0;
    if (sgn_x == 1) l = max(l, (n+c+1)>>1);
    int r = n;
    if (sgn_x == -1) r = min(r, (n+c-1)>>1);
    if (l > r) return 0;
    add(a[l], 1LL*pw_coeff*pw[l-(b0+c)/2] % MOD);
    sub(a[r+1], 1LL*pw_coeff*pw[r+1-(b0+c)/2] % MOD);
    return 1;
  };
 
  int ans = 0;
  // f(k*YX)
  // after reflection trick, end up in x + 2*(m+1)*k
  for (int k = 0; work(2*(m+1)*k - b0, 1, 1); k++);
 
  // f(X + k*YX)
  // after reflection trick, end up in -2-x - 2*(m+1)*k
  for (int k = 0; work(2*(m+1)*k+2+b0, MOD-1, 1); k++);
 
  // g(Y + k*XY)
  // after reflection trick, end up in 2*m-x + 2*(m+1)*k
  for (int k = 0; work(-2*m -2*(m+1)*k + b0, 1, -1); k++);
 
  // g(k*XY)
  // after reflection trick, end up in x - 2*(m+1)*k
  for (int k = 1; work(-2*(m+1)*k - b0, MOD-1, -1); k++);
 
  for (int i = 1; i <= n; i++) {
    add(a[i], 1LL*a[i-1]*(m-1) % MOD);
  }
 
  // do the binomial stuff without precalculated factorials because why not
  int coeff = 1;
  for (int i = 0; i <= n; i++) {
    add(ans, 1LL * coeff * a[i] % MOD);
    coeff = 1LL * coeff * (n-i) % MOD * inv[i+1] % MOD;
  }
 
  return ans;
}
 
int main () {
  ios_base::sync_with_stdio(0); cin.tie(0);
  inv[1] = 1;
  for (int i = 2; i < N; i++) inv[i] = 1LL*(MOD-MOD/i)*inv[MOD % i] % MOD;
 
  int T;
  cin >> T;
  while (T--) {
    int n, m, b0;
    cin >> n >> m >> b0;
    if (b0 >= m) {
      int ans = 1;
      for (int i = 0; i < n; i++) ans = 1LL*ans*m % MOD;
      cout << ans << '\n';
      continue;
    }
    cout << solve(n, m, b0) << '\n';
  }
}
--------------------------------------------------
Problem ID: 1967E1
Editorial Content:
1967E1 - Again Counting Arrays (Easy Version)
Hint 1
Use the simplest way to judge if an $$$a$$$ is valid.
Hint 2
We've got a $$$\mathcal O(nm)$$$ solution. Our target time complexity is $$$\mathcal O(n\sqrt{n})$$$.
Hint 3
It can be boiled down to a grid path counting problem.
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
namespace FastIO {
	template <typename T> inline T read() { T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= (ch == '-'), ch = getchar(); while ('0' <= ch && ch <= '9') x = x * 10 + (ch ^ '0'), ch = getchar(); return w ? -x : x; }
	template <typename T> inline void write(T x) { if (!x) return; write<T>(x / 10), putchar(x % 10 ^ '0'); }
	template <typename T> inline void print(T x) { if (x < 0) putchar('-'), x = -x; else if (x == 0) putchar('0'); write<T>(x); }
	template <typename T> inline void print(T x, char en) { if (x < 0) putchar('-'), x = -x; else if (x == 0) putchar('0'); write<T>(x), putchar(en); }
}; using namespace FastIO;
 
#define MAXN 2000001
namespace Maths {
	constexpr int MOD = 998244353;
	long long qpow(long long a, long long x) { long long ans = 1; while (x) (x & 1) && (ans = ans * a % MOD), a = a * a % MOD, x >>= 1; return ans; }
	long long frac[MAXN << 1 | 1], prac[MAXN << 1 | 1];
	inline void inis(int V = MAXN * 2) { frac[0] = prac[0] = 1; for (int i = 1; i <= V; ++i) frac[i] = frac[i - 1] * i % MOD; prac[V] = qpow(frac[V], MOD - 2); for (int i = V - 1; i; --i) prac[i] = prac[i + 1] * (i + 1) % MOD; }
	inline long long C(int N, int M) { if (N < 0 || M < 0 || N < M) return 0; return frac[N] * prac[M] % MOD * prac[N - M] % MOD; }
}; using namespace Maths;
 
struct Point {
	int x, y;
	Point () {}
	Point (int X, int Y) : x(X), y(Y) {}
	inline void flip(int b) { x += b, y -= b, std::swap(x, y); }
	inline int calc() { return C(x + y, y); }
} pA, pB;
 
inline void add(int& x, int y) { (x += y) >= MOD && (x -= MOD); }
inline void del(int& x, int y) { (x -= y) < 0 && (x += MOD); }
 
int calc(int p, int q, int b1, int b2) {
	pA = pB = Point(p, q);
	int ans = pA.calc();
	while (pA.x >= 0 && pA.y >= 0) 
		pA.flip(b1), del(ans, pA.calc()), pA.flip(b2), add(ans, pA.calc());
	while (pB.x >= 0 && pB.y >= 0) 
		pB.flip(b2), del(ans, pB.calc()), pB.flip(b1), add(ans, pB.calc());
	return ans;
}
 
int dp[2][3001], powm[MAXN];
void solve() {
	int N = read<int>(), M = read<int>(), b0 = read<int>();
	if (b0 >= M) return (void)print<int>(qpow(M, N), '\n');
	powm[0] = 1; for (int i = 1; i <= N; ++i) powm[i] = 1ll * M * powm[i - 1] % MOD;
	if (1ll * M * M <= N) { // dp
		for (int k = 0; k < M; ++k) dp[0][k] = (int)(k == b0), dp[1][k] = 0;
		int ans = 1ll * dp[0][M - 1] * (M - 1) % MOD * powm[N - 1] % MOD;
		for (int i = 1; i <= N; ++i) {
			auto now = dp[i & 1], lst = dp[(i & 1) ^ 1];
			now[0] = 0; for (int k = 0; k + 1 < M; ++k) now[k + 1] = 1ll * lst[k] * (M - 1) % MOD;
			for (int k = 1; k < M; ++k) add(now[k - 1], lst[k]);
			if (i < N) add(ans, 1ll * now[M - 1] * (M - 1) % MOD * powm[N - i - 1] % MOD);
		}
		for (int k = 0; k < M; ++k) add(ans, dp[N & 1][k]);
		print<int>(ans, '\n');
	} else { // reflective inclusion-exclusion
		const int B1 = M - b0, B2 = -1 - b0; int ans = qpow(M, N);
		for (int x = b0, y = 0, k = 1, p = b0; p < N; p += 2, ++x, ++y, k = 1ll * k * (M - 1) % MOD) 
			del(ans, 1ll * calc(x, y, B1, B2) * k % MOD * powm[N - p - 1] % MOD);
		print<int>(ans, '\n');
	}
}
 
int main() { int T = read<int>(); inis(); while (T--) solve(); return 0; }
--------------------------------------------------
Problem ID: 1967D
Editorial Content:
1967D - Long Way to be Non-decreasing
Hint 1
Binary search on the answer of magics.
Hint 2
You may come up with many $$$\mathcal O(m\log m + n\log^2 m)$$$ solutions with heavy data structures. Unfortunately, none of them is helpful.
Hint 3
The key is to judge $$$\mathcal O(m\log n)$$$ times whether vertex $$$u$$$ is reachable from vertex $$$v$$$ in $$$k$$$ steps, instead of querying the minimal value or something else.
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
namespace FastIO {
	template <typename T> inline T read() { T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= (ch == '-'), ch = getchar(); while ('0' <= ch && ch <= '9') x = x * 10 + (ch ^ '0'), ch = getchar(); return w ? -x : x; }
	template <typename T> inline void write(T x) { if (!x) return; write<T>(x / 10), putchar(x % 10 ^ '0'); }
	template <typename T> inline void print(T x) { if (x < 0) putchar('-'), x = -x; else if (x == 0) putchar('0'); write<T>(x); }
	template <typename T> inline void print(T x, char en) { if (x < 0) putchar('-'), x = -x; else if (x == 0) putchar('0'); write<T>(x), putchar(en); }
}; using namespace FastIO;
 
#define MAXM 1000001
int dep[MAXM], id[MAXM], dfn[MAXM], to[MAXM], sz[MAXM], tot = 0;
std::vector<int> ch[MAXM];
void dfs(int u) {
	sz[u] = 1, dfn[u] = ++tot;
	for (int v : ch[u]) {
		dep[v] = dep[u] + 1, id[v] = id[u];
		dfs(v), sz[u] += sz[v];
	}
}
inline bool inSub(int u, int v) /* v \in u ? */ { return dfn[u] <= dfn[v] && dfn[v] < dfn[u] + sz[u]; }
constexpr int INF = 0x3f3f3f3f;
inline int query(int u, int v) /* u -> v */ {
	if (u == v) return 0;
	if (id[u] != id[v]) return INF;
	int res = INF;
	if (inSub(v, u)) res = dep[u] - dep[v];
	if (inSub(v, to[id[u]])) res = std::min(dep[u] - dep[v] + dep[to[id[u]]] + 1, res);
	// printf("query(%d, %d) = %d\n", u, v, res);
	return res;
}
 
#define MAXN 1000001
int a[MAXN], N, M;
bool check(int val) {
	// printf("check %d\n", val);
	int lst = 1;
	for (int i = 1; i <= N; ++i) {
		while (lst <= M && query(a[i], lst) > val) ++lst;
		if (lst > M) return false;
		// printf("a[%d] = %d\n", i, lst);	
	}
	return true;
}
 
namespace DSU {
	int fa[MAXM];
	void inis(int n) { for (int i = 1; i <= n; ++i) fa[i] = i; }
	inline int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
	inline bool merge(int x, int y) { if (find(x) == find(y)) return false; fa[fa[x]] = fa[y]; return true; }
}; using namespace DSU;
 
int main() {
	int T = read<int>();
	while (T--) {
		N = read<int>(), M = read<int>(), inis(M);
		for (int i = 1; i <= N; ++i) a[i] = read<int>();
		for (int x = 1; x <= M; ++x) dep[x] = id[x] = dfn[x] = to[x] = sz[x] = 0, ch[x].clear();
		tot = 0;
		for (int i = 1, p; i <= M; ++i) {
			p = read<int>();
			if (merge(i, p)) ch[p].push_back(i); else to[i] = p;
		}
		for (int i = 1; i <= M; ++i) if (to[i] > 0) id[i] = i, dfs(i);
		if (!check(M)) { puts("-1"); continue; }
		int L = 0, R = M;
		while (L < R) {
			int mid = L + R >> 1;
			if (check(mid)) R = mid; else L = mid + 1;
		}
		print<int>(R, '\n');
	}
}
--------------------------------------------------
Problem ID: 1967C
Editorial Content:
1967C - Fenwick Tree
Hint 1
The height of a Fenwick Tree is $$$\mathcal O(\log n)$$$, so operations like enumerating ancestors of each vertex will be acceptable.
Hint 2
What's the coefficient of $$$a_u$$$ in each $$$b$$$ value of its ancestors?
Tutorial
Tutorial is loading...
Solution
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x, y, z) for(int x = (y); x <= (z); ++x)
#define per(x, y, z) for(int x = (y); x >= (z); --x)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do {freopen(s".in", "r", stdin); freopen(s".out", "w", stdout);} while(false)
#define endl '\n'
using namespace std;
typedef long long ll;
 
mt19937 rnd(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
int randint(int L, int R) {
    uniform_int_distribution<int> dist(L, R);
    return dist(rnd);
}
 
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
 
template<int mod>
inline unsigned int down(unsigned int x) {
	return x >= mod ? x - mod : x;
}
 
template<int mod>
struct Modint {
	unsigned int x;
	Modint() = default;
	Modint(unsigned int x) : x(x) {}
	friend istream& operator>>(istream& in, Modint& a) {return in >> a.x;}
	friend ostream& operator<<(ostream& out, Modint a) {return out << a.x;}
	friend Modint operator+(Modint a, Modint b) {return down<mod>(a.x + b.x);}
	friend Modint operator-(Modint a, Modint b) {return down<mod>(a.x - b.x + mod);}
	friend Modint operator*(Modint a, Modint b) {return 1ULL * a.x * b.x % mod;}
	friend Modint operator/(Modint a, Modint b) {return a * ~b;}
	friend Modint operator^(Modint a, int b) {Modint ans = 1; for(; b; b >>= 1, a *= a) if(b & 1) ans *= a; return ans;}
	friend Modint operator~(Modint a) {return a ^ (mod - 2);}
	friend Modint operator-(Modint a) {return down<mod>(mod - a.x);}
	friend Modint& operator+=(Modint& a, Modint b) {return a = a + b;}
	friend Modint& operator-=(Modint& a, Modint b) {return a = a - b;}
	friend Modint& operator*=(Modint& a, Modint b) {return a = a * b;}
	friend Modint& operator/=(Modint& a, Modint b) {return a = a / b;}
	friend Modint& operator^=(Modint& a, int b) {return a = a ^ b;}
	friend Modint& operator++(Modint& a) {return a += 1;}
	friend Modint operator++(Modint& a, int) {Modint x = a; a += 1; return x;}
	friend Modint& operator--(Modint& a) {return a -= 1;}
	friend Modint operator--(Modint& a, int) {Modint x = a; a -= 1; return x;}
	friend bool operator==(Modint a, Modint b) {return a.x == b.x;}
	friend bool operator!=(Modint a, Modint b) {return !(a == b);}
};
 
const int N = 1e6 + 100, mod = 998244353;
typedef Modint<mod> mint;
 
int T, n, k;
mint a[N], inv[N];
 
inline int lowbit(int x) {return x & -x;}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    inv[0] = inv[1] = 1;
    rep(i, 2, N - 1) inv[i] = (mod - mod / i) * inv[mod % i];
    for(cin >> T; T; --T) {
        cin >> n >> k;
        rep(i, 1, n) cin >> a[i];
        rep(i, 1, n) {
            mint mul = 1;
            for(int u = i + lowbit(i), d = 1; u <= n; u += lowbit(u), ++d) {
                mul *= (d + k - 1) * inv[d];
                a[u] -= mul * a[i];
            }
        }
        rep(i, 1, n) cout << a[i] << " \n"[i == n];
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1967B2
Editorial Content:
1967B2 - Reverse Card (Hard Version)
Hint 1
Denote $$$\gcd(a,b)$$$ as $$$d$$$. Assume that $$$a=pd$$$ and $$$b=qd$$$.
Hint 2
$$$\gcd(p,q)=1$$$.
Hint 3
How large could $$$p$$$ and $$$q$$$ be?
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
 
#define nl "\n"
#define nf endl
#define ll long long
#define pb push_back
#define _ << ' ' <<
 
#define INF (ll)1e18
#define mod 998244353
#define maxn 110
 
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
 
    #if !ONLINE_JUDGE && !EVAL
        ifstream cin("input.txt");
        ofstream cout("output.txt");
    #endif
    int t;
    cin>>t;
    while(t--)
    {
        ll n,m; cin >> n>>m;
        ll sq = sqrt(n) + 2,sqm=sqrt(m)+2;
    
        vector bad(sq + 1, vector<bool>(sqm+1, 0));
        for (ll i = 2; i <= min(sq,sqm); i++) {
            for (ll a = i; a <= sq; a += i) {
                for (ll b = i; b <= sqm; b += i) {
                    bad[a][b] = true;
                }
            }
        }
    
        ll ans = 0;
        for (ll a = 1; a * a <= n; a++) {
            for (ll b = 1; b * b <= m; b++) {
                if (bad[a][b]) continue;
                ans += min(n/(a+b)/a,m/(a+b)/b);
            }
        }
        cout << ans << nl;
    }
 
    return 0;
}
--------------------------------------------------
Problem ID: 1967B1
Editorial Content:
1967B1 - Reverse Card (Easy Version)
Hint 1
Denote $$$\gcd(a,b)$$$ as $$$d$$$.
Hint 2
Did you notice that $$$b\mid a$$$? How to prove that?
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2000005;
int tc,n,m; ll ans;
inline void solve(){
	cin>>n>>m; ans=0;
	for(int i=1;i<=m;i++)
		ans+=(n+i)/(1ll*i*i);
	cout<<ans-1<<'\n';
}
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin>>tc; while(tc--) solve();
	return 0;
}
--------------------------------------------------
Problem ID: 1967A
Editorial Content:
1967A - Permutation Counting
Hint 1
What's the answer if $$$a_1=a_2=\cdots=a_n$$$ and $$$k=0$$$?
Hint 2
What's the answer if $$$k=0$$$?
Hint 3
You've already known the $$$\mathcal O(k)$$$ solution. How to improve it?
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>
using namespace std;
void solve()
{
    int n;long long k;
    cin>>n>>k;
    vector<long long>a(n);
    for(int x=0;x<n;x++)
    cin>>a[x];
    sort(a.begin(),a.end());
    reverse(a.begin(),a.end());
    long long lst=a.back(),cnt=1;
    a.pop_back();
    while(!a.empty()&&lst==a.back())a.pop_back(),cnt++;
    while(!a.empty())
    {
        long long delta=a.back()-lst;
        if(k<delta*cnt)break;
        k-=delta*cnt;
        lst=a.back();
        while(!a.empty()&&lst==a.back())a.pop_back(),cnt++;
    }
    lst+=k/cnt;
    k%=cnt;
    cnt-=k;
    cout<<lst*n-cnt+1<<endl;
}
main()
{
    ios::sync_with_stdio(false),cin.tie(0);
    int t;
    cin>>t;
    while(t--)solve();
}
--------------------------------------------------
Problem ID: 1966B
Editorial Content:
1966B - Rectangle Filling
Solution
Tutorial is loading...
Code
t = int(input())

for tc in range(t):
    n, m = map(int, input().split())
    gr = []

    for i in range(n):
        gr.append(input())

    ans = "YES"

    if gr[0][0] != gr[n - 1][m - 1]:

        impossible = True
        for j in range(m - 1):
            if gr[0][j] != gr[0][j + 1] or gr[n - 1][j] != gr[n - 1][j + 1]:
                impossible = False

        if impossible:
            ans = "NO"

        impossible = True
        for i in range(n - 1):
            if gr[i][0] != gr[i + 1][0] or gr[i][m - 1] != gr[i + 1][m - 1]:
                impossible = False

        if impossible:
            ans = "NO"

    print(ans)
--------------------------------------------------
Problem ID: 1966A
Editorial Content:
1966A - Card Exchange
Solution
Tutorial is loading...
Code
t = int(input())

for tc in range(t):
    n, k = map(int, input().split())

    cards = list(map(int, input().split()))
    ct = {}

    ans = n

    for c in cards:
        if c in ct:
            ct.update({c: ct[c] + 1})
        else:
            ct.update({c: 1})
        if ct[c] >= k:
            ans = k - 1

    print(ans)
--------------------------------------------------
Problem ID: 1965F
Editorial Content:
1965F - Conference
Solution
Tutorial is loading...
Code
/**
 *    author:  tourist
 *    created: 26.11.2023 09:36:38       
**/
#include <bits/stdc++.h>
 
using namespace std;
 
#ifdef LOCAL
#include "algo/debug.h"
#else
#define debug(...) 42
#endif
 
const long long inf = (long long) 1e18;
 
int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  int n;
  cin >> n;
  vector<long long> l(n), r(n);
  for (int i = 0; i < n; i++) {
    cin >> l[i] >> r[i];
  }
  int original_n = n;
  for (int rot = 0; rot < 2; rot++) {
    // make all left ends distinct
    map<long long, vector<long long>> mp;
    for (int i = 0; i < n; i++) {
      mp[l[i]].push_back(r[i]);
    }
    vector<long long> new_l, new_r;
    auto it = mp.begin();
    multiset<long long> s;
    long long T = -inf;
    while (true) {
      if (s.empty()) {
        if (it == mp.end()) {
          break;
        }
        T = it->first;
      }
      while (it != mp.end() && T == it->first) {
        s.insert(it->second.begin(), it->second.end());
        ++it;
      }
      assert(!s.empty());
      new_l.push_back(T);
      new_r.push_back(*s.begin());
      s.erase(s.begin());
      T += 1;
      while (!s.empty() && *s.begin() < T) {
        s.erase(s.begin());
      }
    }
    swap(l, new_l);
    swap(r, new_r);
    n = (int) l.size();
    for (int i = 0; i < n; i++) {
      l[i] *= -1;
      r[i] *= -1;
      swap(l[i], r[i]);
    }
  }
  sort(l.begin(), l.end());
  sort(r.begin(), r.end());
  vector<long long> ans(original_n + 1);
  long long lx = -inf, rx = -inf;
  int pl = 0, pr = 0;
  int k = 0;
  while (pl < n || pr < n) {
    long long wait = min(pl < n ? l[pl] - lx : inf, pr < n ? r[pr] - rx : inf);
    ans[k] += wait;
    lx += wait;
    rx += wait;
    while (pl < n && l[pl] == lx) {
      k += 1;
      lx += 1;
      pl += 1;
    }
    while (pr < n && r[pr] == rx) {
      ans[k] += 1;
      k -= 1;
      rx += 1;
      pr += 1;
    }
  }
  for (int i = n; i > 1; i--) {
    ans[i - 1] += ans[i];
  }
  for (int i = 1; i <= original_n; i++) {
    cout << ans[i] << '\n';
  }
  return 0;
}
--------------------------------------------------
Problem ID: 1965E
Editorial Content:
1965E - Connected Cubes
Solution
Tutorial is loading...
Code
n, m, k = map(int, input().split())
a = []

for i in range(n):
    a.append(list(map(int, input().split())))

ans = []

for x in range(n):
    for y in range(m):
        for z in range(1, n + 1):
            if y % 2 == 1:
                ans.append([x, y, z, a[x][y]])
            else:
                ans.append([x, y, z, a[min(x, n - z)][y]])
        for z in range(n + 1, n + k + 1):
            if y % 2 == 1:
                ans.append([x, y, z, a[x][y]])
            else:
                ans.append([x, y, z, z - n])

for x in range(n, n + k):
    for y in range(m):
        for z in range(1, n + 1):
            if y % 2 == 1:
                ans.append([x, y, z, x - n + 1])
            else:
                ans.append([x, y, z, a[n - z][y]])
        ans.append([x, y, n + 1, x - n + 1])

for y in range(m):
    for z in range(n + 2, n + k + 1):
        ans.append([n, y, z, z - n])

for x in range(n + 1, n + k):
    for z in range(n + 2, n + k + 1):
        ans.append([x, 0, z, max(x - n + 1, z - n)])

print(len(ans))

for cube in ans:
    print(cube[0] + 1, cube[1] + 1, cube[2] + 1, cube[3])
--------------------------------------------------
Problem ID: 1965D
Editorial Content:
1965D - Missing Subarray Sum
Solution
Tutorial is loading...
Code
def getSubarraySums(a):

    cts = []
    for i in range(len(a)):
        sm = 0
        for j in range(i, len(a)):
            sm = sm + a[j]
            cts.append(sm)

    cts.sort()
    return cts

def getOddOccurringElements(cts):

    odds = []

    for ct in cts:
        if len(odds) > 0 and ct == odds[-1]:
            odds.pop()
        else:
            odds.append(ct)
    return odds

def getPalindrome(odds, n):

    a = [0] * n
    prev = 0
    idx = (n - 1) // 2
    
    for x in odds:
        if idx == n - 1 - idx:
            a[idx] = x
        else:
            a[idx] = (x - prev) // 2
            a[n - 1 - idx] = (x - prev) // 2
        prev = x
        idx = idx - 1
    
    return a

def getLargestExcluded(bigList, smallList):

    while len(smallList) > 0 and bigList[-1] == smallList[-1]:
        bigList.pop()
        smallList.pop()
    return bigList[-1]

t = int(input())

for tc in range(t):

    n = int(input())
    
    subarraySums = list(map(int, input().split()))
    subarraySums.sort()
    odds = getOddOccurringElements(subarraySums)
    
    missingSum = -1
    
    if len(odds) > (n + 1) // 2:
    
        oddvals = []
        evenvals = []
        for x in odds:
            if x % 2 == 1:
                oddvals.append(x)
            else:
                evenvals.append(x)

        if len(evenvals) > 0 and len(oddvals) > 0:

            missingSum = evenvals[0] if len(evenvals) == 1 else oddvals[0]

        else:

            b = getPalindrome(odds, n + 2)
            bSums = getSubarraySums(b)
            y = bSums[-1]
            x = getLargestExcluded(bSums, subarraySums)
            missingSum = 2 * x - y
    
    else:
        
        b = getPalindrome(odds, n - 2)
        bSums = getSubarraySums(b)
        y = bSums[-1]
        x = getLargestExcluded(subarraySums, bSums)
        missingSum = 2 * x - y

    odds.append(missingSum)
    odds.sort()
    odds = getOddOccurringElements(odds)
    
    ans = getPalindrome(odds, n)
    print(*ans)
--------------------------------------------------
Problem ID: 1965C
Editorial Content:
1965C - Folding Strip
Solution
Tutorial is loading...
Code
t = int(input())

for tc in range(t):
    n = int(input())
    s = input()
    mn = 0
    mx = 0
    cur = 0

    for c in s:

        if (cur % 2 == 0) == (c == '1'):
            cur = cur + 1
        else:
            cur = cur - 1

        mn = min(mn, cur)
        mx = max(mx, cur)

    print(mx - mn)
--------------------------------------------------
Problem ID: 1965B
Editorial Content:
1965B - Missing Subsequence Sum
Solution
Tutorial is loading...
Code
t = int(input())

for tc in range(t):
    n, k = map(int, input().split())

    i = 0
    while (1 << (i + 1)) <= k:
        i = i + 1

    ans = [k - (1 << i), k + 1, k + 1 + (1 << i)]

    for j in range(20):
        if j != i:
            ans.append(1 << j);

    print(len(ans))
    print(*ans)
--------------------------------------------------
Problem ID: 1965A
Editorial Content:
1965A - Everything Nim
Solution
Tutorial is loading...
Code
t = int(input())

for tc in range(t):

    n = int(input())
    a = list(map(int, input().split()))

    maxsize = max(a)

    a.sort()
    mexsize = 1
    for sz in a:
        if sz == mexsize:
            mexsize = mexsize + 1

    if mexsize > maxsize:
        print("Alice" if maxsize % 2 == 1 else "Bob")
    else:
        print("Alice" if mexsize % 2 == 1 else "Bob")
--------------------------------------------------
Problem ID: 1958J
Editorial Content:
1958J - Necromancer
Tutorial
Tutorial is loading...
Solution (Neon)
const val M = 1000
const val K = 10

fun main() {  
  val (n, q) = readLine()!!.split(" ").map { it.toInt() }
  val a = readLine()!!.split(" ").map { it.toInt() }
  val b = readLine()!!.split(" ").map { it.toInt() }
  val l = IntArray(q)
  val r = IntArray(q)
  for (i in 0 until q) {
    val (x, y) = readLine()!!.split(" ").map { it.toInt() - 1}
    l[i] = x
    r[i] = y
  }
  val s = b.scan(0, Int::plus)
  val ev = Array(n) { mutableListOf<Int>() }
  for (i in 0 until n) {
    for (j in 1 until K) {
      val x = s[i] - (a[i] + j - 1) / j + 1
      val pos = s.binarySearch { if (it < x) -1 else 1 }.inv()
      if (pos < i) ev[pos].add(i)
    }
  }
  val qr = Array(n) { mutableListOf<Int>() }
  for (i in 0 until q) qr[l[i]].add(i)
  val f = IntArray(n) { 0 }
  fun inc(i : Int) = generateSequence(i) { (it or (it + 1)).takeIf { it < n } }.forEach { ++f[it] }
  fun sum(i : Int) = generateSequence(i) { ((it and (it + 1)) - 1).takeIf { it >= 0 } }.sumOf { f[it] }
  for (i in 0 until n) inc(i)
  val ans = IntArray(q) { 0 }
  for (i in 0 until n) {
    for (j in ev[i]) inc(j)
    for (j in qr[i]) {
      var cur = b[l[j]]
      for (x in 1 until M.coerceAtMost(r[j] - l[j] + 1)) {
        ans[j] += (a[l[j] + x] + cur - 1) / cur
        cur += b[l[j] + x]
      }
      if (l[j] + M <= r[j]) ans[j] += sum(r[j]) - sum(l[j] + M - 1)
    }
  }
  println(ans.joinToString("\n"))
}
--------------------------------------------------
Problem ID: 1958I
Editorial Content:
1958I - Equal Trees
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
fun readTree(n: Int) : List<BooleanArray> {
    val p = listOf(null) + readInts().map { it - 1 }
    return List(n) { a -> BooleanArray(n) { b -> a in generateSequence(b) { p[it] } } }
}
fun main() {
    val n = readInt()
    val t1 = readTree(n)
    val t2 = readTree(n)
    val masks = LongArray(n) { a ->
        (0 until n).filter { b -> a != b && t1[a][b] == t2[a][b] && t1[b][a] == t2[b][a] }.sumOf { 1L shl it }
    }
    val data = mutableMapOf<Long, Int>()
    data[0] = 0
    fun compute(mask: Long) : Int = data.getOrPut(mask) {
        val index = mask.countTrailingZeroBits()
        maxOf(compute(mask xor (1L shl index)), compute(mask and masks[index]) + 1)
    }
    println(2 * (n - compute((1L shl n) - 1)))
}

private fun readInt() = readln().toInt()
private fun readLongs() = readStrings().map { it.toLong() }
private fun readStrings() = readln().split(" ")
private fun readInts() = readStrings().map { it.toInt() }
--------------------------------------------------
Problem ID: 1958H
Editorial Content:
1958H - Composite Spells
Tutorial
Tutorial is loading...
Solution (Neon)
import java.math.BigInteger

fun main() = repeat(readLine()!!.toInt()) {
  val (n, hp) = readLine()!!.split(" ").let { (n, hp) -> n.toInt() to BigInteger(hp) } 
  val s = readLine()!!.split(" ").map { BigInteger(it) }
  val m = readLine()!!.toInt()
  val c = Array(m) { readLine()!!.split(" ").drop(1).map { it.toInt() - 1 } }
  val delta = Array(m) { BigInteger.ZERO }
  val minDelta = Array(m) { BigInteger.ZERO }
  for (i in 0 until m) {
    var curHP = BigInteger.ZERO
    for (id in c[i]) {
      if (id < n) {
        curHP += s[id]
        minDelta[i] = minOf(minDelta[i], curHP)
      } else {
        minDelta[i] = minOf(minDelta[i], curHP + minDelta[id - n])
        curHP += delta[id - n]
      }
    }
    delta[i] = curHP
  }
  
  fun rec(remHP : BigInteger, idCompSpell : Int) : Int {
    var curHP = remHP
    for (id in c[idCompSpell]) {
      if (id < n) {
        curHP += s[id]
        if (curHP <= BigInteger.ZERO)
          return id + 1
      } else {
        if (curHP + minDelta[id - n] <= BigInteger.ZERO)
          return rec(curHP, id - n)
        curHP += delta[id - n]
      }
    }
    return -1
  }
  
  println(rec(hp, m - 1))
}
--------------------------------------------------
Problem ID: 1958G
Editorial Content:
1958G - Observation Towers
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
import kotlin.math.abs
import kotlin.math.sign

fun main() {
    readInts()
    val x = readInts()
    val h = readInts()
    val ord = buildList {
        for (i in x.indices.sortedBy { x[it] }) {
            while (isNotEmpty() && h[i] - h[last()] >= x[i] - x[last()]) {
                removeLast()
            }
            if (isEmpty() || h[last()] - h[i] <= x[i] - x[last()]) {
                add(i)
            }
        }
    }.map { x[it] to h[it] }

    fun nextAfter(pos: Int) = ord.binarySearch { (x, _) -> if (x >= pos) 1 else -1 }.inv()
    fun coverBy(idx: Int, pos: Int) = ord.getOrNull(idx)?.let { (x, h) -> maxOf(0, abs(x - pos) - h) } ?: Int.MAX_VALUE
    fun cover(pos: Int): Int {
        val a = nextAfter(pos)
        return minOf(coverBy(a - 1, pos), coverBy(a, pos))
    }

    fun cover2(l: Int, r: Int): Int {
        val a = nextAfter((l + r) / 2)
        return minOf(maxOf(coverBy(a, l), coverBy(a, r)), maxOf(coverBy(a - 1, l), coverBy(a - 1, r)))
    }

    val ans = List(readInt()) {
        val (l, r) = readInts()
        minOf(
            cover(l) + cover(r),
            cover2(l, r)
        )
    }
    println(ans.joinToString(" "))
}

private fun readInt() = readln().toInt()
private fun readLongs() = readStrings().map { it.toLong() }
private fun readStrings() = readln().split(" ")
private fun readInts() = readStrings().map { it.toInt() }
--------------------------------------------------
Problem ID: 1958F
Editorial Content:
1958F - Narrow Paths
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
private const val MOD =  1000000007

@JvmInline
@Suppress("NOTHING_TO_INLINE")
private value class ModInt(val x: Int) {
    inline operator fun plus(other: ModInt) = ModInt((x + other.x).let { if (it >= MOD) it - MOD else it })
    inline operator fun minus(other: ModInt) = ModInt((x - other.x).let { if (it < 0) it + MOD else it })
    inline operator fun times(other: ModInt) = ModInt((x.toLong() * other.x % MOD).toInt())
    fun power(p_: Int): ModInt {
        var a = this
        var res = ModInt(1)
        var p = p_
        while (p != 0) {
            if ((p and 1) == 1) res *= a
            a *= a
            p = p shr 1
        }
        return res
    }

    inline operator fun div(other: ModInt) = this * other.inv()
    inline fun inv() = power(MOD - 2)

    companion object {
        inline fun from(x: Int) = ModInt((x % MOD + MOD) % MOD)
        inline fun from(x: Long) = ModInt(((x % MOD).toInt() + MOD) % MOD)
    }
}

@JvmInline
private value class ModIntArray(val storage:IntArray) {
    operator fun get(index: Int) = ModInt(storage[index])
    operator fun set(index: Int, value: ModInt) { storage[index] = value.x }
    val size get() = storage.size
}
private inline fun ModIntArray(n: Int, init: (Int) -> ModInt) = ModIntArray(IntArray(n) { init(it).x })

private const val COMB_MAX = 400_010

private val fs = ModIntArray(COMB_MAX) { ModInt(1) }.apply {
    for (i in 1 until size) {
        set(i, get(i - 1) * ModInt.from(i))
    }
}
private val ifs = ModIntArray(COMB_MAX) { fs[it].inv() }

private fun cnk(n: Int, k: Int) = if (n >= k) fs[n] * ifs[k] * ifs[n - k] else ModInt(0)

fun main() {
    val (n, k) = readInts()
    val ans = ModIntArray(n + 1) { ModInt(0) }

    for (diff in -n..n) {
        val ways = maxOf(0, diff - 1)
        val ll = maxOf(1, diff)
        val rr = minOf(n, n - 1 + diff)
        ans[ways] += ModInt(maxOf(0, rr - ll)) * cnk(n - diff - 1, k - 2)
    }
    for (i in 1 until n) {
        ans[i] += cnk(n - i - 1, k - 1)
    }
    for (j in 0 until n - 1) {
        ans[n - j - 1] += cnk(j, k - 1)
    }
    println(ans.storage.joinToString(" "))
}

private fun readInt() = readln().toInt()
private fun readLongs() = readStrings().map { it.toLong() }
private fun readStrings() = readln().split(" ")
private fun readInts() = readStrings().map { it.toInt() }
--------------------------------------------------
Problem ID: 1958E
Editorial Content:
1958E - Yet Another Permutation Constructive
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
private fun solve(): String {
    val (n, k) = readInts()
    var ans = listOf(n - 1, n)
    repeat(k - 1) {
        val min = ans.min()
        val prevStart = min - ans.size + 1
        if (prevStart <= 0) {
            return "-1"
        }
        ans = ans.zip(prevStart .. min).flatMap { (a, b) -> listOf(a, b) }.dropLast(1)
    }
    ans = (1 until ans.min()) + ans
    return ans.joinToString(" ")
}
fun main() {
    repeat(readInt()) {
        println(solve())
    }
}

private fun readInt() = readln().toInt()
private fun readLongs() = readStrings().map { it.toLong() }
private fun readStrings() = readln().split(" ")
private fun readInts() = readStrings().map { it.toInt() }
--------------------------------------------------
Problem ID: 1958D
Editorial Content:
1958D - Staircase
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
fun main() {
    repeat(readInt()) {
        readInt()
        val d = mutableListOf(mutableListOf<Long>())
        for (i in readLongs()) {
            if (i == 0L) {
                d.add(mutableListOf())
            } else {
                d.last().add(i)
            }
        }
        println(d.sumOf { l -> 2 * l.sum() - ((l.indices step 2).takeIf { l.size % 2 == 1 }?.maxOfOrNull { l[it] } ?: 0) })
    }
}

private fun readInt() = readln().toInt()
private fun readLongs() = readStrings().map { it.toLong() }
private fun readStrings() = readln().split(" ")
private fun readInts() = readStrings().map { it.toInt() }
--------------------------------------------------
Problem ID: 1958C
Editorial Content:
1958C - Firewood
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
fun main() {
    repeat(readInt()) {
        val (n, k) = readLongs()
        println(n - k.countTrailingZeroBits())
    }
}

private fun readInt() = readln().toInt()
private fun readLongs() = readStrings().map { it.toLong() }
private fun readStrings() = readln().split(" ")
private fun readInts() = readStrings().map { it.toInt() }
--------------------------------------------------
Problem ID: 1958B
Editorial Content:
1958B - Clock in the Pool
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
fun main() {
    repeat(readInt()) {
        val (k, m) = readInts()
        println(maxOf(0, 2 * k - (m % (3 * k))))
    }
}

private fun readInt() = readln().toInt()
private fun readLongs() = readStrings().map { it.toLong() }
private fun readStrings() = readln().split(" ")
private fun readInts() = readStrings().map { it.toInt() }
--------------------------------------------------
Problem ID: 1958A
Editorial Content:
1958A - 1-3-5
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
fun main() {
    val ans = IntArray(101) { Int.MAX_VALUE }
    ans[0] = 0
    for (i in ans.indices) {
        for ((d, c) in listOf(1 to 1, 3 to 0, 5 to 0)) {
            if (i + d in ans.indices) ans[i + d] = minOf(ans[i + d], ans[i] + c)
        }
    }
    repeat(readInt()) {
        println(ans[readInt()])
    }
}

private fun readInt() = readln().toInt()
private fun readLongs() = readStrings().map { it.toLong() }
private fun readStrings() = readln().split(" ")
private fun readInts() = readStrings().map { it.toInt() }
--------------------------------------------------
Problem ID: 1957F2
Editorial Content:
1957F2 - Frequency Mismatch (Hard Version)
Hint 1
How would you find the smallest element with different frequencies in two static arrays using a segment tree? Consider hashing.
Hint 2
Try extending this idea to finding the smallest element with different frequencies in two different paths on a tree. Think persistent data structures.
Hint 3
Once you solve that, you can be extend it to finding the k smallest elements.
Solution
Tutorial is loading...
You can also use an idea similar to the hashing technique used in F1 to hash the segment tree nodes.
Rate this problem
Great Problem
Ok Problem
Bad Problem
Didn't solve
C++ Code
#include <bits/stdc++.h>
using namespace std;
 
const int MOD1 = 1e9 + 7;
const int MOD2 = 998244353;
using ll = long long;
using dbl = long double;
//#define int ll
 
using vi = vector<int>;
using vvi = vector<vi>;
using pii = pair<int, int>;
using vii = vector<pii>;
using vvii = vector<vii>;
using vll = vector<ll>;
 
#define ff first
#define ss second
#define pb push_back
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define tc int t; cin>>t; while(t--)
#define fightFight cin.tie(0) -> sync_with_stdio(0)
template<class T>
struct RMQ {
    vector<vector<T>> jmp;
    RMQ(const vector<T>& V) : jmp(1, V) {
        for (int pw = 1, k = 1; pw * 2 <= sz(V); pw *= 2, ++k) {
            jmp.emplace_back(sz(V) - pw * 2 + 1);
            rep(j,0,sz(jmp[k]))
                jmp[k][j] = min(jmp[k - 1][j], jmp[k - 1][j + pw]);
        }
    }
    T query(int a, int b) {
        assert(a <= b); // tie(a, b) = minimax(a, b)
        int dep = 31 - __builtin_clz(b-a+1);
        return min(jmp[dep][a], jmp[dep][b - (1 << dep) + 1]);
    }
};
struct LCA {
    int T = 0;
    vi st, path, ret; vi en, d;
    RMQ<int> rmq;
    LCA(vector<vi>& C) : st(sz(C)), en(sz(C)), d(sz(C)), rmq((dfs(C,1,-1), ret)) {}
    void dfs(vvi &adj, int v, int par) {
        st[v] = T++;
        for (auto to : adj[v]) if (to != par) {
            path.pb(v), ret.pb(st[v]);
            d[to] = d[v] + 1;
            dfs(adj, to, v);
        }
        en[v] = T-1;
    }
    bool anc(int p, int c) { return st[p] <= st[c] and en[p] >= en[c]; }
    int lca(int a, int b) {
        if (a == b) return a;
        tie(a, b) = minmax(st[a], st[b]);
        return path[rmq.query(a, b-1)];
    }
    int dist(int a, int b) { return d[a] + d[b] - 2*d[lca(a,b)]; }
};
template<const int mod>
struct mint {
    constexpr mint(int x = 0) : val((x % mod + mod) % mod) {}
    mint& operator+=(const mint &b) { val += b.val; val -= mod * (val >= mod); return *this; }
    mint& operator-=(const mint &b) { val -= b.val; val += mod * (val < 0); return *this; }
    mint& operator*=(const mint &b) { val = 1ll * val * b.val % mod; return *this; }
    mint& operator/=(const mint &b) { return *this *= b.inv(); }
    mint inv() const {
        int x = 1, y = 0, t;
        for(int a=val, b=mod; b; swap(a, b), swap(x, y))
            t = a/b, a -= t * b, x -= t * y;
        return mint(x);
    }
    mint pow(int b) const {
        mint a = *this, res(1);
        for(; b; a *= a, b /= 2)  if(b&1) res *= a;
        return res;
    }
    friend mint operator+(const mint &a, const mint &b) { return mint(a) += b; }
    friend mint operator-(const mint &a, const mint &b) { return mint(a) -= b; }
    friend mint operator*(const mint &a, const mint &b) { return mint(a) *= b; }
    friend mint operator/(const mint &a, const mint &b) { return mint(a) /= b; }
    friend bool operator==(const mint &a, const mint &b) { return a.val == b.val; }
    friend bool operator!=(const mint &a, const mint &b) { return a.val != b.val; }
    friend bool operator<(const mint &a, const mint &b) { return a.val < b.val; }
    friend ostream& operator<<(ostream &os, const mint &a) { return os << a.val; }
    int val;
};
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
uniform_int_distribution<ll> rnd(20,10000);
using Mint1 = mint<MOD1>;
using Mint2 = mint<MOD2>;
using Mint = pair<Mint1,Mint2>;
const int N = 3e5 + 10, LOGN = 20;
int p1, p2;
int blen = 0;
int L[N * LOGN], R[N * LOGN];
Mint ST[N * LOGN], p_pow[N];
void prec() {
    p1 = rnd(rng);
    p2 = p1; 
    while (p2 == p1) p2 = rnd(rng);
    p_pow[0].ff = 1;
    p_pow[0].ss = 1;
    for (int i = 1; i < N; i++) {
        p_pow[i].ff = p_pow[i - 1].ff * p1;
        p_pow[i].ss = p_pow[i - 1].ss * p2;
    }
}
int update(int pos, int l, int r, int id) {
    if (pos < l || pos > r) return id;
    int ID = ++blen, m = (l + r) / 2;
    if (l == r) return (ST[ID] = {ST[id].ff + 1, ST[id].ss + 1}, ID);
    L[ID] = update(pos, l, m, L[id]);
    R[ID] = update(pos, m + 1, r, R[id]);
    return (ST[ID] = {ST[L[ID]].ff + p_pow[m - l + 1].ff * ST[R[ID]].ff, ST[L[ID]].ss + p_pow[m - l + 1].ss * ST[R[ID]].ss}, ID);
}
vi vals;
using a4 = array<int,4>;
void descent(int l, int r, const array<int, 4>& a, const array<int, 4>& b, int k) {
    if (l == r) return void(vals.push_back(l));
    int m = (l + r) / 2;
#define stm(X, y) {ST[X[y[0]]].ff + ST[X[y[1]]].ff - ST[X[y[2]]].ff - ST[X[y[3]]].ff, ST[X[y[0]]].ss + ST[X[y[1]]].ss - ST[X[y[2]]].ss - ST[X[y[3]]].ss}
#define arr(X, y) (a4{X[y[0]], X[y[1]], X[y[2]], X[y[3]]})
    Mint l1 = stm(L, a), l2 = stm(L, b), r1 = stm(R, a), r2 = stm(R, b);
    if (sz(vals) < k && l1 != l2) descent(l, m, arr(L, a), arr(L, b), k);
    if (sz(vals) < k && r1 != r2) descent(m + 1, r, arr(R, a), arr(R, b), k);
}
 
vvi adj;
vi a, roots, par; 
void dfs(int x, int p) {
    par[x] = p;
    roots[x] = update(a[x], 0, N, roots[par[x]]);
    for (auto& s : adj[x]) if (s != p) {
        dfs(s, x);
    }
}
void solve(){
    int n; cin >> n;        
    adj = vvi(n + 1);
    a = roots = par = vi(n + 1);
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 0; i < n - 1; i++) {
        int a, b; cin >> a >> b;
        adj[a].pb(b), adj[b].pb(a);
    }
    dfs(1, 0);
    LCA lca(adj);
    int q; cin >> q;
    while (q--) {
        vals.clear();
        int u1, v1, u2, v2, k; cin >> u1 >> v1 >> u2 >> v2 >> k;
        int l1 = lca.lca(u1, v1), l2 = lca.lca(u2, v2);
        a4 a{roots[u1], roots[v1], roots[l1], roots[par[l1]]};
        a4 b{roots[u2], roots[v2], roots[l2], roots[par[l2]]};
        descent(0, N, a, b, k);
        cout << sz(vals) << " ";
        for (auto& s : vals) cout << s << " ";
        cout << "\n";
    }
}
signed main(){ 
    fightFight; 
    prec();
    solve(); 
}
--------------------------------------------------
Problem ID: 1957F1
Editorial Content:
1957F1 - Frequency Mismatch (Easy Version)
Hint 1
Let's try answering a different question. Given two multisets of elements how can we check if they differ? Hashing? How to multiset hash efficiently?
Hint 2
Okay if we can now differentiate two multisets of unequal elements, can we try to answer queries by inserting into these hypothetical multisets and binary search the differing point to identify the element?
Solution
Let's discuss how to hash a multiset of elements $$$a$$$, $$$b$$$ and $$$c$$$. Here, I will link you to a famous blog by
r
ng_58
Hashing and Probability of Collision
. Quoting, let's take a random integer $$$r$$$ from the interval $$$[0, MOD)$$$, and compute the hash $$$(r+a_1)(r+a_2)\dots(r+a_n)$$$. This is a polynomial of $$$r$$$ of degree $$$n$$$, so again from Schwartz-Zippel lemma, the collision probability is at most $$$\frac{n}{MOD}$$$. The nice thing about this construction is that we can compute rolling hashes using this idea fast. To make implementation easier, this bound applies for summing the random numbers as well. You can check
this
for proof.
Let's try to answer a single query $$$(u_1, v_1, u_2, v_2)$$$ using binary search. We will solve this query in $$$nlog^2(n)$$$ using this idea. To check for some $$$mid$$$ in our binary search, we insert the values of all nodes which have values from $$$1$$$ to $$$mid$$$ into a data structure that we can query the path sum of $$$u$$$ to $$$v$$$ using. Querying path sum is a fairly standard problem that can be solved using BIT / Segment trees and ETT (Euler-Tour Trick). Now to solve this query, we only need to binary search and find the first vertex where the hashes differ for both the paths. This vertex is guaranteed to have mismatched frequency on the two paths since it's addition into the path multi-sets changed their hashes. So now we can solve a single query in $$$nlog^2(n)$$$ time using hashing + BIT / Segtree.
Now to solve this problem for all $$$Q$$$ queries. We can use the idea of parallel binary search here to improve our idea to answering all $$$Q$$$ queries efficiently. We can run the binary search for all queries in parallel. For each iteration, sort queries by the current position of their $$$mid$$$ values. Then insert values from $$$1$$$ to $$$mid$$$ of the first query into the BIT and query range sum to determine for that particular query how to adjust $$$mid$$$. You can then move the $$$mid$$$ pointer to that of the next query and so on. This solution will run in $$$O(nlog(n) + qlog^2(n))$$$.
Upd:
Thanks to
IceKnight1093
for pointing this out. If we just use a single
int
hash with a field size of $$$\approx 10^9$$$, it gives us a probability of failure of $$$\frac{1}{10^9}$$$ per query. Since we're doing somewhere of the order $$$10^6$$$ comparisons per hash representation, this gives a rough $$$1 - \Big(1 - \frac{1}{10^9}\Big)^{10^6} \approx 10^{-3}$$$ chance of failure. This is not a great bound theoretically speaking, but from a practical standpoint, it is a loose bound and it is extremely unlikely that this solution can be hacked. That said, if we want better theoretical bounds we can just use a hash with field size $$$\approx 10^{18}$$$ or use double hashing. Even if we were to query all $$${n \choose 2}$$$ paths, the chance of collision is $$$\approx \frac{n^2}{10^{18}} \approx 10^{-8}$$$, which is more than good enough. TL's were set to allow double hashing solutions to pass comfortably.
Rate this problem
Great Problem
Ok Problem
Bad Problem
Didn't solve
C++ Code
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e9 + 7;
using ll = long long;
using dbl = long double;
//#define int ll

using vi = vector<int>;
using vvi = vector<vi>;
using pii = pair<int, int>;
using vii = vector<pii>;
using vvii = vector<vii>;
using vll = vector<ll>;

#define ff first
#define ss second
#define pb push_back
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define tc int t; cin>>t; while(t--)
#define fightFight cin.tie(0) -> sync_with_stdio(0)

template<class T>
struct RMQ {
    vector<vector<T>> jmp;
    RMQ(const vector<T>& V) : jmp(1, V) {
        for (int pw = 1, k = 1; pw * 2 <= sz(V); pw *= 2, ++k) {
            jmp.emplace_back(sz(V) - pw * 2 + 1);
            rep(j,0,sz(jmp[k]))
                jmp[k][j] = min(jmp[k - 1][j], jmp[k - 1][j + pw]);
        }
    }
    T query(int a, int b) {
        assert(a <= b); // tie(a, b) = minimax(a, b)
        int dep = 31 - __builtin_clz(b-a+1);
        return min(jmp[dep][a], jmp[dep][b - (1 << dep) + 1]);
    }
};

struct LCA {
    int T = 0;
    vi st, path, ret; vi en, d;
    RMQ<int> rmq;
    LCA(vector<vi>& C) : st(sz(C)), en(sz(C)), d(sz(C)), rmq((dfs(C,0,-1), ret)) {}
    void dfs(vvi &adj, int v, int par) {
        st[v] = T++;
        for (auto to : adj[v]) if (to != par) {
            path.pb(v), ret.pb(st[v]);
            d[to] = d[v] + 1;
            dfs(adj, to, v);
        }
        en[v] = T-1;
    }
    bool anc(int p, int c) { return st[p] <= st[c] and en[p] >= en[c]; }
    int lca(int a, int b) {
        if (a == b) return a;
        tie(a, b) = minmax(st[a], st[b]);
        return path[rmq.query(a, b-1)];
    }
    int dist(int a, int b) { return d[a] + d[b] - 2*d[lca(a,b)]; }
};

template<const int mod>
struct mint {
    constexpr mint(int x = 0) : val((x % mod + mod) % mod) {}
    mint& operator+=(const mint &b) { val += b.val; val -= mod * (val >= mod); return *this; }
    mint& operator-=(const mint &b) { val -= b.val; val += mod * (val < 0); return *this; }
    mint& operator*=(const mint &b) { val = 1ll * val * b.val % mod; return *this; }
    mint& operator/=(const mint &b) { return *this *= b.inv(); }
    mint inv() const {
        int x = 1, y = 0, t;
        for(int a=val, b=mod; b; swap(a, b), swap(x, y))
            t = a/b, a -= t * b, x -= t * y;
        return mint(x);
    }
    mint pow(int b) const {
        mint a = *this, res(1);
        for(; b; a *= a, b /= 2)  if(b&1) res *= a;
        return res;
    }
    friend mint operator+(const mint &a, const mint &b) {return mint(a) += b;}
    friend mint operator-(const mint &a, const mint &b) {return mint(a) -= b;}
    friend mint operator*(const mint &a, const mint &b) {return mint(a) *= b;}
    friend mint operator/(const mint &a, const mint &b) {return mint(a) /= b;}
    friend bool operator==(const mint &a, const mint &b) {return a.val == b.val;}
    friend bool operator!=(const mint &a, const mint &b) {return a.val != b.val;}
    friend bool operator<(const mint &a, const mint &b) {return a.val < b.val;}
    friend ostream& operator<<(ostream &os, const mint &a) {return os << a.val;}
    int val;
};
using Mint = mint<MOD>;

template<typename... Ts, size_t... Is, typename F>
void __op(index_sequence<Is...>, tuple<Ts...>& a, const tuple<Ts...>& b, F op) { ((get<Is>(a) = op(get<Is>(a), get<Is>(b))), ...); }
#define OVERLOAD(OP, F) \
template<typename... Ts> auto& operator OP##=(tuple<Ts...> &a, const tuple<Ts...> &b) { __op(index_sequence_for<Ts...>(), a, b, F<>{}); return a; } \
template<typename... Ts> auto operator OP(const tuple<Ts...> &a, const tuple<Ts...> &b) { auto c = a; c OP##= b; return c; }
OVERLOAD(+, plus) OVERLOAD(-, minus) OVERLOAD(*, multiplies) OVERLOAD(/, divides)

constexpr int NUM_HASHES = 2; // *
constexpr array<int, NUM_HASHES> mods = {127657753, 987654319}; // *
template <size_t N = NUM_HASHES>
constexpr auto mint_ntuple(const int &v) {
    return [&]<size_t... Is>(index_sequence<Is...>) { return make_tuple(mint<mods[Is]>(v)...); }(make_index_sequence<N>{}); }

using HT = decltype(mint_ntuple(0));

template<typename T>
struct FT {
    vector<T> s;
    T def;
    FT(int n, T def) : s(n, def), def(def) {}
    void update(int pos, T dif) { // a[pos] += dif
        for (; pos < sz(s); pos |= pos + 1) s[pos] += dif;
    }
    T query(int pos) { // sum of values in [0, pos)
        pos++;
        T res = def;
        for (; pos > 0; pos &= pos - 1) res += s[pos-1];
        return res;
    }
};

struct Query {
    int u1, v1, u2, v2, k;
    int l, r, ans, i;
    int mid(){ return l + (r-l)/2; }
};

auto rng = std::mt19937(std::random_device()());
constexpr const int MXN = 1e5+5;

void solve(){
    int n; cin >> n;
    vi a(n); for(auto &x : a) cin >> x, x--;
    vvi adj(n);
    for(int i=0; i < n-1; i++){
        int u, v; cin >> u >> v; u--, v--;
        adj[u].pb(v); adj[v].pb(u);
    }

    int q; cin >> q;
    vector<Query> queries(q);
    int idx=0;
    for(auto &[u1, v1, u2, v2, k, l, r, ans, i] : queries) cin >> u1 >> v1 >> u2 >> v2 >> k, u1--, v1--, u2--, v2--, l=0, ans=-1, i=idx++;

    LCA lca(adj);
    vi uni(a); sort(all(uni)); uni.resize(unique(all(uni)) - uni.begin());
    vvi cnode(MXN);
    for(int v=0; v < n; v++) cnode[a[v]].pb(v);
    vector<HT> hash(MXN);
    for(auto &c : uni) hash[c] = {rng(), rng()};    

    auto get_ett = [&](vvi &adj){
        vi tin(n), tout(n);
        int timer = 0;
        function<void(int,int)> dfs = [&](int v, int p){
            tin[v] = timer++;
            for(auto &to : adj[v]) if(to != p) dfs(to, v);
            tout[v] = timer++;
        };
        dfs(0, -1);
        return make_pair(tin, tout);
    };
    auto [tin, tout] = get_ett(adj);

    for(auto &q : queries) q.r = sz(uni)-1;

    vi vis(MXN);
    for(int _=0; _<20; _++){
        FT<HT> st(2*n, mint_ntuple(0));
        sort(all(queries), [&](Query &a, Query &b) { return a.mid() < b.mid(); });
        for(int qq=0, cptr=0; qq < q; qq++) if(queries[qq].l <= queries[qq].r) {
            auto &[u1, v1, u2, v2, k, l, r, ans, i] = queries[qq];
            for(; cptr < sz(uni) and cptr <= queries[qq].mid(); cptr++){
                for(auto &v : cnode[uni[cptr]])
                    st.update(tin[v], hash[uni[cptr]]), st.update(tout[v], mint_ntuple(0)-hash[uni[cptr]]);
                vis[uni[cptr]] = true;
            }

            int lca1 = lca.lca(u1, v1), lca2 = lca.lca(u2, v2);
            HT r1 = st.query(tin[lca1]), r2 = st.query(tin[lca2]);
            HT hash1 = (st.query(tin[u1]) + st.query(tin[v1]) - (r1 + r1));
            if(vis[a[lca1]]) hash1 += hash[a[lca1]];
            HT hash2 = (st.query(tin[u2]) + st.query(tin[v2]) - (r2 + r2));
            if(vis[a[lca2]]) hash2 += hash[a[lca2]];

            if(hash1 != hash2){
                ans = queries[qq].mid();
                r = queries[qq].mid()-1;
            }
            else l = queries[qq].mid()+1;
        }
        for(auto &c : uni) vis[c] = false;
    }
    
    sort(all(queries), [&](Query &a, Query &b) { return a.i < b.i; });
    for(auto &[u1, v1, u2, v2, k, l, r, ans, i] : queries){
        if(ans == -1) cout << 0 << '\n';
        else cout << 1 << ' ' << uni[ans]+1 << '\n';
    }
}
signed main(){ 
    fightFight; 
    solve(); 
}
--------------------------------------------------
Problem ID: 1957E
Editorial Content:
1957E - Carousel of Combinations
Hint 1
For what values of $$$j$$$ is $$$C(i,j) \bmod j = 0$$$?
Hint 2
For all other values of $$$j$$$, how can you precompute the result?
Hint 3
To precompute, switch around the loop order.
Solution
The number of distinct ways you can select $$$k$$$ distinct numbers from the set {$$$1, 2, \ldots, i$$$} and arrange them in a line is $$$i(i-1)\cdots(i-k+1)$$$, and since arranging in a circle introduces rotational symmetry we have to divide by $$$k$$$, so we have $$$C(i,k) = \frac{i(i-1)\cdots(i-k+1)}{k}$$$.
Therefore $$$C(i,j) \bmod j = \frac{i(i-1)\cdots(i-j+1)}{j} \bmod j$$$. Now since the numerator is a product of $$$j$$$ consecutive integers, atleast one of them will be divisible by $$$j$$$. More precisely the exact integer which will be divisible by $$$j$$$ will be $$$ j \times \lfloor \frac{i}{j} \rfloor$$$. Hence we can simplify the fraction by removing the denominator and replacing the term $$$ j \times \lfloor \frac{i}{j} \rfloor$$$ with $$$\lfloor \frac{i}{j} \rfloor$$$ in the numerator. Each of the other $$$j-1$$$ integers in the numerator, after applying $$$\bmod j$$$ would cover all integers from $$$1$$$ to $$$j-1$$$. Hence
$$$C(i,j) \bmod j = \frac{i(i-1)\cdots(i-j+1)}{j} \bmod j = \left( (j-1)! \times \left\lfloor \frac{i}{j} \right\rfloor \right) \bmod j$$$
Here we can notice that all proper factors of $$$j$$$ will occur in $$$(j-1)!$$$, so based on this we can tell that $$$C(i,j) \bmod j = 0$$$ for all composite numbers $$$j$$$ except $$$j=4$$$.
We first can handle the case of $$$j$$$ being prime. Using Wilson's Theorem, we know that $$$(j-1)! \equiv -1 \bmod j$$$ when $$$j$$$ is prime. Hence
$$$C(i,j) \bmod j = - \left\lfloor \frac{i}{j} \right\rfloor$$$
Now we can reverse the order of loops to sum over all primes, and to calculate the contribution of each prime we can maintain a update array called $$$delta$$$.
To calculate the contribution for a single prime $$$p$$$, we know that for all $$$n$$$ from $$$kp$$$ to $$$(k + 1)p - 1$$$ (for all $$$k$$$ such that $$$kp < 1e6$$$) the contribution would be $$$-k$$$. So, in the $$$delta$$$ array, we increment index $$$kp$$$ with $$$-k \bmod p$$$ and decrement index $$$(k + 1)p$$$ with $$$-k \mod p$$$. Now, when we perform a prefix sum on this $$$delta$$$ array, we obtain the correct contributions from all primes.
For the case of $$$j=4$$$, we just need to handle it as a prime.
Rate this problem
Great Problem
Ok Problem
Bad Problem
Didn't solve
C++ Code
#include <bits/stdc++.h>
 
using namespace std;
 
const int MOD = 1e9 + 7;
const int MAX_N = 1e6 + 3;
bitset<MAX_N> isprime;
vector<int> primes;
 
vector<int> eratosthenesSieve(int lim) {
    isprime.set();
    isprime[0] = isprime[1] = false;
    for (int i = 4; i < lim; i += 2) isprime[i] = false;
    for (int i = 3; i * i < lim; i += 2)
        if (isprime[i])
            for (int j = i * i; j < lim; j += i * 2) isprime[j] = false;
    vector<int> pr;
    for (int i = 2; i < lim; i++)
        if (isprime[i]) pr.push_back(i);
    return pr;
}
 
vector<int> ans(MAX_N, 0);
 
signed main() {
    primes = eratosthenesSieve(MAX_N);
    vector<int> del(MAX_N, 0);
    // Handle the contribution for all primes
    for (auto &p: primes) {
        for (int curr = p; curr < MAX_N; curr += p) {
            int inc = (p - ((curr / p) % p)) % p;
            del[curr] = (del[curr] + inc) % MOD;
            if (curr + p < MAX_N) del[curr + p] = (del[curr + p] - inc + MOD) % MOD;
        }
    }
    //Special case of 4
    for (int curr = 4; curr < MAX_N; curr += 4) {
        int inc = (2 * (curr / 4)) % 4;
        del[curr] = (del[curr] + inc) % MOD;
        if (curr + 4 < MAX_N) del[curr + 4] = (del[curr + 4] - inc + MOD) % MOD;
    }
    int pref = 0;
    for (int i = 1; i < MAX_N; i++) {
        pref = (pref + del[i]) % MOD;
        ans[i] = (ans[i - 1] + pref) % MOD;
    }
    int tc;
    cin >> tc;
    while (tc--) {
        int n;
        cin >> n;
        cout << ans[n] << "\n";
    }
}
--------------------------------------------------
Problem ID: 1957D
Editorial Content:
1957D - A BIT of an Inequality
Hint 1
How can you simplify the given inequality? Use the fact that the XOR of a number with itself is 0.
Hint 2
The inequality simplifies to $$$f(x, z) \oplus a_y > f(x, z)$$$. For a given $$$a_y$$$ what subarrays (that include $$$a_y$$$) would satisfy this?
Solution
First we may rewrite the inequality as $$$f(x, z) \oplus a_y > f(x, z)$$$. So, for each index $$$y$$$, we want to find the total number of subarrays that contain $$$y$$$ but whose $$$\text{xor}$$$ decreases when we include the contribution of $$$a_y$$$.
Including $$$a_y$$$ in some subarray $$$[x, z]$$$ (where $$$x \le y \le z$$$) can make the $$$\text{xor}$$$ lower only when some set bit of $$$a_y$$$ cancels out an existing set bit in $$$f(x, y - 1) \oplus f(y + 1, z)$$$. Consider the most signicant set bit in $$$a_y$$$. Call this bit $$$i$$$. Including $$$a_y$$$ would decrease the subarray $$$\text{xor}$$$ in subarrays where $$$f(x, y - 1)$$$ has $$$i$$$ set while $$$f(y+1, z)$$$ is unset or vice-versa.
Now, for the subarrays where both the prefix subarray ($$$[x \dots y - 1]$$$) as well as the suffix subarray ($$$[y + 1 \dots z]$$$) where either both have bit $$$i$$$ set or both have it unset, by including $$$a_y$$$, we increment the xor by at least $$$2^i$$$. Even if by including $$$a_y$$$, every other smaller bit gets unset (because of cancelling out with $$$a_y$$$), this sum of these decrements is still less than $$$2^i$$$ thereby resulting in an overall positive contribution by including $$$a_y$$$.
Rate this problem
Great Problem
Ok Problem
Bad Problem
Didn't solve
C++ Code
#include <bits/stdc++.h>

using namespace std;

const int Z = 30;
const int MAX_N = 1e5 + 3;
int pref[Z][MAX_N][2];
int suff[Z][MAX_N][2];

void solve() {
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 0; i < Z; i++) suff[i][n + 1][0] = suff[i][n + 1][1] = 0;
    for (int i = 0; i < Z; i++) {
        for (int j = 1; j <= n; j++) {
            int t = !!(a[j] & (1 << i));
            for (int k = 0; k < 2; k++) pref[i][j][k] = (t == k) + pref[i][j - 1][k ^ t];
        }
        for (int j = n; j >= 1; j--) {
            int t = !!(a[j] & (1 << i));
            for (int k = 0; k < 2; k++) suff[i][j][k] = (t == k) + suff[i][j + 1][k ^ t];
        }
    }
    long long ans = 0;
    for (int i = 1; i <= n; i++) {
        int z = 31 - __builtin_clz(a[i]);
        ans += 1ll * pref[z][i - 1][1] * (1 + suff[z][i + 1][0]);
        ans += 1ll * (1 + pref[z][i - 1][0]) * suff[z][i + 1][1];
    }
    cout << ans << "\n";
}

int main() {
    int tc;
    cin >> tc;
    while (tc--)
        solve();
    return 0;
}
--------------------------------------------------
Problem ID: 1957C
Editorial Content:
1957C - How Does the Rook Move?
Hint 1
You can ignore the exact positions of the rooks in the initial configurations. Only the number of free rows and columns matter.
Hint 2
For each move you can make, how does the number of free rows/columns change?
Solution
Tutorial is loading...
Alternate Solution
Altenatively, we can iterate on the number of type $$$1$$$ moves we play. Let's term this to be $$$c$$$.
There are $$${m\choose c}$$$ ways to choose the $$$c$$$ type $$$1$$$ moves. Now, we have $$$m - c$$$ rows/columns left, and this must be even (type 2 moves cannot exhaust an odd number of rows/columns).
We can see that each of the $$$(m - c)!$$$ permutations of the remaining columns correspond to a set of moves we can play. For example, if we have the columns $$$(1, 4, 5, 6)$$$ remaining, a permutation $$$(4, 5, 6, 1)$$$ corresponds to playing the moves $$$(4, 5), (6, 1)$$$. However, if we simply count the number of permutations, we would also be counting the permutation $$$(6, 1, 4, 5)$$$, which corresponds to the same set of moves.
To remove overcounting, we can just divide $$$(m - c)!$$$ by $$$((m - c)/2)!$$$ (removing the permutations of the pairs chosen).
Hence, the answer becomes
$$$\sum\limits_{c = 0}^m [(m - c) \bmod 2 = 0] {m \choose c} \frac{(m - c)!}{\left(\frac{m - c}{2}\right)!}$$$
Rate this problem
Great Problem
Ok Problem
Bad Problem
Didn't solve
C++ Code
#include <bits/stdc++.h>
using namespace std;
 
int dp[(int) 3e5+5];
const int MOD = 1e9 + 7;
 
int main() {
    cin.tie(0), cout.tie(0)->sync_with_stdio(0);
    int t; 
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        int used = 0;
        for (int i = 0; i < k; i++) {
            int r, c; cin >> r >> c;
            used += 2 - (r == c);
        }
        int m = n - used;
        dp[0] = dp[1] = 1;
        for (int i = 2; i <= m; i++)
            dp[i] = (dp[i-1] + 2ll * (i-1) * dp[i-2] % MOD) % MOD;
        cout << dp[m] << "\n";    
    }
    
}
--------------------------------------------------
Problem ID: 1957B
Editorial Content:
1957B - A BIT of a Construction
Hint 1
Given that the sum is bounded, which bits could be set in the bitwise OR?
Solution
Tutorial is loading...
Rate this problem
Great Problem
Ok Problem
Bad Problem
Didn't solve
C++ Code
#include <bits/stdc++.h>

using namespace std;
 
int main(){
    int t; 
    cin >> t;
    while(t--) {
        int n, k;
        cin >> n >> k;
        vector<int> a(n);
        if (n == 1) {
            a[0] = k;
        }
        else {
            int msb = 0;
            // find the msb of k
            for (int i = 0; i < 31; i++) {
                if (k & (1 << i)) {
                    msb = i;
                }
            }
            a[0] = (1 << msb) - 1;
            a[1] = k - a[0];
            for (int i = 2; i < n; i++) {
                a[i] = 0;
            }
        }
        for (int i = 0; i < n; i++) {
            cout << a[i] << " ";
        }
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1957A
Editorial Content:
1957A - Stickogon
Hint 1
To create the most polygons, you should use as few sticks as possible per polygon. What polygon has the least number of sides?
Solution
Tutorial is loading...
Rate this problem
Great Problem
Ok Problem
Bad Problem
Didn't solve
C++ Code
#include <bits/stdc++.h>

using namespace std;

int main(){ 
  int t; 
  cin >> t;
  while(t--) {
    int n; 
    cin >> n; 
    vector<int> a(101, 0);
    for (int i = 0; i < n; i++) {
      int x; 
      cin >> x;
      a[x]++;
    }
    int sum = 0;
    for (auto& s : a) 
      sum += s / 3;
    cout << sum << "\n";
  }
}
--------------------------------------------------
Problem ID: 1956F
Editorial Content:

--------------------------------------------------
Problem ID: 1956E2
Editorial Content:

--------------------------------------------------
Problem ID: 1956E1
Editorial Content:

--------------------------------------------------
Problem ID: 1956D
Editorial Content:

--------------------------------------------------
Problem ID: 1956C
Editorial Content:

--------------------------------------------------
Problem ID: 1956B
Editorial Content:

--------------------------------------------------
Problem ID: 1956A
Editorial Content:

--------------------------------------------------
Problem ID: 1955H
Editorial Content:
1955H - The Most Reckless Defense
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using ll = signed long long int;
 
#define all(x) (x).begin(), (x).end()
 
using pii = std::pair<int, int>;
using pll = std::pair<ll, ll>;
 
using namespace std;
 
const int R = 12, INF = 2e9;
 
bool check(int x, int n) { return (0 <= x && x < n); }
 
void solve() {
    int n, m, k;
    cin >> n >> m >> k;
    vector<string> gr(n);
    for (int i = 0; i < n; ++i) {
        cin >> gr[i];
    }
    vector<pii> cord(k);
    vector<int> p(k);
    for (int i = 0; i < k; ++i) {
        cin >> cord[i].first >> cord[i].second >> p[i];
        --cord[i].first;
        --cord[i].second;
    }
    vector<vector<int> > cover(k, vector<int>(R + 1));
    for (int i = 0; i < k; ++i) {
        int x = cord[i].first;
        int y = cord[i].second;
        for (int r = 1; r <= R; ++r) {
            for (int dx = -r; dx <= r; ++dx) {
                for (int dy = -r; dy <= r; ++dy) {
                    int nx = x + dx;
                    int ny = y + dy;
                    if (!check(nx, n) || !check(ny, m)) {
                        continue;
                    }
                    if ((x - nx) * (x - nx) + (y - ny) * (y - ny) <= r * r) {
                        cover[i][r] += (gr[nx][ny] == '#');
                    }
                }
            }
        }
    }
    vector<vector<int> > dp(k + 1, vector<int>(1 << R, -INF));
    dp[0][0] = 0;
    for (int i = 1; i <= k; ++i) {
        for (int mask = 0; mask < (1 << R); ++mask) {
            dp[i][mask] = dp[i - 1][mask];
            for (int r = 1; r <= R; ++r) {
                int j = r - 1;
                if (!(mask & (1 << j))) {
                    continue;
                }
                dp[i][mask] = max(dp[i][mask], dp[i - 1][mask ^ (1 << j)] +
                                                   p[i - 1] * cover[i - 1][r]);
            }
        }
    }
    int ans = 0;
    for (int mask = 0; mask < (1 << R); ++mask) {
        int hp = 0, mlt = 3;
        for (int j = 0; j < R; ++j) {
            if (mask & (1 << j)) {
                hp += mlt;
            }
            mlt *= 3;
        }
        for (int i = 0; i <= k; ++i) {
            ans = max(ans, dp[i][mask] - hp);
        }
    }
    cout << ans << '\n';
}
 
int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1955G
Editorial Content:
1955G - GCD on a grid
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using ll = signed long long int;
 
#define all(x) (x).begin(), (x).end()
 
using pii = std::pair<int, int>;
using pll = std::pair<ll, ll>;
 
using namespace std;
 
void solve() {
    int n, m;
    cin >> n >> m;
    vector<vector<int> > a(n, vector<int>(m));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            cin >> a[i][j];
        }
    }
    int ans = 1, g = gcd(a[0][0], a[n - 1][m - 1]);
    vector<vector<char> > dp(n, vector<char>(m));
    for (int x = 1; x * x <= g; ++x) {
        if (g % x > 0) {
            continue;
        }
        vector<int> cand = {x, g / x};
        for (int el : cand) {
            for (int i = 0; i < n; ++i) {
                dp[i].assign(m, 0);
            }
            dp[0][0] = 1;
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < m; ++j) {
                    if (a[i][j] % el > 0) {
                        continue;
                    }
                    if (!dp[i][j] && i) {
                        dp[i][j] = (dp[i - 1][j] == 1 ? 1 : 0);
                    }
                    if (!dp[i][j] && j) {
                        dp[i][j] = (dp[i][j - 1] == 1 ? 1 : 0);
                    }
                }
            }
            if (dp[n - 1][m - 1]) {
                ans = max(ans, el);
            }
        }
    }
    cout << ans << '\n';
}
 
int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1955F
Editorial Content:
1955F - Unfair Game
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 201;
 
int dp[N][N][N];
 
void precalc() {
    dp[0][0][0] = 0;
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            for (int k = 0; k < N; ++k) {
                int prev = 0;
                if (i) prev = max(prev, dp[i - 1][j][k]);
                if (j) prev = max(prev, dp[i][j - 1][k]);
                if (k) prev = max(prev, dp[i][j][k - 1]);
                dp[i][j][k] = prev;
                int xr = ((i & 1) * 1) ^ ((j & 1) * 2) ^ ((k & 1) * 3);
                if (xr == 0 && (i || j || k)) {
                    ++dp[i][j][k];
                }
            }
        }
    }
}
 
void solve() {
    vector<int> cnt(4);
    for (int i = 0; i < 4; ++i) {
        cin >> cnt[i];
    }
    cout << dp[cnt[0]][cnt[1]][cnt[2]] + cnt[3] / 2 << '\n';
}
 
int main() {
    precalc();
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1955E
Editorial Content:
1955E - Long Inversions
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using ll = signed long long int;
 
#define all(x) (x).begin(), (x).end()
 
using pii = std::array<int, 2>;
using pll = std::array<ll, 2>;
using vi = std::vector<int>;
using vl = std::vector<ll>;
 
using namespace std;
 
void solve() {
    int n;
    string s;
    cin >> n >> s;
    for (int k = n; k > 0; --k) {
        vector<char> t(n), end(n + 1);
        for (int i = 0; i < n; ++i) {
            t[i] = s[i] - '0';
        }
        int cnt = 0;
        for (int i = 0; i < n; ++i) {
            cnt -= end[i];
            t[i] ^= (cnt & 1);
            if (t[i] == 0) {
                if (i + k <= n) {
                    ++end[i + k];
                    ++cnt;
                    t[i] = 1;
                } else {
                    break;
                }
            }
        }
        if (*min_element(all(t)) == 1) {
            cout << k << '\n';
            return;
        }
    }
    assert(false);
}
 
int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1955D
Editorial Content:
1955D - Inaccurate Subsequence Search
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using ll = signed long long int;
 
#define all(x) (x).begin(), (x).end()
 
using pii = std::pair<int, int>;
using pll = std::pair<ll, ll>;
 
using namespace std;
 
void solve() {
    int n, m;
    size_t k;
    cin >> n >> m >> k;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    multiset<int> todo, done, extra;
    for (int j = 0; j < m; ++j) {
        int b;
        cin >> b;
        todo.insert(b);
    }
    for (int j = 0; j < m; ++j) {
        if (todo.find(a[j]) != todo.end()) {
            todo.erase(todo.find(a[j]));
            done.insert(a[j]);
        } else {
            extra.insert(a[j]);
        }
    }
    int ans = (done.size() >= k);
    for (int r = m; r < n; ++r) {
        int old = a[r - m];
        if (extra.find(old) != extra.end()) {
            extra.erase(extra.find(old));
        } else if (done.find(old) != done.end()) {
            done.erase(done.find(old));
            todo.insert(old);
        }
        if (todo.find(a[r]) != todo.end()) {
            todo.erase(todo.find(a[r]));
            done.insert(a[r]);
        } else {
            extra.insert(a[r]);
        }
        ans += (done.size() >= k);
    }
    cout << ans << '\n';
}
 
int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1955C
Editorial Content:
1955C - Inhabitant of the Deep Sea
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

#define all(x) (x).begin(), (x).end()

using ll = signed long long int;

void solve() {
    int n;
    ll k;
    cin >> n >> k;
    deque<ll> dq(n);
    for (int i = 0; i < n; ++i) {
        cin >> dq[i];
    }
    while (dq.size() > 1 && k) {
        ll mn = min(dq.front(), dq.back());
        if (k < 2 * mn) {
            dq.front() -= k / 2 + k % 2;
            dq.back() -= k / 2;
            k = 0;
        } else {
            dq.front() -= mn;
            dq.back() -= mn;
            k -= 2 * mn;
        }
        if (dq.front() == 0) {
            dq.pop_front();
        }
        if (dq.back() == 0) {
            dq.pop_back();
        }
    }
    int ans = n - dq.size();
    cout << ans + (dq.size() && dq.front() <= k) << '\n';
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1955B
Editorial Content:
1955B - Progressive Square
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define all(x) (x).begin(), (x).end()
 
using ll = signed long long int;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using vi = vector<int>;
using vl = vector<ll>;
 
void solve() {
    int n;
    ll c, d;
    cin >> n >> c >> d;
    vl a(n * n);
    for (int i = 0; i < n * n; ++i) {
        cin >> a[i];
    }
    sort(all(a));
    vl b(n * n);
    b[0] = a[0];
    for (int i = 1; i < n; ++i) {
        b[i] = b[i - 1] + c;
    }
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            b[i * n + j] = b[(i - 1) * n + j] + d;
        }
    }
    sort(all(b));
    cout << (a == b ? "YEs" : "nO") << '\n';
}
 
int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1955A
Editorial Content:
1955A - Yogurt Sale
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using ll = signed long long int;
 
using namespace std;
 
void solve() {
    ll n, a, b;
    cin >> n >> a >> b;
    ll ans = n * a;
    if (b < 2 * a) {
        ans = (n / 2) * b + (n % 2) * a;
    }
    cout << ans << '\n';
}
 
int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1954F
Editorial Content:
1954F - Unique Strings
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>
 
using namespace std;
 
#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define sz(a) int((a).size())
 
typedef long long li;
typedef pair<int, int> pt;
 
template<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {
    return out << "(" << p.x << ", " << p.y << ")";
}
template<class A> ostream& operator <<(ostream& out, const vector<A> &v) {
    fore(i, 0, sz(v)) {
        if(i) out << " ";
        out << v[i];
    }
    return out;
}
 
const int MOD = int(1e9) + 7;
int add(int a, int b) {
    a += b;
    while (a >= MOD)
        a -= MOD;
    while (a < 0)
        a += MOD;
    return a;
}
void upd(int &ans, int val) {
    ans = add(ans, val);
}
int mul(int a, int b) {
    return int(a * 1ll * b % MOD);
}
int binPow(int a, int k) {
    int ans = 1;
    while (k > 0) {
        if (k & 1)
            ans = mul(ans, a);
        a = mul(a, a);
        k >>= 1;
    }
    return ans;
}
 
const int N = 3055;
int f[N], invf[N];
 
void precalcFact() {
    f[0] = invf[0] = 1;
    fore (i, 1, N) {
        f[i] = mul(f[i - 1], i);
        invf[i] = binPow(f[i], MOD - 2);
    }
}
int C(int n, int k) {
    if (k < 0 || k > n)
        return 0;
    return mul(f[n], mul(invf[k], invf[n - k]));
}
 
int n, c, k;
 
inline bool read() {
    if(!(cin >> n >> c >> k))
        return false;
    return true;
}
 
int d[N][N], sum[N][N];
 
// d[z][l] - number of strings of length l, with z zeroes and blocks of 1-s shorter than mx
void precalcShort(int mx) {
    memset(d, 0, sizeof d);
    d[0][0] = 1;
    fore (z, 0, n) {
        fore (l, 0, n) {
            if (d[z][l] == 0)
                continue;
            upd(d[z + 1][l + 1], +d[z][l]);
            upd(d[z + 1][min(n, l + mx) + 1], -d[z][l]);
        }
        fore (l, 0, n + 1)
            upd(d[z + 1][l + 1], d[z + 1][l]);
    }
        
    memset(sum, 0, sizeof sum);
    fore (z, 0, n + 1) fore (l, 0, n + 1)
        sum[z][l + 1] = add(sum[z][l], d[z][l]);
    
}
 
//[lf, rg)
int getSum(int z, int lf, int rg) {
    if (z < 0 || z > n || lf >= rg)
        return 0;
    return add(sum[z][rg], -sum[z][lf]);
}
 
// cnt[g] is a number of x <= n with gcd(x, n) = g
vector<int> precalcCnt(int n) {
    vector<int> cnt(n + 1, 0);
    fore (x, 1, n + 1)
        cnt[gcd(x, n)]++;
    return cnt;
}
 
int calcFixedPoints(int g) {
    if (c >= g)
        return c + k >= n;
    
    int cntOnes = (c + k) / (n / g);
    int cntZeros = g - cntOnes;
    
    int all = 0;
    fore (ones, 0, cntOnes + 1)
        upd(all, C(g, ones));
    
    int bad = 0;
    fore (pref, 0, c) {
        int minZeros = max(0, cntZeros - 1);
        int minMid = g - c;
        int sufLen = g - pref - 1;
        fore (z, minZeros, sufLen + 1)
            upd(bad, getSum(z, minMid, sufLen + 1));
    }
    return add(all, -bad);
}
 
inline void solve() {
    precalcFact();
    precalcShort(c);
    auto cnt = precalcCnt(n);
    
    int ans = 0;
    fore (g, 1, n + 1) {
        if (n % g != 0)
            continue;
        
        int cntFP = calcFixedPoints(g);
//      cerr << "g = " << g << " += " << cnt[g] << " * " << cntFP << endl;
        upd(ans, mul(cnt[g], cntFP));
    }
    
//  cerr << "ans/n = " << ans << " " << n << endl;
    cout << mul(ans, binPow(n, MOD - 2)) << endl;
}
 
int main() {
#ifdef _DEBUG
    freopen("input.txt", "r", stdin);
    int tt = clock();
#endif
    ios_base::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cout << fixed << setprecision(15);
    
    if(read()) {
        solve();
        
#ifdef _DEBUG
        cerr << "TIME = " << clock() - tt << endl;
        tt = clock();
#endif
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1954E
Editorial Content:
1954E - Chain Reaction
Tutorial
Tutorial is loading...
Solution 1 (awoo)
#include <bits/stdc++.h>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
using namespace std;
 
int divup(int a, int b){
    return (a + b - 1) / b;
}
 
int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    int n;
    cin >> n;
    vector<int> a(n);
    forn(i, n) cin >> a[i];
    int mx = *max_element(a.begin(), a.end());
    vector<long long> ans(mx + 1);
    forn(i, n){
        int coef = 0;
        if (i == 0 || a[i] > a[i - 1]) ++coef;
        if (i + 1 < n && a[i] < a[i + 1]) --coef;
        int r = a[i];
        ans[r] += coef;
        while (r > 0){
            int val = divup(a[i], r);
            int l = divup(a[i], val);
            ans[l - 1] += coef * val;
            ans[r] -= coef * val;
            r = l - 1;
        }
    }
    forn(i, mx) ans[i + 1] += ans[i];
    forn(i, mx) cout << ans[i] << ' ';
    cout << '\n';
    return 0;
}
Solution 2 (awoo)
#include <bits/stdc++.h>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
using namespace std;
 
int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    int n;
    cin >> n;
    vector<int> a(n);
    forn(i, n) cin >> a[i];
    int mx = *max_element(a.begin(), a.end());
    vector<long long> pr(mx + 1);
    forn(i, n){
        int coef = 0;
        if (i == 0 || a[i] > a[i - 1]) ++coef;
        if (i + 1 < n && a[i] < a[i + 1]) --coef;
        pr[a[i]] += coef;
    }
    forn(i, mx) pr[i + 1] += pr[i];
    for (int k = 1; k <= mx; ++k){
        long long ans = 0;
        for (int l = 1, val = 1; l <= mx; l += k, ++val)
            ans += val * 1ll * (pr[min(mx, l + k - 1)] - pr[l - 1]);
        cout << ans << ' ';
    }
    cout << '\n';
    return 0;
}
--------------------------------------------------
Problem ID: 1954D
Editorial Content:
1954D - Colored Balls
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
const int MOD = 998244353;
 
int add(int x, int y) {
  x += y;
  if (x >= MOD) x -= MOD;
  return x;
} 
 
int mul(int x, int y) {
  return x * 1LL * y % MOD;
}
 
int main() {
  int n;
  cin >> n;
  vector<int> a(n);
  for (int i = 0; i < n; ++i) cin >> a[i];
  int s = accumulate(a.begin(), a.end(), 0);
  vector<int> dp(s + 1);
  dp[0] = 1;
  for (int i = 0; i < n; ++i)
    for (int j = s - a[i]; j >= 0; --j) 
      dp[j + a[i]] = add(dp[j + a[i]], dp[j]);
  int ans = 0;
  for (int j = 0; j <= s; ++j) 
    ans = add(ans, mul((j + 1) / 2, dp[j]));
  for (int i = 0; i < n; ++i)
    for (int j = 0; j < a[i]; ++j) 
      ans = add(ans, mul(a[i] - (a[i] + j + 1) / 2, dp[j]));
  cout << ans << '\n';
}
--------------------------------------------------
Problem ID: 1954C
Editorial Content:
1954C - Long Multiplication
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  int t;
  cin >> t;
  while (t--) {
    string x, y;
    cin >> x >> y;
    int n = x.size();
    bool f = false;
    for (int i = 0; i < n; ++i) {
      if ((x[i] > y[i]) == f) swap(x[i], y[i]);
      f |= (x[i] != y[i]);
    }
    cout << x << '\n' << y << '\n';
  }
}
--------------------------------------------------
Problem ID: 1954B
Editorial Content:
1954B - Make It Ugly
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    lst = -1
    ans = n
    for i in range(n):
        if a[i] != a[0]:
            ans = min(ans, i - lst - 1)
            lst = i
    ans = min(ans, n - lst - 1)
    if ans == n:
        print(-1)
    else:
        print(ans)
--------------------------------------------------
Problem ID: 1954A
Editorial Content:
1954A - Painting the Ribbon
Tutorial
Tutorial is loading...
Solution (BledDest)
t = int(input())
for i in range(t):
    n, m, k = map(int, input().split())
    max_color = (n + m - 1) / m
    if max_color + k >= n:
        print('NO')
    else:
        print('YES')
--------------------------------------------------
Problem ID: 1953A
Editorial data not available.
--------------------------------------------------
Problem ID: 1952J
Editorial Content:
1952J - Help, what does it mean to be "Based"
Solution
1952J - Help, what does it mean to be "Based"
Update: You can find checker implementations
here
.
The recent April Fools contests all have problems related to mysterious languages. In this one, you are given several samples in a new, never been seen before constructed language, and your task is to learn it and solve a simple task with it. The idea of using internet slangs as a language was inspired by
this meme
. The problem format is similar to some Linguistics Olympiad problems.
If you can't access the twitter post
This problem is rather straightforward: simply figure out what each line of code does, and try to combine known operations to solve the last task. Knowing the meaning of slangs might help in understanding them.
In task 1, we learn 4 operations:
yoink a
: Input an integer
a
.
*slaps a on top of b*
: Add
a
to
b
.
yeet b
: Output the integer
b
.
go touch some grass
: Return/exit the program.
In task 2 we learn:
bruh b is lowkey just 0
: Assign the variable
b
to 0.
rip this b fell off by a
: Subtract
a
from
b
.
And the less obvious:
vibe check a ratios b
: Check if
a
is larger than
b
. If yes, execute the next line, otherwise don't.
simp for 7
: Goto line 7.
In task 3 we learn new things:
yoink a
: Input an entire array
a
.
Indexing operations:
a[0]
. We can also see that arrays are 0-indexed.
These are enough to solve task 4. There are two simple approaches.
Sort the array and output $$$a[k-1]$$$. We may use bubble sort for easier implementation.
yoink n
yoink a
bruh i is lowkey just n
vibe check i ratios 1
simp for 7
simp for 22
bruh j is lowkey just 1
vibe check i ratios j
simp for 11
simp for 20
bruh k is lowkey just j
*slaps -1 on top of k*
vibe check a[k] ratios a[j]
simp for 18
bruh tmp is lowkey just a[j]
bruh a[j] is lowkey just a[k]
bruh a[k] is lowkey just tmp
*slaps 1 on top of j*
simp for 8
rip this i fell off by 1
simp for 4
yoink k
rip this k fell off by 1
yeet a[k]
go touch some grass
Since the input integers are distinct, we can loop over each element to see whether exactly $$$k-1$$$ elements are smaller than it.
yoink n
yoink a
yoink k
bruh i is lowkey just 0
bruh m is lowkey just 1
bruh j is lowkey just 0
vibe check n ratios j
simp for 10
simp for 13
vibe check a[j] ratios a[i]
*slaps 1 on top of m*
simp for 19
vibe check m ratios k
simp for 21
vibe check k ratios m
simp for 21
yeet a[i]
go touch some grass
*slaps 1 on top of j*
simp for 7
*slaps 1 on top of i*
simp for 5
1952J - Help, what does it mean to be "Based"
If you can't access the twitter post
Feedback
Based problem
Based problem
Based problem
--------------------------------------------------
Problem ID: 1952I
Editorial Content:
1952I - Dark Matter
Hint
Something looks off with the text (literally).
Solution
1952I - Dark Matter
If you stare at the PDF hard enough, you'll notice that some of the text looks curved. Given the hint about "gravitational lensing", it should be clear that this is not a coincidence.
How can gravitational lensing distort text? If there's a lot of mass between you and the text, those matter can bend light going from text into your eyes, making straight text look curved. In addition, the meme image looks normal, implying such mass lies between the image and text (in other words, behind the image from your perspective). Here's a visualization of the configuration:
Now let's do the difficult and technical part: finding the dark matter. To do this we need to first grab some PDF/vector graphics editor like LibreOffice or Inkscape. We can see a lot of random objects behind the image:
These are probably the mass causing distorted text. Unfortunately, as the problem suggests, these objects are dark matter so are transparent because they don't interact with light. We can set their transparency to 0 (or opacity to max) and change their color to see them better:
Which gives the formula $$$(a^2 + b^2) + (a - b) + |a| \times 2b - (ab + 2)$$$. If we plug in $$$a$$$ and $$$b$$$ from the samples, we get $$$1$$$, which corresponds to the missing number in the image. Therefore the solution is to output $$$a + b + ((a^2 + b^2) + (a - b) + |a| \times 2b - (ab + 2))$$$.
1952I - Dark Matter
Feedback
Based problem
Based problem
Based problem
--------------------------------------------------
Problem ID: 1952H
Editorial Content:
1952H - Palindrome
Hint 1
Why are there two examples when each one already has multiple test cases?
Hint 2
A change of perspective might help you solve the problem.
Solution
1952H - Palindrome
One obvious weird thing in the statement is that there are 2 sample tests despite the multi-test input format. This implies that the lines ("tests") in each input might not be independent tests and are related in some way.
If we read very closely we might notice two weird things about the statement. First, instead of the usual "Each test case contains a line...", it says "The following t lines each contain...". This is because one line does not correspond to one test case. Another is the unusual definition of palindromes: "in both directions".
This problem is solved by seeing it in a different direction. If we read the third and fourth columns, we may notice that they are palindromes — which read the same in both directions, up and down. The solution is to read $$$t$$$ strings, vertically, from the input and determine whether they are palindromes. Empty strings count as palindromes as you can see in sample 2.
1952H - Palindrome
Feedback
Based problem
Based problem
Based problem
--------------------------------------------------
Problem ID: 1952G
Editorial Content:
1952G - Mathematician Takeover
Hint 1
There is a function that has the same name but different definitions in math and computer science. What is it?
Hint 2
Try to fit a curve through the three points given in the problem. It can help you solve the previous question.
Solution
1952G - Mathematician Takeover
The problem is a joke about the function $$$\log$$$. For mathematicians, it means $$$\log_e$$$, but for computer scientists, it means $$$\log_2$$$. In particular, the samples all give the correct output for $$$\log_e(x)$$$, but we really want to output $$$\log_2(x)$$$.
1952G - Mathematician Takeover
Feedback
Based problem
Based problem
Based problem
--------------------------------------------------
Problem ID: 1952F
Editorial Content:
1952F - Grid
Hint 1
Can you convert a grid of 0s and 1s into a useful piece of data?
Hint 2
Look in the top-left, top-right, and bottom-left corners. What do you notice?
Hint 2.2
Namely, look at the the top-left, top-right, and bottom-left $$$7 \times 7$$$ subgrids. They form a pattern. Have you seen this pattern elsewhere? (It is well-known.)
Hint 2.2
Namely, look at the the top-left, top-right, and bottom-left $$$7 \times 7$$$ subgrids. They form a pattern. Have you seen this pattern elsewhere? (It is well-known.)
Solution
1952F - Grid
Replace 0 with white and 1 with black to get this QR code:
Scanning it tells you that you need to find the $$$4 \times 4$$$ grid with the maximum sum.
1952F - Grid
Feedback
Based problem
Based problem
Based problem
--------------------------------------------------
Problem ID: 1952E
Editorial Content:
1952E - Sweep Line
Hint 1
Almost everything in this problem is a hint.
Hint 2
The problem name is "Sweep Line". Does it sound familiar?
Hint 3
Look at the quote in the statement. When does a mistake force you to start all over again?
Hint 4
Why are the numbers in the note section are colored?
Hint 5
Why does the note section contain "I had to take a guess." and "I am literally going to explode."
Hint 6
Minesweeper. This is a slightly different version, since all cells are numbered. Why do the numbers only go up to $$$2$$$?
Solution
1952E - Sweep Line
The theme of the problem is
Minesweeper
.
In Minesweeper, the numbers represent the count of mines around them.
The array given in the input represents a Minesweeper game that is only a line (hence the name
Sweep Line
). The problem asks you to output the number of possible mine placements that is consistent with the given array.
Note that here each cell refers to the number of mines in the neighboring cells, but
not
including itself (since the input is only up to $$$2$$$).
The modulo $$$20240401$$$ part is unnecessary as the answer can be at most $$$2$$$ (try to prove this).
1952E - Sweep Line
Feedback
Based problem
Based problem
Based problem
--------------------------------------------------
Problem ID: 1952D
Editorial Content:
1952D - Are You a Procrastinator?
Hint 1
Are you a procrastinator?
Hint 2
You should be.
Hint 3
What? The checker does not trust you after you say yes? How can you make it believe you?
Solution
1952D - Are You a Procrastinator?
The problem asks you if you are procrastinator or not. You should output "yes" (or any other confirmation word that the checker can understand) to solve the problem. However, it does not seem to be enough as the checker responds with "I have no reason to believe you."
You should prove to the checker that you are a procrastinator. You can do this by submitting "yes" in the last $$$15$$$ mins of the contest.
Furthermore, the checker can give different responses depending on your output. Feel free to share what funny responses you got (there are many of them).
1952D - Are You a Procrastinator?
Feedback
Based problem
Based problem
Based problem
--------------------------------------------------
Problem ID: 1952C
Editorial Content:
1952C - They Have Fooled
Hint 1
They have fooled? Who have fooled?
Hint 2
The image says April. Could it be about April Fools?
Hint 3
The problem has $$$n \leq 12$$$. Where did you see the number $$$12$$$ before?
Solution
1952C - They Have Fooled
Looking at the announcement blog, it can be seen that the first April Fools Day Contest was $$$12$$$ years ago.
The problem asks for the problem count of the April Fools Day Contest that was $$$n$$$ years ago.
The sample that has $$$n = 9$$$ is also given as a hint as there was not an April Fools Day Contest on $$$2015$$$.
1952C - They Have Fooled
Feedback
Based problem
Based problem
Based problem
--------------------------------------------------
Problem ID: 1952B
Editorial Content:
1952B - Is it stated?
Hint
Can you interpret the question in the title another way?
Solution
1952B - Is it stated?
You just need to check if there is a substring $$$\texttt{it}$$$ in the string. (That is, the question is asking, "is $$$\texttt{it}$$$ stated?")
1952B - Is it stated?
Feedback
Based problem
Based problem
Based problem
--------------------------------------------------
Problem ID: 1952A
Editorial Content:
1952A - Are You a Robot, Again?
Hint
Have you seen the "are you a robot" boxes on websites?
Solution
1952A - Are You a Robot, Again?
If you select all the squares with traffic lights and read the corresponding letters from left-to-right, top-to-bottom, you get the text "$$$\texttt{print safety}$$$". So all you need to do is print the word $$$\texttt{safety}$$$.
1952A - Are You a Robot, Again?
Feedback
Based problem
Based problem
Based problem
--------------------------------------------------
Problem ID: 1951I
Editorial Content:
1951I - Growing Trees
Hint 1
This helps to check if $$$x$$$ satisfies
. Pattern match it to
Hall's marriage theorem
.
Hint 2
It is possible to check if $$$x$$$ satisfies with $$$n$$$ flow runs, each flow graph having $$$O(n + m)$$$ nodes and edges.
Hint 3
Spanning trees are independent sets of the graphic matroid.
Direct sums of $$$k$$$ such matroids is also a matroid.
.
Hint 4
We can greedily select to increase $$$x_i$$$ with the least increment cost that still satisfies. Quickly simulate this via a binary search.
Tutorial and Implementation
Tutorial is loading...
255371862
--------------------------------------------------
Problem ID: 1951H
Editorial Content:
1951H - Thanos Snap
Hint 1
Let's binary search the answer. Every element is now either $$$0$$$ or $$$1$$$, and Alice tries to get $$$1$$$.
Hint 2
Let's directly construct the strategy for Alice. It can be viewed as a perfect binary game tree.
Hint 3
Construct the strategy greedily bottom-up.
Tutorial and Implementation
Tutorial is loading...
255374619
--------------------------------------------------
Problem ID: 1951G
Editorial Content:
1951G - Clacking Balls
Hint 1
We should represent a state as the sequence of distances between each pair of consecutive balls.
Hint 2
This should probably help.
Tutorial and Implementation
Tutorial is loading...
255371802
--------------------------------------------------
Problem ID: 1951F
Editorial Content:
1951F - Inversion Composition
Hint 1
Let's look at the "inverseness" of $$$(p_i, p_j)$$$ on $$$q$$$ and $$$(i, j)$$$ on $$$q \cdot p$$$. What is their relation to the inverseness of $$$(i, j)$$$ on $$$p$$$?
Hint 2
They either contribute $$$0$$$ or $$$2$$$ if $$$(i, j)$$$ is not an inverse on $$$p$$$, or $$$1$$$ if $$$(i, j)$$$ is an inverse on $$$p$$$. We now know the necessary condition for $$$k$$$ if there is an answer. This is also sufficient.
Tutorial and Implementation
Tutorial is loading...
255371767
--------------------------------------------------
Problem ID: 1951E
Editorial Content:
1951E - No Palindromes
Hint
Let $$$i$$$ be the first character that is different from $$$s_1$$$. Then $$$s_{1..i}$$$ is not a palindrome. If $$$s_{i+1..n}$$$ is also not a palindrome then we are done, but what can we do if it is?
Tutorial and Implementation
Tutorial is loading...
255371747
--------------------------------------------------
Problem ID: 1951D
Editorial Content:
1951D - Buying Jewels
Rate this problem
Yay
Meh
Nay
Banger song
1951D - Buying Jewels
Hint
Perhaps the easiest way of dealing with this problem is writing down small cases and see what happens.
Tutorial and Implementation
Tutorial is loading...
255371688
--------------------------------------------------
Problem ID: 1951C
Editorial Content:
1951C - Ticket Hoarding
Hint 1
If there is no additional cost (i.e. buying a ticket at day $$$i$$$ costs only $$$a_i$$$), what is the optimal buying strategy?
Hint 2
If there \textit{is} additional cost but $$$a_i = 1$$$ for all $$$i$$$, what is the optimal buying strategy?
Hint 3
The above two strategies are the same, and the primary and secondary costs are independent of each other. \textit{Surely} the solution is not just choosing $$$k$$$ cheapest tickets right?
Tutorial and Implementation
Tutorial is loading...
255371666
--------------------------------------------------
Problem ID: 1951B
Editorial Content:
1951B - Battle Cows
Hint 1
What is the condition for your cow to win her first match?
Hint 2
If your cow is not already winning her first match, there are at most two candidate positions you can swap her to.
Tutorial and Implementation
Tutorial is loading...
255371643
1951B - Battle Cows
Rate this problem
Yay
Meh
Nay
Banger song
--------------------------------------------------
Problem ID: 1951A
Editorial Content:
1951A - Dual Trigger
Tutorial and Implementation
Tutorial is loading...
255371605
--------------------------------------------------
Problem ID: 1950G
Editorial Content:
1950G - Shuffling Songs
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;

#define all(x) x.begin(),x.end()

void solve() {
    int n; cin >> n;
    vector<int> s(n), g(n);
    vector<string> aa(n), bb(n);
    vector<string> vals;
    for(int i = 0; i < n; ++i) {
        string a, b; cin >> a >> b;
        vals.push_back(a);
        vals.push_back(b);
        aa[i] = a, bb[i] = b;
    }
    sort(all(vals));
    vals.erase(unique(all(vals)), vals.end());
    for(int i = 0; i < n; ++i) {
        s[i] = lower_bound(all(vals), aa[i]) - vals.begin();
        g[i] = lower_bound(all(vals), bb[i]) - vals.begin();
    }
    vector<vector<int>> dp(1 << n, vector<int>(n, 0));
    for(int i = 0; i < n; ++i) dp[1 << i][i] = 1;
    for(int mask = 0; mask < (1 << n); ++mask) {
        for(int lst = 0; lst < n; ++lst) {
            if(!dp[mask][lst]) continue;
            for(int i = 0; i < n; ++i) {
                if(mask >> i & 1) continue;
                if(s[lst] == s[i] || g[lst] == g[i]) {
                    dp[mask | (1 << i)][i] |= dp[mask][lst];
                }
            }
        }
    }
    int ans = 0;
    for(int mask = 0; mask < (1 << n); ++mask) {
        for(int i = 0; i < n; ++i) {
            if(dp[mask][i]) {
                ans = max(ans, __builtin_popcount(mask));
            }
        }
    }
    cout << n - ans << "\n";
}   
 
main() {
    int t = 1; cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1950F
Editorial Content:
1950F - 0, 1, 2, Tree!
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

void solve() {
	int a, b, c;
	cin >> a >> b >> c;
	if (a + 1 != c) {cout << -1 << '\n'; return;}
	if (a + b + c == 1) {cout << 0 << '\n'; return;}
	int curr = 1, next = 0, res = 1;
	for (int i = 0; i < a + b; i++) {
		if (!curr) {
	        swap(next, curr);
	        res++;
	    }
	    curr--;
	    next++;
	    if (i < a) {next++;}
	}
	cout << res << '\n';
}

int main() {
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1950E
Editorial Content:
1950E - Nearly Shortest Repeating Substring
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;

void solve() {
    int n;
    cin >> n;
    string s;
    cin >> s;
    for(int i = 1; i <= n; i++)
    {
        if(n%i == 0)
        {
            int satisfy = 2;
            for(int j = 0; j < i; j++)
            {
                for(int k = j+i; k < n; k+=i)
                {
                    if(s[k] != s[j])
                    {
                        satisfy--;
                    }
                }
            }
            if(satisfy > 0)
            {
                cout << i << endl;
                return;
            }
            satisfy = 2;
            for(int j = n-i; j < n; j++)
            {
                for(int k = j-i; k >= 0; k-=i)
                {
                    if(s[k] != s[j])
                    {
                        satisfy--;
                    }
                }
            }
            if(satisfy > 0)
            {
                cout << i << endl;
                return;
            }
        }
    }
}

int32_t main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1950D
Editorial Content:
1950D - Product of Binary Decimals
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

const int MAX = 100'007;
const int MOD = 1'000'000'007;

vector<int> binary_decimals;

bool ok(int n) {
	if (n == 1) {return true;}
	bool ans = false;
	for (int i : binary_decimals) {
		if (n % i == 0) {
			ans |= ok(n / i);
		}
	}
	return ans;
}

void solve() {
	int n;
	cin >> n;
	cout << (ok(n) ? "YES\n" : "NO\n");	
}

int main() {
	for (int i = 2; i < MAX; i++) {
		int curr = i;
		bool bad = false;
		while (curr) {
			if (curr % 10 > 1) {bad = true; break;}
			curr /= 10;
		}
		if (!bad) {binary_decimals.push_back(i);}
	}
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1950C
Editorial Content:
1950C - Clock Conversion
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

void solve() {
    int h, m; char c;
    cin >> h >> c >> m;
    string am = (h < 12 ? " AM" : " PM");
    h = (h % 12 ? h % 12 : 12);
    cout << (h < 10 ? "0" : "") << h << c << (m < 10 ? "0" : "") << m << am << '\n';
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1950B
Editorial Content:
1950B - Upscaling
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

void solve() {
	int n;
	cin >> n;
	for (int i = 0; i < 2 * n; i++) {
		for (int j = 0; j < 2 * n; j++) {
			cout << (i / 2 + j / 2 & 1 ? '.' : '#');
		}
		cout << '\n';
	}	
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1950A
Editorial Content:
1950A - Stair, Peak, or Neither?
Tutorial
Tutorial is loading...
Solution
#include <iostream>

void solve() {
	int a, b, c;
	std::cin >> a >> b >> c;
	if(a < b && b < c) std::cout << "STAIR"<< "\n";
	else if(a < b && b > c) std::cout << "PEAK"<< "\n";
	else std::cout << "NONE" << "\n";
}

int main() {
	int tt; std::cin >> tt;
	while(tt--) 
	    solve();
}
--------------------------------------------------
Problem ID: 1949K
Editorial Content:

--------------------------------------------------
Problem ID: 1949J
Editorial Content:

--------------------------------------------------
Problem ID: 1949I
Editorial Content:

--------------------------------------------------
Problem ID: 1949H
Editorial Content:

--------------------------------------------------
Problem ID: 1949G
Editorial Content:

--------------------------------------------------
Problem ID: 1949F
Editorial Content:

--------------------------------------------------
Problem ID: 1949E
Editorial Content:

--------------------------------------------------
Problem ID: 1949D
Editorial Content:

--------------------------------------------------
Problem ID: 1949C
Editorial Content:

--------------------------------------------------
Problem ID: 1949B
Editorial Content:

--------------------------------------------------
Problem ID: 1949A
Editorial Content:

--------------------------------------------------
Problem ID: 1948G
Editorial Content:
1948G - MST with Matching
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

int n, c;
int g[21][21];

const int INF = int(1e9);

int primMST(int vertex_cover_mask)
{
    vector<int> d(n, INF);
    vector<bool> used(n, false);
    d[0] = 0;
    int ans = 0;
    for(int i = 0; i < n; i++)
    {
        int idx = -1;
        for(int j = 0; j < n; j++)
        {
            if(!used[j] && d[j] < INF && (idx == -1 || d[j] < d[idx]))
                idx = j;
        }
        if(idx == -1) return INF;
        used[idx] = true;
        ans += d[idx];
        for(int k = 0; k < n; k++)
        {
            if(used[k]) 
                continue;
            if((vertex_cover_mask & (1 << idx)) == 0 && (vertex_cover_mask & (1 << k)) == 0)
                continue;
            d[k] = min(d[k], g[idx][k]);
        }
    }
    return ans;
}

int main()
{
    cin >> n >> c;
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < n; j++)
        {
            cin >> g[i][j];
            if(g[i][j] == 0) g[i][j] = INF;
        }
    }
    int ans = INF;
    for(int mask = 0; mask < (1 << n); mask++)
    {
        int cur = primMST(mask);
        if(cur != INF) ans = min(ans, cur + c * __builtin_popcount(mask));
    }
    cout << ans << endl;
}
--------------------------------------------------
Problem ID: 1948F
Editorial Content:
1948F - Rare Coins
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

const int MOD = 998244353;

int add(int x, int y) {
  x += y;
  if (x >= MOD) x -= MOD;
  return x;
}

int mul(int x, int y) {
  return x * 1LL * y % MOD;
}

int binpow(int x, int y) {
  int z = 1;
  while (y) {
    if (y & 1) z = mul(z, x);
    x = mul(x, x);
    y >>= 1;
  }
  return z;
}

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int n, q;
  cin >> n >> q;
  vector<int> a(n), b(n);
  for (auto& x : a) cin >> x;
  for (auto& x : b) cin >> x;
  vector<int> suma(n + 1), sumb(n + 1);
  for (int i = 0; i < n; ++i) {
    suma[i + 1] = suma[i] + a[i];
    sumb[i + 1] = sumb[i] + b[i];
  }
  int m = sumb[n];
  vector<int> f(m + 1), invf(m + 1);
  f[0] = 1;
  for (int i = 1; i <= m; ++i) f[i] = mul(f[i - 1], i);
  invf[m] = binpow(f[m], MOD - 2);
  for (int i = m; i > 0; --i) invf[i - 1] = mul(invf[i], i);
  vector<int> sumc(m + 2);
  for (int i = 0; i <= m; ++i)
    sumc[i + 1] = add(sumc[i], mul(f[m], mul(invf[i], invf[m - i])));
  int pw2 = binpow(binpow(2, MOD - 2), m);
  while (q--) {
    int l, r;
    cin >> l >> r;
    --l;
    int k = 2 * (suma[r] - suma[l]) - suma[n];
    int cur = sumb[r] - sumb[l];
    int mx = max(0, min(k + cur, m + 1));
    int cnt = sumc[mx];
    cout << mul(cnt, pw2) << ' ';
  }
}
--------------------------------------------------
Problem ID: 1948E
Editorial Content:
1948E - Clique Partition
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
void solve()
{
    int n, k;
    cin >> n >> k;
    vector<int> a(n), c(n);
    for(int i = 0; i < n; i++)
    {
        a[i] = i + 1;
        c[i] = i / k + 1;
    }
    int q = *max_element(c.begin(), c.end());
    for(int i = 1; i <= q; i++)
    {
        int l = find(c.begin(), c.end(), i) - c.begin();
        int r = c.rend() - find(c.rbegin(), c.rend(), i);
        int m = (l + r) / 2;
        reverse(a.begin() + l, a.begin() + m);
        reverse(a.begin() + m, a.begin() + r);
    }
    for(int i = 0; i < n; i++)
        cout << a[i] << " \n"[i == n - 1];
    cout << q << "\n";
    for(int i = 0; i < n; i++)
        cout << c[i] << " \n"[i == n - 1];
}
 
int main()
{
    int t;
    cin >> t;
    for(int i = 0; i < t; i++)
        solve();
}
--------------------------------------------------
Problem ID: 1948D
Editorial Content:
1948D - Tandem Repeats?
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
    s = input()
    n = len(s)
    ans = 0
    for d in range(1, n // 2 + 1):
        cnt = 0
        for i in range(n - d):
            cnt += s[i] == s[i + d] or s[i] == '?' or s[i + d] == '?'
            if i - d >= 0:
                cnt -= s[i - d] == s[i] or s[i - d] == '?' or s[i] == '?'
            if i - d >= -1 and cnt == d:
                ans = 2 * d
    print(ans)
--------------------------------------------------
Problem ID: 1948C
Editorial Content:
1948C - Arrow Path
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<char> ok1(n / 2), ok2(n / 2);
    for (int i = 0; i < 2; ++i) {
      string s;
      cin >> s;
      for (int j = 0; j < n; ++j) if ((i + j) & 1) {
        ok1[(i + j) / 2] |= (s[j] == '>');
        ok2[(j - i + 1) / 2] |= (s[j] == '>');
      }
    }
    bool ans = true;
    for (int i = 0; i < n / 2; ++i) ans &= ok1[i] && ok2[i];
    cout << (ans ? "YES" : "NO") << '\n';
  }
}
--------------------------------------------------
Problem ID: 1948B
Editorial Content:
1948B - Array Fix
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<int> a(n);
    for (auto& x : a) cin >> x;
    vector<int> b({a[n - 1]});
    for (int i = n - 2; i >= 0; --i) {
      if (a[i] > b.back()) {
        b.push_back(a[i] % 10);
        b.push_back(a[i] / 10);
      } else {
        b.push_back(a[i]);
      }
    }
    cout << (is_sorted(b.rbegin(), b.rend()) ? "YES" : "NO") << '\n';
  }
}
--------------------------------------------------
Problem ID: 1948A
Editorial Content:
1948A - Special Characters
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    if (n % 2 == 1) {
      cout << "NO" << '\n';
      continue;
    }
    cout << "YES" << '\n';
    for (int i = 0; i < n / 2; ++i)
      for (int j = 0; j < 2; ++j)
        cout << "AB"[i & 1];
    cout << '\n';
  }
}
--------------------------------------------------
Problem ID: 1946F
Editorial Content:
1946F - Nobody is needed
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using i64 = long long;

template<class Info>
struct Fenwick {
    std::vector<Info> t;
    int n;
    
    Fenwick(int n = 0) : n(n) {
        t.resize(n);
    }
    
    void add(int x, const Info &v) {
        for (int i = x + 1; i <= n; i += i & -i) {
            t[i - 1] = t[i - 1] + v;
        }
    }
    
    Info sum(int x) {
        x++;
        Info res = Info();
        for (int i = x; i > 0; i -= i & -i) {
            res = res + t[i - 1];
        }
        return res;
    }
    
    Info rangeSum(int l, int r) {
        Info res = sum(r) - sum(l - 1);
        return res;
    }
};

void solve() {
    int n, q;
    std::cin >> n >> q;
    std::vector<int> a(n), pos(n + 1);
    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
    }
    std::reverse(a.begin(), a.end());
    for (int i = 0; i < n; i++) {
        pos[a[i]] = i;
    }
    constexpr int K = 19;
    std::vector<i64> res(q);
    std::vector<std::vector<std::pair<int, int>>> qry(n);
    for (int i = 0; i < q; i++) {
        int l, r;
        std::cin >> l >> r;
        l--, r--;
        std::swap(l, r);
        l = n - l - 1;
        r = n - r - 1;
        qry[r].emplace_back(l, i);
    }
    std::vector<i64> dp(n + 1);
    Fenwick<i64> f(n);
    for (int r = 0; r < n; r++) {
        int x = a[r];
        dp[x] = 1;
        // n * log(n) * log(n)
        for (int y = x; y <= n; y += x) {
            if (pos[y] > pos[x]) {
                continue;
            }
            for (int z = 2 * y; z <= n; z += y) {
                if (pos[z] > pos[y]) {
                    continue;
                }
                dp[z] += dp[y];
            }
        }
        // n * log(n) * log(n)
        for (int y = x; y <= n; y += x) {
            f.add(pos[y], dp[y]);
            dp[y] = 0;
        }
        // q * log(n)
        for (auto [l, i] : qry[r]) {
            res[i] += f.rangeSum(l, r);
        }
    }
    for (int i = 0; i < q; i++) {
        std::cout << res[i] << " \n"[i == q - 1];
    }
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int t = 1;
    std::cin >> t;

    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1946E
Editorial Content:
1946E - Girl Permutation
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using i64 = long long;
 
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
 
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % P)} {}
    
    constexpr int norm(int x) const {
        if (x < 0) {
            x += P;
        }
        if (x >= P) {
            x -= P;
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(P - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    constexpr MInt &operator*=(MInt rhs) {
        x = 1LL * x * rhs.x % P;
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
constexpr int MOD = 1e9 + 7;
using Z = MInt<MOD>;
 
namespace comb {
    int n = 0;
    std::vector<Z> _fac = {1};
    std::vector<Z> _invfac = {1};
    std::vector<Z> _inv = {0};
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int m, int k) {
        if (m < k || k < 0) return 0;
        return fac(m) * invfac(k) * invfac(m - k);
    }
} // namespace comb
 
void solve() {
    int n, m1, m2;
    std::cin >> n >> m1 >> m2;
    std::vector<int> p(m1), s(m2);
    for (int i = 0; i < m1; i++) {
        std::cin >> p[i];
    }
    for (int i = 0; i < m2; i++) {
        std::cin >> s[i];
    }
    if (p[0] != 1 || s[0] != p[m1 - 1] || s[m2 - 1] != n) {
        std::cout << "0\n";
        return;
    }
    Z res = comb::binom(n - 1, s[0] - 1);
    for (int i = m1 - 2; i > -1; i--) {
        res *= comb::binom(p[i + 1] - 2, p[i + 1] - p[i] - 1) * comb::fac(p[i + 1] - p[i] - 1);
    }
    for (int i = 1; i < m2; i++) {
        res *= comb::binom(n - s[i - 1] - 1, s[i] - s[i - 1] - 1) * comb::fac(s[i] - s[i - 1] - 1);
    }
    std::cout << res << "\n";
}
 
signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
 
    #ifndef ONLINE_JUDGE
        freopen("/home/q1n/coding/input.txt", "r", stdin);
        freopen("/home/q1n/coding/output.txt", "w", stdout);
    #else
        // online submission
    #endif
 
    int t = 1;
    std::cin >> t;
 
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1946D
Editorial Content:
1946D - Birthday Gift
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
using ll = long long;
 
#define int ll
#define all(a) a.begin(), a.end()
 
void solve() {
    int n, x;
    cin >> n >> x;
    ++x;
    vector<int> a(n);
    for (int &i: a)
        cin >> i;
    int res = -1;
    for (int i = 30; i >= 0; --i) {
        vector<int> b;
        bool open = false;
        for (int j = 0; j < a.size(); ++j) {
            if (!open)
                b.push_back(a[j]);
            else
                b.back() ^= a[j];
            if (a[j] & (1 << i))
                open = !open;
        }
        if (!(x & (1 << i))) {
            if (open) {
                cout << res << '\n';
                return;
            }
            a = b;
        } else {
            if (!open)
                res = max(res, (int) b.size());
        }
    }
    cout << res << '\n';
}
 
signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int t = 1;
    cin >> t;
    while (t--)
        solve();
}
Solution (74TrAkToR)
#include<bits/stdc++.h>
 
using namespace std;
 
int const maxn = 1e5 + 5;
int a[maxn];
 
int solve(int n, int x) {
    int res = 0, curr = 0;
    for (int i = 1; i <= n; i++) {
        curr ^= a[i];
        if ((curr|x) == x) curr = 0, res++;
        else {
            if (i == n) return -1;
        }
    }
    return res;
}
 
main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t;
    cin >> t;
    while (t--) {
        int n, x;
        cin >> n >> x;
        for (int i = 1; i <= n; i++) cin >> a[i];
        int ans = -1;
        ans = max(ans, solve(n, x));
        for (int b = 29; b >= 0; b--) {
            if ((x>>b)&1) {
                int y = (x^(1 << b));
                for (int c = b - 1; c >= 0; c--) {
                    if (((y>>c)&1) == 0) y ^= (1 << c);
                }
                ans = max(ans, solve(n, y));
            }
        }
        cout << ans << '\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1946C
Editorial Content:
1946C - Tree Cutting
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using i64 = long long;
 
void solve() {
    int n, k;
    std::cin >> n >> k;
    std::vector<std::vector<int>> adj(n);
    for (int i = 0; i < n - 1; i++) {
        int v, u;
        std::cin >> v >> u;
        --v, --u;
        adj[v].emplace_back(u);
        adj[u].emplace_back(v);
    }
    auto check = [&](int x) {
        int res = 0;
        auto dfs = [&](auto self, int v, int f) -> int {
            int sz = 1;
            for (int u : adj[v]) {
                if (u == f) {
                    continue;
                }
                sz += self(self, u, v);
            }
            if (sz >= x && f != v) {
                ++res, sz = 0;
            }
            return sz;
        };
        int t = dfs(dfs, 0, 0);
        return (res > k || (t >= x && res == k) ? true : false);
    };
    int low = 1, high = n / (k + 1) + 1;
    while (high - low > 1) {
        int mid = (low + high) / 2;
        if (check(mid)) {
            low = mid;
        } else {
            high = mid;
        }
    }
    std::cout << low << "\n";
}
 
signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
 
    int t = 1;
    std::cin >> t;
 
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1946B
Editorial Content:
1946B - Maximum Sum
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int P = 1e9 + 7;

void solve() {
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    int S = 0, sum = 0;
    int cur = 0;
    for (int i = 0; i < n; i++) {
        sum += a[i];
        cur += a[i];
        cur = max(cur, 0LL);
        S = max(S, cur);
    }
    sum = (sum % P + P) % P;
    S = S % P;
    int t = 1;
    for (int i = 0; i < k; i++) {
        t = t * 2 % P;
    }
    int ans = (sum + S * t - S + P) % P;
    cout << ans << '\n';
}


signed main() {
    //cout << fixed << setprecision(20);
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1, G = 1;
    //cin >> G;
    cin >> T;
    while (T--)
        solve();
    return 0;
}
--------------------------------------------------
Problem ID: 1946A
Editorial Content:
1946A - Median of an Array
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using i64 = long long;

void solve() {
    int n;
    std::cin >> n;
    std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
    }
    std::sort(a.begin(), a.end());
    int p = (n + 1) / 2 - 1;
    int res = std::count(a.begin() + p, a.end(), a[p]);
    std::cout << res << "\n";
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int t = 1;
    std::cin >> t;

    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1945H
Editorial Content:
1945H - GCD is Greater
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int BITS = 20;
const int MAX_N = 4e5 + 10;
int n;
int x;

int src[MAX_N];

void coutYES(int fId, int sId) {
    cout << "YES\n";
    cout << "2 " << src[fId] << ' ' << src[sId] << '\n';
    cout << n - 2 << ' ';
    for (int i = 0; i < n; i++) {
        if (i == fId || i == sId) {
            continue;
        }
        cout << src[i] << ' ';
    }
    cout << '\n';
}

void solve() {
    cin >> n >> x;
    vector<int> bitCnt[BITS];

    int maxA = 1;
    for (int i = 0; i < n; i++) {
        cin >> src[i];
        maxA = max(maxA, src[i] + 1);
        for (int bit = 0; bit < BITS; bit++) {
            if ((1 << bit) & src[i]) {
                continue;
            }

            bitCnt[bit].push_back(i);
        }
    }

    bool incr[n];
    int cnt[maxA];
    int divBy[maxA];
    for (int i = 0; i < maxA; ++i) {
        cnt[i] = 0;
        divBy[i] = 0;
    }

    int pref[n];
    int suf[n];
    for (int i = 0; i < n; i++) {
        incr[i] = false;
        pref[i] = src[i];
        if (i) {
            pref[i] = pref[i - 1] & src[i];
        }
    }

    for (int i = n - 2; i >= 0; i--) {
        suf[n - 1] = src[n - 1];
        if (i < n - 1) {
            suf[i] = suf[i + 1] & src[i];
        }
    }

    for (const auto& item : bitCnt) {
        if (item.size() <= 2) {
            for (const int& id : item) {
                incr[id] = true;
                int myAnd = -1;
                for (int j = id + 1; j < n; j++) {
                    int curAND = (1 << BITS) - 1;
                    if (j + 1 < n) curAND &= suf[j + 1];
                    if (id - 1 >= 0) curAND &= pref[id - 1];
                    if (myAnd != -1) curAND &= myAnd;

                    if (curAND + x < __gcd(src[id], src[j])) {
                        coutYES(id, j);
                        return;
                    }

                    if (myAnd == -1) {
                        myAnd = src[j];
                    } else {
                        myAnd &= src[j];
                    }
                }

                myAnd = -1;
                for (int j = id - 1; j >= 0; j--) {
                    int curAND = (1 << BITS) - 1;

                    if (j - 1 >= 0) curAND &= pref[j - 1];
                    if (id + 1 < n) curAND &= suf[id + 1];
                    if (myAnd != -1) curAND &= myAnd;

                    if (curAND + x < __gcd(src[id], src[j])) {
                        coutYES(id, j);
                        return;
                    }

                    if (myAnd == -1) {
                        myAnd = src[j];
                    } else {
                        myAnd &= src[j];
                    }
                }
            }
        }
    }

    int AND = (1 << BITS) - 1;
    for (int i = 0; i < BITS; i++) {
        if (!bitCnt[i].empty()) {
            AND ^= (1 << i);
        }
    }

    for (int i = 0; i < n; i++) {
        if (!incr[i]) {
            ++cnt[src[i]];
        }
    }

    for (int i = 1; i < maxA; i++) {
        for (int j = i; j < maxA; j += i) {
            divBy[i] += cnt[j];
        }
    }

    for (int g = maxA - 1; g > AND + x; g--) {
        if (divBy[g] < 2) {
            continue;
        }

        int fId = -1;
        int sId = -1;
        for (int i = 0; i < n; i++) {
            if (!incr[i]) {
                if (src[i] % g == 0) {
                    if (fId == -1) {
                        fId = i;
                    } else {
                        sId = i;
                    }
                }
            }
        }
        coutYES(fId, sId);
        return;
    }

    cout << "NO\n";
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int testN;
    cin >> testN;
    while (testN--) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1945G
Editorial Content:
1945G - Cook and Porridge
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <queue>

using namespace std;
using ll = long long;

const int MAX_N = 2e5;
const int MAX_D = 3e5;

struct Student {
    int k;
    int s;
    int tin = 0;

    bool operator<(const Student& other) const {
        if (k == other.k) {
            if (tin == other.tin) {
                return s > other.s;
            }
            return tin > other.tin;
        }
        return k < other.k;
    }
};

int n, D, x;
Student qu1[MAX_N];
int sufMax[MAX_N];
vector<Student> eat[MAX_D];

int check() {
    int origPos = 0;
    priority_queue<Student> qu2;
    for (int i = 0; i < D && origPos < n; ++i) {
        if (qu2.empty() || qu2.top().k <= sufMax[origPos]) {
            ll nxtTime = ll(i) + ll(x) * ll(qu1[origPos].s);
            if (nxtTime < D) {
                eat[nxtTime].push_back(qu1[origPos]);
            }

            ++origPos;
            if (origPos == n) {
                for (int tm = 0; tm < D; ++tm) {
                    eat[tm].clear();
                }

                return i + 1;
            }
        } else {
            ll nxtTime = ll(i) + ll(x) * ll(qu2.top().s);
            if (nxtTime < D) {
                eat[nxtTime].push_back(qu2.top());
            }
            qu2.pop();
        }

        for (const auto& student : eat[i]) {
            qu2.push({student.k, student.s, i});
        }
    }

    for (int i = 0; i < D; ++i) {
        eat[i].clear();
    }

    return -1;
}

void solve() {
    cin >> n >> D;
    x = 1;
    for (int i = 0; i < n; ++i) {
        cin >> qu1[i].k >> qu1[i].s;
    }

    sufMax[n - 1] = qu1[n - 1].k;
    for (int i = n - 2; i >= 0; --i) {
        sufMax[i] = max(qu1[i].k, sufMax[i + 1]);
    }

    cout << check() << '\n';
}

int32_t main() {
    ll testN;
    cin >> testN;
    while (testN--) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1945F
Editorial Content:
1945F - Kirill and Mushrooms
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>

using namespace std;
using ll = long long;

void solve() {
    ll n;
    cin >> n;
    vector<ll> src(n);
    vector<pair<ll, ll>> can(n);
    for (ll i = 0; i < n; ++i) {
        cin >> src[i];
        can[i] = {src[i], i};
    }

    vector<ll> ord(n);
    for (auto& item : ord) {
        cin >> item;
        --item;
    }

    sort(can.rbegin(), can.rend());
    ll best = can[0].first;
    ll take = 1;

    ll cur;
    ll P = 1;
    vector<bool> burn(n);
    vector<bool> used(n);
    used[can[0].second] = true;
    for (ll k = 0; k + 1 < n && P < n; ++k) {
        while (P < n && burn[can[P].second]) {
            ++P;
        }

        if (P == n) {
            break;
        }

        used[can[P].second] = true;
        cur = can[P].first;
        ++P;

        burn[ord[k]] = true;
        if (used[ord[k]]) {
            while (P < n && burn[can[P].second]) {
                ++P;
            }

            if (P == n) {
                break;
            }

            used[can[P].second] = true;
            cur = can[P].first;
            ++P;
        }

        if (best < cur * (k + 2)) {
            take = k + 2;
            best = cur * (k + 2);
        }
    }

    cout << best << ' ' << take << '\n';
}

int32_t main() {
    ll testN;
    cin >> testN;
    while (testN--) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1945E
Editorial Content:
1945E - Binary Search
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>

using namespace std;

void solve() {
    int n, x;
    cin >> n >> x;
    vector<int> src(n);
    int P = 0;
    for (int i = 0; i < n; ++i) {
        cin >> src[i];
        if (src[i] == x) {
            P = i;
        }
    }

    int l = 0;
    int r = n;
    while (r - l > 1) {
        int m = (l + r) / 2;

        if (src[m] <= x) {
            l = m;
        } else {
            r = m;
        }
    }

    cout << "1\n";
    cout << P + 1 << ' ' << l + 1 << '\n';
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }

    return 0;
}
--------------------------------------------------
Problem ID: 1945D
Editorial Content:
1945D - Seraphim the Owl
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
using ll = long long;

void solve() {
    ll n, k;
    cin >> n >> k;
    vector<ll> A(n);
    for (auto& item : A) {
        cin >> item;
    }
    reverse(A.begin(), A.end());

    vector<ll> B(n);
    for (auto& item : B) {
        cin >> item;
    }
    reverse(B.begin(), B.end());

    ll bSum = 0;
    ll pref = 0;
    for (ll i = 0; i < n - k; ++i) {
        if (A[i] < B[i]) {
            pref += bSum;
            pref += A[i];
            bSum = 0;
        } else {
            bSum += B[i];
        }
    }

    ll res = 1e18;
    for (ll i = n - k; i < n; ++i) {
        res = min(res, pref + bSum + A[i]);
        bSum += B[i];
    }

    cout << res << '\n';
}

int32_t main() {
    ll testN;
    cin >> testN;
    while (testN--) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1945C
Editorial Content:
1945C - Left and Right Houses
Tutorial
Tutorial is loading...
Solution
for case in range(int(input())):
    n = int(input())
    a = input()
    suf_cnt = [0] * (n + 1)
    for i in range(n - 1, -1, -1):
        suf_cnt[i] = suf_cnt[i + 1] + (a[i] == '1')
    pref_cnt = 0
     
    opt_ans = -1
    opt_dist = n * 2
    threshold = (n + 1) // 2
     
    for i in range(n + 1):
        if pref_cnt >= (i + 1) // 2 and suf_cnt[i] >= (n - i + 1) // 2 and abs(n - 2 * i) < opt_dist:
            opt_dist = abs(n - 2 * i)
            opt_ans = i
        if i != n:
            pref_cnt += (a[i] == '0')
     
    print(opt_ans)
--------------------------------------------------
Problem ID: 1945B
Editorial Content:
1945B - Fireworks
Tutorial
Tutorial is loading...
Solution
t = int(input())
for qi in range(t):
    a, b, m = [int(x) for x in  input().split()]
    ans = m // a + m // b + 2
    print(ans)
--------------------------------------------------
Problem ID: 1945A
Editorial Content:
1945A - Setting up Camp
Tutorial
Tutorial is loading...
Solution
#include <iostream>

using namespace std;
using ll = long long;

void solve() {
    ll single, poly, uni;
    cin >> single >> poly >> uni;
    ll needPoly = (3 - poly % 3) % 3;
    if (poly > 0 && needPoly > uni) {
        cout << "-1\n";
        return;
    }

    uni -= needPoly;
    poly += needPoly;

    ll mn = single + uni / 3 + (uni % 3 + 1) / 2 + poly / 3;
    cout << mn << '\n';
}

int32_t main() {
    ll T;
    cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1944B
Editorial Content:
1944B - Equal XOR
Hint 1
Group numbers according to how many times they occur in $$$a[1...n]$$$.
Hint 2
The group of numbers having $$$0$$$ occurrences in $$$a[1...n]$$$ is of the same size as the group of numbers having $$$2$$$ occurences in $$$a[1...n]$$$.
Hint 3
Try to use the $$$0$$$ and $$$2$$$ occurrence numbers first, and then if we still need more, we can use the $$$1$$$ occurence numbers. Remember that we have to form sequences of size $$$2 \cdot k$$$ which is even.
Solution
We can append any $$$2$$$ occurrence numbers to our sequence $$$l$$$ and any $$$0$$$ occurrence numbers to our sequence $$$r$$$ without any issue because the xor value will cancel out. We do this while our sequence sizes are less than $$$2 \cdot k$$$. At the end of this process, $$$l$$$ and $$$r$$$ will have the same size due to Hint $$$2$$$.
Now, we use as many $$$1$$$ occurrence numbers appending to both $$$l$$$ and $$$r$$$ as needed. Since we append to both sequences, the xor value of the $$$2$$$ sequences will be the same.
If we had to solve for odd sequence sizes, we could take a $$$1$$$ occurrence number at the very start to make it even, and then run the same process, but if there are no $$$1$$$ occurrence numbers at all, we fail with this method.
Code
#include <bits/stdc++.h>
using namespace std;

int main(){
    int t; cin >> t;
    while (t--){
        int n, k; 
        cin >> n >> k; 
        k = 2 * k;
        
        vector <int> a(2 * n), occ(n + 1, 0);
        
        for (auto &x : a) cin >> x;
        for (int i = 0; i < n; i++) occ[a[i]]++;
        
        vector <int> g0, g1, g2;
        for (int i = 1; i <= n; i++){
            if (occ[i] == 0) g0.push_back(i);
            else if (occ[i] == 1) g1.push_back(i);
            else g2.push_back(i);
        }
        
        int v = 0;
        for (auto x : g2){
            if (v < k){
                v += 2;
                cout << x << " " << x << " ";
            }
        }
        for (auto x : g1){
            if (v < k){
                v++;
                cout << x << " ";
            }
        }
        cout << "\n";
        
        v = 0;
        for (auto x : g0){
            if (v < k){
                v += 2;
                cout << x << " " << x << " ";
            }
        }
        for (auto x : g1){
            if (v < k){
                v++;
                cout << x << " ";
            }
        }
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1944A
Editorial Content:
1944A - Destroying Bridges
Hint 1
What is the minimum number of bridges to burn if we want to make exactly $$$i$$$ islands visitable from $$$1$$$?
O(n) Solution
Atleast $$$i \cdot (n - i)$$$ bridges need to burnt (the bridges connecting the $$$i$$$ reachable islands and the $$$n - i$$$ non-reachable islands).
A simple $$$O(n)$$$ solution is for every $$$i$$$ from $$$1$$$ to $$$n$$$, check if $$$i \cdot (n - i) \le k$$$, in which case print $$$i$$$ and break.
Hint 2
What is the answer when $$$k \ge n - 1$$$.
Hint 3
When $$$k < n - 1$$$, is it possible to make any island non-visitable?
O(1) Solution
When $$$k \ge n - 1$$$, the answer is $$$1$$$ since we can just destroy all bridges $$$(1, i)$$$ for $$$2 \le i \le n$$$.
Otherwise, suppose we tried to make some set of $$$i$$$ islands non-visitable, and the other $$$n - i$$$ nodes reachable from $$$1$$$. Then we need to burn atleast $$$i \cdot (n - i)$$$ bridges (the bridges connecting the $$$2$$$ sets). It is not hard to see that this function attains the minimum value when $$$i = 1$$$ or $$$i = n - 1$$$ for $$$1 \le i < n$$$. Hence the minimum number of bridges to burn always exceeds $$$n - 1$$$.
Formal Proof
The function $$$f(x) = x \cdot (n - x)$$$ is a quadratic function in $$$x$$$, which attains maximum value at $$$x = \frac{n}{2}$$$, and the value decreasing proportionally as the distance from $$$\frac{n}{2}$$$ increases. This means that $$$f(1) = f(n - 1)$$$, and $$$f(1) > f(i)$$$ for all ($$$2 \le i \le (n - 2)$$$).
Formal Proof
The function $$$f(x) = x \cdot (n - x)$$$ is a quadratic function in $$$x$$$, which attains maximum value at $$$x = \frac{n}{2}$$$, and the value decreasing proportionally as the distance from $$$\frac{n}{2}$$$ increases. This means that $$$f(1) = f(n - 1)$$$, and $$$f(1) > f(i)$$$ for all ($$$2 \le i \le (n - 2)$$$).
Code (O(n))
#include <bits/stdc++.h>
using namespace std;

int main(){
    int t; cin >> t;
    while (t--){
        int n, k; cin >> n >> k;
        for (int i = 1; i <= n; i++){
            if (i * (n - i) <= k){
                cout << i << "\n";
                break;
            }
        }
    }
    return 0;
}
Code (O(1))
#include <bits/stdc++.h>
using namespace std;

int main(){
    int t; cin >> t;
    while (t--){
        int n, k; cin >> n >> k;
        if (k >= n - 1) cout << 1 << "\n";
        else cout << n << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1943F
Editorial Content:
1943F - Minimum Hamming Distance
Hint 1 / Claim 1
Assumption: 0 is the mode of string t. If 1 occurs more times than 0 in t, we will flip all characters of s and t so that 0 is the mode of string t.
Let us say index $$$i$$$
nice
if there exists $$$l$$$ and $$$r$$$($$$1 \le l \le i \le r \le n$$$) such that $$$s_i$$$ is the mode of substring $$$t[l,r]$$$.
So we might have some not
nice
indices $$$i$$$ such that $$$s_i =$$$ $$$\mathtt{1} $$$. We will not have any index $$$i$$$ such that i is not
nice
and $$$s_i =$$$ $$$\mathtt{0} $$$, as $$$\mathtt{0} $$$ is the mode of $$$t$$$. So, we need to fix the not
nice
indices.
Now we will start changing some $$$\mathtt{0} $$$ to $$$\mathtt{1} $$$. So it might be possible that in final $$$t$$$, the frequency of $$$\mathtt{1} $$$ is more than that of $$$\mathtt{0} $$$, and $$$\mathtt{0} $$$ is no longer the mode. So should we worry about indices $$$ i $$$ such that $$$ i $$$ was nice in the beginning, and now that we made some flips, $$$ i $$$ may become not
nice
?
No! It will never be possible.
In case $$$\mathtt{1} $$$ occurs more times than $$$\mathtt{0} $$$ in the updated $$$t$$$, we will have $$$frequency[1] = frequency[0] + 1$$$ and $$$t[1] = t[n] =$$$ $$$\mathtt{1} $$$(we will have such cases for pairs like ($$$s =$$$ $$$\mathtt{011} $$$, $$$t =$$$ $$$\mathtt{100} $$$; for this pair final $$$t$$$ should be $$$t =$$$ $$$\mathtt{101} $$$). So the substrings $$$t[1, n - 1]$$$ and $$$t[2, n]$$$ will have equal numbers of $$$\mathtt{0} $$$ and $$$\mathtt{1} $$$, and thus all indices should be
nice
. So our claim is that we should change some $$$\mathtt{0} $$$ to $$$\mathtt{1} $$$, without caring about indices $$$i$$$(which were
nice
initially) becoming not
nice
such that $$$s_i =$$$ $$$\mathtt{0} $$$.
Hint 2
We can use dynamic programming here.
So let us have $$$dp$$$, such that $$$dp[i][j]$$$ gives the minimum number of flips required to make $$$t[1, i]$$$
friend
of $$$s[1, i]$$$ and the maximum suffix sum is $$$j$$$.
String $$$x$$$ is called to be
friend
of string $$$y(|x| = |y|)$$$, if for every $$$i$$$($$$1 \le i \le |x|$$$), there exists indices $$$l$$$ and $$$r$$$ such that:
1. $$$1 \le l \le i \le r \le |x|$$$
2. $$$x_i$$$ is a mode of the string $$$y[l,r]$$$
Solution
Please read hints $$$1$$$ and $$$2$$$ if you haven't as they contain some claims and definitions.
Note that when we find some sum, we add $$$1$$$ when we get $$$\mathtt{1} $$$ and subtract $$$-1$$$ when we get $$$\mathtt{0} $$$.
Suppose we have found $$$dp$$$ values for the first $$$i - 1$$$ indices, and we want to find $$$dp[i][j]$$$ for $$$0 \le j \le n$$$. Now, we need to perform the transitions.
Let us try to have a $$$O(n^3)$$$ solution first, which we can optimise after making some observations.
Take some $$$l$$$($$$0 \leq l \leq i - 1$$$). We will iterate over $$$suff$$$_$$$sum = 0$$$ to $$$n$$$, here $$$suff$$$_$$$sum$$$ is the maximum suffix sum of substring $$$t[1, l]$$$, and use $$$dp[l][suff$$$_$$$sum]$$$ to find optimal values for $$$dp[i][x]$$$ for some $$$x$$$.
So we need to do some flips to substring $$$t[l + 1, i]$$$, as $$$s[1, l]$$$ and $$$t[1, l]$$$ are already
friends
. So we only care to make all indices $$$j$$$ ($$$l + 1 \le j \le i$$$)
nice
. So there are two possibilities(either $$$\mathtt{1} $$$ occurs in substring $$$s[l + 1, i]$$$ or not):
If $$$\mathtt{1} $$$ does not occur, we can perform the transition without making any flips.
Assume $$$\mathtt{1} $$$ occurs in substring $$$s[l + 1, i]$$$. So firstly, find the sum(say $$$cur$$$_$$$sum$$$) of substring $$$t[l + 1, i]$$$. Now, if we do some flips to substring $$$t[l + 1, i]$$$, $$$cur$$$_$$$sum$$$ will change accordingly. We will do a minimum number of flips such that $$$suff$$$_$$$sum + cur$$$_$$$sum \ge 0$$$. Note that we are talking here about updated $$$cur$$$_$$$sum$$$. So we can find the minimum number(say $$$cost$$$) of flips, which will be $$$\lfloor \frac{\max(0, 1 -d )}{2} \rfloor$$$, where $$$d=suff$$$_$$$sum + initial$$$_$$$cur$$$_$$$sum$$$. So we know how many flips to make.
But which ones to flip? Here is one more claim. We should only flip the last $$$cost$$$ $$$\mathtt{0} $$$ of substring $$$t[l + 1, i]$$$.
So this is a sufficient condition, as we can certainly say that $$$t[1, i]$$$ will be
friend
of $$$s[1, i]$$$ now. So we know the required number of flips, which is $$$dp[l][suff$$$_$$$sum] + cost$$$. We need to find one more thing — what would be the maximum suffix sum if we flip the last $$$cost$$$ characters of $$$t[l + 1, i]$$$? We can precompute.
But we have an issue now. We know that what we performed is sufficient. But is it necessary? What if we did not need to flip cost characters of $$$t[l + 1, i]$$$?
It might be possible that we could have done less number of flips and still made all indices $$$l + 1 \le j \le i$$$
nice
. The reasoning behind this is we made sure that $$$suff$$$_$$$sum + cur$$$_$$$sum \ge 0$$$, but what if it was not needed?
Like it is possible that total sum is negative, but all indices $$$j$$$($$$l + 1 \le j \le i$$$) such that $$$s_j =$$$ $$$\mathtt{1} $$$ are satisfied. So here, we can use exchange arguments and conclude that all cases will be covered if we check for all pairs of ($$$l, suff$$$_$$$sum$$$) $$$0 \le l, suff$$$_$$$sum \le i - 1$$$.
Now we need to optimise this to $$$O(n^2)$$$.
Notice that when we do the flips, there will be a suffix(possibly empty when $$$cost=0$$$) of $$$t[l + 1, i]$$$ containing only $$$\mathtt{1} $$$ s. Suppose we are at index $$$i$$$ and need to find $$$dp[i][j]$$$ for $$$0 \le j \le i$$$. We can iterate over all $$$j$$$($$$1 \le j \le i$$$), assume that all the characters in substring $$$t[j,i]$$$ are $$$\mathtt{1} $$$ s, and find the $$$dp$$$ values. Maximum suffix sum will be $$$i-j+1+max$$$_$$$suffix$$$_$$$sum[j-1]$$$. So we can find the smallest index $$$p$$$ such that the sum of the elements in substring $$$t[p,l]$$$ is greater than or equal to $$$0$$$ if we make all the characters in substring $$$t[j,i]$$$ $$$\mathtt{1} $$$.
Notice that we already have the new suffix maximum, and we know the $$$cost$$$ too, which is equal to the number of $$$\mathtt{0} $$$ s in the original substring $$$t[j,i]$$$. So our transition will be $$$dp[i][new$$$_$$$suffix$$$_$$$max]=\max(dp[i][new$$$_$$$suffix$$$_$$$max], \min\limits_{k = p-1}^{i} best[k] + cost)$$$, where $$$best[i]= \min\limits_{k = 0}^{i} dp[i][k]$$$.
So, our final complexity will be $$$O(n^2)$$$, as we can perform the transition in $$$O(1)$$$ if we precompute the needed things.
Code
#include <bits/stdc++.h>   
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;   
using namespace std;
#define ll int
#define pb push_back                  
#define mp make_pair          
#define nline "\n"                            
#define f first                                            
#define s second                                             
#define pll pair<ll,ll> 
#define all(x) x.begin(),x.end()     
const ll MOD=998244353;
const ll MAX=10005;  
ll dp[MAX][MAX];
ll suffix_min[MAX];
ll suffix_max[MAX];
ll can_go_till[MAX][MAX+5];
void solve(){     
    ll n; cin>>n; 
    ll shift=n;
    for(ll i=-n;i<=0;i++){
        can_go_till[0][shift+i]=0;
    }
    string s,t; cin>>s>>t;
    s=" "+s,t=" "+t;
    ll sum=0;
    for(ll i=1;i<=n;i++){
        sum+=2*(t[i]-'0')-1;
    }
    suffix_max[0]=0;
    if(sum>=0){   
        for(ll i=1;i<=n;i++){
            s[i]='0'+'1'-s[i];  
            t[i]='0'+'1'-t[i];
        }    
    }
    ll max_sum=0;
    for(ll i=1;i<=n;i++){
        max_sum+=2*(t[i]-'0')-1;
        max_sum=max(0,max_sum);
        suffix_max[i]=max_sum;
    }  
    for(ll i=1;i<=n;i++){
        sum=0;
        for(ll j=-n;j<=0;j++){
            can_go_till[i][shift+j]=i+1;
        }
        for(ll j=i;j>=1;j--){
            sum+=2*(t[j]-'0')-1;
            ll use=min(sum,0);
            can_go_till[i][shift+use]=j;
        }
        for(ll j=n-1;j>=0;j--){
            can_go_till[i][j]=min(can_go_till[i][j],can_go_till[i][j+1]);
        }
    }
    for(ll i=0;i<=n+1;i++){
        for(ll j=0;j<=n+1;j++){
            dp[i][j]=MOD;
        }
    }
    dp[0][0]=0;
    vector<ll> best(n+5,MOD);
    best[0]=0;
    for(ll i=1;i<=n;i++){
        for(ll l=0;l<=i-1;l++){ 
            dp[i][l+1]=dp[i-1][l]+(t[i]=='0');
        }
        for(ll l=0;l<=i;l++){
            ll new_sum=l+2*(t[i]-'0')-1;  
            if(s[i]=='1' and new_sum<=-1){
                continue; 
            }    
            new_sum=max(0,new_sum); 
            dp[i][new_sum]=min(dp[i][new_sum],dp[i-1][l]);
        }
        suffix_min[i]=MOD;
        for(ll j=i-1;j>=0;j--){
            suffix_min[j]=min(suffix_min[j+1],best[j]);
        }
        ll cnt=0;
        for(ll j=i;j>=1;j--){
            cnt+=(t[j]=='0');
            ll now=i-j+1;
            ll cur_suff_max=now+suffix_max[j-1];
            ll pos=max(0,can_go_till[j-1][shift-now]-1);
            dp[i][cur_suff_max]=min(dp[i][cur_suff_max],suffix_min[pos]+cnt);
        }
        for(ll j=0;j<=n;j++){
            best[i]=min(best[i],dp[i][j]); 
        }
    } 
    ll ans=MOD; 
    s[0]='1';
    for(ll i=n;i>=0;i--){  
        ans=min(ans,best[i]);    
        if(s[i]=='1'){
            cout<<ans<<nline;
            return;  
        }
    }
    return;          
}                                          
int main()                                                                               
{     
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);                               
    #ifndef ONLINE_JUDGE                 
    freopen("input.txt", "r", stdin);                                           
    freopen("output.txt", "w", stdout);      
    freopen("error.txt", "w", stderr);                        
    #endif     
    ll test_cases=1;                 
    cin>>test_cases;
    while(test_cases--){
        solve();
    }
    cout<<fixed<<setprecision(10);
    cerr<<"Time:"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms\n"; 
}
--------------------------------------------------
Problem ID: 1943E2
Editorial Content:
1943E2 - MEX Game 2 (Hard Version)
Solution
Instead of doing the check for $$$ans \geq i$$$ in $$$O(m^3)$$$, we will do it in $$$O(m)$$$.
For an array $$$f$$$ of length $$$n$$$. Let $$$s=f_1+f_2+\ldots+f_n$$$ be the sum of the element. $$$f$$$ will be called
flat
if $$$f_i = \lfloor \frac{s+i-1}{n} \rfloor$$$. That is, it has the form $$$x, \ldots, x, x+1, \ldots x+1$$$. All flat array can be characters by $$$2$$$ integers $$$(n,s)$$$ only.
Imagine simulating Bob's strategy without simulating Alice's moves of removing the first element of the array. For some prefix of the moves, the actual simulation will be a suffix of this simulation. This is because to subtract something from index $$$\leq i$$$, we must have $$$f_{i+1} = f_{i+2} = \ldots = f_n$$$.
As an example, let $$$k=4$$$.
With Alice moves: $$$[1,2,3,5,5] \to [2,3,3,3] \to [1,2,2]$$$
Without Alice moves: $$$[1,2,3,5,5] \to [1,2,3,3,3] \to [1,1,2,2,2]$$$
$$$[1,2,2]$$$ is not a suffix of $$$[1,1,2,2,2]$$$ and is the first time such a thing happens.
Suppose that the first time this happens is after $$$p$$$ moves. Then the resulting array is the flat array $$$(n-p,f_{p+1}+f_{p+2}+\ldots+f_n-pk)$$$. To find the necessary value of $$$p$$$, we can binary search or run $$$2$$$-pointers to check if the suffix of the array can reach $$$f_p$$$ with the amount of subtraction operations till then. (What we basically did is find the suffix of the array that actually gets operated on, since that makes it much more easier to solve)
Then, since the flat array $$$(n,s)$$$ becomes $$$(n-1,s-\lfloor \frac{s}{n} \rfloor - k)$$$, we can figure out whether each flat array evantually becomes a losing or winning state as we can calculate for each $$$n$$$, the minimum $$$s$$$ such that $$$(n,s)$$$ is a winning state.
Code
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define ll long long
#define ii pair<ll,ll>
#define iii pair<ii,ll>
#define fi first
#define se second
#define endl '\n'
#define debug(x) cout << #x << ": " << x << endl

#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define lb lower_bound
#define ub upper_bound

#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

mt19937 rng(chrono::system_clock::now().time_since_epoch().count());

int n,k;
int arr[200005];
int temp[200005];

bool solve(vector<int> v){
    sort(all(v));
    
    rep(x,0,sz(v)) temp[x]=1e18;
    
    int l=1,curr=0;
    rep(x,1,sz(v)){
        curr+=v[x];
        
        while (l<x && (curr-v[l])-(x-l)*v[l] >= l*k){
            curr-=v[l];
            l++;
        }
        
        temp[x-l]=min(temp[x-l],curr-l*k);
    }
    
    rep(x,sz(v),1) temp[x-1]=min(temp[x-1],(temp[x]-temp[x]/(x+1))-k);
    
    return temp[0]>0;
}

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin.exceptions(ios::badbit | ios::failbit);
    
    int TC;
    cin>>TC;
    while (TC--){
        cin>>n>>k;
        rep(x,0,n+1) cin>>arr[x];
        
        // solve(vector<int>(arr,arr+n+1));
        // continue;
        
        int lo=0,hi=n+2,mi;
        while (hi-lo>1){
            mi=hi+lo>>1;
            
            if (solve(vector<int>(arr,arr+mi))) lo=mi;
            else hi=mi;
        }
        
        cout<<lo<<endl;
    }
}
--------------------------------------------------
Problem ID: 1943E1
Editorial Content:
1943E1 - MEX Game 2 (Easy Version)
Hint 1
It might be optimal for Bob to reduce multiple elements at the same time, thus making Alice choose between which element she wants to take.
Hint 2
Suppose you are only checking whether $$$ans \ge i$$$ for now, what would Alice's strategy be?
Hint 3
Try fixing the element that Bob wants to make sure Alice is not able to get. What would be his strategy then?
Solution
For now, lets try to see if $$$ans \ge i$$$. This is equivalent to Alice being able to take $$$1$$$ occurence of everything when the game is reduced to numbers $$$[0, i - 1]$$$.
Alice's strategy here is actually easy to find. At every step, Alice will choose the minimum $$$f_j$$$ such that $$$0 \le j < i$$$, and she hasn't chosen $$$i$$$ yet. You can reason this with greedy stays ahead, exchange argument, whatever you want.
This gives us a nice definition of Alice's moves, however we seemingly have to maintain the sorted sequence of $$$f_i$$$ always. But we can actually rewrite Bob's moves such that it does not affect the sorted order of $$$f_i$$$ and always keeps it sorted. Here, by sorted order, we mean some permutation $$$p = [p_1, p_2, ...., p_i]$$$ of $$$[0, i - 1]$$$ such that $$$f_{p_i} \le f_{p_j}$$$ whenever $$$i \le j$$$.
First, instead of subtracting $$$k$$$, we will do $$$k$$$ subtractions of only $$$1$$$. Then, the only case when sorted order can be destroyed is when there exists $$$k1$$$ and $$$k2$$$ such that $$$f_{k1} = f_{k2}$$$ and we do an operation on $$$k1$$$ but $$$k2$$$ occurs before $$$k1$$$ in the sorted order. This issue can simply be fixed by doing the operation on the smallest $$$x$$$ (according to sorted order) such that $$$f_x = f_{k1}$$$.
Now, we have a good way of representing Alice moves. Suppose we fixed the element that Bob "wins" on. Then, Bob's strategy will obviously be to make the frequency of that element as small as possible, but he must make sure to never violate sorted condition. Since Bob will make at most $$$m$$$ moves, you can just simulate his moves.
The main details of the simulation is that you need to figure out upto what index all values will become equal when doing k operations (or nearly equal, off by 1), and then first take all elements to that state. Let $$$w$$$ be the remaining operations from the $$$k$$$ operations after this, and $$$l$$$ the length of the equal sequence. Then you will reduce every frequency by $$$w / l$$$, and finally reduce the first $$$w$$$ mod $$$l$$$ numbers of this sequence. Check the code for more details.
A naive implementation takes $$$O(m)$$$ per move, so $$$O(m^2)$$$ per element we fix => $$$O(m^3)$$$ total to check $$$ans \ge i$$$. With a binary search on the answer, you get $$$O(m^3 logm)$$$. It can be optimized further, but it wasnt needed to pass. Most other polynomial solutions should pass this.
Code
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define INF (int)1e18
#define f first
#define s second

mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());

void Solve() 
{
    int n, k; cin >> n >> k;

    vector <int> a(n + 1);
    for (auto &x : a) cin >> x;

    auto check = [&](int x){
        vector <int> b;
        for (int i = 0; i < x; i++){
            b.push_back(a[i] - k);
        }

        sort(b.begin(), b.end());

        for (int fix = 1; fix < x; fix++){
            // this is element where bob wins 

            deque <int> c;
            for (int i = 0; i <= fix; i++){
                c.push_back(b[i]);
            }
            
            assert(c.size() >= 2);

            while (c.size() != 2){
                c.pop_front(); 

                // find suffix which works 
                int sz = c.size();
                int works = 0;
                int sum = 0;
                for (int j = 1; j < sz; j++){
                    // sum(elements of c - current element) 
                    // this shud be >= k 
                    sum += c[sz - j];
                    int loss = sum - c[sz - j - 1] * j;
                    if (loss >= k){
                        works = sz - j;
                        break;
                    }
                }

                int have = k;

                // make everything = c[works]
                for (int j = works + 1; j < sz; j++){
                    have -= c[j] - c[works];
                    c[j] = c[works];
                }

                assert(have >= 0);
                for (int j = works; j < sz; j++){
                    c[j] -= have / (sz - works);
                }
                have %= (sz - works);

                for (int j = works; j < sz; j++){
                    if (have){
                        c[j]--;
                        have--;
                    }
                }

                for (int j = 0; j < sz - 1; j++){
                    assert(c[j] <= c[j + 1]);
                }
            }

            c.pop_front();
            if (c[0] <= 0) return false;
        }

        return true;
    };

    int l = 1, r = n + 1;   
    while (l != r){
        int mid = (l + r + 1) / 2;

        if (check(mid)) l = mid;
        else r = mid - 1;
    }

    cout << l << "\n";
}

int32_t main() 
{
    auto begin = std::chrono::high_resolution_clock::now();
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int t = 1;
    // freopen("in",  "r", stdin);
    // freopen("out", "w", stdout);
    
    cin >> t;
    for(int i = 1; i <= t; i++) 
    {
        //cout << "Case #" << i << ": ";
        Solve();
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);
    cerr << "Time measured: " << elapsed.count() * 1e-9 << " seconds.\n"; 
    return 0;
}
--------------------------------------------------
Problem ID: 1943D2
Editorial Content:
1943D2 - Counting Is Fun (Hard Version)
Hint 1
Try to apply Principle of Inclusion Exclusion (PIE).
Hint 2
You do not need to store both last elements! Only the last is enough.
Solution
Since there are $$$n^3$$$ states in our dp, we will have to optimize the number of states somehow.
Let us consider all arrays and not just good arrays. An element is bad if $$$a_i > a_{i - 1} + a_{i + 1}$$$.
Suppose, $$$f(x_1, x_2, ...., x_k)$$$ gave us the number of arrays where each of $$$x_i$$$ are distinct and bad. (Note that other positions may be bad as well). Then, by PIE, the answer is $$$(-1)^k \cdot f(x_1, x_2, ....., x_k)$$$.
For example, for $$$n = 3$$$, we would want to compute $$$f([]) - f([1]) - f([2]) - f([3]) + f([1, 2]) + f([1, 3]) + f([2, 3]) - f([1, 2, 3])$$$. Note that $$$f([])$$$ is simply $$$(k + 1)^n$$$ as there are no restrictions placed on the array.
This has $$$2^n$$$ calculations, so we need to optimize it.
First optimization : obviously, only $$$k$$$ matters and not the exact indices. This means we only have to maintain the count of the number of indices we have made sure are bad.
Second optimization : only parity of $$$k$$$ matters, due to the only dependence of $$$k$$$ being $$$(-1)^k$$$.
We now define $$$dp(i, last, x)$$$ = number of arrays such that $$$a_i = last$$$ and the parity of bad elements (that we know of) till $$$i$$$ is $$$x$$$.
Transitions :
Without (necessarily) creating a bad element : $$$dp(i, last, x) += dp(i - 1, y, x)$$$ for all $$$0 \le y \le k$$$. We might accidentally create more bad elements, but remember that PIE allows us to not worry about that.
With creating a bad element : We view it as a transition from index $$$(i - 2)$$$, $$$a_{i - 1} > a_i + a_{i - 2}$$$ for it to bad, so fix $$$a_i = l1$$$, $$$a_{i - 2} = l2$$$, and you get $$$dp(i, l1, x) += dp(i - 2, l2, 1 - x) \cdot (max(0, k - l1 - l2))$$$.
The $$$max(0, k - l1 - l2)$$$ term comes from the ways to choose $$$a_{i - 1}$$$ such that $$$a_{i - 1} > l1 + l2$$$.
Both the transitions are optimizable with some prefix sums and running totals to get a $$$\mathcal{O}(n^2)$$$ solution.
Code
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define INF (int)1e18
#define f first
#define s second

mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());

void Solve() 
{
    int n, k, mod; cin >> n >> k >> mod;
    
    vector<vector<int>> dp(2, vector<int>(k + 1, 0));
    auto prev2 = dp;
    dp[0][0] = 1;
    
    for (int i = 1; i <= n + 1; i++){
        vector<vector<int>> ndp(2, vector<int>(k + 1, 0));
        vector<int> sum(2, 0);
        
        for (int j = 0; j < 2; j++) for (int x = 0; x <= k; x++){
            sum[j] += dp[j][x]; sum[j] %= mod;
        }
        
        for (int j = 0; j < 2; j++){
            int s1 = 0, s2 = 0;
            
            for (int x = k; x >= 0; x--){
                ndp[j][x] += sum[j];  // normal transition
                
                ndp[j][x] += s2; ndp[j][x] %= mod; // with one wrong
                
                s1 += prev2[j ^ 1][k - x]; s1 %= mod;
                s2 += s1; s2 %= mod;
            }
        }
        
        prev2 = dp;
        dp = ndp;
    }
    
    int ans = (dp[0][0] - dp[1][0] + mod) % mod;
    cout << ans << "\n";
}

int32_t main() 
{
    auto begin = std::chrono::high_resolution_clock::now();
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int t = 1;
    // freopen("in",  "r", stdin);
    // freopen("out", "w", stdout);
    
    cin >> t;
    for(int i = 1; i <= t; i++) 
    {
        //cout << "Case #" << i << ": ";
        Solve();
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);
    cerr << "Time measured: " << elapsed.count() * 1e-9 << " seconds.\n"; 
    return 0;
}
--------------------------------------------------
Problem ID: 1943D1
Editorial Content:
1943D1 - Counting Is Fun (Easy Version)
Hint 1
Try to come up with some necessary and sufficient conditions of a good array.
Hint 2
Apply dp once you have a good condition.
Solution
All operations which include $$$i$$$ must also either include $$$i - 1$$$ or $$$i + 1$$$. Hence $$$a_i \le a_{i - 1} + a_{i + 1}$$$ must hold. Throughout the editorial treat $$$a_i = 0$$$ for $$$(i \le 0)$$$ or $$$(i > n)$$$.
But, is this sufficient? Infact, it is and we can prove it by strong induction.
Proof
Group arrays according to the sum of the array. We will now apply strong induction on the sum of the array.
Base Cases (sum = 0, 1 or 2) are all trivial.
Now, assume that the condition is sufficient for all arrays with sum $$$< x$$$ ($$$x \ge 3$$$).
Let us consider some array $$$a_1, a_2, ...., a_n$$$ with sum $$$x$$$. Let $$$a_i$$$ be the first non-zero element of $$$a$$$.(Observe that $$$a_{i + 1}$$$ can't be $$$0$$$).
We claim that either operating on $$$[i, i + 1]$$$ or $$$[i, i + 2]$$$ will give still satisfy the condition $$$a_j \le a_{j - 1} + a_{j + 1}$$$ for all $$$j$$$.
Let's check it. The only time $$$[i, i + 1]$$$ operation causes an issue is when $$$a_{i + 2} > a_{i + 1} - 1 + a_{i + 3}$$$, i.e. it should necessarily hold that $$$a_{i + 2} > a_{i + 3}$$$, but then $$$a_{i + 3} \le a_{i + 2} - 1$$$, and so, $$$a_{i + 3} \le a_{i + 2} - 1 + a_{i + 4}$$$, meaning $$$[i, i + 2]$$$ is valid.
Now that we have the condition, we can define a dynamic programming as follows :
$$$dp(i, a, b)$$$ = number of ways to make an array upto the $$$i$$$-th index with $$$a_{i - 1} = a$$$, $$$a_i = b$$$ (since only the last $$$2$$$ elements are relevant).
Let the new element be $$$c$$$, then it is a valid way iff $$$b \le a + c$$$. So we have a $$$\mathcal{O}(n^4)$$$ by iterating over all possibilities.
As a final optimization, we can speed it up to $$$\mathcal{O}(n^3)$$$ by using prefix sums. Note that the valid values of $$$a$$$ for fixed $$$b$$$ and $$$c$$$ satisfy $$$a \ge max(0, b - c)$$$, and hence maintaining prefix sums over $$$a$$$, we can speed it up.
Proof
Group arrays according to the sum of the array. We will now apply strong induction on the sum of the array.
Base Cases (sum = 0, 1 or 2) are all trivial.
Now, assume that the condition is sufficient for all arrays with sum $$$< x$$$ ($$$x \ge 3$$$).
Let us consider some array $$$a_1, a_2, ...., a_n$$$ with sum $$$x$$$. Let $$$a_i$$$ be the first non-zero element of $$$a$$$.(Observe that $$$a_{i + 1}$$$ can't be $$$0$$$).
We claim that either operating on $$$[i, i + 1]$$$ or $$$[i, i + 2]$$$ will give still satisfy the condition $$$a_j \le a_{j - 1} + a_{j + 1}$$$ for all $$$j$$$.
Let's check it. The only time $$$[i, i + 1]$$$ operation causes an issue is when $$$a_{i + 2} > a_{i + 1} - 1 + a_{i + 3}$$$, i.e. it should necessarily hold that $$$a_{i + 2} > a_{i + 3}$$$, but then $$$a_{i + 3} \le a_{i + 2} - 1$$$, and so, $$$a_{i + 3} \le a_{i + 2} - 1 + a_{i + 4}$$$, meaning $$$[i, i + 2]$$$ is valid.
Code
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define INF (int)1e18
#define f first
#define s second

mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());

void Solve() 
{
    int n, k, mod; cin >> n >> k >> mod;
    
    vector<vector<int>> dp(k + 1, vector<int>(k + 1, 0));
    dp[0][0] = 1; // dp[a][b]
    
    for (int i = 1; i <= n + 2; i++){
        vector<vector<int>> ndp(k + 1, vector<int>(k + 1, 0)); // dp[b][c]
        vector<vector<int>> pref(k + 1, vector<int>(k + 1, 0)); // pref[b][a]
        
        for (int b = 0; b <= k; b++){
            pref[b][0] = dp[0][b];
            for (int a = 1; a <= k; a++){
                pref[b][a] = (pref[b][a - 1] + dp[a][b]) % mod;
            }
        }
        
        for (int b = 0; b <= k; b++){
            for (int c = 0; c <= k; c++){
                if (b > c){
                    // a must be atleast b - c 
                    ndp[b][c] = (pref[b][k] - pref[b][b - c - 1] + mod) % mod;
                } else {
                    ndp[b][c] = pref[b][k];
                }
            }
        }
        
        dp = ndp;
    }
    
    cout << dp[0][0] << "\n";
}

int32_t main() 
{
    auto begin = std::chrono::high_resolution_clock::now();
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int t = 1;
    // freopen("in",  "r", stdin);
    // freopen("out", "w", stdout);
    
    cin >> t;
    for(int i = 1; i <= t; i++) 
    {
        //cout << "Case #" << i << ": ";
        Solve();
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);
    cerr << "Time measured: " << elapsed.count() * 1e-9 << " seconds.\n"; 
    return 0;
}
--------------------------------------------------
Problem ID: 1943C
Editorial Content:
1943C - Tree Compass
Hint 1
Try to solve for line case.
Hint 2
You may have to use more than $$$1$$$ node for certain cases.
Hint 3
Extend the solution for the line to the general tree version (consider the diamater).
Solution
For a line, an obvious bound on the answer is $$$\lceil \frac{n}{2} \rceil$$$, as we can colour atmost $$$2$$$ nodes per operation. I claim this is achieveable except for when $$$n$$$ mod $$$4 = 2$$$, where we do $$$1$$$ worse. That is however still provably optimal as you can bicolour the line and operations only colours nodes black which are in the same bicolouring.
Construction for line
When $$$n$$$ mod $$$2 = 1$$$, simply use the centre of the line and do operations of the form $$$(centre, i)$$$ ($$$0 \le i \le \lfloor \frac{n}{2} \rfloor$$$).
When $$$n$$$ mod $$$4 = 0$$$, for convenience let the line be $$$1, 2, ...., n$$$. Then, we can do operations like $$$(2, 1), (3, 1), (6, 1), (7, 1)....$$$.
When $$$n$$$ mod $$$4 = 2$$$, either of the above $$$2$$$ methods can be adapted to work because we are allowed $$$1$$$ "extra" operation.
Now that we have the solution for the line case, lets divide into $$$2$$$ cases based on parity of diamater (maximum number of nodes on a path) :
diameter mod $$$2 = 1$$$ : Find the centre of the diamater. Then we can simply do operations of the form $$$(centre, i)$$$ (for all $$$0 \le i \le \lfloor \frac{diameter}{2} \rfloor$$$). If this doesn't colour all nodes, then one can easily check that the diamater we found is not the real diamater, as the node which is not coloured is an endpoint of a larger diameter.
diamater mod $$$2 = 0$$$ : Find the $$$2$$$ centres of the diameter. Then the following set of operations satisfy the requirements : $$$(centre1, i)$$$ and $$$(centre2, i)$$$ for all odd $$$i$$$ satisfying $$$1 \le i \le \frac{diameter}{2}$$$. The intuition behind this is to basically split the nodes into $$$2$$$ sets according to a bicolouring, and then $$$1$$$ centre colours all nodes of a certain colour, while the other centre colours all nodes of the other colour.
Construction for line
When $$$n$$$ mod $$$2 = 1$$$, simply use the centre of the line and do operations of the form $$$(centre, i)$$$ ($$$0 \le i \le \lfloor \frac{n}{2} \rfloor$$$).
When $$$n$$$ mod $$$4 = 0$$$, for convenience let the line be $$$1, 2, ...., n$$$. Then, we can do operations like $$$(2, 1), (3, 1), (6, 1), (7, 1)....$$$.
When $$$n$$$ mod $$$4 = 2$$$, either of the above $$$2$$$ methods can be adapted to work because we are allowed $$$1$$$ "extra" operation.
Code
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define INF (int)1e18
#define f first
#define s second

mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());

void Solve() 
{
    int n;
    cin >> n;
    
    vector<vector<int>> E(n);
    
    for (int i = 1; i < n; i++){
        int u, v; cin >> u >> v;
        
        u--; v--;
        E[u].push_back(v);
        E[v].push_back(u);
    }
    
    auto bfs = [&](int s){
      vector<int> d(n, -1);
      d[s] = 0;
      queue<int> Q;
      Q.push(s);
      while (!Q.empty()){
        int v = Q.front();
        Q.pop();
        for (int w : E[v]){
          if (d[w] == -1){
            d[w] = d[v] + 1;
            Q.push(w);
          }
        }
      }
      return d;
    };
    
    vector<int> d1 = bfs(0);
    int a = max_element(d1.begin(), d1.end()) - d1.begin();
    vector<int> d2 = bfs(a);
    int b = max_element(d2.begin(), d2.end()) - d2.begin();
    vector<int> d3 = bfs(b);
    int diam = d3[max_element(d3.begin(), d3.end()) - d3.begin()] + 1;
    //if 3 we want 1, 1 if 4 we want 1 2 
    
    vector <int> ans;
    for (int i = 0; i < n; i++){
        if ((d2[i] + d3[i] == diam - 1) && ((d2[i] == diam/2) || (d3[i] == diam/2))) 
            ans.push_back(i);
    }
    
    if (diam & 1) assert(ans.size() == 1);
    else assert(ans.size() == 2);
    
    vector <pair<int, int>> ok;
    
    if (diam & 1){
        //print everything from 0 to diam/2 
        for (int i = 0; i <= diam/2; i++){
            ok.push_back({ans[0], i});
        }
    } else {
        //2 => 2 ops, 4 => 2 ops , 6 => 4 ops, 8 => 4 ops 
        int ops = ((n - 2)/4) + 1;
        int need = (diam/2) - 1;
        while (need >= 0){
            ok.push_back({ans[0], need});
            ok.push_back({ans[1], need});
            
            need -= 2;
        }
    }
    
    cout << ok.size() << "\n";
    for (auto [u, r] : ok){
        cout << u + 1 << " " << r << "\n";
    }
}

int32_t main() 
{
    auto begin = std::chrono::high_resolution_clock::now();
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int t = 1;
    cin >> t;
    for(int i = 1; i <= t; i++) 
    {
        //cout << "Case #" << i << ": ";
        Solve();
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);
   // cerr << "Time measured: " << elapsed.count() * 1e-9 << " seconds.\n"; 
    return 0;
}
--------------------------------------------------
Problem ID: 1943B
Editorial Content:
1943B - Non-Palindromic Substring
Hint 1
When is a string not $$$k$$$-good? (Ignore the trivial edge cases of $$$k = 1$$$ and $$$k = n$$$).
Hint 2
What happens when $$$s[i....j]$$$ and $$$s[i + 1....j + 1]$$$ are both palindromes?
Solution
We first try to find the answer for a string
Let $$$k = j - i + 1$$$, $$$s[i....j]$$$ -> I and $$$s[i + 1...j + 1]$$$ -> II are both palindromes.
Then $$$s_i = s_j$$$ (due to I)
$$$s_j = s_{i + 2}$$$ (due to II)
$$$s_{i + 2} = s_{j - 2}$$$ (due to I)
$$$s_{j - 2} = s_{i + 4}$$$ (due to II)
and so on.... you can see that it forces $$$s_i = s_{i + 2} = s_{i + 4} = ....$$$. A similiar reasoning gives you $$$s_{i + 1} = s_{i + 3} = s_{i + 5}$$$.
Further, if $$$k$$$ is even, $$$i$$$ and $$$j$$$ have different parities, but $$$s_i = s_j$$$ implies that all characters must be equal actually.
We mentioned that the edge cases are $$$1$$$ and $$$n$$$, but why exactly? How does the analysis fail for them?(Left as a exercise)
So, the condition for a string to be $$$k$$$-good can be written as follows : $$$k = 1$$$ : never possible
$$$1 < k < n$$$, odd : not an alternating string
$$$1 < k < n$$$, even : not all characters same
$$$k = n$$$ : non-palindromic string
Now onto substring queries. The second and third things are easy to handle, you can store the next position where $$$s_i \ne s_{i + 2}$$$ and $$$s_i \ne s_{i + 1}$$$ respectively. Checking if a substring is a palindrome is standard with various methods such as string hashing or manacher's algorithm.
Code
#include <bits/stdc++.h>
using namespace std;

#define INF (int)1e18

mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());

vector<int> manacher_odd(string s) {
    int n = s.size();
    s = "$" + s + "^";
    vector<int> p(n + 2);
    int l = 1, r = 1;
    for(int i = 1; i <= n; i++) {
        p[i] = max(0, min(r - i, p[l + (r - i)]));
        while(s[i - p[i]] == s[i + p[i]]) {
            p[i]++;
        }
        if(i + p[i] > r) {
            l = i - p[i], r = i + p[i];
        }
    }
    return vector<int>(begin(p) + 1, end(p) - 1);
}

vector<int> manacher(string s) {
    string t;
    for(auto c: s) {
        t += string("#") + c;
    }
    auto res = manacher_odd(t + "#");
    return vector<int>(begin(res) + 1, end(res) - 1);
}

#define int long long

void Solve() 
{
    int n, q; cin >> n >> q;

    string s; cin >> s;
    auto v = manacher(s);
    for (auto &x : v) x--;

    // we also need to know if all same, and all alternating 
    set <int> s1, s2;
    for (int i = 0; i < n - 1; i++){
        if (s[i] != s[i + 1]) s1.insert(i);
        if (i != n - 1 && s[i] != s[i + 2]) s2.insert(i);
    }

    while (q--){
        int l, r; cin >> l >> r;
        l--;
        r--;

        if (l == r){
            cout << 0 << "\n";
            continue;
        }
        
        int len = r - l + 1;

        int ans;
        auto it = s1.lower_bound(l);
        if (it == s1.end() || (*it) >= r){
            ans = 0;
        } else {
            it = s2.lower_bound(l);
            if (it == s2.end() || (*it) >= r - 1){
                ans = ((len - 1)/ 2) * (((len - 1) / 2) + 1);
            } else {
                ans =  len * (len - 1) / 2 - 1;
            }
        }

        if (v[l + r] < (r - l + 1)) ans += len;

        cout << ans << "\n";
    }
}

int32_t main() 
{
    auto begin = std::chrono::high_resolution_clock::now();
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int t = 1;
    // freopen("in",  "r", stdin);
    // freopen("out", "w", stdout);
    
    cin >> t;
    for(int i = 1; i <= t; i++) 
    {
        //cout << "Case #" << i << ": ";
        Solve();
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);
    cerr << "Time measured: " << elapsed.count() * 1e-9 << " seconds.\n"; 
    return 0;
}
--------------------------------------------------
Problem ID: 1943A
Editorial Content:
1943A - MEX Game 1
Hint 1
Alice can adapt to Bob's strategy. Try to keep that in mind.
Big Hint 2
Whenever Bob chooses $$$i$$$, and if there are any copies of $$$i$$$ left, Alice can take $$$i$$$ on her next move.
Hint 3
Let $$$f$$$ be the frequency array of $$$a$$$. You can ignore all $$$f(i) \ge 2$$$ due to the previous hint. Now the answer is some simple casework.
Solution
For any $$$i$$$ s.t. $$$f_i \ge 2$$$, whenever Bob chooses to remove an occurence of $$$i$$$, on the next move Alice simply chooses $$$i$$$ herself (if she hasn't already taken $$$i$$$ before that). Thus, we only focus on $$$f_i \le 1$$$ now.
The answer is min(first $$$i$$$ s.t. $$$f(i) = 0$$$, second $$$i$$$ s.t. $$$f(i) = 1$$$).
Obviously, Alice can't do better than the mex of array (first $$$i$$$ s.t. $$$f(i) = 0$$$). Further, among $$$f(i) = 1$$$, Alice can save atmost $$$1$$$ $$$i$$$ after which Bob will remove the smallest $$$f(i) = 1$$$ he can find. This is optimal for Bob as well because he cannot do better when Alice removes the (first $$$i$$$ s.t. $$$f(i) = 1$$$) on her first move.
Code
#include <bits/stdc++.h>
using namespace std;

int main(){
    int t; cin >> t;
    while (t--){
        int n; cin >> n;
        vector <int> f(n + 1, 0);
        
        for (int i = 0; i < n; i++){
            int x; cin >> x;
            f[x]++;
        }
        
        int c = 0;
        for (int i = 0; i <= n; i++){
            c += (f[i] == 1);
            if ((c == 2) || (f[i] == 0)){
                cout << i << "\n";
                break;
            }
        }
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1942H
Editorial Content:
1942H - Farmer John's Favorite Intern
Solution 1
Model this as a flow problem where growth events are an input of some flow to a node and harvest events and the necessary amount of fruits are an output of flow to the sink. We will define the $$$a_i$$$ edge to be the input edge of every node, $$$b_i$$$ to be the output edge for necessary fruits, and $$$c_i$$$ to be the output edge for growth events. The connections for each individual node will look like:
$$$(\text{source}, a_i, \text{# of growth events})$$$
$$$(a_i, \text{temporary node}, \text{INF})$$$
$$$(\text{temporary node}, b_i, \text{INF})$$$
$$$(\text{temporary node}, c_i, \text{INF})$$$
$$$(b_i, \text{sink}, \text{# of required peaches})$$$
$$$(c_i, \text{sink}, \text{# of harvest events})$$$
To simulate growth events affecting the subtree, every temporary node has infinite capacity directed edges down to the temporary nodes of its children. To simulate growth events affecting the parent, every temporary node has an infinite capacity directed edge to its parent's $$$b_i$$$. To simulate harvest events affecting subtree, every node has infinite capacity directed edges to all its ancestors' $$$c_i$$$ nodes. Lets try to find the min cut of the graph. If we don't put cut some node's $$$a_i$$$, then we must cut both $$$b_i$$$ and $$$c_i$$$ for all of its descendants. If we don't cut some node's $$$a_i$$$, then we also must cut $$$c_i$$$ for all its ancestors and $$$b_i$$$ for its parent. Thus, we can model a $$$dp[i][0/1/2]$$$ to know if we are currently cutting the a_i input edge, cutting the b_i and c_i output edge, or cutting the a_i edge but there is some node in the subtree where we did not cut the a_i edge, in which case we need to cut the c_i edge as well. Transitions look like:
$$$dp[i][0] = a_i + \sum_j dp[j][0]$$$
$$$dp[i][1] = b_i + c_i + \sum_j dp[j][1]$$$
$$$dp[i][2] = a_i + c_i + \min(\sum_j \min(dp[j][0], dp[j][2]), b_i + \sum_j \min(dp[j][0], dp[j][1], dp[j][2]))$$$ where at least one child is a $$$dp[j][2]$$$ or $$$dp[j][1]$$$
$$$dp[i][2]$$$ can be rewritten as:
$$$dp[i][2] = a_i + c_i + \min(\min(dp[j][2] - \min(dp[j][0], dp[j][2])) + \sum_j \min(dp[j][0], dp[j][2]),$$$ $$$\min(dp[j][1] - \min(dp[j][0], dp[j][1], dp[j][2])) + b_i + \sum_j \min(dp[j][0], dp[j][1], dp[j][2])))$$$
Use dynamic dp by representing dp transitions as a matrix where all the light children dp values are known and the heavy child dp values are variable. Then, we can accelerate each chain in the heavy light decomposition of the tree. To get the matrix representation of each transition to the heavy child, there are 5 cases when considering a $$$dp[j][0/1/2]$$$ -> $$$dp[j][2]$$$ transiton where $$$dp[j][0]$$$ is the min, $$$dp[j][1]$$$ is the min, and $$$dp[j][2]$$$ is the min, $$$dp[j][2] - \min(dp[j][0], dp[j][2])$$$ is the optimal added value, or $$$dp[j][0] - min(dp[j][0], dp[j][1], dp[j][2])$$$, is the optimal added value. For each cell in the matrix, put the min of the $$$5$$$ cases.
Since you will only ever change hld chains $$$\log n$$$ times, the total complexity will be $$$n \log^2 n \cdot 3^3$$$. If we use balanced hld or other $$$n \log n$$$ hld techniques, then the complexity becomes $$$n \log^2 n$$$. Both solutions should pass under the given constraints.
Code (C++)
#ifndef LOCAL
    #pragma GCC optimize("O3,unroll-loops")
    #pragma GCC target("avx,avx2,fma")
    #pragma GCC target("sse4,popcnt,abm,mmx,tune=native")
    #endif
    #include <bits/stdc++.h>
    #include <ext/pb_ds/assoc_container.hpp>
    #include <ext/pb_ds/tree_policy.hpp>
    using namespace __gnu_pbds;
    using namespace std;
    
    #define pb push_back
    #define ff first
    #define ss second
    
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll, ll> pll;
    typedef pair<ld, ld> pld;
    
    const int INF = 1e9;
    const ll LLINF = 1e18;
    const int MOD = 1e9 + 7;
    
    template<class K> using sset =  tree<K, null_type, less<K>, rb_tree_tag, tree_order_statistics_node_update>;
    
    inline ll ceil0(ll a, ll b) {
        return a / b + ((a ^ b) > 0 && a % b);
    }
    
    void setIO() {
        ios_base::sync_with_stdio(0); cin.tie(0);
    }
    
    struct Matrix {
    
        array<array<ll, 3>, 3> mat;
    
        array<ll, 3> &operator[](int x){
            return mat[x];
        }
    
        const array<ll, 3> &operator[](int x) const {
            return mat[x];
        }
    
        Matrix(){
            for(int i = 0; i < 3; i++) for(int j = 0; j < 3; j++) mat[i][j] = 0;
        }
    
        Matrix operator*(const Matrix &x){
            Matrix ret;
            for(int i = 0; i < 3; i++) for(int j = 0; j < 3; j++) ret[i][j] = LLINF;
            for(int i = 0; i < 3; i++){
                for(int k = 0; k < 3; k++){
                    for(int j = 0; j < 3; j++){
                        ret[i][j] = min(ret[i][j], mat[i][k] + x[k][j]);
                    }
                }
            }
            return ret;
        }
    
        Matrix &operator*=(const Matrix &x){
            (*this) = (*this) * x;
            return *this;
        }
    };
    
    struct fastset {
    
        priority_queue<ll, vector<ll>, greater<ll>> q, rem;
    
        void insert(ll x){
            q.push(x);
        }
    
        void erase(ll x){
            rem.push(x);
        }
    
        ll query(){
            while(rem.size() && q.top() == rem.top()){
                rem.pop();
                q.pop();
            }
            return q.top();
        }
    
        void clear(){
            while(q.size()) q.pop();
            while(rem.size()) rem.pop();
        }
    };
    
    vector<int> g[500005];
    int sub[500005];
    int head[500005];
    int par[500005];
    int tim = 0;
    vector<int> chain[500005];
    int weight[500005];
    
    void dfs1(int x){
        sub[x] = 1;
        for(int &i : g[x]){
            dfs1(i);
            sub[x] += sub[i];
            if(sub[i] > sub[g[x][0]]) swap(i, g[x][0]);
        }
    }
    
    int in[500005], out[500005];
    int dir[500005];
    
    void dfs2(int x, int p){
        chain[head[x]].pb(x);
        par[x] = p;
        weight[x] = 1;
        in[x] = tim++;
        for(int i : g[x]){
            head[i] = (i == g[x][0] ? head[x] : i);
            dfs2(i, x);
            if(i != g[x][0]) weight[x] += sub[i];
        }
        out[x] = tim - 1;
    }
    
    Matrix dp[500005]; 
    Matrix cum[500005];
    int rt[500005];
    int left0[500005], right0[500005], ppar[500005];
    
    int dnq(int l, int r, int p, const vector<int> &v){
        if(l > r) return 0;
        int sum = 0;
        for(int i = l; i <= r; i++) sum += weight[v[i]];
        int cur = 0;
        int mid = -1;
        for(int i = l; i <= r; i++){
            cur += weight[v[i]];
            if(cur >= sum/2){
                mid = i;
                break;
            }
        }
        if(p == -1) ppar[v[mid]] = v[mid];
        else ppar[v[mid]] = p;
        left0[v[mid]] = dnq(l, mid - 1, v[mid], v);
        right0[v[mid]] = dnq(mid + 1, r, v[mid], v);
        return v[mid];
    }
    
    void merge(int x){
        if(right0[x] && left0[x]){
            cum[x] = cum[left0[x]]*dp[x]*cum[right0[x]];
        } else if(left0[x] && !right0[x]){
            cum[x] = cum[left0[x]]*dp[x];
        } else if(right0[x] && !left0[x]){
            cum[x] = dp[x]*cum[right0[x]];
        } else {
            cum[x] = dp[x];
        }
    }
    
    void pull(int x){
        while(x != rt[x]){
            merge(x); 
            x = ppar[x];
        }
        merge(x);
    }
    
    ll a[500005], b[500005], c[500005];
    ll dp0[500005][3];
    
    void dfs3(int x){
        dp0[x][0] = a[x];
        dp0[x][2] = b[x] + c[x];
        ll deg1 = a[x] + c[x], deg2 = b[x] + a[x] + c[x];
        ll mn1 = LLINF, mn2 = LLINF;
        for(int i : g[x]){
            dfs3(i);
            dp0[x][0] += dp0[i][0];
            dp0[x][2] += dp0[i][2];
            deg1 += min(dp0[i][0], dp0[i][1]);
            deg2 += min({dp0[i][0], dp0[i][1], dp0[i][2]});
            mn1 = min(mn1, max((ll)0, dp0[i][1] - dp0[i][0]));
            mn2 = min(mn2, max((ll)0, min(dp0[i][1], dp0[i][2]) - dp0[i][0]));
        }
        dp0[x][1] = min(deg1 + mn1, deg2 + mn2);
    }
    
    fastset deg1[500005], deg2[500005];
    ll sum0[500005], sum2[500005], sum01[500005], sum012[500005];
    
    void rebuild(int x){
        dp[x][0][0] = a[x] + sum0[x];
        dp[x][0][1] = LLINF;
        dp[x][0][2] = LLINF;
        if(g[x].size()){
            dp[x][1][0] = min(a[x] + b[x] + c[x] + deg2[x].query() + sum012[x], a[x] + c[x] + deg1[x].query() + sum01[x]);
            dp[x][1][1] = min(a[x] + c[x] + sum01[x], a[x] + b[x] + c[x] + sum012[x]);
            dp[x][1][2] = a[x] + b[x] + c[x] + sum012[x];
        } else {
            dp[x][1][0] = dp[x][1][1] = dp[x][1][2] = LLINF;
        }
        dp[x][2][0] = LLINF;
        dp[x][2][1] = LLINF;
        dp[x][2][2] = b[x] + c[x] + sum2[x];
    }
    
    ll eval(int x, int ind){
        return min({cum[rt[x]][ind][0], cum[rt[x]][ind][1], cum[rt[x]][ind][2]});
    }
    
    void rem(int x){
        while(head[x] != 1){
            if(x == head[x]){
                ll v0 = eval(x, 0), v1 = eval(x, 1), v2 = eval(x, 2);
                deg1[par[x]].erase(max((ll)0, v1 - v0));
                deg2[par[x]].erase(max((ll)0, min(v1, v2) - v0));
                sum012[par[x]] -= min({v0, v1, v2});
                sum01[par[x]] -= min(v0, v1);
                sum0[par[x]] -= v0;
                sum2[par[x]] -= v2;
                x = par[x];
            }
            x = head[x];
        }
    }
    
    void add(int x){
        while(head[x] != 1){
            if(x == head[x]){
                ll v0 = eval(x, 0), v1 = eval(x, 1), v2 = eval(x, 2);
                deg1[par[x]].insert(max((ll)0, v1 - v0));
                deg2[par[x]].insert(max((ll)0, min(v1, v2) - v0));
                sum012[par[x]] += min({v0, v1, v2});
                sum01[par[x]] += min(v0, v1);
                sum0[par[x]] += v0;
                sum2[par[x]] += v2;
                rebuild(par[x]);
                pull(par[x]);
                x = par[x];
            }
            x = head[x];
        }
    }
    
    int main(){
        setIO();
        int t;
        cin >> t;
        while(t--){
            int n, q;
            cin >> n >> q;
            for(int i = 2; i <= n; i++){
                int x;
                cin >> x;
                g[x].pb(i);
            }
            ll sum = 0;
            for(int i = 1; i <= n; i++) cin >> b[i], sum += b[i];
            dfs1(1);
            head[1] = 1;
            dfs2(1, 1);
            dfs3(1);
            for(int i = 1; i <= n; i++){
                if(chain[i].size()){
                    int p = dnq(0, chain[i].size() - 1, -1, chain[i]);
                    for(int j : chain[i]) rt[j] = p;
                }
            }
            for(int i = 1; i <= n; i++){
                deg1[i].insert(LLINF);
                deg2[i].insert(LLINF);
                for(int j : g[i]){
                    if(head[j] == head[i]) continue;
                    deg1[i].insert(max((ll)0, dp0[j][1] - dp0[j][0]));
                    deg2[i].insert(max((ll)0, min(dp0[j][1], dp0[j][2]) - dp0[j][0]));
                    sum012[i] += min({dp0[j][0], dp0[j][1], dp0[j][2]});
                    sum01[i] += min(dp0[j][0], dp0[j][1]);
                    sum0[i] += dp0[j][0];
                    sum2[i] += dp0[j][2];
                }
                rebuild(i);
                pull(i);
            } 
            while(q--){
                int t, x, v;
                cin >> t >> x >> v;
                rem(x);
                if(t == 1) a[x] += v;
                else c[x] += v, sum += v;
                rebuild(x);
                pull(x);
                add(x);
                cout << (min({eval(1, 0), eval(1, 1), eval(1, 2)}) == sum ? "YES" : "NO") << "\n";
            }
            tim = 0;
            for(int i = 1; i <= n; i++){
                a[i] = b[i] = c[i] = 0;
                g[i].clear();
                chain[i].clear();
                deg1[i].clear();
                deg2[i].clear();
                sum0[i] = sum2[i] = sum01[i] = sum012[i] = 0;
            }
        }
    }
Solution 2
There also exists a solution without flows. Thanks to
rainboy
for discovering it during testing!
Lets greedily assign the growth events. We will always try to use the growth events to satisfy harvest events or required peaches in its subtree, and if there is any excess then we give it to the parent's required peaches. Similarly, we will always use harvest events on growth events in its subtree. Lets define a $$$dp[u]$$$ for each node $$$u$$$. If $$$dp[x] > 0$$$ then it means we can give $$$dp[u]$$$ growths to $$$u$$$'s parent. Otherwise, it means $$$dp[u]$$$ requires $$$-dp[u]$$$ growths from its ancestors. Let $$$pos_u$$$ denote the sum of positive $$$dp[v]$$$ where $$$v$$$ is a child a of $$$u$$$, and $$$neg_u$$$ denote the sum of negative $$$dp[v]$$$. First we used the excess growth to satisfy the required peaches, so we can set $$$b_u = \max(0, b_u - pos_u)$$$. Then we distribute the growth events at node $$$u$$$ to satisfy the requirements in the subtree. Define $$$a_i$$$ as the number of growth events on node $$$i$$$ and $$$c_i$$$ as the number of harvest events on node $$$i$$$. To account for the harvest events at node $$$i$$$, we can define $$$bal_u = \text{sum of } a_i \text{ in u's subtree} - \text{sum of } b_i \text{ in u's subtree} - \text{sum of } c_i \text{ in u's subtree}$$$. We know that $$$dp[u] \le bal_u$$$, and as it turns out, as long as we keep $$$bal_u$$$ as an upper bound on $$$dp[u]$$$, the harvest events will always be satisfied. Why? $$$a_u + neg_u - \max(0, b_u - pos_u)$$$ is the assignment of growth events without considering harvest events. The amount of unused growth events in the subtree of $$$u$$$ is given by $$$bal_u - (a_u + neg_u - \max(0, b_u - pos_u)) + c_u$$$. If $$$a_u + neg_u - \max(0, b_u - pos_u) \le bal_u$$$, then it means we can use all of our harvest events on unused growth events in the subtree. If $$$a_u + neg_u - \max(0, b_u - pos_u) > bal_u$$$, then it means we will use all of our harvest events but still have $$$bal_u - (a_u + neg_u - \max(0, b_u - pos_u))$$$ harvest events remaining. Thus, we can formulate our dp as $$$dp[u] = \min(a_u + neg_u - \max(0, b_u - pos_u), bal_u)$$$. Let $$$v$$$ be the heavy child of $$$u$$$ and $$$pos'_u$$$ be the sum of positive dp excluding $$$v$$$ and $$$neg'_u$$$ be the sum of positive dp excluding $$$v$$$. Then, we can rewrite our dp as $$$dp[u] = \min(dp[v] + a_u + neg'_u - \max(0, b_u - pos'_u), a_u + neg'_u, bal_u)$$$. Define $$$x_u = a_u + neg'_u - \max(0, b_u - pos'_u)$$$ and $$$y_u = a_u + neg'_u$$$. Then $$$dp[u] = \min(dp[v] + x_u, y_u, bal_u)$$$. This can be accelerated by representing the transition as a matrix and accelerating it using dynamic dp. However, we can also notice that the dp can be represented as the smallest $$$x_1 + x_2 + \ldots + x_{i - 1} + \min(y_i, bal_i)$$$ over all prefixes of each heavy light decomposition chain. Thus, we can maintain the dp by using a range add and prefix min segment tree.
Code (C++)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N	300000
#define N_	(1 << 19)	/* N_ = pow2(ceil(log2(N))) */
#define INF	0x3f3f3f3f3f3f3f3fLL

long long min(long long a, long long b) { return a < b ? a : b; }
long long max(long long a, long long b) { return a > b ? a : b; }

int *ej[N], eo[N], n;

void append(int i, int j) {
	int o = eo[i]++;

	if (o >= 2 && (o & o - 1) == 0)
		ej[i] = (int *) realloc(ej[i], o * 2 * sizeof *ej[i]);
	ej[i][o] = j;
}

int dd[N], pp[N], qq[N], jj[N], ta[N], tb[N], qu[N];
int bb[N]; long long aa[N], zz[N], zzp[N], zzn[N];

int dfs1(int i, int d) {
	int o, s, k_, j_;

	dd[i] = d;
	s = 1, k_ = 0, j_ = -1;
	zz[i] = -bb[i];
	for (o = eo[i]; o--; ) {
		int j = ej[i][o], k = dfs1(j, d + 1);

		s += k;
		if (k_ < k)
			k_ = k, j_ = j;
		zz[i] += zz[j];
	}
	qq[i] = j_, jj[i] = j_ == -1 ? i : jj[j_];
	return s;
}

int t_;

void dfs2(int i, int q) {
	int o, j_;

	qu[ta[i] = t_++] = i;
	j_ = qq[i], qq[i] = q;
	if (j_ != -1)
		dfs2(j_, q);
	for (o = eo[i]; o--; ) {
		int j = ej[i][o];

		if (j != j_)
			dfs2(j, j);
	}
	tb[i] = t_;
}

long long stx[N_ * 2], sty[N_ * 2], stz[N_ * 2], lz[N_]; int h_, n_;

void put(int i, long long x) {
	stz[i] += x;
	if (i < n_)
		lz[i] += x;
}

void pus(int i) {
	if (lz[i])
		put(i << 1 | 0, lz[i]), put(i << 1 | 1, lz[i]), lz[i] = 0;
}

void pul(int i) {
	if (!lz[i]) {
		int l = i << 1, r = l | 1;

		stx[i] = stx[l] + stx[r];
		sty[i] = min(sty[l], stx[l] + sty[r]);
		stz[i] = min(stz[l], stx[l] + stz[r]);
	}
}

void push(int i) {
	int h;

	for (h = h_; h > 0; h--)
		pus(i >> h);
}

void pull(int i) {
	while (i > 1)
		pul(i >>= 1);
}

void build() {
	int i, j, a, o;
        h_ = 0;

	while (1 << h_ < n)
		h_++;
	n_ = 1 << h_;
	memset(stx, 0, n_ * 2 * sizeof *stx);
	memset(sty, 0, n_ * 2 * sizeof *sty);
	memset(stz, 0, n_ * 2 * sizeof *stz);
	memset(lz, 0, n_ * sizeof *lz);
	memset(aa, 0, n * sizeof *aa);
	memset(zzp, 0, n * sizeof *zzp);
	memset(zzn, 0, n * sizeof *zzn);
	for (i = 0; i < n; i++) {
		a = ta[i];
		stz[n_ + a] = zz[i];
		for (o = eo[i]; o--; ) {
			j = ej[i][o];
			if (qq[j] == j)
				zzn[i] += -zz[j];
		}
		stx[n_ + a] = -zzn[i] - bb[i];
		sty[n_ + a] = -zzn[i];
	}
	for (i = n_ - 1; i > 0; i--)
		pul(i);
}

void upd(int i) {
	int i_ = n_ + ta[i];

	push(i_);
	stx[i_] = aa[i] - zzn[i] - max(bb[i] - zzp[i], 0);
	sty[i_] = aa[i] - zzn[i];
	pull(i_);
}

void update_z(int l, int r, long long x) {
	int l_ = l += n_, r_ = r += n_;

	push(l_), push(r_);
	for ( ; l <= r; l >>= 1, r >>= 1) {
		if ((l & 1) == 1)
			put(l++, x);
		if ((r & 1) == 0)
			put(r--, x);
	}
	pull(l_), pull(r_);
}

long long query(int l, int r) {
	long long xl, yl, zl, xr, yr, zr;

	push(l += n_), push(r += n_);
	xl = 0, yl = INF, zl = INF, xr = 0, yr = INF, zr = INF;
	for ( ; l <= r; l >>= 1, r >>= 1) {
		if ((l & 1) == 1) {
			yl = min(yl, xl + sty[l]), zl = min(zl, xl + stz[l]), xl += stx[l];
			l++;
		}
		if ((r & 1) == 0) {
			yr = min(sty[r], yr == INF ? INF : stx[r] + yr), zr = min(stz[r], zr == INF ? INF : stx[r] + zr), xr += stx[r];
			r--;
		}
	}
	return min(min(xl + xr, min(yl, yr == INF ? INF : xl + yr)), min(zl, zr == INF ? INF : xl + zr));
}

int main() {
	int t;

	scanf("%d", &t);
	while (t--) {
		int q_, i, p, q;

		scanf("%d%d", &n, &q_);
		for (i = 0; i < n; i++)
			ej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;
		pp[0] = -1;
		for (i = 1; i < n; i++) {
			scanf("%d", &pp[i]), pp[i]--;
			append(pp[i], i);
		}
		for (i = 0; i < n; i++)
			scanf("%d", &bb[i]);
		dfs1(0, 0);
		t_ = 0, dfs2(0, 0);
		build();
		while (q_--) {
			int t, x;

			scanf("%d%d%d", &t, &i, &x), i--;
			if (t == 2)
				x = -x;
			if (t == 1)
				aa[i] += x, upd(i);
			while (i >= 0) {
				q = qq[i], p = pp[q];
				if (p >= 0) {
					if (zz[q] > 0)
						zzp[p] -= zz[q];
					else
						zzn[p] -= -zz[q];
				}
				update_z(ta[q], ta[i], x);
				zz[q] = query(ta[q], ta[jj[q]]);
				if (p >= 0) {
					if (zz[q] > 0)
						zzp[p] += zz[q];
					else
						zzn[p] += -zz[q];
					upd(p);
				}
				i = p;
			}
			printf(zz[0] >= 0 ? "YES\n" : "NO\n");
		}
		for (i = 0; i < n; i++)
			free(ej[i]);
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1942G
Editorial Content:
1942G - Bessie and Cards
Hint 1
"Draw $$$1$$$" cards do not matter because we can immediately play them when we draw them.
Hint 2
Treat "draw $$$2$$$" as $$$+1$$$ and "draw $$$0$$$" as $$$-1$$$. We start with a balance of $$$+5$$$. We draw all the cards up to the first prefix where the balance dips to $$$0$$$. We are interested in the number of ways where the special cards lie in this prefix.
Solution
Read the hints.
Treat the special cards as "draw $$$0$$$" cards and multiply by the appropriate binomial coefficient at the end. Also treat cards of the same type as indistinguishable and multiply by the appropriate factorials at the end.
Enumerate the length of the prefix where the balance first hits $$$0$$$. This dictates how many $$$+1$$$ and $$$-1$$$ we have. Now we want to count the number of ways of arranging $$$+1$$$ and $$$-1$$$ such that the balance never dips to $$$0$$$, assuming we start with $$$+5$$$.
To solve this subproblem, we can draw inspiration from the
path counting interpretation
for counting balanced bracket sequences. We have $$$n$$$ open and $$$n$$$ close brackets and want to count the number of balanced bracket sequences starting with
((((
(note that there are only $$$4$$$ instead of $$$5$$$ open brackets to shift from all balances being strictly positive to all balances being non-negative). The number of sequences ignoring the balance constraint is $$$\binom{2n-4}{n}$$$. Any bracket sequence where some balance dips negative corresponds to a path that walks above the line $$$y = x$$$. For those paths, we reflect over the line $$$y = x + 1$$$ at the first point where it steps over the line. So there is a bijection between these paths and paths that reach the point $$$(n-1,n+1)$$$, of which there are $$$\binom{2n-4}{n+1}$$$. So the total number of ways is $$$\binom{2n-4}{n} - \binom{2n-4}{n+1}$$$.
Our final answer is summing up the number of ways over all prefix lengths. Make sure to handle the case where you draw the entire deck correctly. The complexity is $$$\mathcal O(\min(a,c))$$$.
Code (C++)
--------------------------------------------------
Problem ID: 1942F
Editorial Content:
1942F - Farmer John's Favorite Function
Hint 1
Consider the case where all $$$f(i)$$$ are integers. Decreasing
any
$$$a_i$$$ will decrease $$$\lfloor f(n) \rfloor$$$. So solutions that iterate over the last few elements will not work.
Hint 2
If $$$n \ge 6$$$, changing $$$a_1$$$ will only affect $$$\lfloor f(n) \rfloor$$$ by at most $$$1$$$.
Hint 3
We can take the floor each time we square root. Specifically, we can define $$$f$$$ as:
$$$f(1) = \lfloor \sqrt{a_1} \rfloor$$$
For all $$$i > 1$$$, $$$f(i) = \lfloor \sqrt{f(i-1)+a_i} \rfloor$$$
This allows us to work with integers.
Hint 4
We can divide our array into blocks of size $$$b \ge 6$$$ (note that the value of $$$b$$$ depends on the solution). How can we use hint $$$2$$$? What should we store for each block?
Solution
Let's first look at the impact of earlier numbers on the final result. Earlier numbers can still influence $$$\lfloor f(n) \rfloor$$$ when $$$n$$$ is large. Suppose that all $$$f(i)$$$ are integers. Then decreasing
any
$$$a_i$$$ will decrease $$$\lfloor f(n) \rfloor$$$.
However, it is clear that the impact of earlier number on $$$\lfloor f(n) \rfloor$$$ is still extremely small. A key observation is that when $$$n \ge 6$$$, changing $$$a_1$$$ will only affect $$$\lfloor f(n) \rfloor$$$ by at most $$$1$$$.
Another observation is that we can take the floor each time we square root. Specifically, we can define $$$f$$$ as:
$$$f(1) = \lfloor \sqrt{a_1} \rfloor$$$
For all $$$i > 1$$$, $$$f(i) = \lfloor \sqrt{f(i-1)+a_i} \rfloor$$$
This allows us to work with integers. From here on, we work with this new definition of $$$f$$$.
Let's divide our array into blocks of size $$$b=6$$$. We can append zeroes to the front of the array to make $$$n$$$ a multiple of $$$b$$$.
Consider some block representing range $$$[l,r]$$$. Let's consider the subarray $$$a_l,a_{l+1},\ldots ,a_r$$$. Let $$$v$$$ be the value of $$$f(r)$$$ if we let $$$f(l - 1)=0$$$. Using our first observation, we know that $$$f(r)$$$ will be either $$$v$$$ or $$$v+1$$$ depending on $$$f(l - 1)$$$. So let's find the smallest value $$$c$$$ such that if $$$f(l - 1)=c$$$, then $$$f(r)=v+1$$$. This can be done by iterating over the elements of the block backwards.
For each block, we store its corresponding ($$$v,c$$$). We can build a segment tree over the blocks for an $$$\mathcal{O}((n + q) \log n)$$$ solution.
Alternatively, we can do square root decomposition by having $$$b=\sqrt n$$$ which leads to an $$$\mathcal{O}(n + q \sqrt n)$$$ solution (in practice, we should set $$$b$$$ to something small like $$$100$$$).
Code (C++)
Segment Tree
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define pll pair<ll, ll>

const int B = 6, MAX = 2e5 + B + 5;

int n, q, offset, numBlocks; ll A[MAX]; pll seg[MAX];

pll comb(pll a, pll b){
    auto [vl, cl] = a;
    auto [vr, cr] = b;

    // Not defined
    if (vl == -1)
        return b;
    if (vr == -1)
        return a;

    // Doesn't cross cutoff
    if (vl < cr - 1)
        return {vr, (ll)2e18};
    if (vl >= cr)
        return {vr + 1, (ll)2e18};
    
    // If vl == cr - 1
    return {vr, cl};
}
void updSeg(int i, pll v){
    seg[i += numBlocks] = v;

    for (i /= 2; i > 0; i /= 2) 
        seg[i] = comb(seg[i * 2], seg[i * 2 + 1]);
}
ll qry(int l = 0, int r = numBlocks - 1){ 
    pll retL = {-1, -1};
    pll retR = {-1, -1};

    for (l += numBlocks, r += numBlocks; l <= r; r /= 2, l /= 2){
        if (l % 2 == 1) 
            retL = comb(retL, seg[l++]);
        if (r % 2 == 0) 
            retR = comb(seg[r--], retR);
    }
    return comb(retL, retR).first;
}
void updBlock(int blk){
    int l = blk * B;
    int r = l + B - 1;

    ll val = 0;
    for (int i = l; i <= r; i++)
        val = floor(sqrtl((long double)val + A[i]));
    
    ll req = val + 1;
    for (int i = r; i >= l; i--){
        if (req > 2e9){
            updSeg(blk, {val, (ll)2e18});
            return;
        }
        req = req * req - A[i];
    }
    updSeg(blk, {val, req});
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    cin >> n >> q;

    offset = (B - n % B) % B;
    n += offset;
    numBlocks = n / B;

    for (int i = offset; i < n; i++)
        cin >> A[i];
    
    for (int b = 0; b < numBlocks; b++)
        updBlock(b);

    while (q--){
        ll k, x;
        cin >> k >> x;
        k--; 
        k += offset;

        A[k] = x;
        updBlock(k / B);

        cout << qry() << "\n";
    }
}
Square Root Decomposition
#include <bits/stdc++.h>
using namespace std;

#define ll long long

const int B = 100, MAX = 2e5 + B + 5;

int n, q, offset, numBlocks; ll A[MAX], val[MAX], cut[MAX];

void buildBlock(int blk){
    int l = blk * B;
    int r = l + B - 1;

    ll cur = 0;

    for (int i = l; i <= r; i++)
        cur = floor(sqrtl((long double)cur + A[i]));
    
    val[blk] = cur;

    ll req = cur + 1;

    for (int i = r; i >= l; i--){
        if (req > 2e9){
            cut[blk] = 2e18;
            return;
        }
        req = req * req - A[i];
    }
    cut[blk] = req;
}
ll qry(){
    ll cur = 0;

    for (int b = 0; b < numBlocks; b++)
        cur = (cur >= cut[b]) ? val[b] + 1 : val[b];
    
    return cur;
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    cin >> n >> q;

    offset = (B - n % B) % B;
    n += offset;
    numBlocks = n / B;

    for (int i = offset; i < n; i++)
        cin >> A[i];
    
    for (int b = 0; b < numBlocks; b++)
        buildBlock(b);

    while (q--){
        ll k, x;
        cin >> k >> x;
        k--; 
        k += offset;

        A[k] = x;
        buildBlock(k / B);

        cout << qry() << "\n";
    }
}
Segment Tree
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define pll pair<ll, ll>

const int B = 6, MAX = 2e5 + B + 5;

int n, q, offset, numBlocks; ll A[MAX]; pll seg[MAX];

pll comb(pll a, pll b){
    auto [vl, cl] = a;
    auto [vr, cr] = b;

    // Not defined
    if (vl == -1)
        return b;
    if (vr == -1)
        return a;

    // Doesn't cross cutoff
    if (vl < cr - 1)
        return {vr, (ll)2e18};
    if (vl >= cr)
        return {vr + 1, (ll)2e18};
    
    // If vl == cr - 1
    return {vr, cl};
}
void updSeg(int i, pll v){
    seg[i += numBlocks] = v;

    for (i /= 2; i > 0; i /= 2) 
        seg[i] = comb(seg[i * 2], seg[i * 2 + 1]);
}
ll qry(int l = 0, int r = numBlocks - 1){ 
    pll retL = {-1, -1};
    pll retR = {-1, -1};

    for (l += numBlocks, r += numBlocks; l <= r; r /= 2, l /= 2){
        if (l % 2 == 1) 
            retL = comb(retL, seg[l++]);
        if (r % 2 == 0) 
            retR = comb(seg[r--], retR);
    }
    return comb(retL, retR).first;
}
void updBlock(int blk){
    int l = blk * B;
    int r = l + B - 1;

    ll val = 0;
    for (int i = l; i <= r; i++)
        val = floor(sqrtl((long double)val + A[i]));
    
    ll req = val + 1;
    for (int i = r; i >= l; i--){
        if (req > 2e9){
            updSeg(blk, {val, (ll)2e18});
            return;
        }
        req = req * req - A[i];
    }
    updSeg(blk, {val, req});
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    cin >> n >> q;

    offset = (B - n % B) % B;
    n += offset;
    numBlocks = n / B;

    for (int i = offset; i < n; i++)
        cin >> A[i];
    
    for (int b = 0; b < numBlocks; b++)
        updBlock(b);

    while (q--){
        ll k, x;
        cin >> k >> x;
        k--; 
        k += offset;

        A[k] = x;
        updBlock(k / B);

        cout << qry() << "\n";
    }
}
Square Root Decomposition
#include <bits/stdc++.h>
using namespace std;

#define ll long long

const int B = 100, MAX = 2e5 + B + 5;

int n, q, offset, numBlocks; ll A[MAX], val[MAX], cut[MAX];

void buildBlock(int blk){
    int l = blk * B;
    int r = l + B - 1;

    ll cur = 0;

    for (int i = l; i <= r; i++)
        cur = floor(sqrtl((long double)cur + A[i]));
    
    val[blk] = cur;

    ll req = cur + 1;

    for (int i = r; i >= l; i--){
        if (req > 2e9){
            cut[blk] = 2e18;
            return;
        }
        req = req * req - A[i];
    }
    cut[blk] = req;
}
ll qry(){
    ll cur = 0;

    for (int b = 0; b < numBlocks; b++)
        cur = (cur >= cut[b]) ? val[b] + 1 : val[b];
    
    return cur;
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    cin >> n >> q;

    offset = (B - n % B) % B;
    n += offset;
    numBlocks = n / B;

    for (int i = offset; i < n; i++)
        cin >> A[i];
    
    for (int b = 0; b < numBlocks; b++)
        buildBlock(b);

    while (q--){
        ll k, x;
        cin >> k >> x;
        k--; 
        k += offset;

        A[k] = x;
        buildBlock(k / B);

        cout << qry() << "\n";
    }
}
--------------------------------------------------
Problem ID: 1942E
Editorial Content:
1942E - Farm Game
Hint 1
Think about the gaps between $$$(a_1,b_1), (a_2,b_2), ... ,(a_n,b_n)$$$. Let the gaps be $$$g_1,g_2,...,g_n$$$. What effect do the moves have on the gaps?
Hint 2
WLOG let the first cow be FJ's cow. FN wins if all $$$g_i$$$ are even. Otherwise FJ wins. Note that the game will always end.
Hint 3
Try to count the number of ways FN wins. We can iterate over the sum of $$$g_i$$$ and use stars and bars as well as other counting techniques.
Solution
Consider the gaps between $$$(a_1,b_1), (a_2,b_2), ... ,(a_n,b_n)$$$. In the example below, '$$$\texttt{a}$$$' represents FJ's cow, '$$$\texttt{b}$$$' represents FN's cow, and '$$$\texttt{.}$$$' represents an empty space. The gaps are $$$[2,3]$$$.
$$$\texttt{|.a..b....a...b.|}$$$
Consider the gaps $$$g_1,g_2,...,g_n$$$. When a farmer moves, they choose some non-empty subset of non-zero $$$g_i$$$ and add or subtract $$$1$$$ from every element in the subset (so long such move is possible). The game ends when some farmer cannot move (which implies that all $$$g_i$$$ must be $$$0$$$ when the game ends).
WLOG let the first cow be FJ's cow. The winner of the game is determined as follows:
1) If all $$$g_i$$$ are even, then FN wins. If FJ pushes the cows corresponding to gaps $$$i_1, i_2, \ldots, i_k$$$ some direction in a move, then $$$g_{i_1}, g_{i_2}, \ldots g_{i_k}$$$ will change by $$$1$$$ and become odd. FN can then push the cows corresponding to gaps $$$i_1, i_2, \ldots, i_k$$$
left
so that $$$g_{i_1}, g_{i_2}, \ldots g_{i_k}$$$ will become even again. Therefore, all $$$g_i$$$ will be even when it's FJ's turn and at least one $$$g_i$$$ will be odd when it's FN's turn. Since the game ends when all $$$g_i$$$ are $$$0$$$ (which is even), then FJ will lose.
Note that the game will always end.
This is since the sum of positions of FN's cows will always be decreasing since FN will always push some cow left.
2) Otherwise, FJ wins since he can subtract $$$1$$$ to all odd $$$g_i$$$ in his first move to make all elements even. Then it's FN's turn and all $$$g_i$$$ are even so by the reasoning above, FJ wins.
Let's use complementary counting and determine the number of ways
FN
wins (which is when all $$$g_i$$$ are even). We can iterate over the sum, $$$s$$$ ($$$s$$$ is even), of all $$$g_i$$$. At each $$$s$$$, we can use stars and bars to find how many such $$$g_1,g_2,...,g_n$$$ (all $$$g_i$$$ are even) sum to $$$s$$$. Specifically, the number of ways are $$$\frac{s}{2} + n - 1 \choose n - 1$$$. The number of ways to place the cows in the available positions given the gaps will be $$$2 \cdot {l - s - n \choose n}$$$. We multiply by $$$2$$$ since we can alternate starting with either FJ's cow or FN's cow.
Finally, we subtract this result from the total number of configurations, $$$2 \cdot {l \choose 2 \cdot n}$$$, to get the number of ways FJ wins. This runs in $$$\mathcal{O}(l)$$$ time.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

#define ll long long

const int MAX = 2e6 + 5, MOD = 998244353;

ll fact[MAX], ifact[MAX];

ll bpow(ll a, int p){
    ll ans = 1;

    for (;p; p /= 2, a = (a * a) % MOD) 
        if (p & 1) 
            ans = (ans * a) % MOD;

    return ans;
}
ll ncr(int n, int r){
    if (n < 0)
        return 0;
    if (r > n)
        return 0;

    return fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;
}
void solve(){
    int l, n;
    cin >> l >> n;
 
    ll all_even = 0;
 
    for (int s = 0; s <= l; s += 2){
        all_even += 2 * ncr(s / 2 + n - 1, n - 1) % MOD * ncr(l - s - n, n) % MOD;
        all_even %= MOD;
    }
    cout << (2 * ncr(l, 2 * n) % MOD - all_even + MOD) % MOD << "\n";
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0);
    
    for (int i = 0; i < MAX; i++)
        fact[i] = !i ? 1 : fact[i - 1] * i % MOD;
    
    for (int i = MAX - 1; i >= 0; i--)
        ifact[i] = (i == MAX - 1) ? bpow(fact[MAX - 1], MOD - 2) : ifact[i + 1] * (i + 1) % MOD;

    int tc;
    cin >> tc;

    while (tc--)
        solve();
}
--------------------------------------------------
Problem ID: 1942D
Editorial Content:
1942D - Learning to Paint
Hint 1
We can solve this with dynamic programming. Let $$$\texttt{dp}[i]$$$ store a list of all $$$\min(k, 2^i)$$$ highest beauties of a painting in
non-increasing
order if you only paint cells $$$1,2,\ldots ,i$$$.
Hint 2
Transitioning boils down to finding the $$$k$$$ largest elements from $$$n$$$
non-increasing
lists. Try to do this in $$$\mathcal{O}((n + k) \log n)$$$ time.
Solution
Let $$$\texttt{dp}[i]$$$ store a list of all $$$\min(k, 2^i)$$$ highest beauties of a painting in
non-increasing
order if you only paint cells $$$1,2,\ldots ,i$$$.
Let's define
merging
two lists as creating a new list that stores the $$$k$$$ highest values from the two lists.
First, let's look at a slow method of transitioning. We iterate over the left endpoint $$$l$$$ such that $$$l \ldots i$$$ is a maximal painted interval. At each $$$l$$$, we merge $$$\texttt{dp}[l - 2]$$$, with $$$a_{l,i}$$$ added to each value, into $$$\texttt{dp}[i]$$$. We also merge $$$\texttt{dp}[i - 1]$$$ into $$$\texttt{dp}[i]$$$ to handle the case in which we do not paint cell $$$i$$$. If implemented well, transitioning takes $$$\mathcal{O}(nk)$$$ time leading to an $$$\mathcal{O}(n^2k)$$$ solution which is too slow.
We can speed this up. This merging process boils down to finding the $$$k$$$ largest elements from $$$n$$$
non-increasing
lists in $$$\mathcal{O}((n + k) \log n)$$$ time. We can use a priority queue that stores ($$$\texttt{element}, \texttt{index}$$$) for each list. We can do the following $$$k$$$ times: add the top of the priority queue to our answer, advance its index, and update the priority queue accordingly. This allows us to transition in $$$\mathcal{O}((n + k) \log n)$$$ time which leads to an $$$\mathcal{O}((n^2 + nk) \log n)$$$ solution.
Bonus: find an $$$\mathcal{O}(n^2 + k)$$$ solution.
Code (C++)
#include <bits/stdc++.h>
using namespace std;
 
void solve(){
    int n, k;
    cin >> n >> k;
 
    int A[n + 1][n + 1];
 
    for (int i = 1; i <= n; i++)
        for (int j = i; j <= n; j++)
            cin >> A[i][j];
    
    // dp[i] = Answer if we consider 1...i
    vector<int> dp[n + 1];
    dp[0] = {0};
 
    for (int i = 1; i <= n; i++){
        priority_queue<array<int, 3>> pq;
 
        // Don't create an interval
        pq.push({dp[i - 1][0], i - 1, 0});
 
        // Create interval j+2...i (transition from j)
        for (int j = i - 2; j >= -1; j--){
            pq.push({(j < 0 ? 0 : dp[j][0]) + A[j + 2][i], j, 0});
        }
 
        while (pq.size() and dp[i].size() < k){
            auto [val, j, num] = pq.top(); pq.pop();
            dp[i].push_back(val);
            
            if (j < 0 or num + 1 >= dp[j].size())
                continue;
            
            // Don't create interval
            if (j == i - 1)
                pq.push({dp[i - 1][num + 1], i - 1, num + 1});
            
            // Create interval j+2...i (transition from j)
            else 
                pq.push({dp[j][num + 1] + A[j + 2][i], j, num + 1});
        }
    }
    for (int i : dp[n])
        cout << i << " ";
    cout << "\n";
}
 
int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    int tc; 
    cin >> tc;
 
    while (tc--) 
        solve();
}
--------------------------------------------------
Problem ID: 1942C2
Editorial Content:
1942C2 - Bessie's Birthday Cake (Hard Version)
Solution (Easy Version)
Ignoring $$$n$$$ for now, let's just focus on the $$$x$$$ chosen vertices. Sort the $$$x$$$ vertices and connect adjacent vertices to form its own smaller polygon. By drawing out some cases or if you're familiar with triangulation (
video that proves by induction
), you can form $$$x - 2$$$ triangles by drawing diagonals in a polygon with $$$x$$$ vertices. If you don't know it, one possible construction that always work is fixing one vertex $$$v$$$ and drawing diagonals to every other vertex not adjacent to $$$v$$$. Now, let's consider the original $$$n$$$-sided polygon. In additional to the aforementioned construction, to close the $$$x$$$-sided polygon up: for every non-adjacent vertex in the chosen vertices based on the bigger $$$n$$$-sided polygon, draw a diagonal between them. Through this construction, we can always guarantee $$$x - 2$$$ triangles.
However, this doesn't account for all triangles, as some triangles can form sides with the bigger $$$n$$$-sided polygon. These triangles occur exactly when two adjacent vertex in $$$x$$$ have exactly one vertex not in $$$x$$$ between them but part of the bigger polygon. This is because one side is from the diagonals we drew, and the other two sides form from the $$$n$$$-sided polygon.
Therefore, the answer is $$$x - 2$$$ + (number of adjacent chosen vertices $$$2$$$ apart). Note that the first chosen vertex is also adjacent to last chosen vertex in $$$x$$$.
Solution (Hard Version)
Read the solution to the easy version first.
We can now reduce the problem to the following: For every vertex we choose, we can make one more triangle. For every chosen vertices two apart, we can make one more triangle. Let's focus on the latter condition. To maximize the effect of our $$$y$$$ vertices, we want to prioritize vertices $$$v$$$ that satisfy the following: the vertex is not included in $$$x$$$ and there is a chosen vertex two apart. Let's denote such $$$v$$$ as good.
Let vertex $$$a$$$ and $$$b$$$ $$$(a < b)$$$ be adjacent chosen vertices in the $$$x$$$-sided polygon. There are $$$g = b - a - 1$$$ vertices for us to choose between them. There are two cases: if $$$g$$$ is odd, then we can choose $$$\lfloor \frac{g}{2} \rfloor$$$ vertices to form $$$\lfloor \frac{g}{2}\rfloor + 1$$$ extra triangles. This is because all of the vertices we choose will be good. if $$$g$$$ is even, then we can choose $$$\frac{g}{2}$$$ vertices to make $$$\frac{g}{2}$$$ extra triangles. This is because one of the vertices we choose will not be good. This shows that it is always optimal to process smaller and odd $$$g$$$ first.
After processing these adjacent gaps, if we have any leftover vertices, we can just ignore them. This is because since we have maximized the number of good vertices, even though any further vertex we place will increase the answer by $$$1$$$, it will break two good vertices which will decrease the answer by $$$1$$$.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

void solve(){
	int n, x, y; cin >> n >> x >> y;
	int initial_y = y;
	vector<int> chosen(x);
	for(int& i: chosen) cin >> i;
	sort(chosen.begin(), chosen.end());
	int ans = x - 2;
	int triangles_from_even_g = 0;
	vector<int> odd_g;
	auto process_gap = [&](int g) -> void{
		if(g <= 1){
			// already two apart
			ans += g;
		}
		else if(g % 2 == 1){
			odd_g.push_back(g / 2);
		}
		else{
			triangles_from_even_g += g / 2;
		}
	};
	for(int i = 0; i < x - 1; i++){
		process_gap(chosen[i + 1] - chosen[i] - 1);
	}
	process_gap((chosen[0] + n) - chosen[x - 1] - 1);
	sort(odd_g.begin(), odd_g.end());
	for(int g: odd_g){
		if(y >= g){
			// all vertices are good, so we can make g + 1 triangles
			ans += g + 1;
			y -= g;
		}
		else{
			ans += y;
			y = 0;
			break;
		}
	}
	int even_triangles = min(triangles_from_even_g, y);
	y -= even_triangles;
	ans += even_triangles;
	int used_vertices = initial_y - y;
	ans += used_vertices;
	cout << ans << "\n";
}

int main(){
	cin.tie(0) -> sync_with_stdio(0);
	int T = 1;
	cin >> T;
	while(T--) solve();
}

/*   /\_/\
*   (= ._.)
*   / >  \>
*/
--------------------------------------------------
Problem ID: 1942C1
Editorial Content:
1942C1 - Bessie's Birthday Cake (Easy Version)
--------------------------------------------------
Problem ID: 1942B
Editorial Content:
1942B - Bessie and MEX
Hint 1
We will construct the solution forward.
Hint 2
Separate the $$$a_i$$$'s given into negative and positive cases. What does this tell us about the $$$\texttt{MEX}$$$?
Solution
We can find $$$p_1, p_2, ... , p_n$$$ in order, looking at positive and negative cases. Note that $$$a_i \neq 0$$$ because $$$p_i$$$ would equal $$$\texttt{MEX}$$$($$$p_1 \dots p_i$$$), which can never happen.
If $$$a_i > 0$$$, then $$$\texttt{MEX}$$$($$$p_1, p_2, ... p_i$$$) must increase from $$$\texttt{MEX}$$$($$$p_1, p_2, ... p_{i-1}$$$), so we know $$$p_i$$$ must equal $$$\texttt{MEX}$$$($$$p_1, p_2, ... p_{i-1}$$$).
Otherwise, the $$$\texttt{MEX}$$$ stays the same, so $$$p_i$$$ is just simply $$$\texttt{MEX}$$$($$$p_1, p_2, ... p_{i-1}$$$) — $$$a_i$$$.
Thus, we can just maintain the $$$\texttt{MEX}$$$ and find each $$$p_i$$$ as we go forward.
Here's more justification about specific differences leading to specific MEX changes
There are only 2 things the $$$\texttt{MEX}$$$ can do: increase or stay the same (it can never decrease since larger prefixes contain smaller ones).
In the case of a positive difference, consider what would happen if the $$$\texttt{MEX}$$$ stayed the same. Since the difference is positive, the $$$\texttt{MEX}$$$ would have to be greater than the current value, which is impossible because that value had to appear earlier on in the prefix. Since the $$$\texttt{MEX}$$$ is calculated on a permutation that can’t happen. So the $$$\texttt{MEX}$$$ has to increase.
In the case of a negative value, the $$$\texttt{MEX}$$$ has to be less than the current value. But if it increased that means the current value changed its the $$$\texttt{MEX}$$$, meaning its the $$$\texttt{MEX}$$$ is now at least (current value + 1) and it is actually greater. So it has to stay the same.
Note that this is also a way to show $$$p$$$ is always unique.
Here's more justification about specific differences leading to specific MEX changes
There are only 2 things the $$$\texttt{MEX}$$$ can do: increase or stay the same (it can never decrease since larger prefixes contain smaller ones).
In the case of a positive difference, consider what would happen if the $$$\texttt{MEX}$$$ stayed the same. Since the difference is positive, the $$$\texttt{MEX}$$$ would have to be greater than the current value, which is impossible because that value had to appear earlier on in the prefix. Since the $$$\texttt{MEX}$$$ is calculated on a permutation that can’t happen. So the $$$\texttt{MEX}$$$ has to increase.
In the case of a negative value, the $$$\texttt{MEX}$$$ has to be less than the current value. But if it increased that means the current value changed its the $$$\texttt{MEX}$$$, meaning its the $$$\texttt{MEX}$$$ is now at least (current value + 1) and it is actually greater. So it has to stay the same.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

void solve(){
	int n; cin >> n;
	vector<int> a(n);
	for(int& i: a) cin >> i;
	vector<int> p(n), has(n + 1);
	int mex = 0;
	for(int i = 0; i < n; i++){
		if(a[i] >= 0){
			p[i] = mex;
		}
		else{
			p[i] = mex - a[i];
		}
		has[p[i]] = true;
		while(has[mex]) mex++;
	}
	for(int i: p) cout << i << " ";
	cout << "\n";
}

int main(){
	cin.tie(0) -> sync_with_stdio(0);
	int T = 1;
	cin >> T;
	while(T--) solve();
}

/*   /\_/\
*   (= ._.)
*   / >  \>
*/
Hint 1
We will construct the solution backwards.
Hint 2
The $$$\texttt{MEX}$$$ is determined at the last index, since all of $$$0, 1 \dots n-1$$$ appear in $$$p$$$.
Solution
Read the hints.
Since we know the $$$\texttt{MEX}$$$ of the last position is $$$n$$$, then $$$n - p_n = a_n$$$. From this equation, we can find that $$$p_n = n - a_n$$$.
Now, because we know $$$p_n$$$, we can determine the $$$\texttt{MEX}$$$ of the first $$$n-1$$$ numbers. Like how we found $$$p_n$$$, we can do a similar process for finding $$$p_{n-1}$$$. Doing this for $$$i = n, n - 1 \dots 1$$$ will get us a valid answer $$$p$$$.
Note that this is also a way to show $$$p$$$ is always unique.
--------------------------------------------------
Problem ID: 1942A
Editorial Content:
1942A - Farmer John's Challenge
Hint 1
Solve for $$$k = 1$$$.
Answer
$$$a = 1, 2, 3 \dots n$$$ works. Why?
Answer
$$$a = 1, 2, 3 \dots n$$$ works. Why?
Hint 2
Solve for $$$k = n$$$.
Answer
$$$a = 1, 1, 1 \dots 1$$$ works. Why?
Answer
$$$a = 1, 1, 1 \dots 1$$$ works. Why?
Hint 3
What other $$$k$$$ work for a given $$$n$$$?
Answer
Only $$$k = 1$$$ and $$$k = n$$$ have possible answers.
Answer
Only $$$k = 1$$$ and $$$k = n$$$ have possible answers.
Solution
Read the hints.
For $$$k=1$$$, the construction $$$1,2,3\dots n$$$ will always work because in any other cyclic shift, $$$n$$$ will be before $$$1$$$.
Now, consider what happens if we want to find an array with two or more cyclic shifts that are sorted. If we consider two of these cyclic shifts, notice they are actually shifts of each other as well.
So, there should be a sorted array, and a shift of it which is also sorted. What this means is that some of the first elements in the array move to the back and stays sorted, which can
only happen if all values in the array are equal.
If the array has all equal values, this gives us our construction for $$$k=n$$$. As we have seen, for $$$k>1$$$, only $$$k=n$$$ is possible. Thus, for any other $$$k$$$ not equal to $$$1$$$ or $$$n$$$, we can print $$$-1$$$.
Code (C++)
#include <iostream>
using namespace std;
int main(){
	int t; cin >> t;
	while(t--){
		int n, k; cin >> n >> k;
		if(k == 1) for(int i = 0; i < n; i++) cout << i + 1 << " ";
		else if(k == n) for(int i = 0; i < n; i++) cout << 1 << " ";
		else cout << -1;
		cout << "\n";
	}
}
--------------------------------------------------
Problem ID: 1941G
Editorial Content:
1941G - Rudolf and Subway
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>

using LL = long long;
using ld = long double;

using namespace std;



int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cout << fixed << setprecision(10);


    int _ = 0, __ = 1;
    cin >> __;

    for (int _ = 0; _ < __; ++_) {
        int n, m;
        cin >> n >> m;
        vector<vector<pair<int, int>>> g(n + 1);
        map<int, int> clrs;
        int idx = n + 1;
        for (int i = 0; i < m; ++i) {
            int u, v, c;
            cin >> u >> v >> c;
            g[u].push_back({v, c});
            g[v].push_back({u, c});
            if (!clrs.count(c)) {
                clrs[c] = idx;
                idx++;
            }
        }
        int s, t;
        cin >> s >> t;
        
        if (s == t) 
        {
            cout << 0 << endl;
            continue;
        }

        vector<set<int>> bg(n + clrs.size() + 3);

        for (int i = 1; i <= n; ++i) {
            for(auto &[to, c] : g[i])
            {
                int clr_v = clrs[c];
                bg[i].insert(clr_v);
                bg[clr_v].insert(i);

                bg[to].insert(clr_v);
                bg[clr_v].insert(to);
            }
        }

        vector<int> used(bg.size());
        vector<int> d(bg.size(), -1);
        auto bfs = [&](int v)
        {
            queue<int> q;
            q.push(v);
            used[v] = 1;
            d[v] = 0;
            while (!q.empty())
            {
                auto from = q.front();
                q.pop();
                for (auto& to : bg[from])
                {
                    if (!used[to])
                    {
                        q.push(to);
                        used[to] = 1;
                        d[to] = d[from] + 1;
                    }
                }
            }
        };
        bfs(s);
        if (d[t] > 0) cout << d[t] / 2 << endl;
        else cout << -1 << endl;


    }

    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1941F
Editorial Content:
1941F - Rudolf and Imbalance
Tutorial
Tutorial is loading...
Solution
def solve():
    n, m, k = map(int, input().split())
    a = [int(x) for x in input().split()]
    d = [int(x) for x in input().split()]
    f = [int(x) for x in input().split()]
    d.sort()
    f.sort()

    m1, m2 = 0, 0
    ind = -1
    for i in range(1, n):
        e = a[i] - a[i - 1]
        m2 = max(m2, e)
        if m2 > m1:
            m1, m2 = m2, m1
            ind = i - 1

    ans = m1

    target = (a[ind] + a[ind + 1]) // 2
    for model in d:
        l, r = 0, k - 1
        while r - l > 1:
            mid = (r + l) // 2
            if model + f[mid] <= target:
                l = mid
            else:
                r = mid
        ans = min(ans, max(m2, abs(model + f[l] - a[ind]), abs(model + f[l] - a[ind + 1])))
        ans = min(ans, max(m2, abs(model + f[r] - a[ind]), abs(model + f[r] - a[ind + 1])))
    print(ans)


for _ in range(int(input())):
    solve()
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1941E
Editorial Content:
1941E - Rudolf and k Bridges
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>

using namespace std;


int main() {

    int t = 1;
    cin >> t;
    while (t--) {
        int N, M, K, D;
        cin >> N >> M >> K >> D;
        vector<long long> a(N);
        for (int i = 0; i < N; i++) {
            vector<long long> dp(M, 1e9);
            vector<int> v(M);
            multiset<long long> mst = {1};
            dp[0] = 1;
            cin >> v[0];
            for (int j = 1; j < M - 1; j++) {
                cin >> v[j];
                dp[j] = *mst.begin() + v[j] + 1;
                if (j - D - 1 >= 0)
                    mst.erase(mst.find((dp[j - D - 1])));
                mst.insert(dp[j]);
            }
            cin >> v.back();
            dp.back() = 1 + *mst.begin();
            a[i] = dp.back();
        }

        long long cur = 0;
        for (int i = 0; i < K; i++)
            cur += a[i];

        long long mn = cur;

        for (int i = K; i < N; i++) {
            cur += a[i] - a[i - K];
            mn = min(cur, mn);
        }
        cout << mn << endl;
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1941D
Editorial Content:
1941D - Rudolf and the Ball Game
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <set>

using namespace std;

int main()
{
    int t; cin >> t;
    while (t--) {
        int n, m, a; cin >> n >> m >> a;
        set <int> q[2];
        int ix = 0;
        q[ix].insert(a);
        while (m--) {
            int x; char ch; cin >> x >> ch;
            while (!q[ix].empty()) {
                int u = *(q[ix].begin());
                q[ix].erase(u);
                if (ch == '?' || ch == '0') {
                    q[ix ^ 1].insert((u + x - 1) % n + 1);
                }
                if (ch == '?' || ch == '1') {
                    q[ix ^ 1].insert((u - x - 1 + n) % n + 1);
                }
            }
            ix ^= 1;
        }
        cout << q[ix].size() << '\n';
        for (auto& x : q[ix]) {
            cout << x << ' ';
        }
        cout << '\n';
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1941C
Editorial Content:
1941C - Rudolf and the Ugly String
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

int main() {
    long long t;
    cin>>t;
    for(long long c=0;c<t;c++){
	long long n;
	cin >> n;
	string s;
	cin >> s;
	vector<long long> va;                 
	for (string sul : {"mapie", "pie", "map"}) {
		for (size_t pos = 0; (pos = s.find(sul, pos)) != string::npos;) {
			s[pos + sul.length() / 2] = '?';
			va.push_back(pos + sul.length() / 2);
		}
	}
	cout << va.size() << endl;
    }
	return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1941B
Editorial Content:
1941B - Rudolf and 121
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    a = [int(x) for x in input().split()]
    for i in range(n - 2):
        if a[i] < 0:
            print('NO')
            return
        op = a[i]
        a[i] -= op
        a[i + 1] -= 2 * op
        a[i + 2] -= op
    if a[-1] != 0 or a[-2] != 0:
        print('NO')
    else:
        print('YES')
    

for _ in range(int(input())):
    solve()
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1941A
Editorial Content:
1941A - Rudolf and the Ticket
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>

using namespace std;

int main() {
	int t;
	cin >> t;
	while (t--) {
		int n, m, k;
		cin >> n >> m >> k;
		int ans = 0;
		vector<int> v1(n);
		for (int i = 0; i < n; i++) {
			cin >> v1[i];
		}
		int o;
		for (int j = 0; j < m; j++) {
			cin >> o;
			for (int i = 0; i < n; i++) {
				if ((o + v1[i]) <= k) ans++;
			}
		}
		cout << ans << "\n";
	}
	return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1940D
Editorial data not available.
--------------------------------------------------
Problem ID: 1940C
Editorial data not available.
--------------------------------------------------
Problem ID: 1940B
Editorial data not available.
--------------------------------------------------
Problem ID: 1940A
Editorial data not available.
--------------------------------------------------
Problem ID: 1939D
Editorial data not available.
--------------------------------------------------
Problem ID: 1939C
Editorial data not available.
--------------------------------------------------
Problem ID: 1939B
Editorial data not available.
--------------------------------------------------
Problem ID: 1939A
Editorial data not available.
--------------------------------------------------
Problem ID: 1938M
Editorial data not available.
--------------------------------------------------
Problem ID: 1938L
Editorial data not available.
--------------------------------------------------
Problem ID: 1938K
Editorial data not available.
--------------------------------------------------
Problem ID: 1938J
Editorial data not available.
--------------------------------------------------
Problem ID: 1938I
Editorial data not available.
--------------------------------------------------
Problem ID: 1938H
Editorial data not available.
--------------------------------------------------
Problem ID: 1938G
Editorial data not available.
--------------------------------------------------
Problem ID: 1938F
Editorial data not available.
--------------------------------------------------
Problem ID: 1938E
Editorial data not available.
--------------------------------------------------
Problem ID: 1938D
Editorial data not available.
--------------------------------------------------
Problem ID: 1938C
Editorial data not available.
--------------------------------------------------
Problem ID: 1938B
Editorial data not available.
--------------------------------------------------
Problem ID: 1938A
Editorial data not available.
--------------------------------------------------
Problem ID: 1937B
Editorial Content:

--------------------------------------------------
Problem ID: 1937A
Editorial Content:

--------------------------------------------------
Problem ID: 1936F
Editorial Content:

--------------------------------------------------
Problem ID: 1936E
Editorial Content:

--------------------------------------------------
Problem ID: 1936D
Editorial Content:

--------------------------------------------------
Problem ID: 1936C
Editorial Content:

--------------------------------------------------
Problem ID: 1936B
Editorial Content:

--------------------------------------------------
Problem ID: 1936A
Editorial Content:

--------------------------------------------------
Problem ID: 1935F
Editorial Content:
1935F - Andrey's Tree
Hints
Hint 1
What different values can the answer for a vertex take?
Hint 2
Edges with a weight of 1 can connect all vertices $$$[1, v - 1]$$$ and all vertices $$$[v + 1, n]$$$.
Hint 3
Consider the edges of the form $$$(mn_u, mn_u - 1)$$$, $$$(mx_u, mx_u + 1)$$$, where $$$mn_u$$$, $$$mx_u$$$ are the minimum and maximum in the subtree of vertex u with respect to $$$v$$$.
Hint 1
What different values can the answer for a vertex take?
Hint 2
Edges with a weight of 1 can connect all vertices $$$[1, v - 1]$$$ and all vertices $$$[v + 1, n]$$$.
Hint 3
Consider the edges of the form $$$(mn_u, mn_u - 1)$$$, $$$(mx_u, mx_u + 1)$$$, where $$$mn_u$$$, $$$mx_u$$$ are the minimum and maximum in the subtree of vertex u with respect to $$$v$$$.
Tutorial
Let's fix some vertex $$$v$$$ for which the answer is being calculated. Suppose the degree of the vertex $$$v$$$ in the tree is $$$deg_v$$$, then it's clear that it's necessary to add $$$deg_v - 1$$$ edges. Consider the components that appear after removing $$$v$$$. Then, the goal is to use the new edges to unite all the components into one, using the minimum total cost. This is the same as finding the minimum spanning tree in a graph, where the vertices are the components that resulted from removing $$$v$$$, and for every $$$a, b$$$, an edge with a weight of $$$|a - b|$$$ is drawn between the components containing $$$a$$$ and $$$b$$$.
Let's simulate Kruskal's algorithm for this graph. Consider all the single-weight edges in this graph: $$$(1, 2), (2, 3), ..., (v - 2, v - 1), (v + 1, v + 2), ..., (n - 1, n)$$$. It's clear that using the single-weight edges, the vertices with numbers $$$[1, v - 1]$$$ will definitely end up in one component, and the vertices with numbers $$$[v + 1, n]$$$ will also end up in one component. To unite these two components, it would be optimal to add an edge $$$(v - 1, v + 1)$$$.
It turns out that it's sufficient to consider only all the single-weight edges and the edge $$$(v - 1, v + 1)$$$. Let's limit the number of single-weight edges to $$$O(deg_v)$$$. For this, in each component $$$u$$$, calculate $$$mn_u$$$ and $$$mx_u$$$ — the minimum and maximum in the component, respectively. Claim: among the single-weight edges, it's sufficient to consider edges of the form $$$(mn_u, mn_u - 1)$$$, $$$(mx_u, mx_u + 1)$$$.
Proof
First, understand when it's necessary to add the edge $$$(v - 1, v + 1)$$$. Note that if there's at least one component $$$u$$$ such that $$$mn_u < v < mx_u$$$, then the edge $$$(v - 1, v + 1)$$$ won't be needed; otherwise, it will be. This is quite easy to show by simulating Kruskal's algorithm.
Let $$$v = 1$$$. We'll show that using edges $$$(mn_u, mn_u - 1)$$$, all components will unite. Go through the vertices $$$x$$$ from $$$2$$$ to $$$n$$$ and maintain the invariant that all vertices from $$$2$$$ to $$$x$$$ are in one component. At $$$x = 2$$$, this holds. When $$$x$$$ is the minimum in some component, then the edge $$$(x - 1, x)$$$ will be added, and since $$$x - 1$$$ is in one component with $$$2$$$, $$$x$$$ will now also be. When $$$x$$$ is not the minimum in some component, then $$$mn$$$ — the minimum in the component $$$x$$$ will be in one component with $$$2$$$ ($$$mn < x$$$, the invariant holds), meaning $$$x$$$ will also be in one component with $$$2$$$. Thus, it turns out that all will be in one component.
Now consider an arbitrary $$$v$$$. Separately consider the prefix of vertices $$$[1, v - 1]$$$ and the suffix $$$[v + 1, n]$$$. Then, similarly to $$$v = 1$$$, it can be shown that for the prefix of vertices $$$[1, v - 1]$$$, using edges of the form $$$(mn_u, mn_u - 1)$$$, you can unite $$$[1, v - 1]$$$. Similarly, for the suffix of vertices $$$[v + 1, n]$$$, using edges of the form $$$(mx_u, mx_u + 1)$$$, you can unite $$$[v + 1, n]$$$.
Now, if the edge $$$(v - 1, v + 1)$$$ is necessary, then add it to the answer. Otherwise, there's at least one component $$$u$$$ such that $$$mn_u < v < mx_u$$$, meaning the prefix of vertices $$$[1, v - 1]$$$ and the suffix $$$[v + 1, n]$$$ will unite into one component.
Finding $$$mn_u$$$, $$$mx_u$$$ for each component is straightforward; what remains is to determine which components are connected by the edges $$$(mn_u, mn_u - 1)$$$, $$$(mx_u, mx_u + 1)$$$. This can be done with binary search through the Euler tour of the tree. After that, Kruskal's algorithm can be initiated to calculate the answer.
Let's estimate the time complexity. For a specific vertex $$$v$$$, the time complexity will be $$$deg_v \cdot \log n$$$, so the total time complexity is $$$O(n \cdot \log n)$$$.
Depending on the implementation of the last step, the problem can be solved in $$$O(n)$$$, $$$O(n \cdot \alpha(n))$$$, where $$$\alpha(n)$$$ is the inverse Ackermann function relative to $$$n$$$.
Proof
First, understand when it's necessary to add the edge $$$(v - 1, v + 1)$$$. Note that if there's at least one component $$$u$$$ such that $$$mn_u < v < mx_u$$$, then the edge $$$(v - 1, v + 1)$$$ won't be needed; otherwise, it will be. This is quite easy to show by simulating Kruskal's algorithm.
Let $$$v = 1$$$. We'll show that using edges $$$(mn_u, mn_u - 1)$$$, all components will unite. Go through the vertices $$$x$$$ from $$$2$$$ to $$$n$$$ and maintain the invariant that all vertices from $$$2$$$ to $$$x$$$ are in one component. At $$$x = 2$$$, this holds. When $$$x$$$ is the minimum in some component, then the edge $$$(x - 1, x)$$$ will be added, and since $$$x - 1$$$ is in one component with $$$2$$$, $$$x$$$ will now also be. When $$$x$$$ is not the minimum in some component, then $$$mn$$$ — the minimum in the component $$$x$$$ will be in one component with $$$2$$$ ($$$mn < x$$$, the invariant holds), meaning $$$x$$$ will also be in one component with $$$2$$$. Thus, it turns out that all will be in one component.
Now consider an arbitrary $$$v$$$. Separately consider the prefix of vertices $$$[1, v - 1]$$$ and the suffix $$$[v + 1, n]$$$. Then, similarly to $$$v = 1$$$, it can be shown that for the prefix of vertices $$$[1, v - 1]$$$, using edges of the form $$$(mn_u, mn_u - 1)$$$, you can unite $$$[1, v - 1]$$$. Similarly, for the suffix of vertices $$$[v + 1, n]$$$, using edges of the form $$$(mx_u, mx_u + 1)$$$, you can unite $$$[v + 1, n]$$$.
Now, if the edge $$$(v - 1, v + 1)$$$ is necessary, then add it to the answer. Otherwise, there's at least one component $$$u$$$ such that $$$mn_u < v < mx_u$$$, meaning the prefix of vertices $$$[1, v - 1]$$$ and the suffix $$$[v + 1, n]$$$ will unite into one component.
Implementation on C++
#include <bits/stdc++.h>
 
using namespace std;
 
 
struct DSU {
    vector<int> p, r;
    int comp;
    DSU(int n) : p(n), r(n) {
        iota(p.begin(), p.end(), 0);
        comp = n;
    }
    int find(int v) {
        return (p[v] == v) ? v : p[v] = find(p[v]);
    }
    bool join(int a, int b) {
        a = find(a), b = find(b);
        if (a == b) return false;
        comp--;
        if (r[a] < r[b]) swap(a, b);
        p[b] = a;
        if (r[a] == r[b]) r[a]++;
        return true;
    }
};
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        vector<vector<int>> g(n);
        for (int i = 0; i < n - 1; i++) {
            int x, y;
            cin >> x >> y;
            x--, y--;
            g[x].push_back(y);
            g[y].push_back(x);
        }
        vector<int> tin(n), tout(n), l0(n), r0(n);
        vector<int> lup(n), rup(n);
        int timer = 0;
        vector<int> ord;
        function<void(int, int)> dfs = [&](int v, int p) {
            l0[v] = r0[v] = v;
            tin[v] = timer++;
            ord.push_back(v);
            for (int u : g[v]) {
                if (u == p) continue;
                dfs(u, v);
                l0[v] = min(l0[v], l0[u]);
                r0[v] = max(r0[v], r0[u]);
            }
            tout[v] = timer - 1;
        };
        dfs(0, 0);
        function<bool(int, int)> ancestor = [&](int v, int u) {
            return tin[v] <= tin[u] && tin[u] <= tout[v];
        };
        vector<int> pref_min_ord(n + 1, n), suf_min_ord(n + 1, n);
        vector<int> pref_max_ord(n + 1, -1), suf_max_ord(n + 1, -1);
        for (int i = 0; i < n; i++) {
            pref_min_ord[i + 1] = min(pref_min_ord[i], ord[i]);
            pref_max_ord[i + 1] = max(pref_max_ord[i], ord[i]);
        }
        for (int i = n - 1; i >= 0; i--) {
            suf_min_ord[i] = min(suf_min_ord[i + 1], ord[i]);
            suf_max_ord[i] = max(suf_max_ord[i + 1], ord[i]);
        }
        for (int id = (int)ord.size() - 1; id >= 0; id--) {
            int v = ord[id];
            lup[v] = min(pref_min_ord[tin[v]], suf_min_ord[tout[v] + 1]);
            rup[v] = max(pref_max_ord[tin[v]], suf_max_ord[tout[v] + 1]);
        }
        vector<vector<pair<int, int>>> ans(n);
        vector<int> weight(n);
        function<void(int, int)> dfs2 = [&](int v, int p) {
            vector<int> all_id, all_tin;
            int idpar = -1;
            for (int id = 0; id < g[v].size(); id++) {
                int u = g[v][id];
                if (u != p) {
                    dfs2(u, v);
                    all_id.push_back(id);
                    all_tin.push_back(tin[u]);
                } else {
                    idpar = id;
                }
            }
            function<int(int)> get_subtree = [&](int u) {
                if (!ancestor(v, u)) return idpar;
                return all_id[upper_bound(all_tin.begin(), all_tin.end(), tin[u]) - all_tin.begin() - 1];
            };
            DSU dsu(g[v].size());
            function<void(int, int)> try_add = [&](int x, int y) {
                if (x == -1 || y == n || x == v || y == v) return;
                if (dsu.join(get_subtree(x), get_subtree(y))) {
                    ans[v].push_back({x, y});
                    weight[v] += abs(x - y);
                }
            };
            for (int u : g[v]) {
                if (u != p) {
                    try_add(l0[u] - 1, l0[u]);
                    try_add(r0[u], r0[u] + 1);
                } else {
                    try_add(lup[v] - 1, lup[v]);
                    try_add(rup[v], rup[v] + 1);
                }
            }
            if (dsu.comp != 1) {
                try_add(v - 1, v + 1);
            }
            assert(dsu.comp == 1);
        };
        dfs2(0, 0);
        for (int i = 0; i < n; i++) {
            cout << weight[i] << " " << ans[i].size() << "\n";
            for (auto [a, b] : ans[i]) {
                cout << a + 1 << " " << b + 1 << "\n";
            }
            cout << "\n";
        }
    }
}
--------------------------------------------------
Problem ID: 1935E
Editorial Content:
1935E - Distance Learning Courses in MAC
Hints
Hint 1
Try to solve the problem if $$$x_i = 0$$$ for each $$$i$$$.
Hint 2
What will be the answer for two segments $$$(0, 2^i), (0, 2^i)$$$?
Hint 3
Which bits will definitely be included in the answer?
Hint 1
Try to solve the problem if $$$x_i = 0$$$ for each $$$i$$$.
Hint 2
What will be the answer for two segments $$$(0, 2^i), (0, 2^i)$$$?
Hint 3
Which bits will definitely be included in the answer?
Tutorial
Let's solve the problem when $$$x = 0$$$. Then we will iterate over the bits from the most significant to the least significant and try to include them in the answer. Suppose we are iterating over bit $$$i$$$, then if such a bit occurs $$$c$$$ times in $$$y$$$ numbers there are several cases:
$$$c = 0$$$ — this bit cannot be included in the answer
$$$c = 1$$$ — this bit will be included in the answer, we add it
$$$c > 1$$$ — a special case, because for one number where bit x is present, we can set it, and for another number, we can set all bits $$$j < i$$$.
Therefore, if we encounter some bit $$$i$$$ that occurs more than once, then all bits $$$j \le i$$$ will also be included in the answer. Now let's solve the original problem, for this we take a pair $$$(x_i, y_i)$$$ and find the bitwise largest common prefix — let it be number $$$w$$$. Then it is clear that all bits from $$$w$$$ will be included in the answer, then we make a new pair $$$(x'_i, y'_i)$$$ = $$$(x_i - w, y_i - w)$$$, and remember the number $$$w_i$$$. Now note that the number $$$y'_i - 1 \ge x'_i$$$. Why do we need this fact? Remember, in the case when some bit occurred more than once, we added it and all smaller bits to the answer. For this, we would set at this position a number equal to $$$2^i - 1$$$ (and other larger bits $$$i$$$), but if $$$y'_i - 1 \ge x'_i$$$, then we can always add all such bits.
Therefore, the solution algorithm for request $$$j$$$ is as follows:
Take the Bitwise OR of all $$$w_i$$$ for $$$l_j \le i \le r_j$$$, let this be number $$$W$$$
Iterate over bit $$$i$$$ and similarly to the case $$$x = 0$$$ consider the same cases, but for the array $$$y'$$$. Also, take into account that the bit occurs in $$$W$$$.
This solution can be implemented in $$$O(n \cdot \log n)$$$ using prefix sums for each bit. There is also a solution using a segment tree, so the problem can be solved with modification requests as well.
Implementation on C++
/* Includes */
#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
 
/* Using libraries */
using namespace std;
 
/* Defines */
template <class T>
using vc = vector <T>;
using ll = long long;
using ld = long double;
using pii = pair <int, int>;
 
template<class T>
void output(T &a) {
    for (auto i : a)
        cout << i << ' ';
    cout << '\n';
}
 
template<class T>
bool chmin(T &a, T b) {
    if (a > b) {
        a = b;
        return true;
    }
    return false;
}
 
template<class T>
bool chmax(T &a, T b) {
    if (a < b) {
        a = b;
        return true;
    }
    return false;
}
 
const int N = 2e5;
const int bit = 30;
 
struct segtree {
    vc <int> t; int n;
    segtree (int n) : n(n) {
        t.resize(n * 2);
    }
    void upd (int i, int x) {
        for (t[i += n] = x; i > 1; i >>= 1) {
            t[i >> 1] = t[i] | t[i ^ 1];
        }
    }
    int get (int l, int r) {
        int res = 0;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if (l & 1)
                res |= t[l++];
            if (r & 1)
                res |= t[--r];
        }
        return res;
    }
};
 
int n;
int l[N], r[N];
int w[N];
void fix () {
    for (int i = 0; i < n; ++i) {
        if (l[i] == r[i]) {
            w[i] = l[i];
            l[i] = r[i] = 0;
            continue;
        }
        int pref = (1 << (__lg(l[i] ^ r[i]) + 1)) - 1;
        w[i] = r[i] - (r[i] & pref);
        r[i] &= pref;
        l[i] &= pref;
    }
}
 
void solve() {
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> l[i] >> r[i];
    }
    fix();
    segtree t(n);
    vc <vc <int>> bits(bit, vc <int> (n + 1));
    for (int i = 0; i < n; ++i) {
        t.upd(i, w[i]);
        for (int j = 0; j < bit; ++j) {
            bits[j][i + 1] = bits[j][i];
            if (r[i] >> j & 1) {
                bits[j][i + 1]++;
            }
        }
    }
    int q;
    cin >> q;
    while (q--) {
        int x, y;
        cin >> x >> y; --x;
        int ans = t.get(x, y);
        for (int j = bit - 1; j >= 0; --j) {
            int cnt = bits[j][y] - bits[j][x] + (ans >> j & 1);
            if (cnt > 1) {
                ans |= (2 << j) - 1;
                break;
            } else if (cnt == 1) {
                ans |= 1 << j;
            }
        }
        cout << ans << ' ';
    }
    cout << "\n";
}
 
signed main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1935D
Editorial Content:
1935D - Exam in MAC
Hints
Hint 1
The principle of inclusion-exclusion.
Hint 2
The equation $$$x+y = s_i$$$, $$$y-x=s_j$$$ has $$$0$$$ or $$$1$$$ solutions with integers $$$x, y$$$.
Hint 1
The principle of inclusion-exclusion.
Hint 2
The equation $$$x+y = s_i$$$, $$$y-x=s_j$$$ has $$$0$$$ or $$$1$$$ solutions with integers $$$x, y$$$.
Tutorial
Applying the formula of inclusion-exclusion, the answer to the problem will be: $$$\mathrm{cnt}(x, y) - \mathrm{cnt}(x, y: x + y \in s) - \mathrm{cnt}(x, y: y - x \in s) + \mathrm{cnt}(x, y: x + y, y - x \in s)$$$. Let's calculate each value separately.
The number of possible pairs $$$x, y$$$ is $$$\frac{(c+1)\cdot(c+2)}{2}$$$.
The number of pairs $$$x, y: x + y \in s$$$. We iterate over the sum value $$$s_i$$$, let $$$x + y = s_i$$$, then for $$$0 \leq x \leq \lfloor \frac{s_i}{2} \rfloor$$$ there will correspond exactly one $$$y$$$, i.e., the number of pairs with such a sum is $$$\lfloor \frac{s_i}{2} \rfloor + 1$$$.
The number of pairs $$$x, y: y - x \in s$$$. We iterate over the difference value $$$s_i$$$, let $$$y - x = s_i$$$, then for $$$s_i \leq y \leq c$$$ there will correspond exactly one $$$x$$$, i.e., the number of pairs with such a difference is $$$c - s_i + 1$$$.
The number of pairs $$$x, y: x + y, y - x \in s$$$. Let $$$x+y=s_i$$$, $$$y-x=s_j$$$, then $$$x = \frac{s_i - s_j}{2}$$$, and $$$y = \frac{s_i+s_j}{2}$$$. If $$$s_i, s_j$$$ have different parities, then such $$$x, y$$$ will not be suitable because they will be non-integers; otherwise, such $$$x, y$$$ are suitable, and we need to add this pair. Then, let's calculate the number of even and odd numbers in $$$s$$$ — $$$even$$$ and $$$odd$$$ respectively. Thus, the number of such pairs is $$$\frac{even\cdot(even+1)}{2}+\frac{odd\cdot(odd+1)}{2}$$$.
With all these quantities, we can calculate the answer. The final complexity is $$$O(n)$$$. The problem can also be solved in $$$O(n \cdot \log n)$$$ or $$$O(n)$$$ using other methods.
Implementation on C++
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

void solve_case() {
    int n, c;
    cin >> n >> c;
    vector<int> s(n);
    for (int i = 0; i < n; i++) cin >> s[i];
    int odd = 0, even = 0;
    ll ans = 1ll * (c + 1) * (c + 2) / 2;
    for (int i = 0; i < n; i++) {
        ans -= s[i] / 2 + 1;
        ans -= c - s[i] + 1;
        if (s[i] % 2 == 0) {
            even++;
        } else {
            odd++;
        }
    }
    ans += 1ll * even * (even + 1) / 2;
    ans += 1ll * odd * (odd + 1) / 2;
    cout << ans << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int T = 1;
    cin >> T;
    while (T--) {
        solve_case();
    }
}
Implementation on Python
def solve_case() :
    n, c = map(int, input().split())
    s = list(map(int, input().split()))
    ans = (c + 1) * (c + 2) // 2
    even, odd = 0, 0
    for i in range(n):
        ans -= s[i] // 2 + 1
        ans -= c - s[i] + 1
        if s[i] % 2 == 0:
            even += 1
        else:
            odd += 1
    ans += even * (even + 1) // 2
    ans += odd * (odd + 1) // 2
    print(ans)

t = int(input())
for test in range(t):
    solve_case()
--------------------------------------------------
Problem ID: 1935C
Editorial Content:
1935C - Messenger in MAC
Hints
Hint 1
Try to find the answer to the problem by hand. How can changing the order of the messages reduce time?
Hint 2
Let the order in the response be $$$p_1, p_2, \ldots, p_k$$$. It is always advantageous for the response to satisfy $$$b_{p_1} \leq b_{p_2} \leq \ldots \leq b_{p_k}$$$.
Hint 3
Greedy?
Hint 1
Try to find the answer to the problem by hand. How can changing the order of the messages reduce time?
Hint 2
Let the order in the response be $$$p_1, p_2, \ldots, p_k$$$. It is always advantageous for the response to satisfy $$$b_{p_1} \leq b_{p_2} \leq \ldots \leq b_{p_k}$$$.
Hint 3
Greedy?
Solution
Let the order in the response be $$$p_1, p_2, \ldots, p_k$$$. Note that in the optimal response, it will hold that $$$b_{p_1} \leq b_{p_2} \leq \ldots \leq b_{p_k}$$$. It's not hard to prove that such an order minimizes the sum of the absolute differences of adjacent elements in the array $$$b$$$. Then, this sum will turn into $$$b_{p_k} - b_{p_1}$$$, that is, the difference between the highest and lowest value of $$$b$$$ in the set of messages.
Let's sort the pairs $$$(a_i, b_i)$$$ in ascending order of $$$b_i$$$. Fix the minimum value in the set of messages $$$b_l$$$ and the maximum value $$$b_r$$$. Note that the sum of the absolute differences of $$$b$$$ in the response will not change if taking values $$$b_l \leq b_i \leq b_r$$$. Thus, the task reduces to finding the maximum number of messages so that $$$\sum a \leq L - (b_r - b_l)$$$.
Iterate over $$$b_l$$$ and $$$b_r$$$. Apply a greedy algorithm, sort all values of $$$a_i$$$ ($$$l \leq i \leq r$$$), and keep adding values until the time exceeds $$$L$$$. This solution works in $$$O(n^3\log{}n)$$$, which is too slow.
To speed up the solution, while iterating over $$$b_r$$$, maintain a data structure that allows adding an element, removing the maximum, getting the maximum (in C++, there are $$$\textit{multiset}$$$ and $$$\textit{priority_queue}$$$). In this data structure, maintain the minimum values of $$$a$$$, so the sum of times does not exceed $$$L$$$. Then, if the current time exceeds $$$L$$$, remove from the structure until the current time becomes no more than $$$L$$$. There will be no more than $$$n$$$ such removals. We have obtained a solution in $$$O(n^2\log{}n)$$$, which is feasibly fast.
Implementation on C++
#include <bits/stdc++.h>

signed main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int t = 1;
    std::cin >> t;
    while (t--) {
        int n, L;
        std::cin >> n >> L;
        std::vector<std::pair<int, int>> v(n);
        for (int i = 0 ; i < n ; i++) {
            std::cin >> v[i].second >> v[i].first;
        }
        std::sort(v.begin(), v.end());

        int ans = 0;
        for (int l = 0 ; l < n ; l++) {
            std::multiset<int> s;
            int cur = 0;
            for (int r = l ; r < n ; r++) {
                s.insert(v[r].second);
                cur += v[r].second;
                while (!s.empty() && v[r].first - v[l].first + cur > L) {
                    int max_value = *s.rbegin();
                    cur -= max_value;
                    s.extract(max_value);
                }
                ans = std::max(ans, (int) s.size());
            }
        }

        std::cout << ans << "\n";
    }

    return 0;
}
Implementation on Python
import heapq
import sys

input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n, L = map(int, input().split())
    v = []
    for i in range(n):
        a, b = map(int, input().split())
        v.append((b, a))
    v.sort()

    ans = 0
    for l in range(n):
        pq = []
        heapq.heapify(pq)
        cur = 0
        size = 0
        for r in range(l, n):
            heapq.heappush(pq, -v[r][1])
            size += 1
            cur += v[r][1]
            while size and v[r][0] - v[l][0] + cur > L:
                maxx = -heapq.heappop(pq)
                cur -= maxx
                size -= 1
            ans = max(ans, size)

    print(ans)
--------------------------------------------------
Problem ID: 1935B
Editorial Content:
1935B - Informatics in MAC
Hints
Hint 1
What is the minimum $$$k$$$ that can be in a division?
Hint 2
Suppose $$$\operatorname{MEX}(x, y) = \operatorname{MEX}(y + 1, z)$$$, what can be said about $$$\operatorname{MEX}(x, z)$$$?
Hint 1
What is the minimum $$$k$$$ that can be in a division?
Hint 2
Suppose $$$\operatorname{MEX}(x, y) = \operatorname{MEX}(y + 1, z)$$$, what can be said about $$$\operatorname{MEX}(x, z)$$$?
Tutorial
Suppose we correctly divided the array into $$$k > 2$$$ segments — $$$(1, r_1), (l_2, r_2), \ldots, (l_k, r_k)$$$. Then, note that we can merge first two subsegments, as the numbers from 0 to $$$mex - 1$$$ are encountered in these two segments and the number $$$mex$$$ is not encountered in them. Therefore, if there is a division into $$$k > 2$$$ segments, then there is also for $$$k - 1$$$ segments.
Therefore, it is sufficient to check whether there is a division of the array into $$$k = 2$$$ segments, which can be done in $$$O(n)$$$ by precalcing $$$\operatorname{MEX}$$$ on the prefixes and suffixes, then we need to find some $$$i$$$ for which $$$\operatorname{MEX}(1, i) = \operatorname{MEX}(i + 1, n)$$$.
Implementation on C++
/* Includes */
#include <bits/stdc++.h>
 
/* Using libraries */
using namespace std;

/* Defines */
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define vc vector
#define pii pair <int, int>
#define int long long
 
void solve () {
    int n;
    cin >> n;
    vc <int> a(n);
    vc <int> cnt1(n + 1), cnt2(n + 1);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        cnt2[a[i]]++;
    }
    int mex1 = 0, mex2 = 0;
    while (cnt2[mex2])
        ++mex2;
    for (int i = 0; i < n; ++i) {
        cnt1[a[i]]++;
        if (--cnt2[a[i]] == 0 && mex2 > a[i]) {
            mex2 = a[i];
        }
        while (mex2 && !cnt2[mex2 - 1])
            --mex2;
        while (cnt1[mex1])
            ++mex1;
        if (mex1 == mex2) {
            cout << "2\n";
            cout << 1 << " " << i + 1 << "\n";
            cout << i + 2 << " " << n << "\n";
            return;
        }
    }
    cout << "-1\n";
}

signed main() {
    fast;
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
Implementation on Python
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    cur_mex = 0
    cur_have = [0] * (n + 1)
    for el in a:
        cur_have[el] += 1
    while cur_have[cur_mex]:
        cur_mex += 1

    another_mex = 0
    another_have = [0] * (n + 1)
    for i in range(n):
        cur_have[a[i]] -= 1
        if cur_have[a[i]] == 0 and cur_mex > a[i]:
            cur_mex = a[i]

        another_have[a[i]] += 1
        while another_have[another_mex]:
            another_mex += 1

        if cur_mex == another_mex:
            print(2)
            print("1 " + str(i + 1))
            print(str(i + 2) + " " + str(n))
            return

    print(-1)


t = int(input())
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 1935A
Editorial Content:
1935A - Entertainment in MAC
Hints
Hint 1
The answer will always have either the prefix $$$s$$$, or the reversed string $$$s$$$.
Hint 2
Adding the string to the end is required no more than once.
Hint 1
The answer will always have either the prefix $$$s$$$, or the reversed string $$$s$$$.
Hint 2
Adding the string to the end is required no more than once.
Solution
Let $$$t$$$ be the reversed string $$$s$$$. Notice that it is advantageous for us to use operation 1 (adding the reversed string at the end) no more than once. Indeed, having obtained some string, we will simply spend the remaining operations on flipping the string. Thus, we will get the original string or the reversed one, depending on the parity of the number of remaining operations.
It is easy to see that the answer will always have either the prefix $$$s$$$, or $$$t$$$. Then, we find two lexicographically minimal strings with the prefix $$$s$$$ and $$$t$$$. These will be strings:
$$$s$$$, flip the string $$$n$$$ times (since $$$n$$$ is even, every 2 operations we return the string to its original) $$$t + s$$$, initially flip the string, add the reversed string to the end, then flip the string $$$n - 2$$$ times. The answer will be the lexicographically minimal string out of $$$s$$$ and $$$t + s$$$.
Implementation on C++
#include <bits/stdc++.h>

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int tt;
    std::cin >> tt;
    while (tt--) {
        int n;
        std::cin >> n;
        std::string s;
        std::cin >> s;
        std::string t = s;
        reverse(t.begin(), t.end());
        std::cout << std::min(s, t + s) << "\n";
    }

    return 0;
}
Implementation on Python
t = int(input())
for _ in range(t):
    n = int(input())
    s = input()
    t = s[::-1]
    print(min(s, t + s))
--------------------------------------------------
Problem ID: 1934E
Editorial Content:
1934E — Weird LCM Operations
Solution
Fact 1
: If for $$$(x, y, z)$$$ their pairwise GCDs are equal to their common GCD (this means that $$$(x, y, z)$$$ = $$$(g * X, g * Y, g * Z)$$$ where $$$(X, Y, Z)$$$ are pairwise coprime), then making an operation on them (gives $$$(g * X * Y, g * X * Z,g * Y * Z)$$$) and looking at the subsequences of size EXACTLY 2, we find all three GCD: $$$x$$$, $$$y$$$, $$$z$$$. Let's call such tuple NICE.
Result
: If we can split all values in the array into independent NICE tuples, then we can just perform an operation on each of them and the problem is solved.
Fact 2
: We don't touch any value $$$\leq$$$ $$$\frac{n}{2}$$$. If there is $$$x$$$ $$$\leq$$$ $$$\frac{n}{2}$$$, then $$$2 * x \leq n$$$. If we don't touch $$$x$$$, then we will always have another value that is divisible by $$$x$$$ (it's easy to see that performing an operation on a multiple of $$$x$$$ leaves us with another multiple of $$$x$$$), so we will always have GCD equal to $$$x$$$ taking a subsequence $$$(x, x * A)$$$.
Fact 3
: A sequence of consecutive integers $$$(x, x+1, x+2, ..., x+11)$$$ can be partitioned into $$$4$$$ disjoint sets of size $$$3$$$, each forming a NICE tuple, if $$$(x+11) \% 4$$$ equals $$$2$$$ or $$$1$$$.
For $$$(x+11) \% 4 = 2$$$
: The sets $$$(x, x+1, x+2)$$$, $$$(x+4, x+5, x+6)$$$ and $$$(x+8, x+9, x+10)$$$ are NICE because, the first and third terms are always odd, and the second term is always even. The set $$$(x+3, x+7, x+11)$$$ is NICE because it has the form of $$$2*(2*n-1)$$$, $$$2*(2*n)$$$, $$$2*(2*n+1)$$$, ensuring that the pairwise GCDs are equal to the common GCD.
For $$$(x+11) \% 4 = 1$$$
: The sets $$$(x, x+4, x+8)$$$, $$$(x+1, x+2, x+3)$$$, $$$(x+5, x+6, x+7)$$$ and $$$(x+9, x+10, x+11)$$$ are NICE, the same logic like $$$(x+11) \% 4 = 2$$$ follows,
If $$$n \% 4 = 3$$$ we can do one operation as $$$(1, 2, n)$$$, and if $$$n \% 4 = 0$$$ we can do one operation as $$$(1, n-1, n)$$$. Let's group the remaining elements into the groups of size $$$12$$$, starting from the end, and continuing until we reach the number $$$\frac{n}{2}$$$.
Eventually, we can count that we used no more than $$$\lfloor \frac{n}{6} \rfloor + 5$$$ operations.
Solutions for $$$n \leq 13$$$ should be found manually.
Code
#include<bits/stdc++.h>
 
using namespace std;
vector<vector<vector<int>>> pans(14);
int main(){
 
    ios::sync_with_stdio(false), cin.tie(nullptr);
 
    int t;cin>>t;
 
    pans[3]={{1,2,3}};
    pans[4]={{1,3,4}};
    pans[5]={{3,4,5}};
    pans[6]={{1,3,5},{2,4,6}};
    pans[7]={{2,4,6},{3,5,7}};
    pans[8]={{2,6,8},{3,5,7}};
    pans[9]={{1,3,5},{2,4,6},{7,8,9}};
    pans[10]={{3,4,5},{2,6,8},{7,9,10}};
    pans[11]={{2,6,8},{3,5,7},{9,10,11}};
    pans[12]={{1,11,12},{6,8,10},{5,7,9}};
    pans[13]={{1,12,13},{7,9,11},{6,8,10}};
    for(int tt=0;tt<t;tt++){
        int n;cin>>n;
        if(n<=2){
            cout<<-1<<endl;
        }else if(n<14){
            cout<<pans[n].size()<<endl;
            for(auto w: pans[n]){
                cout<<w[0]<<" "<<w[1]<<" "<<w[2]<<endl;
            }
        }else{
            vector<int> v(n);
            for(int i=0;i<n;i++){
                v[i]=i+1;
            }
            vector<vector<int>> ans;
            while (2*v.size()>n){
                if(v.size()%4==2){
                    vector<int> buf;
                    for(int i=0;i<12;i++){
                        buf.push_back(v.back());
                        v.pop_back();
                    }
                    reverse(buf.begin(),buf.end());
                    ans.push_back({buf[0],buf[1],buf[2]});
                    ans.push_back({buf[4],buf[5],buf[6]});
                    ans.push_back({buf[8],buf[9],buf[10]});
                    ans.push_back({buf[3],buf[7],buf[11]});
                }else if(v.size()%4==1){
                    vector<int> buf;
                    for(int i=0;i<12;i++){
                        buf.push_back(v.back());
                        v.pop_back();
                    }
                    reverse(buf.begin(),buf.end());
                    ans.push_back({buf[1],buf[2],buf[3]});
                    ans.push_back({buf[5],buf[6],buf[7]});
                    ans.push_back({buf[9],buf[10],buf[11]});
                    ans.push_back({buf[0],buf[4],buf[8]});
                }else if(v.size()%4==3){
                    vector<int> buf;
                    buf.push_back(v.back());
                    v.pop_back();
                    buf.push_back(2);
                    buf.push_back(1);
                    reverse(buf.begin(),buf.end());
                    ans.push_back({buf[0],buf[1],buf[2]});
                }else{
                    vector<int> buf;
                    buf.push_back(v.back());
                    v.pop_back();
                    buf.push_back(v.back());
                    v.pop_back();
                    buf.push_back(1);
                    reverse(buf.begin(),buf.end());
                    ans.push_back({buf[0],buf[1],buf[2]});
                }
            }
            cout<<ans.size()<<endl;
            for(auto w: ans){
                cout<<w[0]<<" "<<w[1]<<" "<<w[2]<<endl;
            }
        }
    }
}
--------------------------------------------------
Problem ID: 1934D2
Editorial Content:
1934D2 — XOR Break — Game Version
Hint 1
If both $$$p_1$$$ and $$$p_2$$$ are perfect powers of $$$2$$$, it is a losing state since you cannot perform a break operation on either of those.
Hint 2
If either $$$p_1$$$ or $$$p_2$$$ has a bit count of $$$2$$$, then this is a winning state.
Reason
You can force your opponent into the state described in Hint $$$1$$$ using the number which has $$$2$$$ bitcount.
Reason
You can force your opponent into the state described in Hint $$$1$$$ using the number which has $$$2$$$ bitcount.
Solution
Fact 1
: If $$$p_1$$$ has an odd bit count, then it can only be broken into two numbers such that one has an odd bit count and the other has an even bit count.
Fact 2
: If either $$$p_1$$$ or $$$p_2$$$ has an even bit count, then this is a winning state.
Reason
: If either $$$p_1$$$ or $$$p_2$$$ has an even bit count, without loss of generality, assume it's $$$p_1$$$. Then break it into $$$2^{msb \text{ of } p_1}$$$ and $$$p_1 \oplus 2^{msb \text{ of } p_1}$$$, where $$$msb$$$ is the most significant bit.
If the opponent chooses $$$2^{msb \text{ of } p_1}$$$, they instantly lose (using Hint $$$1$$$), so they are forced to choose the other number with an odd bit count. From Fact $$$1$$$, we can conclude that in the next turn, the state will remain conserved for the current player.
Because we eliminate the most significant bit in every query, this game will go on for at most $$$60$$$ turns for the player who reached this position first. At one point, the player who is at this state will have a number with two set bits.
Hence, from Hint $$$2$$$, we can say this player will win. So, as Alice, you will start first if $$$n$$$ has an even number of bits and start second if it has an odd number of bits. Proceed using the strategy discussed above. So as Alice you have will start first if $$$n$$$ has even number of bits and start second if it has odd number of bits. Any proceed using the strategy discussed above.
Code
#include<bits/stdc++.h>
 
using namespace std;
 
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
 
    int testcases;cin>>testcases;
 
    for(int testcase=1;testcase<=testcases;testcase++){
        long long n;cin>>n;
        long long curr=n;
        int parity=0;
        if(__builtin_popcountll(n)%2){
            cout<<"secoNd"<<endl;
        }else{
            cout<<"firSt"<<endl;
            parity=1;
        }
        int turn=0;
        while(1){
            if(turn%2==parity){
                long long p1,p2;cin>>p1>>p2;
                if (p1 == 0 && p2 == 0)
                    break;
                if(__builtin_popcountll(p1)%2==0){
                    curr=p1;
                }else{
                    curr=p2;
                }
            }else{
                int pos=0;
                for(int i=0;(1ll<<i)<curr;i++){
                    if(curr&(1ll<<i)){
                        pos=i;
                    }
                }
                long long p1=(1ll<<pos);
                long long p2=curr^p1;
                cout<<p1<<" "<<p2<<endl;
                curr = p1;
            }
            turn++;
        }
    }
}
--------------------------------------------------
Problem ID: 1934D1
Editorial Content:
1934D1 — XOR Break — Solo Version
Hint
To generate any possible $$$m$$$, it takes at most two operations.
Solution
Let's determine the achievable values of $$$m$$$ for a given $$$n$$$.
If $$$n$$$ is a perfect power of $$$2$$$, then it cannot be broken down further, and no $$$m < n$$$ is achievable. Otherwise, if $$$n$$$ has at least two set bits, let's denote the most significant bit as $$$a$$$ and the second most significant bit as $$$b$$$.
Fact 1
: All $$$m$$$ values less than $$$n$$$ are achievable if their most significant bit does not lie between $$$b+1$$$ and $$$a-1$$$.
Reason
: For instance, $$$1001????$$$ can be decomposed into $$$1000????$$$ and $$$0001????$$$, or $$$1001????$$$ and $$$0000????$$$. In either case, we can never flip the $$$6^{th}$$$ or $$$7^{th}$$$ bit.
Using the above fact, we can break the problem into two cases:
Case 1
: If the most significant bit of $$$m$$$ is at position $$$\leq b$$$.
Perform the first operation as $$$2^{b+1} - 1$$$ and $$$n \oplus (2^{b+1} - 1)$$$ ($$$10001????$$$ -> $$$10000????$$$ and $$$000011111$$$ in binary form). Then, any submask of $$$2^{b+1} - 1$$$ can be created in the next operation.
Case 2
: If the most significant bit of $$$m$$$ is at position $$$a$$$.
If the most significant bit of $$$m$$$ is at position $$$a$$$, then $$$m$$$ can be obtained in one operation as $$$m$$$ and $$$m \oplus n$$$, since $$$m < n$$$ as given in the question, and $$$n \oplus m$$$ has its most significant bit $$$< a$$$.
Code
#include<bits/stdc++.h>

using namespace std;
 
using ll = long long;
 
int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    
    ll t;
    cin >> t;
    
    while (t--) {
        ll n, m;
        cin >> n >> m;
        
        ll hi = 0, sec_hi = 0;
        for (ll p = (1LL<<62); p > 0; p >>= 1) {
            if (p & n) {
                if (!hi) hi = p;
                else if (!sec_hi) sec_hi = p;
            }
        }
        bool flag = (sec_hi && ((m & hi) || (m < sec_hi*2)));
        if (!flag) {
            cout << -1 << '\n';
            continue;
        }
        vector<ll> ans = {n, m};
        if (!(m & hi) && !(m & sec_hi)) ans = {n, m^sec_hi, m};
        
        cout << (ll)ans.size()-1 << '\n';
        for (auto &x: ans) cout << x << ' ';
        cout << '\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1934C
Editorial Content:
1934C — Find a Mine
Hint 1
After querying "$$$?$$$ $$$1$$$ $$$1$$$" What do we know about the location of mines?
Answer
If the answer is $$$a_1$$$ the location of one of the mines is $$$(x, y)$$$ such that $$$x+y = a_1+2$$$.
Answer
If the answer is $$$a_1$$$ the location of one of the mines is $$$(x, y)$$$ such that $$$x+y = a_1+2$$$.
Solution 1
Solution
First, we query "$$$?$$$ $$$1$$$ $$$1$$$" then you get a value $$$a_1$$$ and you know that at least one of the mine is on the line $$$x+y=a_1+2$$$.
Now we make two more queries on both ends of this line where it touches the grid. After these two queries, we get two possible locations of the mine. We query one of these positions if we receive $$$0$$$ as the answer then this location otherwise the other location is the answer.
Reason
: One of that two locations contains a mine. The other mine could spoil the result of the query only from one end. If it was closer from the other mine to both of the ends, it would mean that going from one end to the other is shorter through that mine, than through the diagonal. That's impossible.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int T;
    cin >> T;
    while (T--){
        int n, m;
        cin >> n >> m;
        auto query = [&](int x, int y){
            if (x < 1 || x > n || y < 1 || y > m)
                return -1;
            cout << "? " << x << ' ' << y << endl;
            int z;
            cin >> z;
            return z;
        };
        int d = query(1, 1);
        int lx = max(1, 2 + d - m);
        int p = query(lx, 2 + d - lx);
        int rx = max(1, 2 + d - n);
        int q = query(2 + d - rx, rx);
        if (query(lx + p / 2, 2 + d - lx - p / 2) == 0){
            cout << "! " << lx + p / 2 << " " <<  2 + d - lx - p / 2<<endl;
        }else{
            cout << "! " << 2 + d - rx - q / 2 << " " << rx + q / 2 << endl;
        }
    }
}
Solution
First, we query "$$$?$$$ $$$1$$$ $$$1$$$" then you get a value $$$a_1$$$ and you know that at least one of the mine is on the line $$$x+y=a_1+2$$$.
Now we make two more queries on both ends of this line where it touches the grid. After these two queries, we get two possible locations of the mine. We query one of these positions if we receive $$$0$$$ as the answer then this location otherwise the other location is the answer.
Reason
: One of that two locations contains a mine. The other mine could spoil the result of the query only from one end. If it was closer from the other mine to both of the ends, it would mean that going from one end to the other is shorter through that mine, than through the diagonal. That's impossible.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int T;
    cin >> T;
    while (T--){
        int n, m;
        cin >> n >> m;
        auto query = [&](int x, int y){
            if (x < 1 || x > n || y < 1 || y > m)
                return -1;
            cout << "? " << x << ' ' << y << endl;
            int z;
            cin >> z;
            return z;
        };
        int d = query(1, 1);
        int lx = max(1, 2 + d - m);
        int p = query(lx, 2 + d - lx);
        int rx = max(1, 2 + d - n);
        int q = query(2 + d - rx, rx);
        if (query(lx + p / 2, 2 + d - lx - p / 2) == 0){
            cout << "! " << lx + p / 2 << " " <<  2 + d - lx - p / 2<<endl;
        }else{
            cout << "! " << 2 + d - rx - q / 2 << " " << rx + q / 2 << endl;
        }
    }
}
Solution 2
Hint 2
What if we made the second query as "$$$?$$$ $$$n$$$ $$$m$$$"?
Answer
If the answer is $$$a_2$$$ the location of one of the mines is $$$(x, y)$$$ such that $$$x+y = n+m-a_2$$$.
Solution
Using Hint $$$1$$$ and Hint $$$2$$$ if we get the same line equation i.e. $$$n+m-a_2=a_1-2$$$ we can just query one of the endpoints of this line and get the answer.
Otherwise, we can query "$$$?$$$ $$$1$$$ $$$m$$$" and we will get one more line perpendicular to the earlier two. One of the mines has to be on this line therefore there will be a mine either on the intersection of line we got from query $$$1$$$ and query $$$3$$$ or on the intersection of line we got from query $$$2$$$ and query $$$3$$$.
We can make our next query on any of these intersections if we get the answer as $$$0$$$, then this point is the answer otherwise the other point is the answer.
Code (C++)
#include <bits/stdc++.h>

using namespace std;
 
using ll = long long;
 
ll query(ll x, ll y) {
    cout << "? " << x << ' ' << y << endl;
    ll d;
    cin >> d;
    return d;
}
 
int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    
    ll t;
    cin >> t;
    
    while (t--) {
        ll n, m;
        cin >> n >> m;
        
        ll sum1 = query(1, 1) + 2;
        ll sum2 = n + m - query(n, m);
        ll dif1 = query(1, m) + 1 - m;
        
        auto simplify = [&](ll num, ll lim)->ll{
            return max(min(num, lim), 1LL);
        };
        ll x1 = simplify((sum1+dif1)/2, n), y1 = simplify((sum1-dif1)/2, m);
        ll x2 = simplify((sum2+dif1)/2, n), y2 = simplify((sum2-dif1)/2, m);
        
        if (query(x1, y1)) cout << "! " << x2 << ' ' << y2 << endl;
        else cout << "! " << x1 << ' ' << y1 << endl;
    }
    return 0;
}
Hint 2
What if we made the second query as "$$$?$$$ $$$n$$$ $$$m$$$"?
Answer
If the answer is $$$a_2$$$ the location of one of the mines is $$$(x, y)$$$ such that $$$x+y = n+m-a_2$$$.
Answer
If the answer is $$$a_2$$$ the location of one of the mines is $$$(x, y)$$$ such that $$$x+y = n+m-a_2$$$.
Solution
Using Hint $$$1$$$ and Hint $$$2$$$ if we get the same line equation i.e. $$$n+m-a_2=a_1-2$$$ we can just query one of the endpoints of this line and get the answer.
Otherwise, we can query "$$$?$$$ $$$1$$$ $$$m$$$" and we will get one more line perpendicular to the earlier two. One of the mines has to be on this line therefore there will be a mine either on the intersection of line we got from query $$$1$$$ and query $$$3$$$ or on the intersection of line we got from query $$$2$$$ and query $$$3$$$.
We can make our next query on any of these intersections if we get the answer as $$$0$$$, then this point is the answer otherwise the other point is the answer.
Code (C++)
#include <bits/stdc++.h>

using namespace std;
 
using ll = long long;
 
ll query(ll x, ll y) {
    cout << "? " << x << ' ' << y << endl;
    ll d;
    cin >> d;
    return d;
}
 
int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    
    ll t;
    cin >> t;
    
    while (t--) {
        ll n, m;
        cin >> n >> m;
        
        ll sum1 = query(1, 1) + 2;
        ll sum2 = n + m - query(n, m);
        ll dif1 = query(1, m) + 1 - m;
        
        auto simplify = [&](ll num, ll lim)->ll{
            return max(min(num, lim), 1LL);
        };
        ll x1 = simplify((sum1+dif1)/2, n), y1 = simplify((sum1-dif1)/2, m);
        ll x2 = simplify((sum2+dif1)/2, n), y2 = simplify((sum2-dif1)/2, m);
        
        if (query(x1, y1)) cout << "! " << x2 << ' ' << y2 << endl;
        else cout << "! " << x1 << ' ' << y1 << endl;
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1934B
Editorial Content:
1934B — Yet Another Coin Problem
Solution 1
Hint
At max how many $$$1$$$, $$$3$$$, $$$6$$$, $$$10$$$ are required?
Solution
Fact
: You will never need more than $$$2$$$ ones, $$$1$$$ threes, $$$4$$$ sixes and $$$2$$$ tens.
Reason
:
For $$$1$$$: Suppose if you used $$$k$$$ > $$$2$$$ ones, then you could have used one $$$3$$$ and $$$k$$$ — $$$3$$$ ones.
For $$$3$$$: Suppose if you used $$$k$$$ > $$$1$$$ threes, then you could have used one $$$6$$$ and $$$k$$$ — $$$2$$$ threes.
For $$$6$$$: Suppose if you used $$$k$$$ > $$$4$$$ sixes, then you could have used two $$$15$$$'s and $$$k$$$ — $$$5$$$ sixes.
For $$$10$$$: Suppose if you used $$$k$$$ > $$$2$$$ tens, then you could have used two $$$15$$$'s and $$$k$$$ — $$$3$$$ tens.
now since bound on their count is less, we can bruteforce on these count.
Code (C++)
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int testcases;
    cin >> testcases;
    for (int t = 1; t <= testcases; t++)
    {
        int n;
        cin >> n;
        int ans = 1e9;
        for(int ones = 0; ones <= 2; ones++){
            for(int threes = 0; threes <= 1; threes++){
                for(int sixes = 0; sixes <= 4; sixes++){
                    for(int tens = 0; tens <= 2; tens++){
                        int brute_sum = 1*ones + 3*threes + 6*sixes + 10*tens;
                        if(brute_sum <= n && (n-brute_sum)%15 == 0){
                            ans = min(ans, ones + threes + sixes + tens + (n-brute_sum)/15);
                        }
                    }
                }
            }
        }
        cout << ans << endl;
    }
}
Hint
At max how many $$$1$$$, $$$3$$$, $$$6$$$, $$$10$$$ are required?
Solution
Fact
: You will never need more than $$$2$$$ ones, $$$1$$$ threes, $$$4$$$ sixes and $$$2$$$ tens.
Reason
:
For $$$1$$$: Suppose if you used $$$k$$$ > $$$2$$$ ones, then you could have used one $$$3$$$ and $$$k$$$ — $$$3$$$ ones.
For $$$3$$$: Suppose if you used $$$k$$$ > $$$1$$$ threes, then you could have used one $$$6$$$ and $$$k$$$ — $$$2$$$ threes.
For $$$6$$$: Suppose if you used $$$k$$$ > $$$4$$$ sixes, then you could have used two $$$15$$$'s and $$$k$$$ — $$$5$$$ sixes.
For $$$10$$$: Suppose if you used $$$k$$$ > $$$2$$$ tens, then you could have used two $$$15$$$'s and $$$k$$$ — $$$3$$$ tens.
now since bound on their count is less, we can bruteforce on these count.
Code (C++)
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int testcases;
    cin >> testcases;
    for (int t = 1; t <= testcases; t++)
    {
        int n;
        cin >> n;
        int ans = 1e9;
        for(int ones = 0; ones <= 2; ones++){
            for(int threes = 0; threes <= 1; threes++){
                for(int sixes = 0; sixes <= 4; sixes++){
                    for(int tens = 0; tens <= 2; tens++){
                        int brute_sum = 1*ones + 3*threes + 6*sixes + 10*tens;
                        if(brute_sum <= n && (n-brute_sum)%15 == 0){
                            ans = min(ans, ones + threes + sixes + tens + (n-brute_sum)/15);
                        }
                    }
                }
            }
        }
        cout << ans << endl;
    }
}
Solution 2
Hint
When will the greedy logic of choosing the higher-valued coin first work?
Solution
Fact $$$1$$$
: If coins of value $$$1$$$, $$$3$$$, $$$6$$$ and $$$15$$$ were only present the greedy logic of selecting the higher valued first would work.
Reason
: We use coins of value one at most $$$2$$$ times, coins of value three at most $$$1$$$ time, coins of value six at most $$$2$$$ times (if it was used $$$3$$$ times, it would be better to use two coins $$$15 + 3$$$) But we can't use the coin of value $$$3$$$ and both coins of value $$$6$$$ simultaneously, because we would prefer just using $$$15$$$.
It means that these coins may sum up to $$$1 + 1 + 3 + 6 = 11$$$ or $$$1 + 1 + 6 + 6 = 14$$$ at max. So, we may use the value $$$15$$$ greedily, because the remaining part is less than $$$15$$$. When we are left with only the values $$$1$$$, $$$3$$$, and $$$6$$$, greedily solving is obviously correct, because each coin is a divisor of the next coin.
Fact $$$2$$$
: We don't need more than $$$2$$$ ten coins.
Reason
: Better to use $$$2$$$ fifteen coins instead of $$$3$$$ ten coins.
Using the above two facts it can be shown that the answer will have $$$k < 3$$$ ten coin, therefore, answer = $$$\min$$$($$$\text{answer}(n-10*k)+k$$$ assuming $$$1$$$, $$$3$$$, $$$6$$$ and $$$15$$$ coins are only present).
Code (C++)
#include<bits/stdc++.h>
 
using namespace std;
 
int getAns(int n){
    int ans=0;
    ans+=n/15;
    n%=15;
    ans+=n/6;
    n%=6;
    ans+=n/3;
    n%=3;
    ans+=n;
    return ans;
}
 
int main(){
    ios::sync_with_stdio(false), cin.tie(nullptr);
 
    int testcases;
    cin>>testcases;
    for(int i=1;i<=testcases;i++){
        int n;cin>>n;
        if(n<10){
            cout<<getAns(n)<<endl;
        }else if(n<20){
            cout<<min(getAns(n),getAns(n-10)+1)<<endl;
        }else{
            cout<<min({getAns(n),getAns(n-10)+1,getAns(n-20)+2})<<endl;
        }
    }
}
Hint
When will the greedy logic of choosing the higher-valued coin first work?
Solution
Fact $$$1$$$
: If coins of value $$$1$$$, $$$3$$$, $$$6$$$ and $$$15$$$ were only present the greedy logic of selecting the higher valued first would work.
Reason
: We use coins of value one at most $$$2$$$ times, coins of value three at most $$$1$$$ time, coins of value six at most $$$2$$$ times (if it was used $$$3$$$ times, it would be better to use two coins $$$15 + 3$$$) But we can't use the coin of value $$$3$$$ and both coins of value $$$6$$$ simultaneously, because we would prefer just using $$$15$$$.
It means that these coins may sum up to $$$1 + 1 + 3 + 6 = 11$$$ or $$$1 + 1 + 6 + 6 = 14$$$ at max. So, we may use the value $$$15$$$ greedily, because the remaining part is less than $$$15$$$. When we are left with only the values $$$1$$$, $$$3$$$, and $$$6$$$, greedily solving is obviously correct, because each coin is a divisor of the next coin.
Fact $$$2$$$
: We don't need more than $$$2$$$ ten coins.
Reason
: Better to use $$$2$$$ fifteen coins instead of $$$3$$$ ten coins.
Using the above two facts it can be shown that the answer will have $$$k < 3$$$ ten coin, therefore, answer = $$$\min$$$($$$\text{answer}(n-10*k)+k$$$ assuming $$$1$$$, $$$3$$$, $$$6$$$ and $$$15$$$ coins are only present).
Code (C++)
#include<bits/stdc++.h>
 
using namespace std;
 
int getAns(int n){
    int ans=0;
    ans+=n/15;
    n%=15;
    ans+=n/6;
    n%=6;
    ans+=n/3;
    n%=3;
    ans+=n;
    return ans;
}
 
int main(){
    ios::sync_with_stdio(false), cin.tie(nullptr);
 
    int testcases;
    cin>>testcases;
    for(int i=1;i<=testcases;i++){
        int n;cin>>n;
        if(n<10){
            cout<<getAns(n)<<endl;
        }else if(n<20){
            cout<<min(getAns(n),getAns(n-10)+1)<<endl;
        }else{
            cout<<min({getAns(n),getAns(n-10)+1,getAns(n-20)+2})<<endl;
        }
    }
}
--------------------------------------------------
Problem ID: 1934A
Editorial Content:
1934A — Too Min Too Max
Solution
Hint 1
What will be answer if there were only $$$4$$$ elements in the array?
Solution
Suppose if there were only $$$4$$$ elements in the array. Let them be $$$a \leq b \leq c \leq d$$$. Then the answer will be maximum of the three cases which are listed as follows:-
$$$|a-b|+|b-c|+|c-d|+|d-a| = 2*d - 2*a$$$
$$$|a-b|+|b-d|+|d-c|+|c-a| = 2*d-2*a$$$
$$$|a-c|+|c-b|+|b-d|+|d-a| = 2*(d+c)-2*(a+b)$$$
so clearly $$$2*(d+c)-2*(a+b)$$$ is the maximum.
So, to maximize this we can set $$$d$$$, $$$c$$$ as large as possible and $$$a$$$, $$$b$$$ as small as possible i.e. $$$d=a_n$$$, $$$c=a_{n-1}$$$, $$$b=a_{2}$$$ and $$$a=a_{1}$$$ where $$$a_i$$$ means $$$i^{th}$$$ element in sorted order of given array.
Hint 1
What will be answer if there were only $$$4$$$ elements in the array?
Solution
Suppose if there were only $$$4$$$ elements in the array. Let them be $$$a \leq b \leq c \leq d$$$. Then the answer will be maximum of the three cases which are listed as follows:-
$$$|a-b|+|b-c|+|c-d|+|d-a| = 2*d - 2*a$$$
$$$|a-b|+|b-d|+|d-c|+|c-a| = 2*d-2*a$$$
$$$|a-c|+|c-b|+|b-d|+|d-a| = 2*(d+c)-2*(a+b)$$$
so clearly $$$2*(d+c)-2*(a+b)$$$ is the maximum.
So, to maximize this we can set $$$d$$$, $$$c$$$ as large as possible and $$$a$$$, $$$b$$$ as small as possible i.e. $$$d=a_n$$$, $$$c=a_{n-1}$$$, $$$b=a_{2}$$$ and $$$a=a_{1}$$$ where $$$a_i$$$ means $$$i^{th}$$$ element in sorted order of given array.
Code (C++)
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int testcases;
    cin >> testcases;
    for (int t = 1; t <= testcases; t++)
    {
        int n;
        cin >> n;
        vector<int> v(n);
        for (int j = 0; j < n; j++)
        {
            cin >> v[j];
        }
        sort(v.begin(), v.end());
        cout << 2 * (v[n - 1] - v[0]) + 2 * (v[n - 2] - v[1]) << endl;
    }
}
Code (Python)
t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    a = sorted(a)
    ans = 2 * (a[n - 1] - a[0] + a[n - 2] - a[1])
    print(ans)
--------------------------------------------------
Problem ID: 1933G
Editorial Content:
1933G - Turtle Magic: Royal Turtle Shell Pattern
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;

void solve(int tc) { 
  int n, m, q;
  cin >> n >> m >> q;
  bool b[8] = {1, 1, 1, 1, 1, 1, 1, 1};
  int ans = 8;
  cout << ans << '\n';
  while(q--) {
    int r, c;
    cin >> r >> c;
    string shape;
    cin >> shape;
    if((r + (c+1) / 2) % 2) {
      b[0] &= (shape == "circle");
      b[1] &= (shape == "square");
    }
    else {
      b[0] &= (shape == "square");
      b[1] &= (shape == "circle");
    }
    if((r + c / 2) % 2) {
      b[2] &= (shape == "circle");
      b[3] &= (shape == "square");
    }
    else {
      b[2] &= (shape == "square");
      b[3] &= (shape == "circle");
    }

    if((c + (r+1) / 2) % 2) {
      b[4] &= (shape == "circle");
      b[5] &= (shape == "square");
    }
    else {
      b[4] &= (shape == "square");
      b[5] &= (shape == "circle");
    }
    if((c + r / 2) % 2) {
      b[6] &= (shape == "circle");
      b[7] &= (shape == "square");
    }
    else {
      b[6] &= (shape == "square");
      b[7] &= (shape == "circle");
    }
    ans = 0;
    for(int i = 0; i < 8; i++) ans += b[i];
    cout << ans << '\n';
  }
}

int main() {
  int t; 
  cin >> t;
  for(int i = 1; i <= t; i++) solve(i);
}
--------------------------------------------------
Problem ID: 1933F
Editorial Content:
1933F - Turtle Mission: Robot and the Earthquake
Hint
View the task in a relative perspective, with robot RT and the ending location moving downwards instead of rocks moving upwards.
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main(){
    int t;
    cin >> t;
    while (t--){
        int n, m;
    	cin >> n >> m;
    	bool a[n][m + 1];
    	for (int i = 0; i < n; i++) {
    		for (int j = 1; j <= m; j++) {
    			cin >> a[i][j];
    		}
    	}
    	int dp[n][m + 1];
    	for (int i = 0; i < n; i++) {
    		for (int j = 0; j <= m; j++) {
    			dp[i][j] = INT_MAX;
    		}
    	}
    	dp[0][1] = 0;
    	for (int i = 1; i <= m; i++) {
    		for (int j = 0; j < n; j++) {
    			if (a[j][i]){
    			    continue;
    			}
    			dp[j][i] = min(dp[j][i], dp[(j - 1 + n) % n][i - 1] + 1); 
    		}
    		for (int j = 0; j < 3 * n; j++) {
    			if (a[j % n][i] || a[(j - 1 + n) % n][i]){
    			    continue;
    			}
    			dp[j % n][i] = min(dp[j % n][i], dp[(j - 2 + n) % n][i] + 1);
    		}
    	}
    	int ans = INT_MAX;
    	for (int i = 0; i < n; i++) {
    		if (dp[i][m] == INT_MAX){
    		    continue;
    		}
    		int npos = ((n - 1) + dp[i][m]) % n;
    		if (npos < i) npos += n;
    		int cur = dp[i][m] + min(npos - i, n - (npos - i));
    		ans = min(ans, cur);
    	}
    	if(ans == INT_MAX){
    	    cout << -1 << endl;
    	}else{
    	    cout << ans << endl;
    	}
    }
}
--------------------------------------------------
Problem ID: 1933E
Editorial Content:
1933E - Turtle vs. Rabbit Race: Optimal Trainings
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
#define int long long 
#define double long double

void solve(int tc) {
  int n;
  cin >> n;
  int a[n + 1];
  for(int i = 1; i <= n; i++) cin >> a[i];
  int ps[n + 1];
  ps[0] = 0;
  for(int i = 1; i <= n; i++) ps[i] = ps[i - 1] + a[i];
  int q;
  cin >> q;
  while(q--) {
    int l, u;
    cin >> l >> u;
    int lb = l, rb = n;
    while(lb < rb) {
      int mid = (lb + rb + 1) >> 1;
      if(ps[mid] - ps[l - 1] <= u) lb = mid;
      else rb = mid - 1;
    }
    int maxu = -1e18, optid;
    for(int i = max(l, lb - 2); i <= min(n, lb + 2); i++) {
      int t = ps[i] - ps[l - 1];
      int ut = (u + (u - t + 1)) * t / 2;
      if(ut > maxu) {
        maxu = ut;
        optid = i;
      }
    }
    cout << optid << " ";
  }
}

signed main() {
  int t = 1; cin >> t;
  for(int i = 1; i <= t; i++){
    solve(i);
    cout << "\n";
  }
}
--------------------------------------------------
Problem ID: 1933D
Editorial Content:
1933D - Turtle Tenacity: Continual Mods
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t;
    cin >> t;
    while(t--) {
        int n;
        cin >> n;
        int a[n];
        for(int i=0; i<n; i++) cin >> a[i];
        sort(a, a + n);
        if(a[0] != a[1]) {
            cout << "YES\n";
        }
        else {
            bool PASS = 0;
            for(int i=1; i<n; i++) {
                if(a[i] % a[0] != 0) PASS = 1;
            }
            if(PASS) cout << "YES\n";
            else cout << "NO\n";
        }
    }
}
--------------------------------------------------
Problem ID: 1933C
Editorial Content:
1933C - Turtle Fingers: Count the Values of k
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
#define int long long
using namespace std;

void solve(int tc){
    int a, b, l;
    cin >> a >> b >> l;
    set<int> ans;
    for(int i = 0; i <= 34; ++i){
        int x = l;
        bool fail = false;
        for(int _ = 0; _ < i; ++_){
            if(x % a){
                fail = true;
                break;
            }
            x /= a;
        }
        if(fail) break;
        while(true){
            ans.insert(x);
            if(x % b) break;
            x /= b;
        }
    }
    cout << ans.size();
}
 
bool multi = true;
 
signed main() {
    int t = 1;
    if (multi)cin >> t;
    for (int i = 1; i <= t; ++i) {
        solve(i);
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1933B
Editorial Content:
1933B - Turtle Math: Fast Three Task
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>
using namespace std;

int main(){
    int t;
    cin>>t;
    while(t--){
        int k;
        cin>>k;
        int ACC=0;
        bool hv=false;
        for(int i=0;i<k;i++){
            int x;
            cin>>x;
            ACC+=x;
	    if(x%3==1){
		hv=true;
	    }
        }
        if(ACC%3==0){
            cout<<0<<endl;
        }else if(ACC%3==2){
            cout<<1<<endl;
        }else{
            if(hv==true){
                cout<<1<<endl;
            }else{
                cout<<2<<endl;
            }
        }
    }
}
--------------------------------------------------
Problem ID: 1933A
Editorial Content:
1933A - Turtle Puzzle: Rearrange and Negate
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += abs(arr[i]);
        }
        cout << sum << endl;
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1932G
Editorial Content:
1932G - Moving Platforms
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
#define long long long int
#define DEBUG
using namespace std;
 
// @author: pashka
 
struct triple {
    long d, x, y;
};
 
triple eucl(long a, long b) {
    if (b == 0) {
        return {a, 1, 0};
    }
    long k = a / b;
    auto [d, x, y] = eucl(b, a - k * b);
    return {d, y, x - k * y};
}
 
struct test {
    void solve() {
        int n, m, H;
        cin >> n >> m >> H;
        vector<long> l(n);
        for (int i = 0; i < n; i++) cin >> l[i];
        vector<long> s(n);
        for (int i = 0; i < n; i++) cin >> s[i];
 
        vector<vector<int>> g(n);
        for (int i = 0; i < m; i++) {
            int x, y;
            cin >> x >> y;
            x--;
            y--;
            g[x].push_back(y);
            g[y].push_back(x);
        }
 
        const long INF = 1e18;
        vector<long> d(n, INF);
        d[0] = 0;
        set<pair<long, int>> q;
        q.insert({d[0], 0});
        while (!q.empty()) {
            auto p = *q.begin();
            q.erase(p);
            int v = p.second;
            long t = d[v];
            for (int u: g[v]) {
                long a = (l[v] + (t % H) * s[v]) - (l[u] + (t % H) * s[u]);
                a %= H;
                if (a < 0) a += H;
                long b = s[u] - s[v];
                b %= H;
                if (b < 0) b += H;
                // a - bx = yH
                auto [dd, x, y] = eucl(b, H);
                // xb + yH = dd
                if (a % dd != 0) continue;
                x *= a / dd;
                x %= (H / dd);
                if (x < 0) x += H / dd;
                long dt = x;
                if (d[v] + dt + 1 < d[u]) {
                    q.erase({d[u], u});
                    d[u] = d[v] + dt + 1;
                    q.insert({d[u], u});
                }
            }
        }
        long res = d[n - 1];
        if (res == INF) res = -1;
        cout << res << "\n";
    }
};
 
int main() {
    ios::sync_with_stdio(false);
 
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        test().solve();
    }
    
    return 0;
}
--------------------------------------------------
Problem ID: 1932F
Editorial Content:
1932F - Feed Cats
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
//#define int long long
#define pb emplace_back
#define mp make_pair
#define x first
#define y second
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
 
typedef long double ld;
typedef long long ll;
 
using namespace std;
 
mt19937 rnd(time(nullptr));
 
const ll inf = 1e18;
const ll M = 998244353;
const ld pi = atan2(0, -1);
const ld eps = 1e-6;
 
void solve(int tc){
    int n, m;
    cin >> n >> m;
    vector<pair<int, int>> a(m);
    vector<int> op(n + 1);
    vector<vector<int>> del(n + 1);
    for(auto &e: a) {
        cin >> e.x >> e.y;
        op[e.x]++;
        del[e.y].emplace_back(e.x);
    }
    multiset<int> cur;
    vector<int> dp(n + 1);
    for(int i = 1; i <= n; ++i){
        dp[i] = dp[i - 1];
        for(int j = 0; j < op[i]; ++j){
            cur.insert(i);
        }
        if(!cur.empty()){
            dp[i] = max(dp[i], int(dp[*cur.begin() - 1] + cur.size()));
        }
        for(int e: del[i]){
            cur.erase(cur.find(e));
        }
    }
    cout << dp[n];
}
 
bool multi = true;
 
signed main() {
    int t = 1;
    if (multi)cin >> t;
    for (int i = 1; i <= t; ++i) {
        solve(i);
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1932E
Editorial Content:
1932E - Final Countdown
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
#define long long long int
#define DEBUG
using namespace std;
 
// @author: pashka
 
int main() {
    ios::sync_with_stdio(false);
    
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        string s;
        cin >> s;
        reverse(s.begin(), s.end());
        vector<int> a(n + 1);
        for (int i = n - 1; i >= 0; i--) {
            a[i] = a[i + 1] + (s[i] - '0');
        }
        string res;
        int c = 0;
        for (int i = 0; i < n; i++) {
            c += a[i];
            res += (char)(c % 10 + '0');
            c /= 10;
        }
        res += (char)(c + '0');
        while (res.back() == '0') {
            res.pop_back();
        }
        reverse(res.begin(), res.end());
        cout << res << "\n";
    }
 
    return 0;
}
--------------------------------------------------
Problem ID: 1932D
Editorial Content:
1932D - Card Game
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
#define long long long int
#define DEBUG
using namespace std;
 
// @author: pashka
 
int main() {
    ios::sync_with_stdio(false);
    
    int t;
    cin >> t;
    for (int tt = 0; tt < t; tt++) {
        int n;
        cin >> n;
    
        string suites = "CDHS";
    
        string ts;
        cin >> ts;
        int trump = suites.find(ts[0]);
    
        vector<int> bs[4];
        for (int i = 0; i < 2 * n; i++) {
            string s;
            cin >> s;
            bs[suites.find(s[1])].push_back(s[0] - '2');
        }
    
        vector<string> res;
        vector<string> left;
        for (int i = 0; i < 4; i++) {
            sort(bs[i].begin(), bs[i].end());
            if (i == trump) continue;
            if (bs[i].size() % 2 == 1) {
                int x = bs[i].back();
                left.push_back(string() + char('2' + x) + suites[i]);
                bs[i].pop_back();
            }
            for (int j = 0; j < (int) bs[i].size(); j++) {
                int x = bs[i][j];
                res.push_back(string() + char('2' + x) + suites[i]);
            }
        }
        if (left.size() > bs[trump].size()) {
            cout << "IMPOSSIBLE\n";
        } else {
            for (string s : left) {
                res.push_back(s);
                int x = bs[trump].back();
                bs[trump].pop_back();
                res.push_back(string() + char('2' + x) + suites[trump]);
            }
            for (int j = 0; j < (int) bs[trump].size(); j++) {
                int x = bs[trump][j];
                res.push_back(string() + char('2' + x) + suites[trump]);
            }
            for (int i = 0; i < 2 * n; i += 2) {
                cout << res[i] << " " << res[i + 1] << "\n";
            }
        }
    }
}
--------------------------------------------------
Problem ID: 1932C
Editorial Content:
1932C - LR-remainders
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
int main() {
    int t;
    cin >> t;
    forn(tt, t) {
        int n, m;
        cin >> n >> m;
        vector<int> a(n);
        forn(i, n)
            cin >> a[i];
        string s;
        cin >> s;
 
        int l = 0;
        int r = n - 1;
        forn(i, n - 1)
            if (s[i] == 'L')
                l++;
            else
                r--;
        assert(l == r);
 
        vector<int> b(n);
        b[n - 1] = a[l] % m;
 
        for (int i = n - 2; i >= 0; i--) {
            if (s[i] == 'L')
                b[i] = (b[i + 1] * a[--l]) % m;
            else
                b[i] = (b[i + 1] * a[++r]) % m;
        }
        assert(l == 0);
        assert(r == n - 1);
 
        forn(i, n)
            cout << b[i] << " ";
        cout << endl;
    }
}
--------------------------------------------------
Problem ID: 1932B
Editorial Content:
1932B - Chaya Calendar
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    a = [int(x) for x in input().split()]
    cur = 0
    for e in a:
        cur += e - cur % e
    print(cur)
 
 
for _ in range(1, int(input()) + 1):
    solve()
--------------------------------------------------
Problem ID: 1932A
Editorial Content:
1932A - Thorns and Coins
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
signed main() {
    cin.tie(nullptr);
    cout.tie(nullptr);
    ios::sync_with_stdio(false);
 
    int t;
    cin >> t;
    for(int _ = 0; _ < t; ++_){
        int n, ans = 0;
        cin >> n;
        string s;
        cin >> s;
        for (int i = 1; i < n; i++) {
            ans += (s[i] == '@');
            if (s[i] == '*' && s[i - 1] == '*')
                break;
        }
        cout << ans << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1931G
Editorial Content:
1931G - One-Dimensional Puzzle
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <algorithm>
 
using namespace std;
 
typedef long long ll;
 
const int mod = 998244353;
 
ll pow_mod(ll x, ll p) {
    if (p == 0) {
        return 1;
    }
    if (p % 2 == 0) {
        ll y = pow_mod(x, p / 2);
        return (y * y) % mod;
    }
    return (x * pow_mod(x, p - 1)) % mod;
}
 
ll inv(ll x) {
    return pow_mod(x, mod - 2);
}
 
vector<ll> fact = {1};
 
ll cnk(ll n, ll k) {
    ll res = fact[n];
    res = (res * inv(fact[k])) % mod;
    res = (res * inv(fact[n - k])) % mod;
    return res;
}
 
ll calc(int n1, int n2, int n3, int n4) {
    return (cnk(n1 + n3 - 1, n3) * cnk(n2 + n4 - 1, n4)) % mod;
}
 
void solve() {
    int n1, n2, n3, n4;
    cin >> n1 >> n2 >> n3 >> n4;
    if (n1 + n2 == 0) {
        cout << (n3 == 0 || n4 == 0 ? 1 : 0) << '\n';
        return;
    }
    if (abs(n1 - n2) > 1) {
        cout << "0\n";
        return;
    }
    ll res = 0;
    if (n1 <= n2) {
        res += calc(n1 + 1, n2, n3, n4);
    }
    if (n2 <= n1) {
        res += calc(n1, n2 + 1, n3, n4);
    }
    cout << res % mod << '\n';
}
 
int main() {
    for (ll i = 1; i <= 4e6; ++i) {
        fact.push_back((fact.back() * i) % mod);
    }
    int t;
    cin >> t;
    for (int _ = 0; _ < t; ++_) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1931F
Editorial Content:
1931F - Chat Screenshots
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <algorithm>
 
using namespace std;
 
typedef long long ll;
 
int timer = 0;
 
void dfs(int v, vector<vector<int>> &g, vector<bool> &vis, vector<int> &tout) {
    vis[v] = true;
    for (int u: g[v]) {
        if (!vis[u]) {
            dfs(u, g, vis, tout);
        }
    }
    tout[v] = timer++;
}
 
void solve() {
    timer = 0;
    int n, k;
    cin >> n >> k;
    vector<vector<int>> a(k, vector<int>(n));
    vector<int> authors(k);
    for (int i = 0; i < k; ++i) {
        for (int j = 0; j < n; ++j) {
            cin >> a[i][j];
            a[i][j]--;
        }
        authors[i] = a[i][0];
    }
    vector<vector<int>> g(n);
    for (int i = 0; i < k; ++i) {
        for (int j = 1; j + 1 < n; ++j) {
            int i1 = a[i][j], i2 = a[i][j + 1];
            g[i1].push_back(i2);
        }
    }
    vector<int> tout(n, -1);
    vector<bool> vis(n);
    for (int i = 0; i < n; ++i) {
        if (tout[i] == -1) {
            dfs(i, g, vis, tout);
        }
    }
    for (int i = 0; i < k; ++i) {
        for (int j = 1; j + 1 < n; ++j) {
            int i1 = a[i][j], i2 = a[i][j + 1];
            if (tout[i1] < tout[i2]) {
                cout << "NO";
                return;
            }
        }
    }
    cout << "YES";
}
 
int main() {
    int t;
    cin >> t;
    for (int _ = 0; _ < t; ++_) {
        solve();
        cout << "\n";
    }
}
--------------------------------------------------
Problem ID: 1931E
Editorial Content:
1931E - Anna and the Valentine's Day Gift
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
#define all(arr) arr.begin(), arr.end()
 
using namespace std;
 
const int MAXN = 200200;
 
int n, m;
string arr[MAXN];
int len[MAXN], zrr[MAXN];
 
void build() {
    memset(zrr, 0, sizeof(*zrr) * n);
    for (int i = 0; i < n; ++i) {
        len[i] = arr[i].size();
        for (auto it = arr[i].rbegin(); it != arr[i].rend() && *it == '0'; ++it) {
            ++zrr[i];
        }
    }
}
 
string solve() {
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        ans += len[i] - zrr[i];
    }
    sort(zrr, zrr + n);
    reverse(zrr, zrr + n);
    for (int i = 0; i < n; ++i) {
        if (i & 1) ans += zrr[i];
    }
    return (ans - 1 >= m ? "Sasha" : "Anna");
}
 
int main() {
    int t; cin >> t;
    while (t--) {
        cin >> n >> m;
        for (int i = 0; i < n; ++i)
            cin >> arr[i];
        build();
        cout << solve() << '\n';
    }
}
--------------------------------------------------
Problem ID: 1931D
Editorial Content:
1931D - Divisible Pairs
Tutorial
Tutorial is loading...
Solution
def solve():
    n, x, y = map(int, input().split())
    a = [int(x) for x in input().split()]
    cnt = dict()
    ans = 0
    for e in a:
        xx, yy = e % x, e % y
        ans += cnt.get(((x - xx) % x, yy), 0)
        cnt[(xx, yy)] = cnt.get((xx, yy), 0) + 1
    print(ans)
    
    
for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1931C
Editorial Content:
1931C - Make Equal Again
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    i1 = 0
    i2 = 0
    while i1 < n and a[i1] == a[0]:
        i1 += 1
    while i2 < n and a[n - i2 - 1] == a[n - 1]:
        i2 += 1
    res = n
    if a[0] == a[n - 1]:
        res -= i1
        res -= i2
    else:
        res -= max(i1, i2)
    print(max(0, res))
 
 
t = int(input())
 
 
for i in range(t):
    solve()
--------------------------------------------------
Problem ID: 1931B
Editorial Content:
1931B - Make Equal
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    a = [int(x) for x in input().split()]
    k = sum(a) // n
    for i in range(n - 1):
        if a[i] < k:
            print('NO')
            return
        a[i + 1] += a[i] - k
        a[i] = k
    print('YES')
    
    
for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1931A
Editorial Content:
1931A - Recovering a Small String
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>
using namespace std;
 
 
void solve(){
    int n, sz = 26;
    cin >> n;
    string mins = "zzz", cur;
    for(int i = 0; i < sz; i++){
        for(int j = 0; j < sz; j++){
            for(int k = 0; k < sz; k++){
                if(i + j + k + 3 == n){
                    cur += char(i + 'a');
                    cur += char(j + 'a');
                    cur += char(k + 'a');
                    mins = min(cur, mins);
                }
            }
        }
    }
    cout << mins << "\n";
 
}
int main(){
    int t;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1930I
Editorial Content:
1930I - Counting Is Fun
Hint 1
A167510
Solution
It is convinient here to assign weights to $$$\mathtt{0} \to -1$$$ and $$$\mathtt{1} \to 1$$$.
Given a string $$$t$$$, we can define the prefix sum $$$p$$$ of it's weights. For example, if $$$t=\mathtt{0010111}$$$, then $$$p=[0,-1,-2,-1,-2,-1,0,1]$$$. So that if $$$t$$$ is bad and $$$i$$$ is a index that violates the definition, then $$$\max(p_0,p_1,\ldots,p_{i-1}) < \min(p_i,p_{i+1},\ldots,p_n)$$$ if $$$s_i = \mathtt{0}$$$ or $$$\min(p_0,p_1,\ldots,p_{i-1}) > \max(p_i,p_{i+1},\ldots,p_n)$$$ if $$$s_i = \mathtt{1}$$$.
Naturally, it is convinient to assume that $$$p_0 < p_n$$$. All string with $$$p_0 = p_n$$$ are clearly good and $$$p_0 > p_n$$$ is handled similarly. For strings with $$$p_0 < p_n$$$, the condition can only be violated on an index with $$$s_i = \mathtt{0}$$$.
The solution works using PIE. Let us fix a set of positions $$$I$$$ that are bad, so that if $$$i \in I$$$, then $$$s_i =\mathtt{0}$$$ and $$$\max(p_0,p_1,\ldots,p_{i-1}) < \min(p_i,p_{i+1},\ldots,p_n)$$$. Then we need to count the number of ways to construct $$$p$$$ satisfying these conditions and then add it to the answer multiplied by $$$(-1)^{|I|}$$$.
Suppose that $$$I = i_1,i_2,\ldots,i_k$$$. $$$t[1,i_1]$$$ and $$$t[i_k,n]$$$ need to be a ballot sequence of length $$$i_1-1$$$ and $$$n-i_k$$$ respectively (A001405, denote it as $$$f(n)$$$) while $$$t[i_j,i_{j+1}]$$$ needs to be bidirectional ballot sequence of length $$$i_{j+1}-i_j-1$$$ (A167510, denote it as $$$g(n)$$$). Note that in our definition of ballot sequence, we are do not require that prefixes and suffixes have strictly more $$$\mathtt{1}$$$ s thatn $$$\mathtt{0}$$$ s. It is the same sequence, but note that we need to shift it by a few places when refering to OEIS.
The first $$$n$$$ terms of $$$f$$$ is easily computed in linear time. We will focus on how to compute the first $$$n$$$ terms of $$$g$$$ in $$$O(n \log^2 n)$$$.
Computing $$$g(n)$$$
Firstly, let us consider the number of bidirectional sequences with $$$\frac{n+k}{2}$$$ $$$\mathtt{1}$$$ s and $$$\frac{n-k}{2}$$$ $$$\mathtt{0}$$$ s. We will imagine this as lattice walks from $$$(0,0)$$$ to $$$(n,k)$$$ where $$$\mathtt{1} \to (1,1)$$$ and $$$\mathtt{0} \to (1,-1)$$$. If we touch the lines $$$y=-1$$$ or $$$y=k+1$$$, the walk is invalid.
We can use the reflection method here, similar to a proof of Catalan. The number of valid walks is $$$#(*) - #(T) + #(TB) - #(TBT) ..... - #(B) + #(BT) - #(BTB) + .....$$$ where $$$#(BTB)$$$ denotes the number of walks that touch the bottom line, then the top line, then the bottom line, and then may continue to touch the top and bottom line after that.
We have $$$#(*) =$$$ $$$\binom{n}{\frac{n+k}{2}}$$$, $$$#(T) =$$$ $$$ \binom{n}{\frac{n+k+2}{2}}$$$, $$$#(TB) =$$$ $$$ \binom{n}{\frac{n+3k+4}{2}}$$$, $$$#(TBT) =$$$ $$$ \binom{n}{\frac{n+3k+6}{2}}$$$, $$$\ldots$$$, $$$#(B) = $$$ $$$\binom{n}{\frac{n+k+2}{2}}$$$, $$$#(BT) =$$$ $$$ \binom{n}{\frac{n+k+4}{2}}$$$, $$$#(BTB) =$$$ $$$ \binom{n}{\frac{n+3k+6}{2}}$$$, $$$\ldots$$$
This already gives us a method to compute $$$g(n)$$$ in $$$O(n \log n)$$$ since for a fixed $$$k$$$, we can compute the above sum in $$$O(\frac{n}{k})$$$, since only the first $$$O(\frac{n}{k})$$$ terms are not $$$0$$$.
First, notice that we can aggregate them sums without iterating on $$$k$$$, for some fixed $$$j$$$, we can find the coefficient $$$c_j$$$ of $$$\binom{n}{\frac{n+j}{2}}$$$ across all $$$k$$$. Notice that this coefficient is independent across all $$$n$$$, so we only need to compute $$$c$$$ once.
Now, note that $$$\binom{n}{\frac{n+z}{2}} = [x^z] (x^{-1} + x) ^ n$$$. So that $$$g(n) = [x^0] C \cdot (x^{-1} + x)^n$$$, where $$$C$$$ is the ogf of $$$c$$$.
From this formulation, we can describe how to compute the first $$$n$$$ terms of $$$g$$$ in $$$O(n \log^2 n)$$$ using Divide and Conquer.
$$$DnC(l,r,V)$$$ computes the $$$g(l) \ldots g(r)$$$ where $$$V$$$ is the coefficents between $$$[l-r,r-l]$$$ of $$$C \cdot (x^{-1} + x)^l$$$. $$$DnC(l,r,V)$$$ will call $$$DnC(l,m,V)$$$ and $$$DnC(m+1,r,V \cdot (x^{-1}+x)^{m-l+1})$$$. We have the reccurence $$$T(n) = 2 T(\frac{n}{2}) + O(n \log n)$$$ so $$$T(n) = O(n \log^2 n)$$$.
Of course, for constant time speedup, you can choose to split the odd and even coefficients, but that is not needed.
It is possible to compute the first $$$n$$$ of $$$g$$$ in $$$O(n \log n)$$$ but it does not improve the overall complexity of the solution.
Final Steps
Now that we obtained the $$$n$$$ terms of $$$f$$$ and $$$g$$$, let us return to the origial problem.
If $$$s_i =\mathtt{0}$$$, define $$$dp_i = f(i-1) - \sum\limits_{s_j = \mathtt{0}} dp_j \cdot g(j-i-1)$$$. Then this contributes $$$f(n-i) \cdot dp_i$$$ to the number of bad strings.
Again, we will use Divide and Conquer to perform this quickly.
Briefly, $$$DnC(l,r)$$$ will compute the values of $$$dp[l,r]$$$ given that contributions from $$$dp[1,l-1]$$$ has been transferred to $$$dp[l,r]$$$ already.
We will call $$$DnC(l,m)$$$, compute the contribution from $$$dp[l,m]$$$ to $$$dp[m+1,r]$$$ using FFT and then call $$$DnC(m+1,r)$$$. The complexity of this is $$$O(n \log^2 n)$$$.
Code(errorgorn)
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define ll long long
#define ii pair<int,int>
#define iii tuple<int,int,int>
#define fi first
#define se second
#define endl '\n'
#define debug(x) cout << #x << ": " << x << endl

#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define lb lower_bound
#define ub upper_bound

#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

mt19937 rng(chrono::system_clock::now().time_since_epoch().count());


const int MOD=998244353;

ll qexp(ll b,ll p,int m){
    ll res=1;
    while (p){
        if (p&1) res=(res*b)%m;
        b=(b*b)%m;
        p>>=1;
    }
    return res;
}

ll inv(ll i){
	return qexp(i,MOD-2,MOD);
}

ll fix(ll i){
	i%=MOD;
	if (i<0) i+=MOD;
	return i;
}

ll fac[1000005];
ll ifac[1000005];

ll nCk(int i,int j){
	if (i<j) return 0;
	return fac[i]*ifac[j]%MOD*ifac[i-j]%MOD;
}

const ll mod = (119 << 23) + 1, root = 62; // = 998244353
// For p < 2^30 there is also e.g. 5 << 25, 7 << 26, 479 << 21
// and 483 << 21 (same root). The last two are > 10^9.
typedef vector<ll> vl;
void ntt(vl &a) {
	int n = sz(a), L = 31 - __builtin_clz(n);
	static vl rt(2, 1);
	for (static int k = 2, s = 2; k < n; k *= 2, s++) {
		rt.resize(n);
		ll z[] = {1, qexp(root, mod >> s, mod)};
		rep(i,k,2*k) rt[i] = rt[i / 2] * z[i & 1] % mod;
	}
	vector<int> rev(n);
	rep(i,0,n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;
	rep(i,0,n) if (i < rev[i]) swap(a[i], a[rev[i]]);
	for (int k = 1; k < n; k *= 2)
		for (int i = 0; i < n; i += 2 * k) rep(j,0,k) {
			ll z = rt[j + k] * a[i + j + k] % mod, &ai = a[i + j];
			a[i + j + k] = ai - z + (z > ai ? mod : 0);
			ai += (ai + z >= mod ? z - mod : z);
		}
}
vl conv(const vl &a, const vl &b) {
	if (a.empty() || b.empty()) return {};
	int s = sz(a) + sz(b) - 1, B = 32 - __builtin_clz(s), n = 1 << B;
	int inv = qexp(n, mod - 2, mod);
	vl L(a), R(b), out(n);
	L.resize(n), R.resize(n);
	ntt(L), ntt(R);
	rep(i,0,n) out[-i & (n - 1)] = (ll)L[i] * R[i] % mod * inv % mod;
	ntt(out);
	return {out.begin(), out.begin() + s};
}

int n;
string s;

int c[100005];
int f[100005];

void calc(int l,int r,vector<int> v){
	while (sz(v)>(r-l)*2+1) v.pob();
	
	if (l==r){
		f[l]=v[0];
		return;
	}
	
	int m=l+r>>1;
	
	calc(l,m,vector<int>(v.begin()+(r-m),v.end()));
	vector<int> a;
	int t=m-l+1;
	rep(x,0,t+1) a.pub(nCk(t,x)),a.pub(0);
	
	v=conv(v,a);
	calc(m+1,r,vector<int>(v.begin()+(2*t),v.end()));
}

int ans[100005];

void solve(int l,int r){
	if (l==r) return;
	int m=l+r>>1;
	solve(l,m);
	auto a=conv(vector<int>(ans+l,ans+m+1),vector<int>(f,f+(r-l)));
	rep(x,m+1,r+1) if (s[x]=='0') ans[x]=fix(ans[x]-a[x-1-l]);
	solve(m+1,r);
}


signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin.exceptions(ios::badbit | ios::failbit);
	
	fac[0]=1;
	rep(x,1,1000005) fac[x]=fac[x-1]*x%MOD;
	ifac[1000004]=inv(fac[1000004]);
	rep(x,1000005,1) ifac[x-1]=ifac[x]*x%MOD;
	
	rep(x,1,100005){
		c[x]++;
		
		int curr=x;
		while (curr<100005){
			if (curr+2<100005) c[curr+2]-=2;
			if (curr+4<100005) c[curr+4]++;
			if (curr+2*x+4<100005) c[curr+2*x+4]++;
			curr+=2*x+4;
		}
	}
	
	cin>>n;
	cin>>s;
	
	vector<int> v;
	rep(x,n+1,1) v.pub(fix(c[x]+(x>=2?c[x-2]:0LL)));
	calc(1,n,v);
	f[0]=1;
	
	int fin=qexp(2,n,MOD);
	rep(_,0,2){
		rep(x,0,n) ans[x]=(s[x]=='0')?nCk(x,x/2):0LL;
		solve(0,n-1);
		rep(x,0,n) if (s[x]=='0') fin=fix(fin-ans[x]*nCk((n-x-1),(n-x-1)/2));
		
		for (auto &it:s) it^=1;
	}
	
	cout<<fin<<endl;
}
--------------------------------------------------
Problem ID: 1930H
Editorial Content:
1930H - Interactive Mex Tree
Hint 1
$$$\operatorname{MEX}$$$ of the path from $$$u$$$ to $$$v$$$ will be the minimum value over all the nodes of $$$T$$$ which do not lie on the path from $$$u$$$ to $$$v$$$.
Hint 2
$$$p_1$$$ and $$$p_2$$$ are associated with the Euler tour
Hint 3
$$$p_1$$$ is the permutation of $$$[1,2, \ldots n]$$$ sorted in increasing order on the basis on $$$tin$$$ time observed during Euler tour. Similarly, $$$p_2$$$ is the permutation of $$$[1,2, \ldots n]$$$ sorted in increasing order based on $$$tout$$$ time. Note that any Euler tour is fine.
Solution
Now we have $$$p_1$$$ and $$$p_2$$$ with us. Suppose we need to find $$$\operatorname{MEX}$$$ of the path from $$$u$$$ to $$$v$$$. Assume that $$$tin_u < tin_v$$$ for convenience. Assume $$$T'$$$ is the forest we get if we remove all the nodes on the path from $$$u$$$ to $$$v$$$ from $$$T$$$. Our goal is to find the minimum value over all the nodes in $$$T'$$$. Assume that $$$T'$$$ is non-empty, as $$$\operatorname{MEX}$$$ will be $$$n$$$ if $$$T'$$$ is empty. Assume $$$LCA$$$ is the lowest common ancestor of $$$u$$$ and $$$v$$$. Suppose $$$m$$$ is the child of $$$LCA(u,v)$$$, which lies on the path from $$$v$$$ to $$$LCA(u,v)$$$.
Let us consider some groups of nodes $$$p$$$ such that.
$$$tout_p < tin_u$$$
$$$tin_u < tin_p < tin_m$$$
$$$tin_m < tout_p < tin_v$$$
$$$tin_v < tin_p$$$
$$$tout_{LCA} < tout_p$$$
Note that we have precisely $$$5$$$ groups, with the $$$i$$$-th group consisting of only those nodes which satisfy the $$$i$$$-th condition.
Here comes the interesting claim. All nodes in $$$T'$$$ are present in atleast one of the above $$$5$$$ groups. There does not exist a node $$$p$$$ such that $$$p$$$ is on the path from $$$u$$$ from $$$v$$$ and $$$p$$$ is present in any of the groups.
Now, it is not hard to observe that if we consider the nodes of any group, they will form a continuous segment in either $$$p_1$$$ or $$$p_2$$$. So we can cover each group in a single query. Hence, we can find the $$$\operatorname{MEX}$$$ of the path in any round using atmost $$$5$$$ queries.
Code
#include <bits/stdc++.h>   
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;   
using namespace std;
#define ll long long
const ll INF_ADD=1e18;
#define pb push_back                  
#define mp make_pair          
#define nline "\n"                            
#define f first                                            
#define s second                                             
#define pll pair<ll,ll> 
#define all(x) x.begin(),x.end()     
const ll MOD=998244353;
const ll MAX=200200;   
vector<ll> adj[MAX];
ll now=0,till=20;
vector<ll> tin(MAX,0),tout(MAX,0),depth(MAX,0);
vector<vector<ll>> jump(MAX,vector<ll>(till+1,0));
void dfs(ll cur,ll par){
    jump[cur][0]=par;
    for(ll i=1;i<=till;i++)
        jump[cur][i]=jump[jump[cur][i-1]][i-1];
    tin[cur]=++now;
    for(ll chld:adj[cur]){
        if(chld!=par){
            depth[chld]=depth[cur]+1;
            dfs(chld,cur);
        }
    }
    tout[cur]=++now;
} 
bool is_ancestor(ll a,ll b){
    if((tin[a]<=tin[b])&&(tout[a]>=tout[b]))
        return 1;
    return 0;
} 
ll lca(ll a,ll b){
    if(is_ancestor(a,b))
        return a;
    for(ll i=till;i>=0;i--){
        if(!is_ancestor(jump[a][i],b))
            a=jump[a][i];
    }
    return jump[a][0];
}  
void solve(){
    ll n; cin>>n;
    ll m; cin>>m;
    vector<ll> a(n+5);
    for(ll i=1;i<=n-1;i++){
        ll u,v; cin>>u>>v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    now=1;
    dfs(1,1);
    vector<ll> p(n),q(n);
    for(ll i=0;i<n;i++){
        p[i]=q[i]=i+1;
    }
    sort(all(p),[&](ll l,ll r){
        return tin[l]<tin[r];
    });
    sort(all(q),[&](ll l,ll r){
        return tout[l]<tout[r];
    });
    for(auto it:p){
        cout<<it<<" ";
    }
    cout<<endl;
    for(auto it:q){
        cout<<it<<" ";
    }
    cout<<endl;
    auto query_p=[&](ll l,ll r){
        ll left_pos=n+1,right_pos=-1;
        for(ll i=0;i<n;i++){
            ll node=p[i];
            if((tin[node]>=l) and (tin[node]<=r)){
                left_pos=min(left_pos,i);
                right_pos=i;
            }
        }
        ll now=n+5;
        if(right_pos!=-1){
            left_pos++,right_pos++;
            cout<<"? 1 "<<left_pos<<" "<<right_pos<<endl;
            cin>>now;
        }
        return now;
    };
    auto query_q=[&](ll l,ll r){
        ll left_pos=n+1,right_pos=-1;
        for(ll i=0;i<n;i++){
            ll node=q[i];
            if((tout[node]>=l) and (tout[node]<=r)){
                left_pos=min(left_pos,i);
                right_pos=i;
            }
        }
        ll now=n+5;
        if(right_pos!=-1){
            left_pos++,right_pos++;
            cout<<"? 2 "<<left_pos<<" "<<right_pos<<endl;
            cin>>now;
        }
        return now;
    };
    while(m--){
        ll u,v; cin>>u>>v;
        if(tout[u]>tout[v]){
            swap(u,v);
        }
        ll lca_node=lca(u,v);
        ll ans=n;
        if(lca_node==v){
            ans=min(ans,query_q(1,tin[u]));
            ans=min(ans,query_p(tin[u]+1,tout[v]));
            ans=min(ans,query_q(tout[v]+1,now));
            cout<<"! "<<ans<<endl;
            ll x; cin>>x;
            continue;
        }
        ans=min(ans,query_q(1,tin[u]));
        ll consider=v;
        for(auto it:adj[lca_node]){
            if(is_ancestor(lca_node,it) and is_ancestor(it,v)){
                consider=it;
            }
        }
        ans=min(ans,query_p(tin[u]+1,tin[consider]-1));
        ans=min(ans,query_q(tin[consider],tin[v]));
        ans=min(ans,query_p(tin[v]+1,tout[lca_node]));
        ans=min(ans,query_q(tout[lca_node]+1,now));
        cout<<"! "<<ans<<endl;
        ll x; cin>>x;
    }
    for(ll i=1;i<=n;i++){
        adj[i].clear();
    }
    return;  
}                                       
int main()                                                                               
{     
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL); 
    #ifndef ONLINE_JUDGE                 
    freopen("input.txt", "r", stdin);                                           
    freopen("output.txt", "w", stdout);      
    freopen("error.txt", "w", stderr);                        
    #endif  
    ll test_cases=1;                 
    cin>>test_cases;
    while(test_cases--){
        solve();
    }
    cout<<fixed<<setprecision(10);
    cerr<<"Time:"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms\n"; 
}
--------------------------------------------------
Problem ID: 1930G
Editorial Content:
1930G - Prefix Max Set Counting
Hint 1
Consider some subsequence $$$S$$$ of $$$[1,2, \ldots n]$$$ such that there exists atleast one pre-order $$$a$$$ such that $$$F(a)=S$$$. Look for some non-trivial properties about $$$S$$$. Node $$$S_i$$$ will be visited before the node $$$S_{i+1}$$$.
Hint 2
Assume $$$|S|=k$$$. First of all, we should $$$S_1=1$$$ and $$$S_k = n$$$. There cannot exists there distinct indices $$$a, b$$$ and $$$c$$$ ($$$1 \leq a < b < c \leq |k|$$$) such that $$$S_c$$$ lies on the path from $$$S_a$$$ to $$$S_b$$$. Assume $$$LCA_i$$$ is the lowest common ancestor of $$$S_i$$$ and $$$S_{i+1}$$$. For all $$$i$$$($$$1 \leq i <k$$$), the largest value over all the nodes on the unique path from $$$S_i$$$ to $$$S_{i+1}$$$ should be $$$S_{i+1}$$$.
Hint 3
Suppose $$$nax_p$$$ is the maximum value in the subtree of $$$p$$$. There is one more important restriction if $$$S_i$$$ does not lie on the path from $$$S_{i+1}$$$ to $$$1$$$. Suppose $$$m$$$ is the child of $$$LCA_i$$$, which lies on the path from $$$S_i$$$ to $$$LCA_i$$$. We should have $$$S_{i+1} > nax_m$$$. In fact, if you observe carefully you will realise that we should have $$$S_i = nax_m$$$.
Solution
Let us use dynamic programming. Suppose $$$dp[i]$$$ gives the number of valid subsequences(say $$$S$$$) such that the last element of $$$S$$$ is $$$i$$$. Note that the answer to our original problem will be $$$dp[n]$$$.
Suppose $$$nax(u,v)$$$ denotes the maximum value on the path from $$$u$$$ to $$$v$$$(including the endpoints).
Let us have a $$$O(n^2)$$$ solution first.
We have $$$dp[1]=1$$$.
Suppose we are at some node $$$i$$$($$$i > 1$$$), and we need to find $$$dp[i]$$$. Let us consider some node $$$j$$$($$$1 \le j < i$$$) and see if we can append $$$i$$$ to all the subsequences which end with node $$$j$$$. If we can append, we just need to add $$$dp[j]$$$ to $$$dp[i]$$$.
But how do we check if we can append $$$i$$$ to all the subsequences that end with node $$$j$$$?
Check hints 2 and 3.
So, we have a $$$n^2$$$ solution now.
We need to optimise it now.
We will move in the increasing value of the nodes(from $$$2$$$ to $$$n$$$) and calculate the $$$dp$$$ values.
Suppose $$$nax(1, par_i) = v$$$, where $$$par_i$$$ denotes the parent of $$$i$$$.
Assume we go from node $$$j$$$($$$j < i$$$) to node $$$i$$$.
There are two cases:
$$$j$$$ lies on the path from $$$1$$$ to $$$i$$$: This case is easy, as we just need to ensure that $$$nax(j,par_i) = j$$$. We can add $$$dp[j]$$$ to $$$dp[i]$$$ if we have $$$nax(j,par_i) = j$$$. Note that there exists only one node(node $$$v$$$) for which might add $$$dp[v]$$$ to $$$dp[i]$$$
$$$j$$$ does not lie on the path from $$$1$$$ to $$$i$$$ : We will only consider the case in which $$$dp[j]$$$ will be added to $$$dp[i]$$$. Suppose $$$lca$$$ is the lowest common ancestor of $$$j$$$ and $$$i$$$, and $$$m$$$ is the child of $$$lca$$$, which lies on the path from $$$j$$$ to $$$lca$$$. Notice that the largest value in the subtree of $$$m$$$ should be $$$j$$$. This observation is quite helpful. We can traverse over all the ancestors of $$$i$$$. Suppose that we are at ancestor $$$u$$$. We will iterate over all the child(say $$$c$$$) of $$$u$$$ such that $$$nax_c < i$$$, and add $$$dp[nax_c]$$$ to $$$dp[i]$$$ if $$$nax(u,par_i) < nax_c$$$. Suppose $$$track[u][i]$$$ stores the sum of $$$dp[nax_c]$$$ for all $$$c$$$ such that $$$nax_c < i$$$. So we should add $$$track[u][i]$$$ to $$$dp[i]$$$. But there is a catch. This way, $$$dp[nax_c]$$$ will also get added $$$dp[i]$$$ even when $$$nax_c < nax(u, par_i)$$$. So, we need to subtract some values, which is left as an exercise for the readers. Now, $$$track[u][d] = track[u][d-1] + dp[nax_c]$$$ if $$$nax_c = d$$$. So, instead of keeping a two-dimensional array $$$track$$$, we can just maintain a one-dimensional array $$$track$$$. Note that we will only need the sum of $$$track[u]$$$ for all the ancestors of $$$i$$$, which we can easily calculate using the euler tour.
You can look at the attached code for the implementation details.
The intended time complexity is $$$O(n \cdot \log(n))$$$.
Code
#include <bits/stdc++.h>   
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;   
using namespace std;
#define ll long long
#define pb push_back                  
#define mp make_pair          
#define nline "\n"                            
#define f first                                            
#define s second                                             
#define pll pair<ll,ll> 
#define all(x) x.begin(),x.end()     
const ll MOD=998244353;
const ll MAX=1000100;
struct FenwickTree{
    vector<ll> bit; 
    ll n;
    FenwickTree(ll n){
        this->n = n;
        bit.assign(n, 0);
    }
    FenwickTree(vector<ll> a):FenwickTree(a.size()){  
        ll x=a.size();
        for(size_t i=0;i<x;i++)
            add(i,a[i]);
    }
    ll sum(ll r) {
        ll ret=0;
        for(;r>=0;r=(r&(r+1))-1){
            ret+=bit[r];
            ret%=MOD;
        }
        return ret;
    }
    ll sum(ll l,ll r) {
        if(l>r)
            return 0;
        ll val=sum(r)-sum(l-1)+MOD;
        val%=MOD;
        return val;
    }
    void add(ll idx,ll delta) {
        for(;idx<n;idx=idx|(idx+1)){
            bit[idx]+=delta;
            bit[idx]%=MOD;
        }
    }
};
vector<vector<ll>> adj;
vector<ll> tin(MAX,0),tout(MAX,0);
vector<ll> parent(MAX,0);
vector<ll> overall_max(MAX,0);
ll now=1;
vector<ll> jump_to(MAX,0),sub(MAX,0);
void dfs(ll cur,ll par){
    parent[cur]=par;
    tin[cur]=now++;
    overall_max[cur]=cur;
    for(auto chld:adj[cur]){
        if(chld!=par){
            jump_to[chld]=max(jump_to[cur],cur);
            dfs(chld,cur);
            overall_max[cur]=max(overall_max[cur],overall_max[chld]);
        }
    }
    tout[cur]=now++;
}
vector<ll> dp(MAX,0);
void solve(){ 
    ll n; cin>>n;
    adj.clear();
    adj.resize(n+5);
    for(ll i=1;i<=n-1;i++){
        ll u,v; cin>>u>>v;
        adj[u].push_back(v);  
        adj[v].push_back(u);
    }  
    now=1;      
    dfs(1,0);      
    ll ans=0;    
    FenwickTree enter_time(now+5),exit_time(now+5);
    overall_max[0]=MOD;   
    dp[0]=1;    
    for(ll i=1;i<=n;i++){
        ll p=jump_to[i];
        dp[i]=(enter_time.sum(0,tin[i])-exit_time.sum(0,tin[i])-sub[p]+dp[p]+MOD+MOD)%MOD;
        if(p>i){  
            dp[i]=0;
        }
        ll node=i;
        while(overall_max[node]==i){
            node=parent[node];
        }
        enter_time.add(tin[node],dp[i]);
        exit_time.add(tout[node],dp[i]);
        sub[i]=(enter_time.sum(0,tin[i])-exit_time.sum(0,tin[i])+MOD)%MOD;
    }
    cout<<dp[n]<<nline;
    return;  
}                                       
int main()                                                                               
{       
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);                               
    #ifndef ONLINE_JUDGE                 
    freopen("input.txt", "r", stdin);                                           
    freopen("output.txt", "w", stdout);      
    freopen("error.txt", "w", stderr);                        
    #endif     
    ll test_cases=1;                 
    cin>>test_cases;
    while(test_cases--){
        solve();
    }
    cout<<fixed<<setprecision(10);
    cerr<<"Time:"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms\n"; 
}
--------------------------------------------------
Problem ID: 1930F
Editorial Content:
1930F - Maximize the Difference
Hint 1
For an array $$$b$$$ consiting of $$$m$$$ non-negative integers, $$$f(b) = \max\limits_{p=1}^{m} ( \max\limits_{i = 1}^{m} (b_i | b_p) - \min\limits_{i = 1}^{m} (b_i | b_p))$$$. In other, we can get the maximum possible value by choosing $$$x=b_p$$$ for some $$$p$$$ ($$$1 \leq p \leq m$$$).
Hint 2
$$$f(b)$$$ is the maximum value of $$$b_i \land $$$ ~ $$$b_j$$$ over all pairs of ($$$i,j$$$) ($$$1 \leq i,j \leq m$$$), where $$$\land$$$ is the bitwise AND operator, and ~ is the bitwise One's complement operator.
Solution
Let us see how to find $$$f(b)$$$ in $$$O(n \log(n))$$$ first. We will focus on updates later. Let us have two sets $$$S_1$$$ and $$$S_2$$$ such that
$$$S_1$$$ contains all submasks of $$$b_i$$$ for all $$$1 \leq i \leq m$$$
$$$S_2$$$ contains all submasks of ~$$$b_i$$$for all $$$1 \leq i \leq m$$$
We can observe that $$$f(b)$$$ is the largest element present in both sets $$$S_1$$$ and $$$S_2$$$.
Now, we can insert all submasks naively. But it would be pretty inefficient. Note that we need to insert any submask atmost once in either of the sets.
Can you think of some approach in which you efficiently insert all the non-visited submasks of some mask?
Pseudo Code
insert_submask(cur, S){
    return if mask cur is present in S
    add mask cur to the set S
    vec = list of all the set bits of the mask cur
    for i in vec:
        insert_submask(cur - 2^i)
}
Note that the above pseudo code inserts all the all submasks efficiently. As all the masks will be visited atmost once, the amortised complexity will be $$$O(n \log(n)^2)$$$. Note that instead of using a set, we can use a boolean array of size $$$n$$$ to reduce the complexity to $$$O(n \log(n))$$$.
Thus, we can use the above idea to find $$$f(b)$$$ in $$$O(n \log(n))$$$. For each $$$i$$$ from $$$1$$$ to $$$m$$$, we can insert all submasks of $$$b_i$$$ into set $$$S_1$$$ and insert all the submasks of ~$$$b_i$$$ into set $$$S_2$$$.
The above idea hints at how to deal with updates. If we need to append an element $$$z$$$ to $$$b$$$, we can just insert all submasks of $$$z$$$ into set $$$S_1$$$ and insert all the submasks of ~$$$z$$$ into set $$$S_2$$$.
Hence, the overall complexity is $$$O(n \log(n))$$$.
Pseudo Code
insert_submask(cur, S){
    return if mask cur is present in S
    add mask cur to the set S
    vec = list of all the set bits of the mask cur
    for i in vec:
        insert_submask(cur - 2^i)
}
Code
#pragma GCC optimize("O3,unroll-loops")
#include <bits/stdc++.h>   
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;   
using namespace std;
#define ll long long
#define pb push_back                  
#define mp make_pair          
#define nline "\n"                            
#define f first                                            
#define s second                                             
#define pll pair<ll,ll> 
#define all(x) x.begin(),x.end() 
const ll MAX=100100; 
void solve(){     
    ll n,q; cin>>n>>q;
    ll till=1,len=1;
    while(till<n){
        till*=2;
        len++;
    }
    ll ans=0;
    vector<vector<ll>> track(2,vector<ll>(till+5,0));
    auto add=[&](ll x,ll p){
        queue<ll> trav;
        if(track[p][x]){
            return;
        }
        trav.push(x); track[p][x]=1;
        while(!trav.empty()){
            auto it=trav.front();
            trav.pop();
            if(track[0][it]&track[1][it]){
                ans=max(ans,it);
            }
            for(ll j=0;j<len;j++){
                if(it&(1<<j)){
                    ll cur=(it^(1<<j));   
                    if(!track[p][cur]){
                        track[p][cur]=1;
                        trav.push(cur);
                    }
                }
            }
        }
    };
    ll supermask=till-1;
    vector<ll> a(q+5);
    for(ll i=1;i<=q;i++){
        ll h; cin>>h; 
        a[i]=(h+ans)%n;
        add(a[i],0);
        add(supermask^a[i],1);
        cout<<ans<<" \n"[i==q];
    }
    return;  
}                                         
int main()                                                                               
{     
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);                               
    #ifndef ONLINE_JUDGE                 
    freopen("input.txt", "r", stdin);                                           
    freopen("output.txt", "w", stdout);      
    freopen("error.txt", "w", stderr);                        
    #endif     
    ll test_cases=1;                 
    cin>>test_cases;
    while(test_cases--){
        solve();
    }
    cout<<fixed<<setprecision(10);
    cerr<<"Time:"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms\n"; 
}
--------------------------------------------------
Problem ID: 1930E
Editorial Content:
1930E - 2..3...4.... Wonderful! Wonderful!
Hint 1
Suppose you are given some array $$$b$$$ of length $$$m$$$ and a positive integer $$$k$$$. How to check whether we can get the array $$$b$$$ if we start with an array $$$a$$$ of length $$$n$$$ such that $$$a_i = i$$$ for all $$$i$$$ ($$$1 \leq i \leq n$$$)?
Hint 2
First of all, array $$$b$$$ should be a subsequence of $$$a$$$. Now consider an increasing array $$$c$$$ (possibly empty) such that it contains all the elements of $$$a$$$ which are not present in $$$b$$$.  Now look at some trivial necessary conditions.
The length of array $$$c$$$ should divisible by $$$2k$$$, as exactly $$$2k$$$ elements were deleted in one operation.
There should be atleast one element $$$v$$$ in $$$b$$$ such that there are atleast $$$k$$$ elements smaller than $$$v$$$ in the array $$$c$$$, and alteast $$$k$$$ elements greater than $$$v$$$ in the array $$$c$$$. Why? Think about the last operation. We can consider the case of empty $$$c$$$ separately.
In fact, it turns out that these necessary conditions are sufficient (Why?).
Solution
Now, we need to find the number of possible $$$b$$$. We can instead find the number of binary strings $$$s$$$ of length $$$n$$$ such that $$$s_i = 1$$$ if $$$i$$$ is present in $$$b$$$, and $$$s_i=0$$$ otherwise.
For given $$$n$$$ and $$$k$$$, let us call $$$s$$$
good
if there exists some $$$b$$$ which can be achieved from $$$a$$$.
Instead of counting strings $$$s$$$ which are
good
, let us count the number of strings which are not
good
.
For convenience, we will only consider strings $$$s$$$ having the number of $$$\mathtt{0}$$$'s divisible by $$$2k$$$.
Now, based on the conditions in hint $$$2$$$, we can conclude that $$$s$$$ is
bad
if and only if there does not exist any $$$1$$$ between the $$$k$$$-th $$$0$$$ from the left and the $$$k$$$-th $$$0$$$ from the right in $$$s$$$.
Let us compress all the $$$\mathtt{0}$$$'s between the $$$k$$$-th $$$0$$$ from the left and the $$$k$$$-th $$$0$$$ from the right into a single $$$0$$$ and call the new string $$$t$$$. Note that $$$t$$$ will have exactly $$$2k - 1$$$ $$$\mathtt{0}$$$'s. We can also observe that for each $$$t$$$, a unique $$$s$$$ exists. This is only because we have already fixed the parameters $$$n$$$ and $$$k$$$. Thus the number of
bad
$$$s$$$ having exactly $$$x$$$ $$$\mathtt{1}$$$'s is $$${{x + 2k - 1} \choose {2k - 1}}$$$ as there are exactly $$${{x + 2k - 1} \choose {2k - 1}}$$$ binary strings $$$t$$$ having $$$2k - 1$$$ $$$\mathtt{0}$$$'s and $$$x$$$ $$$\mathtt{1}$$$'s.
Finally, there are exactly $$$\binom{n}{x} - \binom{x + 2k - 1}{2k - 1}$$$
good
binary strings $$$s$$$ having $$$x$$$ $$$\mathtt{1}$$$'s and $$$n-x$$$ $$$\mathtt{0}$$$'s. Now, do we need to find this value for each $$$x$$$ from $$$1$$$ to $$$n$$$? No, as the number($$$n-x$$$) of $$$\mathtt{0}$$$'s in $$$s$$$ should be a multiple of $$$2k$$$. There are only $$$O(\frac{n}{2k})$$$ useful candidates for $$$x$$$.
Thus, our overall complexity is $$$O(n \log(n))$$$ (as $$$\sum_{i=1}^{n} O(\frac{n}{i}) = O(n \log(n))$$$).
Code
#pragma GCC optimize("O3,unroll-loops")
#include <bits/stdc++.h>   
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;   
using namespace std;
#define ll long long
const ll INF_ADD=1e18;
#define pb push_back                  
#define mp make_pair          
#define nline "\n"                            
#define f first                                            
#define s second                                             
#define pll pair<ll,ll> 
#define all(x) x.begin(),x.end()     
const ll MOD=998244353;
const ll MAX=5000500;
vector<ll> fact(MAX+2,1),inv_fact(MAX+2,1);
ll binpow(ll a,ll b,ll MOD){
    ll ans=1;
    a%=MOD;  
    while(b){
        if(b&1)
            ans=(ans*a)%MOD;
        b/=2;
        a=(a*a)%MOD;
    }
    return ans;
}
ll inverse(ll a,ll MOD){
    return binpow(a,MOD-2,MOD);
} 
void precompute(ll MOD){
    for(ll i=2;i<MAX;i++){
        fact[i]=(fact[i-1]*i)%MOD;
    }
    inv_fact[MAX-1]=inverse(fact[MAX-1],MOD);
    for(ll i=MAX-2;i>=0;i--){
        inv_fact[i]=(inv_fact[i+1]*(i+1))%MOD;
    }
}
ll nCr(ll a,ll b,ll MOD){
    if(a==b){
        return 1;
    }
    if((a<0)||(a<b)||(b<0))
        return 0;   
    ll denom=(inv_fact[b]*inv_fact[a-b])%MOD; 
    return (denom*fact[a])%MOD;    
}
ll n,k;    
ll ways(ll gaps,ll options){
    gaps--;
    ll now=nCr(gaps+options-1,options-1,MOD);
    return now;
}
void solve(){
    cin>>n; 
    for(ll k=1;k<=(n-1)/2;k++){
        ll ans=1;
        for(ll deleted=2*k;deleted<=n-1;deleted+=2*k){
            ll options=2*k,left_elements=n-deleted;
            ans=(ans+ways(left_elements+1,deleted+1)-ways(left_elements+1,options)+MOD)%MOD;  
        }
        cout<<ans<<" ";
    }
    cout<<nline;
    return;   
}                                       
int main()                                                                               
{     
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL); 
    #ifndef ONLINE_JUDGE                 
    freopen("input.txt", "r", stdin);                                           
    freopen("output.txt", "w", stdout);      
    freopen("error.txt", "w", stderr);                        
    #endif  
    ll test_cases=1;                 
    cin>>test_cases;
    precompute(MOD);
    while(test_cases--){
        solve();
    }
    cout<<fixed<<setprecision(10);
    cerr<<"Time:"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms\n"; 
}
--------------------------------------------------
Problem ID: 1930D2
Editorial Content:
1930D2 - Sum over all Substrings (Hard Version)
Hint 1
We can use the idea of D1 and dynamic programming to solve in $$$O(n)$$$.
Solution
Suppose $$$dp[i][j]$$$ denotes $$$f(s[i,j])$$$ for all $$$1 \le i \le j \le n$$$.
Performing the transition is quite easy.
If $$$s_i = \mathtt{1}$$$, $$$dp[i][j]=1+dp[i+3][j]$$$, otherwise $$$dp[i][j]=dp[i+1][j]$$$. Note that $$$dp[i][j] = 0$$$ for if $$$i > j$$$.
So if we fix $$$j$$$, we can find $$$dp[i][j]$$$ for all $$$1 \le i \le j$$$ in $$$O(n)$$$, and the original problem in $$$O(n^2)$$$.
Now, we need to optimise it.
Suppose $$$track[i] = \sum_{j=i}^{n} dp[i][j]$$$ for all $$$1 \le i \le n$$$, with base condition that $$$track[i] = 0$$$ if $$$i > n$$$.
There are two cases:
$$$s_i = \mathtt{0}$$$ :
$$$track[i] = \sum_{j=i}^{n} dp[i][j]$$$
$$$track[i] = dp[i][i] + \sum_{j=i+1}^{n} dp[i][j]$$$
$$$track[i] = dp[i][i] + \sum_{j=i+1}^{n} dp[i+1][j]$$$
$$$track[i] = track[i+1]$$$ as $$$dp[i][i]=0$$$
$$$s_i = \mathtt{1}$$$ :
$$$track[i] = \sum_{j=i}^{n} dp[i][j]$$$
$$$track[i] = \sum_{j=i}^{n} 1 + dp[i+3][j]$$$
$$$track[i] = n - i + 1 + \sum_{j=i+3}^{n} dp[i+3][j]$$$ as $$$dp[i+3][i]=dp[i+3][i+1]=dp[i+3][i+2]=0$$$
$$$track[i] = n - i + 1 + \sum_{j=i+3}^{n} dp[i+3][j]$$$
$$$track[i] = n - i + 1 + track[i+3]$$$
So, the answer to the original problem is $$$\sum_{i=1}^{n} track[i]$$$, which we can do in $$$O(n)$$$.
Code
#include <bits/stdc++.h>   
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;   
using namespace std;
#define ll long long
#define pb push_back                  
#define mp make_pair          
#define nline "\n"                            
#define f first                                            
#define s second                                             
#define pll pair<ll,ll> 
#define all(x) x.begin(),x.end()     
const ll MOD=1e9+7;
const ll MAX=500500;
void solve(){ 
    ll n,ans=0; cin>>n;
    string s; cin>>s; s=" "+s;
    vector<ll> dp(n+5,0);
    for(ll i=n;i>=1;i--){
        if(s[i]=='1'){
            dp[i]=dp[i+3]+n-i+1;
        }
        else{
            dp[i]=dp[i+1];
        }
        ans+=dp[i];
    }
    cout<<ans<<nline;
    return;  
}                                       
int main()                                                                               
{     
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);                               
    #ifndef ONLINE_JUDGE                 
    freopen("input.txt", "r", stdin);                                           
    freopen("output.txt", "w", stdout);      
    freopen("error.txt", "w", stderr);                        
    #endif     
    ll test_cases=1;                 
    cin>>test_cases;
    while(test_cases--){
        solve();
    }
    cout<<fixed<<setprecision(10);
    cerr<<"Time:"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms\n"; 
}
--------------------------------------------------
Problem ID: 1930D1
Editorial Content:
1930D1 - Sum over all Substrings (Easy Version)
Hint 1
To find $$$f(s)$$$, we can partition $$$s$$$ into multiple independent substrings of length atmost $$$3$$$ and find best answer for them separately.
Hint 2
There always exists a string $$$g$$$ such that:
$$$g$$$ is $$$s-good$$$
there are $$$f(s)$$$ number of $$$\mathtt{1} $$$s in $$$g$$$
$$$g$$$ is of the form $$$b_1 + b_2 + \ldots b_q$$$, where $$$b_i$$$ is either equal to $$$\mathtt{0}$$$ or $$$\mathtt{010}$$$.
Solution
First of all, append $$$n$$$ $$$\mathtt{0} $$$ s to the back of $$$s$$$ for our convenience. Note that this does not change the answer.
Now let us call a binary string $$$p$$$ of size $$$d$$$
nice
if:
there exists a positive integer $$$k$$$ such that $$$d = 3k$$$
$$$p$$$ is of form $$$ f(\mathtt{0} , k) + f(\mathtt{1} , k) + f(\mathtt{0} , k) $$$, where $$$f(c, z)$$$ gives a string containing exactly $$$z$$$ characters equal to $$$c$$$.
Suppose binary string $$$t$$$ is one of the $$$s-good$$$ strings such that there are exactly $$$f(s)$$$ $$$\mathtt{1} $$$ s in $$$t$$$.
We claim that for any valid $$$t$$$, there always exists a binary string $$$t'$$$ such that:
$$$t'$$$ is permutation of $$$t$$$
$$$t'$$$ is $$$s-good$$$
$$$t'$$$ is of the form $$$f(\mathtt{0}, d_1) + z_1 + f(\mathtt{0}, d_2) + z_2 + f(\mathtt{0}, d_3) + \ldots + z_g + f(\mathtt{0}, d_{g+1}) $$$, where $$$z_1, z_2, \ldots z_g$$$ are
nice
binary strings and $$$d_1, d_2, \ldots d_{g+1}$$$ are non-negative integers.
Proof
Initially, all the $$$\mathtt{1} $$$s in $$$s$$$ are unmarked. We will mark all of them and modify the string $$$t$$$ in the process.
We will do the following recursive process unless all the $$$\mathtt{1} $$$ s in $$$s$$$ are marked.
Find the index of leftmost unmarked $$$\mathtt{1} $$$ in $$$s$$$. Suppose its index is $$$x$$$. Now suppose $$$y$$$ is the largest index such that there are an equal number of $$$\mathtt{0} $$$ s and $$$\mathtt{1} $$$ s in substring $$$t[x, y]$$$. Note that $$$y$$$ will always exist as we appended some extra $$$\mathtt{0} $$$s in the starting. Now we can rearrange the characters in substring $$$t[x,y]$$$, as they will still contain an equal number of $$$\mathtt{0} $$$ s and $$$\mathtt{1} $$$ s and $$$\mathtt{1} $$$ will still be the mode of substring $$$t[x,y]$$$. Obviously rearranging the characters in $$$t[x,y]$$$ to $$$\mathtt{0} \ldots \mathtt{0} \mathtt{1} \ldots \mathtt{1}$$$ is the best we can do. We will mark all the $$$\mathtt{1} $$$ s in substring $$$s[x,y]$$$. Suppose $$$y-x+1 = 2v$$$. Now $$$t[y+1,y+v]$$$ might contain some $$$\mathtt{1} $$$ s. Say there are $$$z$$$ $$$\mathtt{1} $$$ s in $$$t[y+1,y+v]$$$ initially. We will do the following operation exactly $$$z$$$ times.
Find the leftmost $$$\mathtt{1} $$$ in substring $$$t[y+1,y+v]$$$. Find the leftmost $$$\mathtt{0} $$$ in substring $$$t[y+v+1,2n]$$$. Swap both characters.
Now note that $$$t[x,x+3v-1]$$$ will be of form $$$f(\mathtt{0}, v) + f(\mathtt{1}, v) + f(\mathtt{0}, v)$$$. It is easy to verify that in the updated $$$t$$$, there won't be any index $$$i$$$ for which there does not exist two indices $$$1 \le l \le i \le r \le 2n$$$ such that $$$s_i$$$ is
mode
of $$$t[l,r]$$$.
Now we can mark all the $$$\mathtt{1} $$$ s in substring $$$s[x+2v,x+3v-1]$$$ too, as $$$t[x+v,x+3v-1]$$$ contain equal number of $$$\mathtt{0} $$$ s and $$$\mathtt{1} $$$ s.
It is not hard to conclude that the updated $$$t$$$ will be of form $$$f(\mathtt{0}, d_1) + z_1 + f(\mathtt{0}, d_2) + z_2 + f(\mathtt{0}, d_3) + \ldots + z_g + f(\mathtt{0}, d_{g+1}) $$$, where $$$z_1, z_2, \ldots z_g$$$ are
nice
binary strings and $$$d_1, d_2, \ldots d_{g+1}$$$ are non-negative integers.
Note that the $$$\mathtt{1}$$$ s in $$$t[x, x + 3v - 1]$$$ won't help the $$$\mathtt{1}$$$ s in $$$s[x + 3v, 2n]$$$. So, we can solve for $$$s[x + 3v, 2n]$$$ independently.
Let $$$t'$$$ be the updated $$$t$$$.
Now, carefully observe the structure of $$$t'$$$. We can replace all the substrings of the form $$$ f(\mathtt{0} , k) + f(\mathtt{1} , k) + f(\mathtt{0} , k) $$$ in $$$t'$$$ with $$$ \mathtt{0} \mathtt{1} \mathtt{0} \mathtt{0} \mathtt{1} \mathtt{0} \ldots \mathtt{0} \mathtt{1} \mathtt{0} \mathtt{0} \mathtt{1} \mathtt{0}$$$.
So the updated $$$t'$$$(say $$$t"$$$) will be of form $$$b_1 + b_2 + \ldots b_q$$$, where $$$b_i$$$ is either equal to $$$\mathtt{0}$$$ or $$$\mathtt{010}$$$.
So whenever we need to find $$$f(e)$$$ for some binary string $$$e$$$, we can always try to find a string of form $$$t"$$$ using as few $$$\mathtt{1} $$$s as possible. Notice that we can construct $$$t"$$$ greedily. You can look at the attached code for the implementation details. Also, we don't need to actually append the $$$\mathtt{0} $$$s at the back of $$$s$$$. It was just for proof purposes.
Proof
Initially, all the $$$\mathtt{1} $$$s in $$$s$$$ are unmarked. We will mark all of them and modify the string $$$t$$$ in the process.
We will do the following recursive process unless all the $$$\mathtt{1} $$$ s in $$$s$$$ are marked.
Find the index of leftmost unmarked $$$\mathtt{1} $$$ in $$$s$$$. Suppose its index is $$$x$$$. Now suppose $$$y$$$ is the largest index such that there are an equal number of $$$\mathtt{0} $$$ s and $$$\mathtt{1} $$$ s in substring $$$t[x, y]$$$. Note that $$$y$$$ will always exist as we appended some extra $$$\mathtt{0} $$$s in the starting. Now we can rearrange the characters in substring $$$t[x,y]$$$, as they will still contain an equal number of $$$\mathtt{0} $$$ s and $$$\mathtt{1} $$$ s and $$$\mathtt{1} $$$ will still be the mode of substring $$$t[x,y]$$$. Obviously rearranging the characters in $$$t[x,y]$$$ to $$$\mathtt{0} \ldots \mathtt{0} \mathtt{1} \ldots \mathtt{1}$$$ is the best we can do. We will mark all the $$$\mathtt{1} $$$ s in substring $$$s[x,y]$$$. Suppose $$$y-x+1 = 2v$$$. Now $$$t[y+1,y+v]$$$ might contain some $$$\mathtt{1} $$$ s. Say there are $$$z$$$ $$$\mathtt{1} $$$ s in $$$t[y+1,y+v]$$$ initially. We will do the following operation exactly $$$z$$$ times.
Find the leftmost $$$\mathtt{1} $$$ in substring $$$t[y+1,y+v]$$$. Find the leftmost $$$\mathtt{0} $$$ in substring $$$t[y+v+1,2n]$$$. Swap both characters.
Now note that $$$t[x,x+3v-1]$$$ will be of form $$$f(\mathtt{0}, v) + f(\mathtt{1}, v) + f(\mathtt{0}, v)$$$. It is easy to verify that in the updated $$$t$$$, there won't be any index $$$i$$$ for which there does not exist two indices $$$1 \le l \le i \le r \le 2n$$$ such that $$$s_i$$$ is
mode
of $$$t[l,r]$$$.
Now we can mark all the $$$\mathtt{1} $$$ s in substring $$$s[x+2v,x+3v-1]$$$ too, as $$$t[x+v,x+3v-1]$$$ contain equal number of $$$\mathtt{0} $$$ s and $$$\mathtt{1} $$$ s.
It is not hard to conclude that the updated $$$t$$$ will be of form $$$f(\mathtt{0}, d_1) + z_1 + f(\mathtt{0}, d_2) + z_2 + f(\mathtt{0}, d_3) + \ldots + z_g + f(\mathtt{0}, d_{g+1}) $$$, where $$$z_1, z_2, \ldots z_g$$$ are
nice
binary strings and $$$d_1, d_2, \ldots d_{g+1}$$$ are non-negative integers.
Note that the $$$\mathtt{1}$$$ s in $$$t[x, x + 3v - 1]$$$ won't help the $$$\mathtt{1}$$$ s in $$$s[x + 3v, 2n]$$$. So, we can solve for $$$s[x + 3v, 2n]$$$ independently.
Let $$$t'$$$ be the updated $$$t$$$.
Code
#include <bits/stdc++.h>   
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;   
using namespace std;
#define ll long long
#define pb push_back                  
#define mp make_pair          
#define nline "\n"                            
#define f first                                            
#define s second                                             
#define pll pair<ll,ll> 
#define all(x) x.begin(),x.end()     
const ll MOD=1e9+7;
const ll MAX=500500;
ll f(string s){
    ll len=s.size(),ans=0,pos=0;
    while(pos<len){
        if(s[pos]=='1'){
            ans++;
            pos+=2;
        }
        pos++;
    }
    return ans;
}
void solve(){ 
    ll n,ans=0; cin>>n;
    string s; cin>>s; 
    for(ll i=0;i<n;i++){
        string t; 
        for(ll j=i;j<n;j++){
            t.push_back(s[j]);
            ans+=f(t);
        }
    }
    cout<<ans<<nline;
    return;  
}                                       
int main()                                                                               
{     
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);                               
    #ifndef ONLINE_JUDGE                 
    freopen("input.txt", "r", stdin);                                           
    freopen("output.txt", "w", stdout);      
    freopen("error.txt", "w", stderr);                        
    #endif     
    ll test_cases=1;                 
    cin>>test_cases;
    while(test_cases--){
        solve();
    }
    cout<<fixed<<setprecision(10);
    cerr<<"Time:"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms\n"; 
}
--------------------------------------------------
Problem ID: 1930C
Editorial Content:
1930C - Lexicographically Largest
Hint 1
Consider an array $$$c$$$ of length $$$n$$$ such that $$$c_i :=$$$
number of indices smaller than $$$i$$$ which were chosen before index $$$i$$$
.
So set $$$S$$$ will be a collection of $$$a_i + i - c_i$$$ over all $$$1 \leq i \leq n$$$.
Solution
Now one might wonder what type of arrays $$$c$$$ is it possible to get.
First, it is easy to see that we should have $$$0 \leq c_i < i$$$ for all $$$i$$$. Call an array $$$c$$$ of length $$$n$$$
good
, if $$$0 \leq c_i < i$$$ for all $$$1 \leq i \leq n$$$. The claim is that all
good
arrays of length $$$n$$$ can be obtained.
Proof
We can prove it by induction on $$$n$$$.
$$$c_1 = 0$$$ always holds. Now $$$c_2$$$ can either be $$$0$$$ or $$$1$$$. We can obtain $$$c_2 = 0$$$ by deleting the element at index $$$2$$$ before the element at index $$$1$$$. We can also obtain $$$c_2 = 1$$$ by deleting it after deleting the element at index $$$1$$$. Thus, all
good
arrays of length 2 can be obtained.
Now assume that it is possible to obtain all
good
arrays of length atmost $$$k$$$. Choose an integer $$$x$$$ ($$$0 \leq x \leq k$$$) arbitrarily.  Consider the following sequence for the order of deletion:
The elements at indices $$$1, 2, \ldots, x$$$ in the same order.
The element at index $$$k$$$.
The elements at indices $$$x + 1, \ldots, k - 1$$$ in the same order.
It is easy to see that the array obtained on performing the above sequence of operations is a
good
array of length $$$k + 1$$$ with $$$c_{k+1} = x$$$. Hence we can establish a bijection between the sequence of order of deletion and the number of
good
arrays.
So we have the following subproblem. We have a set $$$S$$$. We will iterate $$$i$$$ from $$$1$$$ to $$$n$$$, select an integer $$$c_i$$$ ($$$0 \leq c_i \leq i - 1$$$) and insert $$$a_i + i - c_i$$$ into set $$$S$$$ and move to $$$i + 1$$$. Now using exchange arguments, we can prove that it is never bad if we select the smallest integer $$$v$$$ ($$$0 \leq v \leq i - 1$$$) such that $$$a_i + i - v$$$ is not present in the set $$$S$$$, and assign it to $$$c_i$$$. Note that as we have $$$i$$$ options for $$$v$$$, and we would have inserted exactly $$$i-1$$$ elements before index $$$i$$$, there always exists an integer $$$v$$$ ($$$0 \leq v \leq i - 1$$$) such that $$$a_i + i - v$$$ is not present in the set $$$S$$$. You can refer to the attached submission to see how to find $$$v$$$ efficiently for each $$$i$$$.
Proof
We can prove it by induction on $$$n$$$.
$$$c_1 = 0$$$ always holds. Now $$$c_2$$$ can either be $$$0$$$ or $$$1$$$. We can obtain $$$c_2 = 0$$$ by deleting the element at index $$$2$$$ before the element at index $$$1$$$. We can also obtain $$$c_2 = 1$$$ by deleting it after deleting the element at index $$$1$$$. Thus, all
good
arrays of length 2 can be obtained.
Now assume that it is possible to obtain all
good
arrays of length atmost $$$k$$$. Choose an integer $$$x$$$ ($$$0 \leq x \leq k$$$) arbitrarily.  Consider the following sequence for the order of deletion:
The elements at indices $$$1, 2, \ldots, x$$$ in the same order.
The element at index $$$k$$$.
The elements at indices $$$x + 1, \ldots, k - 1$$$ in the same order.
It is easy to see that the array obtained on performing the above sequence of operations is a
good
array of length $$$k + 1$$$ with $$$c_{k+1} = x$$$. Hence we can establish a bijection between the sequence of order of deletion and the number of
good
arrays.
Code
#include <bits/stdc++.h>     
using namespace std;
#define ll long long
void solve(){ 
    ll n; cin>>n;
    set<ll> used,not_used;
    vector<ll> ans;
    for(ll i=1;i<=n;i++){
        ll x; cin>>x; x+=i;
        if(!used.count(x)){
            not_used.insert(x);
        }
        ll cur=*(--not_used.upper_bound(x)); //find the largest element(<= x) which is not in set "used"
        not_used.erase(cur);
        ans.push_back(cur);
        used.insert(cur);
        if(!used.count(cur-1)){
            not_used.insert(cur-1);
        }
    }
    sort(ans.begin(), ans.end());
    reverse(ans.begin(), ans.end());
    for(auto i:ans){
        cout<<i<<" ";
    }  
    cout<<"\n";
    return;  
}                                       
int main()                                                                               
{       
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);                               
    #ifndef ONLINE_JUDGE                   
    freopen("input.txt", "r", stdin);                                           
    freopen("output.txt", "w", stdout);      
    freopen("error.txt", "w", stderr);                        
    #endif     
    ll test_cases=1;                 
    cin>>test_cases;
    while(test_cases--){
        solve();
    }
    cout<<fixed<<setprecision(10);
    cerr<<"Time:"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms\n"; 
}
--------------------------------------------------
Problem ID: 1930B
Editorial Content:
1930B - Permutation Printing
Hint 1
For integers $$$x$$$ ($$$\lfloor \frac{n}{2} \rfloor < x \leq n$$$), there does not exist integer $$$y$$$ ($$$y > x$$$) such that $$$y$$$ is divisible by $$$x$$$.
Solution
Consider the permutation $$$p$$$ such that $$$p=[1, n, 2, n - 1, \ldots \lceil \frac{n+1}{2} \rceil]$$$. It is valid. Why?
Proof
We have $$$\max(p_a, p_{a+1}) > \lfloor \frac{n}{2} \rfloor$$$ for all $$$1 \leq a < n - 1$$$. So we cannot ever have a pair of integers ($$$a,b$$$) such that:
$$$1 \leq a < n - 1$$$
$$$1 \leq b < n$$$
$$$a \neq b$$$
$$$p_a$$$ divides $$$p_b$$$ and $$$p_{a+1}$$$ divides $$$p_{b+1}$$$
Now, we just need to check for $$$a = n - 1$$$. First of all, notice that $$$p_a$$$ does not divide $$$p_1$$$.
There does not exist an integer $$$b$$$ ($$$2 \leq b < n - 1$$$) such that $$$p_{a+1}$$$ divides $$$p_{b+1}$$$ as $$$2 \cdot p_{a+1} \ge n$$$ and $$$p_{c+1} < n$$$ for all $$$c$$$ ($$$2 \leq c < n - 1$$$).
Note that we covered all possible pairs of indices and did not find two
distinct
indices $$$i$$$ and $$$j$$$ ($$$1 \leq i, j < n$$$; $$$i \neq j$$$) such that $$$p_i$$$ divides $$$p_j$$$ and $$$p_{i+1}$$$ divides $$$p_{j+1}$$$.
Proof
We have $$$\max(p_a, p_{a+1}) > \lfloor \frac{n}{2} \rfloor$$$ for all $$$1 \leq a < n - 1$$$. So we cannot ever have a pair of integers ($$$a,b$$$) such that:
$$$1 \leq a < n - 1$$$
$$$1 \leq b < n$$$
$$$a \neq b$$$
$$$p_a$$$ divides $$$p_b$$$ and $$$p_{a+1}$$$ divides $$$p_{b+1}$$$
Now, we just need to check for $$$a = n - 1$$$. First of all, notice that $$$p_a$$$ does not divide $$$p_1$$$.
There does not exist an integer $$$b$$$ ($$$2 \leq b < n - 1$$$) such that $$$p_{a+1}$$$ divides $$$p_{b+1}$$$ as $$$2 \cdot p_{a+1} \ge n$$$ and $$$p_{c+1} < n$$$ for all $$$c$$$ ($$$2 \leq c < n - 1$$$).
Note that we covered all possible pairs of indices and did not find two
distinct
indices $$$i$$$ and $$$j$$$ ($$$1 \leq i, j < n$$$; $$$i \neq j$$$) such that $$$p_i$$$ divides $$$p_j$$$ and $$$p_{i+1}$$$ divides $$$p_{j+1}$$$.
Code
#include <bits/stdc++.h>     
using namespace std;
#define ll long long
void solve(){ 
    ll n; cin>>n;
    ll l=1,r=n;
    for(ll i=1;i<=n;i++){
        if(i&1){
            cout<<l<<" ";
            l++;
        }
        else{
            cout<<r<<" ";
            r--;
        }
    }
    cout<<"\n";
    return;  
}                                       
int main()                                                                               
{       
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);                               
    #ifndef ONLINE_JUDGE                   
    freopen("input.txt", "r", stdin);                                           
    freopen("output.txt", "w", stdout);      
    freopen("error.txt", "w", stderr);                        
    #endif     
    ll test_cases=1;                 
    cin>>test_cases;
    while(test_cases--){
        solve();
    }
    cout<<fixed<<setprecision(10);
    cerr<<"Time:"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms\n"; 
}
--------------------------------------------------
Problem ID: 1930A
Editorial Content:
1930A - Maximise The Score
Hint 1
Selecting the smallest two elements on the whiteboard is a good choice in the first move.
Solution
Let $$$b$$$ denote the sorted array $$$a$$$. Assume that $$$b$$$ contains only distinct elements for convenience. We prove by induction on $$$n$$$ that the maximum final score is $$$b_1 + b_3 + \ldots + b_{2n-1}$$$.
For the base case $$$n = 1$$$, the final and only possible score that can be achieved is $$$b_1$$$.
Now let $$$n > 1$$$.
Claim
: It is optimal to choose $$$b_{1}$$$ with $$$b_{2}$$$ for some move.
Proof
Suppose that in some move, $$$b_{1}$$$ is choosen with $$$b_i$$$ and $$$b_{2}$$$ is choosen with $$$b_j$$$, for some $$$2 < i,j < 2n, i \not = j$$$.
The contribution to the score according to these choices is $$$\min(b_{1}, b_{i}) + \min(b_{2}, b_{j}) = b_{1} + b_{2}$$$.
However, if we had chosen $$$b_{1}$$$ and $$$b_{2}$$$ in one move, and $$$b_i$$$ and $$$b_j$$$ in the other move, the score according to these choices is $$$\min(b_{1}, b_{2}) + \min(b_{i}, b_{j}) = b_{1} + \min(b_{i}, b_{j})$$$.
As $$$i, j > 2$$$, $$$b_i > b_{2}$$$ and $$$b_j > b_{2} \implies \min(b_{i}, b_{j}) > b_2$$$. Thus, we can achieve a strictly larger score by choosing $$$b_1$$$ with $$$b_2$$$ in some move.
The choice of selecting $$$b_1$$$ and $$$b_2$$$ contributes a value of $$$b_1$$$ to the score. The maximum score that can achieved for the remaining numbers $$$[b_3, b_4, \ldots, b_{2n}]$$$ on the whiteboard in the remaining moves is $$$b_3 + b_5 + b_7 + \ldots b_{2n-1}$$$ by the induction hypothesis.
Note that we can extend the arguments for the case where $$$a$$$ has duplicate elements.
Proof
Suppose that in some move, $$$b_{1}$$$ is choosen with $$$b_i$$$ and $$$b_{2}$$$ is choosen with $$$b_j$$$, for some $$$2 < i,j < 2n, i \not = j$$$.
The contribution to the score according to these choices is $$$\min(b_{1}, b_{i}) + \min(b_{2}, b_{j}) = b_{1} + b_{2}$$$.
However, if we had chosen $$$b_{1}$$$ and $$$b_{2}$$$ in one move, and $$$b_i$$$ and $$$b_j$$$ in the other move, the score according to these choices is $$$\min(b_{1}, b_{2}) + \min(b_{i}, b_{j}) = b_{1} + \min(b_{i}, b_{j})$$$.
As $$$i, j > 2$$$, $$$b_i > b_{2}$$$ and $$$b_j > b_{2} \implies \min(b_{i}, b_{j}) > b_2$$$. Thus, we can achieve a strictly larger score by choosing $$$b_1$$$ with $$$b_2$$$ in some move.
The choice of selecting $$$b_1$$$ and $$$b_2$$$ contributes a value of $$$b_1$$$ to the score. The maximum score that can achieved for the remaining numbers $$$[b_3, b_4, \ldots, b_{2n}]$$$ on the whiteboard in the remaining moves is $$$b_3 + b_5 + b_7 + \ldots b_{2n-1}$$$ by the induction hypothesis.
Code
#include <bits/stdc++.h>     
using namespace std;
#define ll long long
void solve(){ 
    ll n; cin>>n;
    vector<ll> a(2*n);
    ll ans=0;
    for(auto &it:a){
        cin>>it;
    }
    sort(a.begin(),a.end());
    for(ll i=0;i<2*n;i+=2){
        ans+=a[i];
    }
    cout<<ans<<"\n";
    return;  
}                                       
int main()                                                                               
{       
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);                               
    #ifndef ONLINE_JUDGE                   
    freopen("input.txt", "r", stdin);                                           
    freopen("output.txt", "w", stdout);      
    freopen("error.txt", "w", stderr);                        
    #endif     
    ll test_cases=1;                 
    cin>>test_cases;
    while(test_cases--){
        solve();
    }
    cout<<fixed<<setprecision(10);
    cerr<<"Time:"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms\n"; 
}
--------------------------------------------------
Problem ID: 1929F
Editorial Content:

--------------------------------------------------
Problem ID: 1929E
Editorial Content:

--------------------------------------------------
Problem ID: 1929D
Editorial Content:

--------------------------------------------------
Problem ID: 1929C
Editorial Content:

--------------------------------------------------
Problem ID: 1929B
Editorial Content:

--------------------------------------------------
Problem ID: 1929A
Editorial Content:

--------------------------------------------------
Problem ID: 1928F
Editorial Content:
1928F - Digital Patterns
Solution
Let's assume that $$$a_i = a_{i+1}$$$ for some $$$1 \le i < n$$$, then for any $$$1 \le j \le m$$$, the cells $$$(i, j)$$$ and $$$(i+1, j)$$$ will have the same transparency. A similar statement can be made if there is an index $$$j$$$: $$$b_j = b_{j+1}$$$.
Then the positions $$$a_i = a_{i+1}$$$ divide the array $$$a$$$ into \textit{blocks}, in each of which all neighboring pairs are not equal to each other. It is clear that if there is a square $$$(x, y, d)$$$ consisting of cells $$$(i, j)$$$ such that $$$x \le i < x+d$$$ and $$$y \le j < y+d$$$, then the segment $$$[x, x+d-1]$$$ is entirely contained in one of these \textit{blocks} of the array $$$a$$$. Similarly, the array $$$b$$$ can also be divided into blocks, and then the segment $$$[y, y+d-1]$$$ will also be entirely contained in one of the blocks.
Let's try to solve the problem in $$$O(1)$$$ time, if there are no neighboring elements with the same values in the arrays $$$a$$$ and $$$b$$$ (also assuming that $$$n \le m$$$):
$$$ f(n, m) = \sum \limits_{k=1}^{n} (n-k+1)(m-k+1) = \sum_{k=1}^n \left( k^2 + (m-n)k \right) \\ f(n, m) = \frac{n(n + 1)(2n + 1)}6 + (m - n) \cdot \frac{n(n+1)}2 \\ $$$
This formula can be further transformed by introducing a quadruple of numbers for each natural number $$$n$$$: $$$a_n = 1$$$, $$$b_n = n$$$, $$$c_n = \frac12 n(n+1)$$$, $$$d_n = \frac16 n(n+1)(2n+1) - \frac12n^2(n+1)$$$. Then $$$f(n, m) = d_n a_m + c_n b_m$$$, if $$$n \le m$$$ and $$$f(n, m) = a_n d_m + b_n c_m$$$, if $$$n > m$$$.
But if there are neighboring identical elements in the arrays $$$a$$$ and $$$b$$$, then this means that they are somehow divided into blocks. If these are blocks of lengths $$$n_1, \ldots, n_k$$$ in the array $$$a$$$ and blocks of lengths $$$m_1, \ldots, m_l$$$ in the array $$$b$$$, then the answer to the problem is
$$$ \textrm{ans} = \sum_{i=1}^k \sum_{j=1}^l f(n_i, m_j) $$$
Let's learn how to quickly calculate sums of the form $$$f(x, m_1) + \ldots + f(x, m_l)$$$. To do this, we will create 4 segment trees to quickly calculate the sums $$$\sum a_y$$$, $$$\sum b_y$$$, $$$\sum c_y$$$, $$$\sum d_y$$$ over segments of $$$y$$$, taking into account the multiplicity of $$$y$$$ in the array $$$m_1, \ldots, m_l$$$. Now the calculation of $$$f(x, m_1) + \ldots + f(x, m_k)$$$ is reduced to $$$4$$$ segment tree queries:
$$$ f(x, m_1) + \ldots + f(x, m_l) = a_x \cdot \sum_{m_i < x} d_{m_i} + b_x \cdot \sum_{m_i < x} c_{m_i} + c_x \cdot \sum_{m_i \ge x} b_{m_i} + d_x \cdot \sum_{m_i \ge x} a_{m_i} $$$
The sum $$$f(n_1, y) + \ldots + f(n_k, y)$$$ is calculated similarly. Now we just need to put our solution together. We will maintain the blocks of arrays $$$a$$$ and $$$b$$$ in an online mode. It is very convenient to do this by storing the positions $$$a_i = a_{i+1}$$$ in a data structure like std::set, and also by working with the differential array $$$a$$$ (i.e., maintaining not the array $$$a$$$ itself, but the array of differences between neighboring elements $$$c_i = a_{i+1} - a_i$$$). To recalculate the answer, we will count the number of squares that are involved in a specific block of the array $$$a$$$ or $$$b$$$, using the above result. As a result, we have a solution in $$$O((n+q) (\log n + \log m))$$$.
P.S. A solution in $$$O(q \sqrt n)$$$ will not work due to a large constant. I tried very hard to rule it out :D.
Code
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
using pi = pair<int, int>;

struct SegmentTree {
    int n;
    vector<ll> t;

    SegmentTree(int n) : n(n), t(2*n) { }

    void Add(int i, ll x) {
        for (i += n; i != 0; i >>= 1) t[i] += x;
    }

    ll Query(int l, int r) {
        ll ans = 0;

        for (l += n, r += n - 1; l <= r; l >>= 1, r >>= 1) {
            if ((l&1) == 1) ans += t[l++];
            if ((r&1) == 0) ans += t[r--];
        }
        return ans;
    }
};

struct SegmentContainer {
    int side;
    SegmentTree sgt_a, sgt_b, sgt_c, sgt_d;
    int id;
    // sgt_a: sum(1)
    // sgt_b: sum(m)
    // sgt_c: sum(m*(m+1)/2)
    // sgt_d: sum(m*(m-1)*(2*m-1)/6 - m*(m-1)/2*m)

    SegmentContainer(int side) : side(side), sgt_a(side), sgt_b(side), sgt_c(side), sgt_d(side) {
    }

    tuple<ll, ll, ll, ll> GetABCD(ll m) {
        return make_tuple(1, m, m*(m+1)/2, m*(m-1)*(2*m-1)/6 - m*(m-1)/2*m);
    }

    void Insert(int m) {
        auto [a, b, c, d] = GetABCD(m);
        sgt_a.Add(m-1, +a);
        sgt_b.Add(m-1, +b);
        sgt_c.Add(m-1, +c);
        sgt_d.Add(m-1, +d);
    }

    void Erase(int m) {
        auto [a, b, c, d] = GetABCD(m);
        sgt_a.Add(m-1, -a);
        sgt_b.Add(m-1, -b);
        sgt_c.Add(m-1, -c);
        sgt_d.Add(m-1, -d);
    }

    ll SquaresCount(int n) {
        const int mid = min(side, n);
        auto sum_a = sgt_a.Query(mid, side); // m > n
        auto sum_b = sgt_b.Query(mid, side); // m > n
        auto sum_c = sgt_c.Query(0, mid); // m <= n
        auto sum_d = sgt_d.Query(0, mid); // m <= n
        auto [a, b, c, d] = GetABCD(n);

        return d * sum_a + c * sum_b + b * sum_c + a * sum_d;
    }
};

struct SegmentMaintainer {
    SegmentContainer& my;
    SegmentContainer& other;
    ll& ans;

    set<int> pos_zero;
    vector<ll> diff_array;

    SegmentMaintainer(vector<int> a, 
                      SegmentContainer& my,
                      SegmentContainer& other,
                      ll& ans) :
            pos_zero(), diff_array(a.size()), my(my), other(other), ans(ans) {
        pos_zero.insert(0);
        for (int i = 1; i < a.size(); ++i) {
            diff_array[i] = a[i] - a[i-1];
            if (diff_array[i] == 0) pos_zero.insert(i);
        }
        pos_zero.insert(a.size());

        for (auto it = pos_zero.begin(); *it != my.side; ++it) {
            OnSegmentAppear(*next(it) - *it);
        }
    }

    void OnSegmentAppear(int len) {
        my.Insert(len);
        ans += other.SquaresCount(len);
    }

    void OnSegmentDissapear(int len) {
        my.Erase(len);
        ans -= other.SquaresCount(len);
    }

    void ChangeBound(int pos, ll dx) {
        if (pos == 0 || pos == my.side) return; 
            
        bool was_zero = diff_array[pos] == 0;
        diff_array[pos] += dx;
        bool now_zero = diff_array[pos] == 0;

        if (was_zero && !now_zero) {
            auto mid = pos_zero.find(pos);
            auto prv = prev(mid), nxt = next(mid);
            
            OnSegmentDissapear(*mid - *prv);
            OnSegmentDissapear(*nxt - *mid);
            OnSegmentAppear(*nxt - *prv);

            pos_zero.erase(mid);
        }
        
        if (!was_zero && now_zero) {
            auto mid = pos_zero.insert(pos).first;
            auto prv = prev(mid), nxt = next(mid);

            OnSegmentAppear(*mid - *prv);
            OnSegmentAppear(*nxt - *mid);
            OnSegmentDissapear(*nxt - *prv);
        }
    }

    void RangeAdd(int l, int r, int x) {
        ChangeBound(l, +x);
        ChangeBound(r, -x);
    }
};

int main() {
    ios::sync_with_stdio(0); cin.tie(0);
    int n, m, q; cin >> n >> m >> q;

    vector<int> a(n), b(m);
    for (int& x : a) cin >> x;
    for (int& x : b) cin >> x;

    ll ans = 0;
    SegmentContainer a_segments(n), b_segments(m);

    a_segments.id = 1;
    b_segments.id = 2;

    SegmentMaintainer a_maintainer(a, a_segments, b_segments, ans); 
    SegmentMaintainer b_maintainer(b, b_segments, a_segments, ans);
    
    cout << ans << '\n';
    while (q--) {
        int t, l, r, x; cin >> t >> l >> r >> x; --l;
        if (t == 1) a_maintainer.RangeAdd(l, r, x);
        if (t == 2) b_maintainer.RangeAdd(l, r, x);
        cout << ans << '\n';
    }
}
--------------------------------------------------
Problem ID: 1928E
Editorial Content:
1928E - Modular Sequence
Solution
Let's see what the answer will look like: first, there will be a prefix of the form $$$x, x + y, \ldots, x + k\cdot y$$$, and then there will be some number of blocks of the form $$$x \bmod y, x \bmod y + y, \ldots, x \bmod y + k \cdot y$$$.
We can subtract the number $$$x \bmod y$$$ from all the elements of the sequence, and then divide all the elements by $$$y$$$ (all the elements will be divisible by $$$y$$$, since they initially had a remainder of $$$x \bmod y$$$). Let $$$b_1 = \frac{x - x \bmod y}{y}$$$. Then our sequence will start with $$$b_1, b_1 + 1, \ldots, b_1 + k_1$$$, and then there will be blocks of the form $$$0, 1, \ldots, k_i$$$.
Let's calculate these values: $$$dp_i$$$~--- the minimum length of a sequence of blocks of the form $$$0, 1, \ldots, k_j$$$ with a sum of $$$i$$$. This value can be calculated for all numbers from $$$0$$$ to $$$s$$$ using dynamic programming. If we have processed all values from $$$0$$$ to $$$k-1$$$, then for $$$k$$$ we have calculated the minimum length, and we can update the value of $$$dp$$$ for $$$k + 1, k + 1 + 2, \ldots$$$~--- a total of $$$O(\sqrt{s})$$$ values not exceeding $$$s$$$. In this same $$$dp$$$, we can store through which values we were recalculated, for the restoration of the answer.
Now, we can iterate over the length of the first block of the form $$$b_1, b_1 + 1, \ldots, b_1 + k_1$$$. Then we know the sum of the remaining blocks, and using the precalculated $$$dp$$$, we can determine whether the desired sequence can be formed or not.
Code
#include <cassert>
#include <initializer_list>
#include <numeric>
#include <vector>
#include <iostream>
#include <utility>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <algorithm>
#include <math.h>

using namespace std;

#define pii pair<int, int>
#define mp make_pair
#define fi first
#define se second
#define all(x) (x).begin(), (x).end()
#define ll long long
#define pb emplace_back

const int INF = 1e9 + 10;
const ll INFLL = 1e18;

void solve() {
    int n, x, y, S;
    cin >> n >> x >> y >> S;
    vector<int> dp(S + 1, INF);
    dp[0] = 0;
    for (int k = 1; k <= S; k++) {
        for (int l = 2; (l * (l - 1)) / 2 <= k; l++) {  // just 0 is never optimal
            dp[k] = min(dp[k], dp[k - (l * (l - 1)) / 2] + l);
        }
        assert(dp[k] <= 2 * k);
    }
    for (ll k = 0; k < n; k++) {
        ll prevSum = (k + 1) * x + (k * (k + 1)) / 2 * y;
        if (prevSum > S) {
            continue;
        }
        ll needSum = S - prevSum;
        needSum -= (n - k - 1) * (x % y);
        if (needSum < 0) {
            continue;
        }
        if (needSum % y != 0) {
            continue;
        }
        needSum /= y;
        assert(needSum <= S);
        if (dp[needSum] <= n - k - 1) {  // we found the answer
            vector<int> a(n);
            a[0] = x;
            for (int i = 1; i <= k; i++) {  // construct prefix
                a[i] = a[i - 1] + y;
            }
            for (int i = k + 1; i <= k + (n - k - 1) - dp[needSum];
                 i++) {  // fill the rest like 0 0 0 ...
                a[i] = x % y;
            }
            int i = k + (n - k - 1) - dp[needSum] + 1;  // first free index
            vector<int> lens;                           // recover lengths of the segments
            while (needSum != 0) {
                for (int l = 2; (l * (l - 1)) / 2 <= needSum; l++) {
                    if (dp[needSum] == dp[needSum - (l * (l - 1)) / 2] + l) {
                        lens.pb(l);
                        needSum -= (l * (l - 1)) / 2;
                        break;
                    }
                }
            }
            for (auto &len : lens) {
                for (int j = 0; j < len; j++) {
                    a[i] = (x % y) + y * j;
                    i++;
                }
            }
            cout << "YES\n";
            for (auto &c : a) {
                cout << c << " ";
            }
            cout << "\n";
            return;
        }
    }
    cout << "NO\n";
}

int main() {
    cin.tie(0);
    cout.tie(0);
    ios_base::sync_with_stdio(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1928D
Editorial Content:
1928D - Lonely Mountain Dungeons
Solution
Let's learn how to solve the problem when $$$n = 1$$$. Suppose there is only one race and the number of its representatives is $$$c$$$. Notice that for a fixed $$$k$$$, it is advantageous for us to divide the representatives of the race almost evenly into squads.
If $$$c$$$ is divisible by $$$k$$$, then it is advantageous for us to take exactly $$$y = \frac{c}{k}$$$ beings in each squad. Then the total number of pairs of beings in different squads is equal to $$$\frac{k(k-1)}{2} \cdot y^2$$$ (there are a total of $$$\frac{k(k-1)}{2}$$$ pairs of squads, and for each pair of squads there are $$$y^2$$$ pairs of beings from different squads).
In the general case, when $$$c$$$ may not be divisible by $$$k$$$, let's denote $$$y = \left\lfloor \frac{c}{k} \right\rfloor$$$ and $$$y' = \left\lceil \frac{c}{k} \right\rceil$$$. Then it is advantageous for us to make squads of size $$$y$$$ and $$$y'$$$, where the number of squads of size $$$y'$$$ is equal to $$$c \bmod k$$$ (we essentially make all squads of size $$$y$$$, and then add 1 to some squads from the remaining part). In this case, the total number of pairs of beings in different squads is equal to $$$C_{k - c \bmod k}^2 \cdot y^2 + C_{c \bmod k}^2 \cdot y'^2 + (k - c \bmod k) \cdot (c \bmod k) \cdot y \cdot y'$$$. It remains to notice that it makes no sense to have $$$k > c$$$, so we can simply iterate through $$$k$$$ from $$$1$$$ to $$$c$$$ and choose the optimal one.
When $$$n > 1$$$, we can notice that for a fixed $$$k$$$, we can solve the problem independently for each race. Let the number of representatives of the $$$i$$$-th race be $$$c_i$$$. Then we will iterate through $$$k$$$ from $$$1$$$ to $$$c_i$$$ for it and add the maximum total strength to the value of $$$cnt_k$$$ (the array $$$cnt$$$ is common for all races). Also, notice that for $$$k > c_i$$$, we will get the same total strength as for $$$k = c_i$$$. Then in the additional array $$$add$$$ (again, common for all races), we will add the maximum total strength for $$$k = c_i$$$ to $$$add_{c_i}$$$.
We get the following solution: first, calculate the described arrays $$$cnt$$$ and $$$add$$$. After that, iterate through $$$k$$$ from $$$1$$$ to the maximum $$$c_i$$$. The maximum total strength of the squads for a fixed $$$k$$$ will be equal to $$$(cnt_k + (\text{sum of values } add_i \text{ for } i < k)) \cdot b - (k - 1) \cdot X$$$. From these values, we need to choose the maximum.
Code
#include <iostream>
#include <vector>

using namespace std;
using ll = long long;

ll pairs(ll n, ll k){
    if (n == 0 || k == 0){
        return 0;
    }
    ll x = n / k;
    ll l = n % k;
    ll r = k - l;
    ll L = (x + 1) * l, R = x * r;
    return R * L + (R - x) * R / 2 + L * (L - x - 1) / 2;
}

void solve(){
    int m;
    long long c, b;
    cin >> m >> b >> c;

    int n = 0;
    vector<int> cnt(m);
    for (int i = 0; i < m; ++i) {
        cin >> cnt[i];
        n = max(n, cnt[i]);
    }


    vector<long long> pair(n + 1);
    vector<long long> add(n + 1);
    for (int i = 0; i < m; ++i) {
        for (int j = 1; j <= cnt[i]; ++j) {
            pair[j] += pairs(cnt[i], j);
        }
        add[cnt[i]] += pairs(cnt[i], cnt[i]);
    }


    long long ans = 0;
    long long other = 0;
    for (int i = 1; i <= n; ++i) {
        ans = max(ans, b * (pair[i] + other) - c * (i - 1));
        other += add[i];
    }
    cout << ans << endl;
}

int main(){
    int t;
    cin >> t;
    while (t--){
        solve();
    }
}
--------------------------------------------------
Problem ID: 1928C
Editorial Content:
1928C - Physical Education Lesson
Solution
All numbers repeat every $$$2k - 2$$$ positions. If the boy Vasya's number is calculated to be $$$x$$$, then it can be at positions of the form $$$(2k - 2) \cdot t + x$$$, or $$$(2k - 2) \cdot t + k + k - x$$$, for some non-negative $$$t$$$. This is true for all $$$x$$$, except for $$$x = 1$$$ and $$$x = k$$$ ~--- for these values, there is only one option left.
Let's fix one of the options, the second one will be analogous. We need to find how many different values of $$$k$$$ satisfy the equation $$$(2k - 2) \cdot t + x = n$$$, for some non-negative $$$t$$$. It is not difficult to see that this holds if and only if $$$n - x$$$ is divisible by $$$2k - 2$$$. Therefore, it is necessary to find the number of \textbf{even} divisors of the number $$$n - x$$$. To consider the second case, it is necessary to proceed similarly with the number $$$n + x - 2$$$. The solution's complexity: $$$O(\sqrt{n})$$$
Code
#include <iostream>
#include <unordered_set>

using namespace std;

unordered_set<int> solve(int a) {
    unordered_set<int> candidates;
    for (int i = 1; i * i <= a; i++) {
        if (a % i == 0) {
            if (i % 2 == 0) // segment len should be even
                candidates.insert(i);
            if ((a / i) % 2 == 0)
                candidates.insert(a / i);
        }
    }
    unordered_set<int> answer;
    for (int i : candidates) {
        answer.insert(1 + i / 2);
    }
    return answer;
}

int main() {
    int t;
    cin >> t;
    for (int _ = 1; _ <= t; _++) {
        int n, pos;
        cin >> n >> pos;
        unordered_set<int> candidates = solve(n - pos);  // bug2
        for (int i : solve(n + pos - 2)) { // bug1
            candidates.insert(i);
        }
        int answer = 0;
        for (int i : candidates) {
            if (i >= pos) {
                answer++;
            }
        }
        cout << answer << endl;
    }
}
--------------------------------------------------
Problem ID: 1928B
Editorial Content:
1928B - Equalize
Solution
Suppose we already know the permutation that needs to be added. Let's consider the elements that will become equal after the addition. Notice that among them there cannot be equal elements, because among the numbers we are adding, there are no duplicates. Thus, only a set of numbers among which there are no equal ones, and the difference between the maximum and minimum does not exceed $$$n - 1$$$, can become equal. It is easy to see that any set of numbers satisfying these conditions can be equalized, and any set of numbers that became equal after adding the permutation satisfies these constraints.
So let's sort the array, remove the equal elements from it. After that, we can use two pointers to find the maximum length subarray where the difference between the maximum and minimum does not exceed $$$n - 1$$$. The answer will be the length of such a subarray. The complexity of the solution is $$$O(n \log n)$$$.
Code
#include <bits/stdc++.h>

using namespace std;

void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    sort(a.begin(), a.end());
    a.resize(unique(a.begin(), a.end()) - a.begin());
    int pnt = 0, ans = 0;
    for (int i = 0; i < a.size(); i++) {
        while(a[i] - a[pnt] >= n) {
            pnt++;
        }
        ans = max(ans, i - pnt + 1);
    }
    cout << ans << endl;
}

signed main() {
    int t = 1;
    cin >> t;
    for (int i = 0; i < t; ++i) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1928A
Editorial Content:
1928A - Rectangle Cutting
Solution
Let $$$a \le b$$$. Let's consider several cases:
If $$$a$$$ is even, then we can cut the rectangle into two rectangles of size $$$\frac{a}{2} \times b$$$ and combine them into a rectangle of size $$$\frac{a}{2} \times 2b$$$, which is definitely different from $$$a \times b$$$.
If $$$b$$$ is even and $$$b \ne 2a$$$, then we can cut the rectangle into two rectangles of size $$$a \times \frac{b}{2}$$$ and combine them into a rectangle of size $$$2a \times \frac{b}{2}$$$. Note that here we use the fact that $$$b \ne 2a$$$, because if $$$b = 2a$$$, then we will get the same rectangle of size $$$b \times a$$$.
If $$$a$$$ and $$$b$$$ are both odd, or $$$b = 2a$$$ and $$$a$$$ is odd, then the rectangle is not interesting. It is easy to understand that if we cut the rectangle of size $$$a \times b$$$ into two rectangles of size $$$a \times c$$$ and $$$a \times d$$$, where $$$c \ne d$$$, then we can always only combine the original rectangle (similarly if we cut it into rectangles $$$c \times b$$$ and $$$d \times b$$$). And from here it follows that we must divide one of the sides of the rectangle in half, so at least one side must be even.
Code
#include <vector>
#include <iostream>
#include <numeric>
#include <algorithm>
#include <cassert>
#include <map>

using namespace std;
 
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin >> t;
	while (t--) {
	    int a, b;
	    cin >> a >> b;
	    if (a > b) {
	        swap(a, b);
	    }
	    if (((a % 2 == 1) && (b % 2 == 1)) || ((a % 2 == 1) && (b == 2 * a))) {
	        cout << "No\n";
	    } else {
	        cout << "Yes\n";
	    }
	}
	
	return 0;
}
--------------------------------------------------
Problem ID: 1927G
Editorial Content:
1927G - Paint Charges
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
int main() {
    int t;
    cin >> t;
    forn(tt, t) {
        int n;
        cin >> n;
        vector<int> a(n);
        forn(i, n)
            cin >> a[i];
 
        vector<vector<vector<int>>> d(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, INT_MAX)));
        d[0][0][0] = 0;
 
        forn(i, n)
            forn(j, n)
                forn(k, n + 1)
                    if (d[i][j][k] < INT_MAX) {
                        int ai = a[i];
 
                        // Z
                        {
                            int ni = i + 1;
                            int nj = j > 0 ? j + 1 : (k == 0 ? 1 : 0);
                            int nk = max(0, k - 1);
                            d[ni][nj][nk] = min(d[ni][nj][nk], d[i][j][k]);
                        }
 
                        // L
                        {
                            int ni = i + 1;
                            int nj = j > 0 ? j + 1 : 0;
                            if (nj <= ai)
                                nj = 0;
                            int nk = max(0, k - 1);
                            d[ni][nj][nk] = min(d[ni][nj][nk], d[i][j][k] + 1);
                        }
 
                        // R
                        {
                            int ni = i + 1;
                            int nj = j > 0 ? j + 1 : 0;
                            int nk = max(ai - 1, k - 1);
                            d[ni][nj][nk] = min(d[ni][nj][nk], d[i][j][k] + 1);
                        }
                    }
 
        cout << *min_element(d[n][0].begin(), d[n][0].end()) << endl;
    }
}
--------------------------------------------------
Problem ID: 1927F
Editorial Content:
1927F - Microcycle
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
#define int long long
#define pb emplace_back
#define mp make_pair
#define x first
#define y second
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
 
typedef long double ld;
typedef long long ll;
 
using namespace std;
 
mt19937 rnd(time(nullptr));
 
const ll inf = 1e18;
const ll M = 998244353;
const ld pi = atan2(0, -1);
const ld eps = 1e-6;
 
struct dsu{
    vector<int> p, lvl;
 
    dsu(int n){
        p.resize(n);
        iota(p.begin(), p.end(), 0);
        lvl.assign(n, 0);
    }
 
    int get(int i){
        if (p[i] == i) return i;
        return p[i] = get(p[i]);
    }
 
    bool unite(int a, int b){
        a = get(a);
        b = get(b);
        if(a == b) return false;
        if(lvl[a] < lvl[b]) swap(a, b);
        p[b] = a;
        if(lvl[a] == lvl[b]) lvl[a]++;
        return true;
    }
};
 
bool found;
vector<int> ans, path;
 
void dfs(int v, int p, vector<vector<int>> &g, int f){
    path.push_back(v);
    if(v == f){
        ans = path;
        found = true;
        return;
    }
    for(int u: g[v]){
        if(u != p) dfs(u, v, g, f);
        if (found) return;
    }
    path.pop_back();
}
 
void solve(int tc){
    int n, m;
    cin >> n >> m;
    vector<vector<int>> sl(n);
    vector<pair<int, pair<int, int>>> edges;
    for(int i = 0; i < m; ++i){
        int u, v, w;
        cin >> u >> v >> w;
        --u, --v;
        edges.push_back({w, {u, v}});
    }
    sort(rall(edges));
    dsu g(n);
    pair<int, int> fin;
    int best = INT_MAX;
    for(auto e: edges){
        if(!g.unite(e.y.x, e.y.y)){
            fin = e.y;
            best = e.x;
        }
        else{
            sl[e.y.x].push_back(e.y.y);
            sl[e.y.y].push_back(e.y.x);
        }
    }
    found = false;
    path.resize(0);
    dfs(fin.x, -1, sl, fin.y);
    cout << best <<  " " << ans.size() << "\n";
    for(int e: ans) cout << e + 1 << " ";
}
 
bool multi = true;
 
signed main() {
    int t = 1;
    if (multi)cin >> t;
    for (int i = 1; i <= t; ++i) {
        solve(i);
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1927E
Editorial Content:
1927E - Klever Permutation
Tutorial
Tutorial is loading...
Solution
def solve():
    n, k = map(int, input().split())
    l, r = 1, n
    ans = [0] * n
    for i in range(k):
        for j in range(i, n, k):
            if i % 2 == 0:
                ans[j] = l
                l += 1
            else:
                ans[j] = r
                r -= 1
    print(*ans)
    
    
for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1927D
Editorial Content:
1927D - Find the Different Ones!
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    a = [int(x) for x in input().split()]
    p = [-1] * n
    for i in range(1, n):
        p[i] = p[i - 1]
        if a[i] != a[i - 1]:
            p[i] = i - 1
    for i in range(int(input())):
        l, r = map(int, input().split())
        l -= 1
        r -= 1
        if p[r] < l:
            print("-1 -1")
        else:
            print(p[r] + 1, r + 1)
    
    
t = int(input())
for _ in range(t):
    solve()
    if _ + 1 != t:
        print()
--------------------------------------------------
Problem ID: 1927C
Editorial Content:
1927C - Choose the Different Ones!
Tutorial
Tutorial is loading...
Solution
def solve():
    n, m, k = map(int, input().split())
    a = [int(x) for x in input().split()]
    b = [int(x) for x in input().split()]
    cnt = [0] * (k + 1)
    for e in a:
        if e <= k:
            cnt[e] |= 1
    for e in b:
        if e <= k:
            cnt[e] |= 2
    c = [0] * 4
    for e in cnt:
        c[e] += 1
    if c[1] > k // 2 or c[2] > k // 2 or c[1] + c[2] + c[3] != k:
        print("NO")
    else:
        print("YES")
 
 
for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1927B
Editorial Content:
1927B - Following the String
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    a = [int(x) for x in input().split()]
    cnt = [0] * 26
    s = ''
    for i in range(n):
        for j in range(26):
            if cnt[j] == a[i]:
                cnt[j] += 1
                s += chr(97 + j)
                break
    print(s)
 
 
for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1927A
Editorial Content:
1927A - Make it White
Tutorial
Tutorial is loading...
Solution
from collections import deque
 
def solve():
    n = int(input())
    s = deque(input())
    while len(s) > 0 and s[0] == 'W':
        s.popleft()
    while len(s) > 0 and s[-1] == 'W':
        s.pop()
    print(len(s))
    
 
for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1926G
Editorial Content:
1926G - Vlad and Trouble at MIT
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define INF (int)1e18
 
int n;
const int N = 1e5 + 69;
int dp[N][3];
string s; 
vector <int> adj[N];
 
void dfs(int u){
    // dp[u][0] = nothing open 
    // dp[u][1] = P open 
    // dp[u][2] = S open 
    
    dp[u][0] = INF;
    if (s[u] != 'S') dp[u][1] = 0;
    else dp[u][1] = INF;
    if (s[u] != 'P') dp[u][2] = 0;
    else dp[u][2] = INF;
    int tot = 0;
    
    for (int v : adj[u]){
        dfs(v);
        dp[u][1] = dp[u][1] + min({dp[v][1], dp[v][2] + 1, dp[v][0]});
        dp[u][2] = dp[u][2] + min({dp[v][2], dp[v][1] + 1, dp[v][0]});
        tot += dp[v][0];
    }
    
    if (s[u] != 'C') tot = INF;
    
    dp[u][0] = min({tot, dp[u][1] + 1, dp[u][2] + 1});
    
    //cout << u << " " << dp[u][0] << " " << dp[u][1] << " " << dp[u][2] << "\n";
}
 
void Solve() 
{
    cin >> n;
    for (int i = 1; i <= n; i++) adj[i].clear();
    for (int i = 2; i <= n; i++){
        int x; cin >> x;
        adj[x].push_back(i);
    }
    
    cin >> s; s = "0" + s;
    
    dfs(1);
    
    cout << min({dp[1][0], dp[1][1], dp[1][2]}) << "\n";
}
 
int32_t main() 
{
    int t = 1;
    // freopen("in",  "r", stdin);
    // freopen("out", "w", stdout);
    
    cin >> t;
    for(int i = 1; i <= t; i++) 
    {
        //cout << "Case #" << i << ": ";
        Solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1926F
Editorial Content:
1926F - Vlad and Avoiding X
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200'007;
const int MOD = 1'000'000'007;
 
vector<pair<int, int>> odd, even;
 
bool valid(int gc[7][7], bool odd) {
	for (int r = 1; r < 6; r++) {
		for (int c = 1; c < 6; c++) {
			if (gc[r][c] && ((r + c) % 2 == odd)) {
				if (gc[r - 1][c - 1] && gc[r - 1][c + 1] && gc[r + 1][c - 1] && gc[r + 1][c + 1]) {
					return false;
				}
			}
		}
	}
	return true;
}
 
bool check(int g[7][7], int flips_left, int idx, vector<pair<int, int>>& vec, int valid_val) {
    if (flips_left == 0) {
        return valid(g, valid_val);
    }
    if (idx == vec.size()) {
        return false;
    }
    bool ok = false;
    ok |= check(g, flips_left, idx + 1, vec, valid_val);
    g[vec[idx].first][vec[idx].second] ^= 1;
    ok |= check(g, flips_left - 1, idx + 1, vec, valid_val);
    g[vec[idx].first][vec[idx].second] ^= 1;
    return ok;
}
 
void solve() {
    int g[7][7];
    for (int i = 0; i < 7; i++) {
        for (int j = 0; j < 7; j++) {
            char c;
            cin >> c;
            g[i][j] = (c == 'B');
        }
    }   
    int res = 0;
    for (int i = 0; i <= 4; i++) {
        if (check(g, i, 0, odd, 1)) {res += i; break;}
    }
    for (int i = 0; i <= 4; i++) {
        if (check(g, i, 0, even, 0)) {res += i; break;}
    }
    cout << res << '\n';
}
int main() {
	
	for (int i = 0; i < 7; i++) {
		for (int j = 0; j < 7; j++) {
			if ((i + j) % 2) {
				odd.emplace_back(i, j);
			}
			else {
				even.emplace_back(i, j);
			}
		}
	}
	
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
}
--------------------------------------------------
Problem ID: 1926E
Editorial Content:
1926E - Vlad and an Odd Ordering
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200'007;
const int MOD = 1'000'000'007;
 
void solve() {
	int n, k;
	cin >> n >> k;
	vector<int> v;
	while (n) {
		v.push_back((n + 1) / 2);
		n /= 2;
	}
	int tot = 0, pow2 = 1;
	for (int x : v) {
		if (tot < k && k <= tot + x) {
			cout << pow2 * (2 * (k - tot) - 1) << '\n';
			return;
		}
		tot += x;
		pow2 *= 2;
	}
}
 
int main() {
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1926D
Editorial Content:
1926D - Vlad and Division
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
void solve() {
    int n; cin >> n;
    map<int, int> cnt;
    int ans = 0;
    for(int i = 0, x; i < n; ++i) {
        cin >> x;
        if(!cnt[x]) ++ans, ++cnt[((1 << 31) - 1) ^ x];
        else --cnt[x];
    }
    cout << ans << "\n";
}   
 
main() {
    int t = 1; cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1926C
Editorial Content:
1926C - Vlad and a Sum of Sum of Digits
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200'007;
const int MOD = 1'000'000'007;
 
int res[MAX];
 
int S(int x) {
	int res = 0;
	while (x) {
		res += (x % 10);
		x /= 10;
	}
	return res;
}
 
void solve() {
	int x;
	cin >> x;
	cout << res[x] << '\n';
}
 
int main() {
	res[0] = 0;
	for (int i = 1; i < MAX; i++) {
		res[i] = res[i - 1] + S(i);
	}
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1926B
Editorial Content:
1926B - Vlad and Shapes
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <algorithm>
#include <vector>
#include <array>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <list>
#include <chrono>
#include <random>
#include <cstdlib>
#include <cmath>
#include <ctime>
#include <cstring>
#include <iomanip>
#include <bitset>
#include <cassert>
 
using namespace std;
 
void solve()
{
    int n;
    cin >> n;
    vector<string> g;
    for(int i = 0; i < n; i++)
    {
        string s;
        cin >> s;
        g.push_back(s);
    }
    bool triangle = false;
    for(int i = 0; i < n; i++)
    {
        int cnt = 0;
        for(int j = 0; j < n; j++)
        {
            if(g[i][j] == '1')
            {
                cnt++;
            }
        }
        if(cnt == 1)
        {
            triangle = true;
        }
        else if(cnt > 1)
        {
            break;
        }
    }
    reverse(g.begin(), g.end());
    for(int i = 0; i < n; i++)
    {
        int cnt = 0;
        for(int j = 0; j < n; j++)
        {
            if(g[i][j] == '1')
            {
                cnt++;
            }
        }
        if(cnt == 1)
        {
            triangle = true;
        }
        else if(cnt > 1)
        {
            break;
        }
    }
    if(triangle)
    {
        cout << "TRIANGLE" << endl;
    }
    else
    {
        cout << "SQUARE" << endl;
    }
}
 
int32_t main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1926A
Editorial Content:
1926A - Vlad and the Best of Five
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200'007;
const int MOD = 1'000'000'007;
 
void solve() {
	string s;
	cin >> s;
	int a = 0, b = 0;
	for (char c : s) {
		if (c == 'A') {a++;}
		else {b++;}
	}	
	cout << (a > b ? 'A' : 'B') << '\n';
}
 
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1925D
Editorial Content:

--------------------------------------------------
Problem ID: 1925B
Editorial Content:

--------------------------------------------------
Problem ID: 1925A
Editorial Content:

--------------------------------------------------
Problem ID: 1924F
Editorial Content:

--------------------------------------------------
Problem ID: 1924E
Editorial Content:

--------------------------------------------------
Problem ID: 1924D
Editorial Content:

--------------------------------------------------
Problem ID: 1924C
Editorial Content:

--------------------------------------------------
Problem ID: 1924B
Editorial Content:

--------------------------------------------------
Problem ID: 1924A
Editorial Content:

--------------------------------------------------
Problem ID: 1923F
Editorial Content:
1923F - Shrink-Reverse
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>
 
using namespace std;
 
#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define sz(a) int((a).size())
#define all(a) (a).begin(), (a).end()
 
typedef long long li;
typedef pair<int, int> pt;
 
const int INF = int(1e9);
const int MOD = int(1e9) + 7;
 
int add(int a, int b) {
    a += b;
    if (a >= MOD)
        a -= MOD;
    return a;
}
int mul(int a, int b) {
    return int(a * 1ll * b % MOD);
}
 
namespace SuffixArray {
    string s;
    vector< array<int, 2> > classes;
    
    vector<int> build(const string &bs) {
        s = bs;
        s += '$';
        
        vector<int> c(all(s)), ord(sz(s));
        iota(all(ord), 0);
        classes.resize(sz(s));
 
        for (int len = 1; len < 2 * sz(s); len <<= 1) {
            int half = len >> 1;
            fore (i, 0, sz(s))
                classes[i] = {c[i], c[(i + half) % sz(s)]};
            
            sort(all(ord), [&](int i, int j) {
                return classes[i] < classes[j];
            });
            c[ord[0]] = 0;
            fore (i, 1, sz(ord))
                c[ord[i]] = c[ord[i - 1]] + (classes[ord[i - 1]] != classes[ord[i]]);
        }
        
        c.pop_back();
        for (int &cc : c)
            cc--;
        return c;
    }
};
 
int n, k;
string s;
 
inline bool read() {
    if(!(cin >> n >> k))
        return false;
    cin >> s;
    return true;
}
 
string calcZero(string s) {
    int rem = k;
    int pos = 0;
    for (int i = sz(s) - 1; rem > 0 && i >= 0; i--) {
        if (s[i] == '1')
            continue;
        
        while (pos < sz(s) && s[pos] == '0')
            pos++;
        if (pos >= i)
            break;
        
        swap(s[pos], s[i]);
        rem--;
    }
    return s.substr(s.find('1'));
}
 
string calcOne(string s) {
    reverse(all(s));
    
    auto c = SuffixArray::build(s);
    int cntOnes = count(all(s), '1');
    
    array<int, 3> mn = { 2 * sz(s), INF, -1 };
        
    int u = 0, curOnes = 0;
    fore (i, 0, n) {
        while (u < sz(s) && (u - i < cntOnes || cntOnes - curOnes > k - 1)) {
            curOnes += s[u] == '1';
            u++;
        }
        if (u - i < cntOnes || cntOnes - curOnes > k - 1)
            break;
        
        array<int, 3> curAns = { u - i, c[i], i };
        mn = min(mn, curAns);
        
        curOnes -= s[i] == '1';
    }
    assert(mn[2] >= 0);
    
    string res = s.substr(mn[2], mn[0]);
    int toAdd = cntOnes - count(all(res), '1');
    for (int i = sz(res) - 1; toAdd > 0 && i >= 0; i--) {
        if (res[i] == '0') {
            res[i] = '1';
            toAdd--;
        }
    }
    return res;
}
 
inline void solve() {
    auto s1 = calcZero(s);
    auto s2 = calcOne(s);
 
    if (sz(s1) > sz(s2) || (sz(s1) == sz(s2) && s1 > s2))
        swap(s1, s2);
    
    int res = 0;
    for (char c : s1)
        res = add(mul(res, 2), c - '0');
    cout << res << endl;
}
 
int main() {
#ifdef _DEBUG
    freopen("input.txt", "r", stdin);
    int tt = clock();
#endif
    ios_base::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cout << fixed << setprecision(15);
    
    if(read()) {
        solve();
        
#ifdef _DEBUG
        cerr << "TIME = " << clock() - tt << endl;
        tt = clock();
#endif
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1923E
Editorial Content:
1923E - Count Paths
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
using namespace std;
 
int n;
vector<int> a;
vector<vector<int>> g;
 
long long ans;
vector<map<int, int>> cnt;
 
void dfs(int v, int p = -1){
    int bst = -1;
    for (int u : g[v]) if (u != p){
        dfs(u, v);
        if (bst == -1 || cnt[bst].size() < cnt[u].size())
            bst = u;
    }
    for (int u : g[v]) if (u != p && u != bst){
        for (auto it : cnt[u]){
            int x = it.first, y = it.second;
            if (x != a[v]) ans += cnt[bst][x] * 1ll * y;
            cnt[bst][x] += y;
        }
    }
    if (bst != -1) swap(cnt[bst], cnt[v]);
    ans += cnt[v][a[v]];
    cnt[v][a[v]] = 1;
}
 
int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    int t;
    cin >> t;
    while (t--){
        int n;
        cin >> n;
        a.resize(n);
        forn(i, n) cin >> a[i];
        g.assign(n, {});
        forn(_, n - 1){
            int v, u;
            cin >> v >> u;
            --v, --u;
            g[v].push_back(u);
            g[u].push_back(v);
        }
        ans = 0;
        cnt.assign(n, {});
        dfs(0);
        cout << ans << '\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1923D
Editorial Content:
1923D - Slimes
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<int> a(n);
    for (auto& x : a) cin >> x;
    vector<int> ans(n, n);
    for (int z = 0; z < 2; ++z) {
      vector<long long> s(n + 1);
      for (int i = 0; i < n; ++i) s[i + 1] = s[i] + a[i];
      vector<int> p(n, -1);
      for (int i = 1; i < n; ++i) {
        int j = (z ? n - i - 1 : i);
        int l = 1, r = i;
        while (l <= r) {
          int m = (l + r) / 2;
          if (s[i] - s[i - m] > a[i] && p[i - 1] >= i - m) {
            ans[j] = min(ans[j], m);
            r = m - 1;
          } else {
            l = m + 1;
          }
        }
        if (a[i - 1] > a[i]) ans[j] = 1;
        p[i] = (a[i] == a[i - 1] ? p[i - 1] : i - 1);
      }
      reverse(a.begin(), a.end());
    }
    for (int i = 0; i < n; ++i)
      cout << (ans[i] == n ? -1 : ans[i]) << ' ';
    cout << '\n';
  }
}
--------------------------------------------------
Problem ID: 1923C
Editorial Content:
1923C - Find B
Tutorial
Tutorial is loading...
Solution (Roms)
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 300043;
 
int t;
int n, m;
int a[N];
long long sum[N];
int cnt1[N];
 
int main() {
    ios_base::sync_with_stdio(false);
    
    cin >> t;
    for (int tc = 0; tc < t; ++tc) {
        cin >> n >> m;
        memset(sum, 0, sizeof(sum[0]) * (n + 5));
        memset(cnt1, 0, sizeof(cnt1[0]) * (n + 5));
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
            sum[i + 1] = sum[i] + a[i];
            cnt1[i + 1] = cnt1[i] + (a[i] == 1);
        }
        
        for (int i = 0; i < m; ++i) {
            int l, r;
            cin >> l >> r;
            --l;
            int cur_cnt1 = cnt1[r] - cnt1[l];
            long long cur_sum = sum[r] - sum[l];
            
            if((r - l) + cur_cnt1 <= cur_sum && r - l > 1)
                cout << "YES\n";
            else
                cout << "NO\n";
        }
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1923B
Editorial Content:
1923B - Monsters Attack!
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  int t;
  cin >> t;
  while (t--) {
    int n, k;
    cin >> n >> k;
    vector<int> a(n), x(n);
    for (auto& it : a) cin >> it;
    for (auto& it : x) cin >> it;
    vector<long long> s(n + 1);
    for (int i = 0; i < n; ++i) s[abs(x[i])] += a[i];
    bool ok = true;
    long long lft = 0;
    for (int i = 1; i <= n; ++i) {
      lft += k - s[i];
      ok &= (lft >= 0);
    }
    cout << (ok ? "YES" : "NO") << '\n';
  }
}
--------------------------------------------------
Problem ID: 1923A
Editorial Content:
1923A - Moving Chips
Tutorial
Tutorial is loading...
Solution (BledDest)
t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    l, r = a.index(1), n - a[::-1].index(1) - 1
    c = a.count(1)
    print(r - l - c + 1)
--------------------------------------------------
Problem ID: 1922F
Editorial Content:
1922F - Replace on Segment
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 111;
 
int n, k;
int a[N];
int nxtx[N][N], prvx[N][N];
int nxtnx[N][N], prvnx[N][N];
int dp1[N][N][N], dp2[N][N][N];
 
int calc2(int, int, int);
 
int calc1(int l, int r, int x) {
  l = nxtnx[l][x], r = prvnx[r][x];
  if (l > r) return 0;
  if (dp1[l][r][x] != -1) return dp1[l][r][x];
  dp1[l][r][x] = calc2(l, r, x) + 1;
  for (int i = l; i < r; ++i) dp1[l][r][x] = min(dp1[l][r][x], calc1(l, i, x) + calc1(i + 1, r, x));
  return dp1[l][r][x];
}
 
int calc2(int l, int r, int x) {
  l = nxtx[l][x], r = prvx[r][x];
  if (l > r) return 0;
  if (dp2[l][r][x] != -1) return dp2[l][r][x];
  dp2[l][r][x] = n;
  for (int i = l; i < r; ++i) dp2[l][r][x] = min(dp2[l][r][x], calc2(l, i, x) + calc2(i + 1, r, x));
  for (int y = 0; y < k; ++y) if (x != y) dp2[l][r][x] = min(dp2[l][r][x], calc1(l, r, y)); 
  return dp2[l][r][x];
}
 
void solve() {
  cin >> n >> k;
  for (int i = 0; i < n; ++i) cin >> a[i], --a[i];
  for (int x = 0; x < k; ++x) prvx[0][x] = prvnx[0][x] = -1;
  for (int i = 0; i < n; ++i) {
    prvx[i][a[i]] = i;
    for (int x = 0; x < k; ++x) prvx[i + 1][x] = prvx[i][x];
    for (int x = 0; x < k; ++x) if (x != a[i]) prvnx[i][x] = i;
    for (int x = 0; x < k; ++x) prvnx[i + 1][x] = prvnx[i][x];
  }
  for (int x = 0; x < k; ++x) nxtx[n][x] = nxtnx[n][x] = n;
  for (int i = n - 1; i >= 0; --i) {
    for (int x = 0; x < k; ++x) nxtx[i][x] = nxtx[i + 1][x];
    nxtx[i][a[i]] = i;
    for (int x = 0; x < k; ++x) nxtnx[i][x] = nxtnx[i + 1][x];
    for (int x = 0; x < k; ++x) if (x != a[i]) nxtnx[i][x] = i;
  }
  memset(dp1, -1, sizeof(dp1));
  memset(dp2, -1, sizeof(dp2));
  int ans = n;
  for (int x = 0; x < k; ++x) ans = min(ans, calc1(0, n - 1, x));
  cout << ans << '\n';
}
 
int main() {
  int t;
  cin >> t;
  while (t--) solve();
}
--------------------------------------------------
Problem ID: 1922E
Editorial Content:
1922E - Increasing Subsequences
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
vector<int> f(long long x) {
  vector<int> res;
  if (x == 2) {
  	res.push_back(0);
  } else if (x & 1) {
    res = f(x - 1);
    res.push_back(*min_element(res.begin(), res.end()) - 1);
  } else {
    res = f(x / 2);
    res.push_back(*max_element(res.begin(), res.end()) + 1);
  }
  return res;
}
 
int main() {
  int t;
  cin >> t;
  while (t--) {
    long long x;
    cin >> x;
    auto ans = f(x);
    cout << ans.size() << '\n';
    for (int i : ans) cout << i << ' ';
    cout << '\n';
  }
}
--------------------------------------------------
Problem ID: 1922D
Editorial Content:
1922D - Berserk Monsters
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<int> a(n + 2), d(n + 2, INT_MAX);
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1; i <= n; ++i) cin >> d[i];
    set<int> lft, cur;
    for (int i = 0; i < n + 2; ++i) {
      lft.insert(i);
      cur.insert(i);
    }
    for (int z = 0; z < n; ++z) {
      set<int> del, ncur;
      for (int i : cur) {
        auto it = lft.find(i);
        if (it == lft.end()) continue;
        int prv = *prev(it);
        int nxt = *next(it);
        if (a[prv] + a[nxt] > d[i]) {
          del.insert(i);
          ncur.insert(prv);
          ncur.insert(nxt);
        }
      }
      cout << del.size() << ' ';
      for (auto it : del) lft.erase(it);
      cur = ncur;
    }
    cout << '\n';
  }
}
--------------------------------------------------
Problem ID: 1922C
Editorial Content:
1922C - Closest Cities
Tutorial
Tutorial is loading...
Solution (Roms)
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 200'000;
const int INF = 1'000'000'009;
int t;
 
char type(const vector <int>& a, int id) {
    int distL = (id == 0? INF : a[id] - a[id - 1]);
    int distR = (id + 1 == a.size()? INF : a[id + 1] - a[id]);
    if(distL < distR) return 'L';
    if(distL > distR) return 'R';
    assert(false);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin >> t;
    for (int tc = 0; tc < t; ++tc) {
        int n;
        cin >> n;
        vector <int> a(n);
        for (int i = 0; i < n; ++i)
            cin >> a[i];
            
        vector <int> l(n), r(n);
        for (int i = 1; i < n; ++i)
            r[i] = r[i - 1] + (type(a, i - 1) == 'R'? 1 : a[i] - a[i - 1]);
        for (int i = n - 2; i >= 0; --i)
            l[i] = l[i + 1] + (type(a, i + 1) == 'L'? 1 : a[i + 1] - a[i]);
        
        int m;
        cin >> m;
        for (int i = 0; i < m; ++i) {
            int x, y;
            cin >> x >> y;
            --x, --y;
            if (x < y) 
                cout << r[y] - r[x] << endl;
            else
                cout << l[y] - l[x] << endl;
        }
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1922B
Editorial Content:
1922B - Forming Triangles
Tutorial
Tutorial is loading...
Solution (Roms)
#include <bits/stdc++.h>
 
using namespace std;
 
int t;
 
int main() {
    cin >> t;
    for (int tc = 0; tc < t; ++tc) {
        int n;
        cin >> n;
        map<int, int> numOfLens;
        for (int i = 0; i < n; ++i){
            int x;
            cin >> x;
            ++numOfLens[x];
        }
        
        long long res = 0;
        int sum = 0;
        for (auto it : numOfLens) {
            long long cnt = it.second;
            if(cnt >= 3)
                res += cnt * (cnt - 1) * (cnt - 2) / 6;
            if(cnt >= 2)
                res += cnt * (cnt - 1) / 2 * sum;
            sum += cnt;
        }
        
        cout << res << endl;
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1922A
Editorial Content:
1922A - Tricky Template
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	n = int(input())
	a = input()
	b = input()
	c = input()
	print("YES" if any([a[i] != c[i] and b[i] != c[i] for i in range(n)]) else "NO")
--------------------------------------------------
Problem ID: 1921G
Editorial Content:
1921G - Mischievous Shooter
Tutorial
Tutorial is loading...
Solution
//ciao_chill
#include<bits/stdc++.h>
using namespace std;
#define int long long

int n, m, k;
vector<vector<int>> a;


bool prov(int i, int j) {
    return 0 <= i && i < n && 0 <= j && j < m;
}

int ans() {
    int cnt = 0;
    int dp[n][m];
    int pref[n][m];
    int pref_up[n][m];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            pref_up[i][j] = a[i][j];
            if (prov(i - 1, j))
                pref_up[i][j] += pref_up[i - 1][j];
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = m - 1; j >= 0; j--) {
            pref[i][j] = a[i][j];
            if (prov(i - 1, j + 1))
                pref[i][j] += pref[i - 1][j + 1];
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            dp[i][j] = pref_up[i][j];
            if (prov(i - k, j))
                dp[i][j] -= pref_up[i - k][j];
            if (prov(i, j - 1))
                dp[i][j] += dp[i][j - 1];
            if (j < k) {
                int i1 = j - k + i;
                if (i1 >= 0)
                    dp[i][j] -= pref[i1][0];
            }
            else
                dp[i][j] -= pref[i][j - k];
            if (prov(i - k, j))
                dp[i][j] += pref[i - k][j];
            cnt = max(cnt, dp[i][j]);
        }
    }

    return cnt;
}

void solve() {
    cin >> n >> m >> k;
    k++;
    char c;
    bool st[n][m];
    a.resize(n);
    for (int i = 0; i < n; i++) {
        a[i].resize(m);
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
        {
            cin >> c;
            st[i][j] = (c == '#');
            a[i][j] = st[i][j];
        }
    }

    int mx = ans();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            a[i][j] = st[n - i - 1][j];
        }
    }
    mx = max(mx, ans());
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            a[i][j] = st[i][m - j - 1];
        }
    }
    mx = max(mx, ans());
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            a[i][j] = st[n - i - 1][m - j - 1];
        }
    }
    mx = max(mx, ans());

    cout << mx << '\n';

}

signed main() {
    cin.tie(nullptr);
    cout.tie(nullptr);
    ios_base::sync_with_stdio(false);

    int tt;
    cin >> tt;
    while (tt--)
        solve();

    return 0;
}
--------------------------------------------------
Problem ID: 1921F
Editorial Content:
1921F - Sum of Progression
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

long long precalc[322][200322];
long long precalci[322][200322];

void solve() {
    int n, q;
    cin >> n >> q;
    vector<long long> a(n);
    int pivot = 1;
    while (pivot * pivot < n) {
        pivot++;
    }
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    for (int i = 0; i < pivot; i++) {
        for (int j = 0; j <= i; j++) {
            precalc[i][j] = 0LL;
            precalci[i][j] = 0LL;
        }
        for (int j = 0; j < n; j++) {
            precalci[i][j + i + 1] = precalci[i][j] + a[j] * (j / (i + 1) + 1);
            precalc[i][j + i + 1] = precalc[i][j] + a[j];
        }
    }
    while (q--) {
        int s, d;
        long long k;
        long long ans = 0;
        cin >> s >> d >> k;
        s--;
        if (d > pivot) {
            for (int i = s; i <= s + (k - 1) * d; i += d) {
                ans += a[i] * ((i - s) / d + 1);
            }
            cout << ans << " ";
            continue;
        }
        long long last = s + d * k - d;
        int first = s;
        cout << precalci[d - 1][last + d] - precalci[d - 1][first] -
                (precalc[d - 1][last + d] - precalc[d - 1][first]) * (first / d) << ' ';
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int tests;
    cin >> tests;
    while (tests--) {
        solve();
        if (tests) cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1921E
Editorial Content:
1921E - Eat the Chip
Tutorial
Tutorial is loading...
Solution
def solve():
    h, w, xA, yA, xB, yB = map(int, input().split())

    if (xA - xB) % 2 == 0:
        winner = "Bob"
        if xA >= xB:
            win = False
        elif yA == yB:
            win = True
        else:
            if yA < yB:
                n_turns = yB - 1
            else:
                n_turns = w - yB
            win = xB - 2 * n_turns >= xA

    else:
        winner = "Alice"

        xA += 1
        yA += 0 if yB - yA == 0 else 1 if yB - yA > 0 else -1

        if xA > xB:
            win = False
        elif yA == yB:
            win = True
        else:
            if yA < yB:
                n_turns = w - yA
            else:
                n_turns = yA - 1
            win = xB - 2 * n_turns >= xA

    print(winner if win else "Draw")


t = int(input())

for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 1921D
Editorial Content:
1921D - Very Different Array
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;

struct test {
   void solve() {
        int n, m;
        cin >> n >> m;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        vector<int> b(m);
        for (int i = 0; i < m; i++) cin >> b[i];
        sort(a.begin(), a.end());
        sort(b.rbegin(), b.rend());
        vector<int> c(n);
        long long s = 0;
        for (int i = 0; i < n; i++) {
            c[i] = b[m &mdash; n + i];
            s += abs(c[i] &mdash; a[i]);
        }
        long long res = 0;
        for (int k = 0; k <= n; k++) {
            res = max(res, s);
            if (k < n) {
                s -= abs(c[k] &mdash; a[k]);
                c[k] = b[k];
                s += abs(c[k] &mdash; a[k]);
            }
        }
        cout << res << "\n";
    }
};

int main() {
    ios::sync_with_stdio(false);
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        test().solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1921C
Editorial Content:
1921C - Sending Messages
Tutorial
Tutorial is loading...
Solution
t = int(input())
for _ in range(t):
    n, f, a, b = map(int, input().split())
    m = [0] + [int(x) for x in input().split()]
    for i in range(1, n + 1):
        f -= min(a * (m[i] - m[i - 1]), b)
    print('YES' if f > 0 else 'NO')
--------------------------------------------------
Problem ID: 1921B
Editorial Content:
1921B - Arranging Cats
Tutorial
Tutorial is loading...
Solution
t = int(input())

for _ in range(t):
    n = int(input())
    start = [int(x) for x in input()]
    finish = [int(x) for x in input()]
    pairs = list(zip(start, finish))
    add_amnt = sum(int(a < b) for a, b in pairs)
    rmv_amnt = sum(int(a > b) for a, b in pairs)
    print(max(add_amnt, rmv_amnt))
--------------------------------------------------
Problem ID: 1921A
Editorial Content:
1921A - Square
Tutorial
Tutorial is loading...
Solution
t = int(input())
for _ in range(t):
    a = [[int(x) for x in input().split()] for i in range(4)]
    x = [p[0] for p in a]
    dx = max(x) - min(x)
    print(dx * dx)
--------------------------------------------------
Problem ID: 1920F2
Editorial Content:
1920F2 - Smooth Sailing (Hard Version)
Hint 1
How do we check if a point is inside a polygon using a ray?
Hint 2
If u draw line from island cell extending all the way right, an optimal round trip will cross this line an odd number of times.
Hint 3
What can your state be? How can we simplify this problem down into finding the path that maximizes the minimum node? How can we solve this classic problem?
Solution
For each non-island cell $$$(i, j)$$$, let $$$d_{i,j}$$$ be the minimum Manhattan distance of cell $$$(i, j)$$$ to an underwater volcano. We can find all $$$d_{i,j}$$$ with a multisource BFS from all underwater volcanos. The danger of a round trip is the smallest value of $$$d_{u,v}$$$ over all $$$(u, v)$$$ in the path.
Consider any island cell. We can take inspiration from how we check whether a point is in a polygon — if a point is inside the polygon then a ray starting from the point and going in any direction will intersect the polygon an odd number of times. Draw an imaginary line along the top border of the cell and extend it all the way to the right of the grid.
We can observe that
an optimal round trip will always cross the line an odd number of times.
Using this observation, we can let our state be $$$(\text{row}, \, \text{column}, \, \text{parity of the number of times we crossed the line})$$$. Naively, we can binary search for our answer and BFS to check if $$$(x, y, 0)$$$ and $$$(x, y, 1)$$$ are connected. This solves the easy version of the problem.
To fully solve this problem, we can add states (and their corresponding edges to already added states) one at a time from highest $$$d$$$ to lowest $$$d$$$. For each query $$$(x, y)$$$, we want to find the first time when $$$(x, y, 0)$$$ and $$$(x, y, 1)$$$ become connected. This is a classic DSU with small to large merging problem. In short, we drop a token labeled with the index of the query at both $$$(x, y, 0)$$$ and $$$(x, y, 1)$$$. Each time we merge, we also merge the sets of tokens small to large and check if merging has caused two tokens of the same label to be in the same component. The time complexity of our solution is $$$O(nm \log{(nm)} + q\log^2 q)$$$ with the $$$\log{(nm)}$$$ coming from sorting the states or edges. Note that there exists a $$$O((nm \cdot \alpha{(nm)} + q) \cdot \log{(n+m)})$$$ parallel binary search solution as well as a $$$O(nm \log{(nm)} + q\log{(nm)})$$$ solution that uses LCA queries on the Kruskal's reconstruction tree or min path queries on the MSTs. In fact, with offline LCA queries, we can reduce the complexity to $$$O(nm \cdot \alpha{(nm)} + q)$$$.
Code (small to large)
#include <bits/stdc++.h>
using namespace std; 

const int mx = 3e5 + 5, di[4] = {-1, 0, 1, 0}, dj[4] = {0, -1, 0, 1};

int n, m, q, linei, linej, par[mx * 2], ans[mx]; string A[mx]; 
queue<pair<int, int>> bfsQ; vector<int> dist[mx]; vector<array<int, 3>> edges; set<int> S[mx * 2]; 

int enc(int i, int j, bool crossParity){
    return i * m + j + crossParity * n * m;
}
bool inGrid(int i, int j){
    return i >= 0 and i < n and j >= 0 and j < m;
}
int getR(int i){ 
    return i == par[i] ? i : par[i] = getR(par[i]); 
}
void merge(int a, int b, int w){
    a = getR(a); b = getR(b); 
    
    if (a == b) 
        return;

    if (S[a].size() > S[b].size()) 
        swap(S[a], S[b]);

    for (int i : S[a]){
        if (S[b].count(i)){
            ans[i] = w; 
            S[b].erase(i);
        }
        else 
            S[b].insert(i);
    }
    par[a] = b;
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    cin >> n >> m >> q;

    for (int i = 0; i < n; i++){
        cin >> A[i];
        for (int j = 0; j < m; j++){
            dist[i].push_back(1e9);

            if (A[i][j] == 'v'){
                dist[i][j] = 0;
                bfsQ.push({i, j});
            }
            if (A[i][j] == '#'){
                linei = i;
                linej = j;
            }
        }
    }
    for (int i = 0; i < q; i++){
        int x, y; cin >> x >> y;
        x--; y--;
        S[enc(x, y, 0)].insert(i);
        S[enc(x, y, 1)].insert(i);
    }

    // Multisource BFS to find min distance to volcano
    while (bfsQ.size()){
        auto [i, j] = bfsQ.front(); bfsQ.pop();

        for (int dir = 0; dir < 4; dir++){
            int ni = i + di[dir], nj = j + dj[dir];

            if (inGrid(ni, nj) and dist[i][j] + 1 < dist[ni][nj]){
                dist[ni][nj] = dist[i][j] + 1;
                bfsQ.push({ni, nj});
            }
        }
    }

    // Get the edges
    for (int i = 0; i < n; i++){
        for (int j = 0; j < m; j++){
            // Look at cells to the up and left (so dir = 0 and dir = 1)
            for (int dir = 0; dir < 2; dir++){
                int ni = i + di[dir], nj = j + dj[dir];

                if (inGrid(ni, nj) and A[i][j] != '#' and A[ni][nj] != '#'){
                    int w = min(dist[i][j], dist[ni][nj]);
                    
                    // Crosses the line
                    if (i == linei and ni == linei - 1 and j > linej){
                        edges.push_back({w, enc(i, j, 0), enc(ni, nj, 1)});
                        edges.push_back({w, enc(i, j, 1), enc(ni, nj, 0)});
                    }
                    // Doesn't cross the line
                    else{
                        edges.push_back({w, enc(i, j, 0), enc(ni, nj, 0)});
                        edges.push_back({w, enc(i, j, 1), enc(ni, nj, 1)});
                    }
                }
            }
        }
    }

    // Sort in reverse and merge to solve offline
    sort(edges.begin(), edges.end(), greater<array<int, 3>>());

    // Init DSU stuff
    iota(par, par + mx * 2, 0);

    for (auto [w, u, v] : edges)
        merge(u, v, w);
    
    for (int i = 0; i < q; i++)
        cout<<ans[i]<<"\n";
}
Code (LCA queries)
#include <bits/stdc++.h>
using namespace std; 

const int mx = 3e5 + 5, di[4] = {-1, 0, 1, 0}, dj[4] = {0, -1, 0, 1};

int n, m, q, id, linei, linej, par[mx * 4], dep[mx], up[mx * 4][21], val[mx * 4]; 
string A[mx]; queue<pair<int, int>> bfsQ; vector<int> dist[mx], adj[mx * 4]; vector<array<int, 3>> edges; 

int enc(int i, int j, bool crossParity){
    // Note that nodes are 1 indexed
    return 1 + i * m + j + crossParity * n * m;
}
bool inGrid(int i, int j){
    return i >= 0 and i < n and j >= 0 and j < m;
}
int getR(int i){ 
    return i == par[i] ? i : par[i] = getR(par[i]); 
}
void merge(int a, int b, int w){
    a = getR(a); b = getR(b); 

    if (a == b)
        return;
    
    adj[id].push_back(a);
    adj[id].push_back(b);
    val[id] = w;

    par[a] = par[b] = id;
    id++;
}
void dfs(int i){
    for (int l = 1; l < 21; l++)
        up[i][l] = up[up[i][l - 1]][l - 1];
    
    for (int to : adj[i]){
        if (to != up[i][0]){
            up[to][0] = i;
            dep[to] = dep[i] + 1;
            dfs(to);
        }
    }
}
int qry(int x, int y){
    if (dep[x] < dep[y]) 
        swap(x, y);

    for (int l = 20, jmp = dep[x] - dep[y]; ~l; l--){
        if (jmp & (1 << l)){
            x = up[x][l];
        }
    }
    if (x == y)
        return val[x];
    
    for (int l = 20; ~l; l--){
        if (up[x][l] != up[y][l]){
            x = up[x][l]; 
            y = up[y][l];
        }
    }
    return val[up[x][0]];
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    cin >> n >> m >> q;

    for (int i = 0; i < n; i++){
        cin >> A[i];
        for (int j = 0; j < m; j++){
            dist[i].push_back(1e9);

            if (A[i][j] == 'v'){
                dist[i][j] = 0;
                bfsQ.push({i, j});
            }
            if (A[i][j] == '#'){
                linei = i;
                linej = j;
            }
        }
    }

    // Multisource BFS to find min distance to volcano
    while (bfsQ.size()){
        auto [i, j] = bfsQ.front(); bfsQ.pop();

        for (int dir = 0; dir < 4; dir++){
            int ni = i + di[dir], nj = j + dj[dir];

            if (inGrid(ni, nj) and dist[i][j] + 1 < dist[ni][nj]){
                dist[ni][nj] = dist[i][j] + 1;
                bfsQ.push({ni, nj});
            }
        }
    }

    // Get the edges
    for (int i = 0; i < n; i++){
        for (int j = 0; j < m; j++){
            // Look at cells to the up and left (so dir = 0 and dir = 1)
            for (int dir = 0; dir < 2; dir++){
                int ni = i + di[dir], nj = j + dj[dir];

                if (inGrid(ni, nj) and A[i][j] != '#' and A[ni][nj] != '#'){
                    int w = min(dist[i][j], dist[ni][nj]);
                    
                    // Crosses the line
                    if (i == linei and ni == linei - 1 and j > linej){
                        edges.push_back({w, enc(i, j, 0), enc(ni, nj, 1)});
                        edges.push_back({w, enc(i, j, 1), enc(ni, nj, 0)});
                    }
                    // Doesn't cross the line
                    else{
                        edges.push_back({w, enc(i, j, 0), enc(ni, nj, 0)});
                        edges.push_back({w, enc(i, j, 1), enc(ni, nj, 1)});
                    }
                }
            }
        }
    }

    // We merge from largest w to smallest
    sort(edges.begin(), edges.end(), greater<array<int, 3>>());

    // Init DSU stuff
    id = n * m * 2 + 1;
    iota(par, par + mx * 4, 0);

    // Merge
    for (auto [w, u, v] : edges)
        merge(u, v, w);
    
    // DFS to construct the Kruskal's reconstruction trees
    for (int i = n * m * 4; i; i--)
        if (!up[i][0])
            dfs(i);
    
    // Answer queries via LCA queries
    for (int i = 0; i < q; i++){
        int x, y; cin >> x >> y;
        x--; y--;
        cout<<qry(enc(x, y, 0), enc(x, y, 1))<<"\n";
    }
}
--------------------------------------------------
Problem ID: 1920F1
Editorial Content:
1920F1 - Smooth Sailing (Easy Version)
Hint 1
Use the fact that a good some path $$$p$$$ fully encircles the island if it is impossible to go from an island cell to a cell on the border by only travelling to adjacent or diagonal cells without touching a cell on path $$$p$$$.
Hint 2
Binary search!
Solution
For each non-island cell $$$(i, j)$$$, let $$$d_{i,j}$$$ be the minimum Manhattan distance of cell $$$(i, j)$$$ to an underwater volcano. We can find all $$$d_{i,j}$$$ with a multisource BFS from all underwater volcanos. The danger of a round trip is the smallest value of $$$d_{u,v}$$$ over all $$$(u, v)$$$ in the path.
For each query, binary search on the answer $$$k$$$ — we can only visit cell ($$$i, j$$$) if $$$d_{i,j} \geq k$$$. Now, let's
mark
all cells ($$$i, j$$$) ($$$d_{i,j} \geq k$$$)
reachable
from ($$$x, y$$$). There exists a valid round trip if it is not possible to go from an island cell to a border cell without touching a
marked
cell.
The time complexity of this solution is $$$O(nm \log{(n+m)})$$$.
Code
#include <bits/stdc++.h>
using namespace std;

const int mx = 3e5 + 5;
const int diAdj[4] = {-1, 0, 1, 0}, djAdj[4] = {0, -1, 0, 1};
const int diDiag[8] = {0, 0, -1, 1, -1, -1, 1, 1}, djDiag[8] = {-1, 1, 0, 0, -1, 1, 1, -1};

int n, m, q, islandi, islandj; string A[mx]; vector<int> dist[mx]; vector<bool> reachable[mx], islandVis[mx]; queue<pair<int, int>> bfsQ;

bool inGrid(int i, int j){
    return i >= 0 and i < n and j >= 0 and j < m;
}
bool onBorder(int i, int j){
    return i == 0 or i == n - 1 or j == 0 or j == m - 1;
}
void getReach(int i, int j, int minVal){
    if (!inGrid(i, j) or reachable[i][j] or dist[i][j] < minVal or A[i][j] == '#')
        return;
    
    reachable[i][j] = true;

    for (int dir = 0; dir < 4; dir++)
        getReach(i + diAdj[dir], j + djAdj[dir], minVal);
}
bool reachBorder(int i, int j){
    if (!inGrid(i, j) or reachable[i][j] or islandVis[i][j])
        return false;
    
    if (onBorder(i, j))
        return true;
    
    islandVis[i][j] = true;

    bool ok = false;
    for (int dir = 0; dir < 8; dir++)
        ok |= reachBorder(i + diDiag[dir], j + djDiag[dir]);
    return ok;
}
bool existsRoundTrip(int x, int y, int minVal){
    // Reset
    for (int i = 0; i < n; i++){
        reachable[i] = vector<bool>(m, false);
        islandVis[i] = vector<bool>(m, false);
    }
    // Get all valid cells you can reach from (x, y)
    getReach(x, y, minVal);

    // Check if the valid cells you can reach from (x, y) blocks the island from the border
    return !reachBorder(islandi, islandj);
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    cin >> n >> m >> q;

    for (int i = 0; i < n; i++){
        cin >> A[i];
        dist[i] = vector<int>(m, 1e9);

        for (int j = 0; j < m; j++){
            if (A[i][j] == 'v'){
                dist[i][j] = 0;
                bfsQ.push({i, j});
            }
            if (A[i][j] == '#'){
                islandi = i;
                islandj = j;
            }
        }
    }

    // Multisource BFS to find min distance to volcano
    while (bfsQ.size()){
        auto [i, j] = bfsQ.front(); bfsQ.pop();

        for (int dir = 0; dir < 4; dir++){
            int ni = i + diAdj[dir], nj = j + djAdj[dir];

            if (inGrid(ni, nj) and dist[i][j] + 1 < dist[ni][nj]){
                dist[ni][nj] = dist[i][j] + 1;
                bfsQ.push({ni, nj});
            }
        }
    }
    while (q--){
        int x, y;
        cin >> x >> y;
        x--; y--;

        int L = 0, H = n + m;
        while (L < H){
            int M = (L + H + 1) / 2;
            existsRoundTrip(x, y, M) ? L = M : H = M - 1;
        }
        cout<<L<<"\n";
    }
}
--------------------------------------------------
Problem ID: 1920E
Editorial Content:
1920E - Counting Binary Strings
Hint 1
How do you count the number of good substrings in a string?
Hint 2
We can count the number of good substrings in a string with the counting contribution technique. Now try to solve this problem with dynamic programming.
Hint 3
$$$\frac{n}{1} + \frac{n}{2} + \cdots + \frac{n}{n} = O(n\log n)$$$
Solution
Let's first solve the problem where we are given some string $$$s$$$ and must count the number of good substrings. To do this we use the technique of counting contributions. For every $$$1$$$ in $$$s$$$, we find the number of good substrings containing that $$$1$$$. Consider the following example:
$$$ \underbrace{00001}_{a_1} \! \! \! \, \underbrace{ \; \, \! 0001}_{a_2} \! \! \! \, \underbrace{ \; \, \! 00000001}_{a_3} \! \! \! \, \underbrace{ \; \, \! 0001}_{a_4} \! \! \! \, \underbrace{ \; \, \! 000}_{a_5} $$$
The number of good substrings in this example is $$$a_1 a_2 + a_2 a_3 + a_3 a_4 + a_4 a_5$$$. We can create such array for any string $$$s$$$ and the number of good substrings of $$$s$$$ is the sum of the products of adjacent elements of the array.
This motivates us to reformulate the problem. Instead, we count the number of arrays $$$a_1,a_2,...,a_m$$$ such that every element is positive and the sum of the products of adjacent elements is exactly equal to $$$n$$$. Furthermore, every pair of adjacent elements should have sum minus $$$1$$$ be less than or equal to $$$k$$$. We can solve this with dynamic programming.
$$$ dp_{i,j} = \text{number of arrays with sum $$$i$$$ and last element $$$j$$$} $$$
$$$ \displaystyle dp_{i, j} = \sum_{p=1}^{\min({\lfloor \frac{i}{j} \rfloor},\, k-j+1)}{dp_{i - j \cdot p,p}} $$$
The key observation is that we only have to iterate $$$p$$$ up to $$$\lfloor \frac{i}{j} \rfloor$$$ (since if $$$p$$$ is any greater, $$$j \cdot p$$$ will exceed $$$i$$$). At $$$j=1$$$, we will iterate over at most $$$\lfloor \frac{i}{1} \rfloor$$$ values of $$$p$$$. At $$$j=2$$$, we will iterate over at most $$$\lfloor \frac{i}{2} \rfloor$$$ values of $$$p$$$. In total, at each $$$i$$$, we will iterate over at most $$$\lfloor \frac{i}{1} \rfloor + \lfloor \frac{i}{2} \rfloor +\cdots + \lfloor \frac{i}{i} \rfloor \approx i \log i$$$ values of $$$p$$$. Thus, the time complexity of our solution is $$$O(nk\log n)$$$.
Code
#include <bits/stdc++.h>
using namespace std; 
 
const int md = 998244353;
 
void solve(){
    int n, k;
    cin >> n >> k;
 
    int dp[n + 1][k + 1] = {};
    int ans = 0;
    
    fill(dp[0] + 1, dp[0] + k + 1, 1);
 
    for (int sum = 1; sum <= n; sum++){
        for (int cur = 1; cur <= k; cur++){
            for (int prv = 1; cur * prv <= sum and cur + prv - 1 <= k; prv++)
                dp[sum][cur] = (dp[sum][cur] + dp[sum - cur * prv][prv]) % md;
 
            if (sum == n)
                ans = (ans + dp[sum][cur]) % md;
        }
    }
    cout<<ans<<"\n";
}
 
int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    int tc; 
    cin >> tc;
 
    while (tc--)
        solve();
}
--------------------------------------------------
Problem ID: 1920D
Editorial Content:
1920D - Array Repetition
Hint 1
For some query try to trace your way back to where the $$$k$$$-th number was added.
Hint 2
Here's an example of tracing back:
$$$ \underbrace{[l_1, l_2,...l_{x}]}_{\text{length } x} \underbrace{[l_1, l_2,...l_{x}]}_{\text{length } x} \underbrace{[l_1, l_2,...l_{x}]}_{\text{length } x} ... \underbrace{[l_1, \textbf{l_2},...l_{x}]}_{\text{length } x} $$$
Suppose the $$$k$$$-th element is the bolded $$$l_2$$$. Finding the $$$k$$$-th element is equivalent to finding the ($$$k \bmod x$$$)-th element (unless if $$$k \bmod x$$$ is $$$0$$$).
Solution
First, let's precalculate some things:
$$$lst_i=\text{last element after performing the first $$$i$$$ operations}$$$
$$$dp_i=\text{number of elements after the first i operations}$$$
Now, let's try answering some query $$$k$$$. If we have some $$$dp_i=k$$$ then the answer is $$$lst_i$$$.
Otherwise, let's find the first $$$i$$$ such that $$$dp_i > k$$$. This $$$i$$$ will be a repeat operation and our answer will lie within one of the repetitions. Our list at this point will look like:
$$$ \underbrace{[l_1, l_2,...l_{dp_{i-1}}]}_{\text{length } dp_{i-1}} \underbrace{[l_1, l_2,...l_{dp_{i-1}}]}_{\text{length } dp_{i-1}} \underbrace{[l_1, l_2,...l_{dp_{i-1}}]}_{\text{length } dp_{i-1}} ... \underbrace{[l_1, \textbf{l_2},...l_{dp_{i-1}}]}_{\text{length } dp_{i-1}} $$$
Let the $$$k$$$-th element be the bolded $$$l_2$$$ of the final repetition. As you can see, finding the $$$k$$$-the element is equivalent to finding the $$$(k \bmod dp_{i-1})$$$-th element. Thus, we should do $$$k:=k \bmod dp_{i-1}$$$ and repeat! But there is one more case! If $$$k \equiv 0 \pmod {dp_{i-1}}$$$ then the answer is $$$lst_{i-1}$$$.
At this point there are 2 ways we can go about solving this:
Way 1
Notice that after $$$\log{(\max{k})}$$$ operations of the second type, the number of elements will exceed $$$\max{k}$$$. So we only care about the first $$$\log{(\max{k})}$$$ operations of the second type. Thus, iterate through the $$$\log{(\max{k})}$$$ operations of the second type backwards and perform the casework described above. This leads to a $$$O(n+q\log{(\max{k})})$$$ solution or a $$$O(n+q(\log{(\max{k})}+\log n))$$$ solution depending on implementation details.
Way 2
Observe that $$$k:=k \bmod dp_{i-1}$$$ will reduce $$$k$$$ by at least half. If we repeatedly binary search for the first $$$i$$$ such that $$$dp_i \geq k$$$, and then do $$$k:=k \bmod dp_{i-1}$$$ (or stop if it's one of the other cases), then each query will take $$$O(\log n\log k)$$$ time so the total time complexity will be $$$O(n+q\log n\log {(\max{k})})$$$.
Way 1
Notice that after $$$\log{(\max{k})}$$$ operations of the second type, the number of elements will exceed $$$\max{k}$$$. So we only care about the first $$$\log{(\max{k})}$$$ operations of the second type. Thus, iterate through the $$$\log{(\max{k})}$$$ operations of the second type backwards and perform the casework described above. This leads to a $$$O(n+q\log{(\max{k})})$$$ solution or a $$$O(n+q(\log{(\max{k})}+\log n))$$$ solution depending on implementation details.
Way 2
Observe that $$$k:=k \bmod dp_{i-1}$$$ will reduce $$$k$$$ by at least half. If we repeatedly binary search for the first $$$i$$$ such that $$$dp_i \geq k$$$, and then do $$$k:=k \bmod dp_{i-1}$$$ (or stop if it's one of the other cases), then each query will take $$$O(\log n\log k)$$$ time so the total time complexity will be $$$O(n+q\log n\log {(\max{k})})$$$.
Code (iterating over second type operations)
#include <bits/stdc++.h>
using namespace std; 

#define ll long long

void solve(){
    int n, q;
    cin >> n >> q;

    ll dp[n + 1] = {};
    int lstAdd[n + 1] = {};
    vector<int> pos;

    for (int i = 1, doAdd = true; i <= n; i++){
        int a, v; 
        cin >> a >> v;

        if (a == 1){
            lstAdd[i] = v;
            dp[i] = dp[i - 1] + 1;
        }
        else{
            lstAdd[i] = lstAdd[i - 1];
            dp[i] = ((v + 1) > 2e18 / dp[i - 1]) ? (ll)2e18 : dp[i - 1] * (v + 1);

            if (doAdd)
                pos.push_back(i);
        }
        // No need to consider any more repetitions after this point
        if (dp[i] == 2e18)
            doAdd = false;
    }
    while (q--){
        ll k; 
        cin >> k;

        for (int i = pos.size() - 1; ~i; i--){
            int idx = pos[i];

            if (dp[idx] > k and dp[idx - 1] < k){
                if (k % dp[idx - 1] == 0){
                    k = dp[idx - 1];
                    break;
                }
                k %= dp[idx - 1];
            }
        }
        cout<<lstAdd[lower_bound(dp + 1, dp + n + 1, k) - dp]<<" \n"[q == 0];
    }
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    int tc; 
    cin >> tc;
    
    while (tc--) 
        solve();
}
Code (repeated binary searches)
#include <bits/stdc++.h>
using namespace std; 

#define ll long long

void solve(){
    int n, q;
    cin >> n >> q;

    ll dp[n + 1] = {};
    int lstAdd[n + 1] = {};

    for (int i = 1; i <= n; i++){
        int a, v; 
        cin >> a >> v;

        if (a == 1){
            lstAdd[i] = v;
            dp[i] = dp[i - 1] + 1;
        }
        else{
            lstAdd[i] = lstAdd[i - 1];
            dp[i] = ((v + 1) > 2e18 / dp[i - 1]) ? (ll)2e18 : dp[i - 1] * (v + 1);
        }
    }
    while (q--){
        ll k; 
        cin >> k;

        while (true){
            int pos = lower_bound(dp + 1, dp + n + 1, k) - dp;
            
            if (dp[pos] == k){
                cout<<lstAdd[pos]<<" \n"[q == 0];
                break;
            }
            if (k % dp[pos - 1] == 0){
                cout<<lstAdd[pos - 1]<<" \n"[q == 0];
                break;
            }
            k %= dp[pos - 1];
        }
    }
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    int tc; 
    cin >> tc;
    
    while (tc--) 
        solve();
}
--------------------------------------------------
Problem ID: 1920C
Editorial Content:
1920C - Partitioning the Array
Hint 1
Try to solve the problem for just two integers $$$x$$$ and $$$y$$$. Under what $$$m$$$ are they equal (modulo $$$m$$$)?
Hint 2
How can we use the previous hint and gcd to solve the problem?
Solution
For some $$$x$$$ and $$$y$$$, let's try to find all $$$m$$$ such that $$$x \bmod m \equiv y \bmod m$$$. We can rearrange the equation into $$$(x-y) \equiv 0 \pmod m$$$. Thus, if $$$m$$$ is a factor of $$$|x-y|$$$, then $$$x$$$ and $$$y$$$ will be equal modulo $$$m$$$.
Let's solve for some $$$k$$$. A valid partition exists if there exists some $$$m>1$$$ such that the following is true:
$$$a_1 \equiv a_{1+k} \pmod m$$$
$$$a_2 \equiv a_{2+k} \pmod m$$$
...
$$$a_{n-k} \equiv a_{n} \pmod m$$$
The first condition $$$a_1 \equiv a_{1+k} \pmod m$$$ is satisfied if $$$m$$$ is a factor of $$$|a_1-a_{1+k}|$$$. The second condition $$$a_2 \equiv a_{2+k} \pmod m$$$ is satisfied if $$$m$$$ is a factor of $$$|a_2-a_{2+k}|$$$. And so on...
Thus, all conditions are satisfied if $$$m$$$ is a factor of:
$$$|a_1-a_{1+k}|, |a_2-a_{2+k}|,...,|a_{n-k}-a_n|$$$
In other words, all conditions are satisfied if $$$m$$$ is a factor of:
$$$\gcd(|a_1-a_{1+k}|, |a_2-a_{2+k}|,...,|a_{n-k}-a_n|)$$$
So a valid $$$m$$$ exists for some $$$k$$$ if the aforementioned $$$\gcd$$$ is greater than $$$1$$$.
We can iterate over all possible $$$k$$$ (remember that $$$k$$$ is a divisor of $$$n$$$) and solve for each $$$k$$$ to get our answer. The time complexity of this will be $$$O((n + \log n) \cdot \text{max divisors of n})$$$. Note that each pass through the array takes $$$n + \log n$$$ time because of how the gcd will either be halved or stay the same at each point.
Code
#include <bits/stdc++.h>
using namespace std; 

void solve(){
    int n; 
    cin >> n;

    int A[n];
    for (int &i : A)
        cin >> i;
    
    int ans = 0;
    for (int k = 1; k <= n; k++){
        if (n % k == 0){
            int g = 0;
            for (int i = 0; i + k < n; i++)
                g = __gcd(g, abs(A[i + k] - A[i]));
            ans += (g != 1);
        }
    }
    cout<<ans<<"\n";
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    int tc; 
    cin >> tc;

    while (tc--) 
        solve();
}
--------------------------------------------------
Problem ID: 1920B
Editorial Content:
1920B - Summation Game
Hint 1
What is the optimal strategy for Bob?
Hint 2
It is optimal for Bob to negate the $$$x$$$ largest elements of the array. So what should Alice do?
Solution
It is optimal for Bob to negate the $$$x$$$ largest elements of the array. So in order to minimize the damage Bob will do, Alice should always remove some number of largest elements.
To solve the problem, we can sort the array and iterate over $$$i$$$ ($$$0 \leq i \leq k$$$) where $$$i$$$ is the number of elements Alice removes. For each $$$i$$$, we know that Alice will remove the $$$i$$$ largest elements of the array and Bob will then negate the $$$x$$$ largest remaining elements. So the sum at the end can be calculated quickly with prefix sums. The time complexity is $$$O(n \log n)$$$ because of sorting.
Code
#include <bits/stdc++.h>
using namespace std; 

void solve(){
    int n, k, x;
    cin >> n >> k >> x;
    
    int A[n + 1] = {};
    for (int i = 1; i <= n; i++)
        cin >> A[i];
    
    sort(A + 1, A + n + 1, greater<int>());

    for (int i = 1; i <= n; i++)
        A[i] += A[i - 1];
    
    int ans = -1e9;
    for (int i = 0; i <= k; i++)
        ans = max(ans, A[n] - 2 * A[min(i + x, n)] + A[i]);
    
    cout<<ans<<"\n";
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    int tc; 
    cin >> tc;
    
    while (tc--) 
        solve();
}
--------------------------------------------------
Problem ID: 1920A
Editorial Content:
1920A - Satisfying Constraints
Hint 1
Suppose there are no $$$\neq$$$ constraints. How would you solve the problem? How would you then factor in the $$$\neq$$$ constraints into your solution?
Solution
Let's first only consider the $$$\geq$$$ and $$$\leq$$$ constraints. The integers satisfying those two constraints will be some contiguous interval $$$[l, r]$$$. To find $$$[l,r]$$$, for each $$$\geq x$$$ constraint, we do $$$l := \max{(l, x)}$$$ and for each $$$\leq x$$$ constraint, we do $$$r := \min{(r, x)}$$$.
Now, for each, $$$\neq x$$$ constraint, we check if $$$x$$$ is in $$$[l, r]$$$. If so, we subtract one from the answer (remember that there are no duplicate constraints). Let the total number of times we subtract be $$$s$$$. Then our answer is $$$\max{(r-l+1-s,0)}$$$. The time complexity of this solution is $$$O(n)$$$.
Code
#include <bits/stdc++.h>
using namespace std; 

void solve(){
    int n;
    cin >> n;

    int l = 1;
    int r = 1e9;
    int s = 0;
    
    vector<int> neq;

    for (int i = 0; i < n; i++){
        int a, x;
        cin >> a >> x;

        if (a == 1)
            l = max(l, x);
        if (a == 2)
            r = min(r, x);
        if (a == 3)
            neq.push_back(x);
    }
    for (int x : neq)
        if (x >= l and x <= r)
            s++;
    
    cout<<max(r - l + 1 - s, 0)<<"\n";
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0); 
    int tc; 
    cin >> tc;

    while (tc--)
        solve();
}
--------------------------------------------------
Problem ID: 1919H
Editorial Content:
1919H - Tree Diameter
Background
The original problem allowed $$$5n$$$ type 1 queries and $$$n$$$ type 2 queries and was used as the last problem of a Div. 2 round. When we opened the round for testing,
dario2994
solved the problem using $$$2n$$$ type 1 queries, and a few days later, he managed to improve his solution to use only $$$n$$$ type 1 queries. This was what made us decide to change this round into a Div. 1 round instead of a Div. 2 round.
Hint 1
Try rooting the tree at an
edge
.
Hint 2
Use $$$n - 2$$$ of query $$$2$$$ to find the distance of every edge to the root. For convenience, we will call the distance of an edge to the root the depth of the edge.
Hint 3
We start with only the root edge, then add edges of depth $$$0$$$, followed by depth $$$1, 2, \ldots$$$
Hint 4
If we want to add a new edge with depth $$$i$$$, we need to attach it to one of the edges with depth $$$i - 1$$$. We can let the weight of the edge we want to attach be $$$10^9$$$ to force the diameter to pass through it, then let the edges of depth $$$i - 1$$$ have weights be different multiples of $$$n$$$. This way, we can determine which edges of depth $$$i - 1$$$ are used in the diameter (unless the two largest edges are used).
Hint 5
Make use of isomorphism to handle the case in hint 4 where the largest two edges are used.
Hint 6
If isomorphism cannot be used, find a leaf edge of a lower depth than the query edge and force the diameter to pass through the leaf edge and the query edge. Then, only 1 edge of depth $$$i - 1$$$ will be used and the edge weights for edges of depth $$$i - 1$$$ can follow a similar structure as hint 4.
Solution
We will root the tree at edge $$$1$$$. Then, use $$$n - 2$$$ of query $$$2$$$ to find the distance of every edge to the root. For convenience, we will call the distance of an edge to the root the depth of the edge. Our objective is to add the edges in increasing order of depth, so when we are inserting an edge of depth $$$i$$$, all edges of depth $$$i - 1$$$ are already inserted and we just have to figure out which edge of depth $$$i - 1$$$ we have to attach the edge of depth $$$i$$$ to.
For convenience, the edge weights used in query $$$1$$$ will be $$$1$$$ by default unless otherwise stated. Let $$$c_i$$$ store the list of edges with depth $$$i$$$. Suppose we want to insert edge $$$u$$$ into the tree and the depth of edge $$$u$$$ is $$$d$$$. We let the weight of the edge $$$u$$$ be $$$10 ^ 9$$$ and the weight of edges in $$$c_{d - 1}$$$ be $$$n, 2n, 3n, \ldots, (|c_{d - 1}| - 2)n, (|c_{d - 1}| - 1)n, (|c_{d - 1}| - 1)n$$$. The diameter will pass through edge $$$u$$$, the parent edge of $$$u$$$, as well as one edge of weight $$$(|c_{d - 1}| - 1)n$$$. If we calculate $$$\left\lfloor\frac{\text{diameter} - 10^9}{n}\right\rfloor - (|c_{d - 1}| - 1)$$$, we will be able to tell the index of the parent edge of $$$u$$$.
However, there is one exception. When the parent edge of $$$u$$$ is one of the last 2 edges of $$$c_{d - 1}$$$, we are unable to differentiate between the two of them as they have the same weight. This is not a problem if the last 2 edges are isomorphic to each other, as attaching $$$u$$$ to either parent results in the same tree. For now, we will assume that the last 2 edges of $$$c_{d - 1}$$$ are isomorphic to each other.
However, after attaching edge $$$u$$$ to one last 2 edges in $$$c_{d - 1}$$$, they are no longer isomorphic. Hence, we need to use a different method to insert the remaining edges of depth $$$d$$$. Let the new edge that we want to insert be $$$v$$$. Let the weight of edges $$$u$$$ and $$$v$$$ be $$$10^9$$$ and the weights of edges in $$$c_{d - 1}$$$ be the same as before. Now, we can use $$$\left\lfloor\frac{\text{diameter} - 2\cdot 10^9}{n}\right\rfloor$$$ to determine whether edge $$$v$$$ share the same parent as $$$u$$$, and if it does not share the same parent, it can still determine the index of the parent edge of $$$v$$$. With the additional information of whether edge $$$v$$$ shares the same parent as edge $$$u$$$, we will be able to differentiate the last 2 edges of $$$c_{d - 1}$$$ from each other.
Now, we just need to handle the issue where the last 2 edges of $$$c_{d - 1}$$$ are not isomorphic. When we only have the root edge at the start, the left and right ends of the edge are isomorphic (note that for the root edge, we consider it as 2 separate edges, one with the left endpoint and one with the right endpoint). We try to maintain the isomorphism as we add edges of increasing depth. Suppose the last two edges of $$$c_{d - 1}$$$ are isomorphic. Let the two edges be $$$a$$$ and $$$b$$$. Then, we insert edges of depth $$$d$$$ using the above method. Let the child edges attached to $$$a$$$ and $$$b$$$ be represented by sets $$$S_a$$$ and $$$S_b$$$ respectively. If either $$$S_a$$$ or $$$S_b$$$ has sizes at least $$$2$$$, the two edges in the same set will be isomorphic, so we can let those 2 edges be the last 2 edges of $$$c_d$$$. Now, the sizes of $$$S_a$$$ and $$$S_b$$$ are both strictly smaller than $$$2$$$. If the sizes of both sets are exactly $$$1$$$, the two edges from each set will be isomorphic as well as $$$a$$$ and $$$b$$$ are isomorphic. Now, the only case left is if at least one of the sets is empty.
Without loss of generality, assume that $$$S_a$$$ is empty. Since it is no longer possible to maintain two isomorphic edges, we now change our objective to find a leaf (it will be clear why in the following paragraphs). If $$$S_b$$$ is empty as well, both $$$a$$$ and $$$b$$$ are leaves so we can choose any one of them. If $$$S_b$$$ is not empty, then $$$a$$$ and $$$b$$$ are no longer isomorphic due to their children. This means that we cannot simply use $$$b$$$ as the leaf $$$S_a$$$ might be children of $$$b$$$ instead of $$$a$$$ as we did not differentiate $$$a$$$ and $$$b$$$ in the previous paragraphs. To determine whether $$$S_a$$$ belongs to $$$a$$$ or $$$b$$$, we can make use of one type 2 query to find the distance between one of the edges in $$$S_a$$$ and $$$a$$$. If the distance is $$$0$$$, it means that $$$S_a$$$ belongs to $$$a$$$. Otherwise, the distance will be $$$1$$$ and $$$S_a$$$ belongs to $$$b$$$.
Now that we found a leaf, we can use the following method to insert an edge $$$u$$$ of depth $$$d$$$. We let the weight of the edge $$$u$$$ and the leaf edge be $$$10 ^ 9$$$ and the weight of edges in $$$c_{d - 1}$$$ be $$$n, 2n, 3n, \ldots, (|c_{d - 1}| - 2)n, (|c_{d - 1}| - 1)n, |c_{d - 1}|n$$$. The diameter will pass through edge $$$u$$$, the leaf edge, and only one edge of depth $$$d - 1$$$ which is the parent edge of $$$u$$$. Hence, after finding a leaf edge, we can uniquely determine the parent edge from $$$\left\lfloor\frac{\text{diameter} - 2\cdot 10^9}{n}\right\rfloor$$$.
We used $$$n - 2$$$ type 1 queries and $$$n - 1$$$ type 2 queries in total. This is because we used a single type 1 query for each non-root edge. We used $$$n - 2$$$ type 2 queries at the start, and we only used $$$1$$$ additional type 2 query when we were no longer able to maintain two isomorphic edges and changed our methodology to use a leaf edge instead.
Code
#include <bits/stdc++.h> 
using namespace std;

typedef long long ll;
const int INF = 1000000000;
const int MAXN = 1000;

int n;
int lvl[MAXN + 5];
int pe[MAXN + 5];
vector<int> ch[MAXN + 5];

ll query(vector<int> a) {
    cout << "? 1";
    for (int i = 1; i < n; i++) {
        cout << ' ' << a[i];
    }
    cout << endl;
    ll res; cin >> res;
    return res;
}
int query(int a, int b) {
    cout << "? 2 " << a << ' ' << b << endl;
    int res; cin >> res;
    return res;
}

int main() {
    cin >> n;
    for (int i = 2; i < n; i++) {
        lvl[i] = query(1, i);
    }
    int ptr = 3;
    vector<int> base = {1, 2};
    pe[1] = pe[2] = 1;
    bool iso = 1;
    int piv = -1;
    for (int l = 0; l < n; l++) {
        vector<int> a(n, 1);
        int m = base.size();
        for (int i = 0; i < m; i++) {
            a[pe[base[i]]] = min(i + 1, m - iso) * MAXN;
        }
        if (!iso) {
            a[pe[piv]] = INF;
        }
        bool ciso = 0;
        for (int u = 2; u < n; u++) {
            if (lvl[u] != l) {
                continue;
            }
            a[u] = INF;
            ll res = query(a) - INF;
            a[u] = 1;
            if (!iso || ciso) {
                res -= INF;
            }
            int id = res / MAXN;
            if (iso && l) {
                id -= m - 1;
            }
            int v = ptr++;
            pe[v] = u;
            if (ciso) {
                if ((l == 0 && id == 0) || id == -(m - 1)) {
                    ch[base[m - 2]].push_back(v);
                } else if (id == m - 1) {
                    ch[base[m - 1]].push_back(v);
                } else {
                    ch[base[id - 1]].push_back(v);
                }
            } else if (iso && id == m - 1) {
                ch[base[m - 2]].push_back(v);
                ciso = 1;
                a[u] = INF;
            } else {
                ch[base[id - 1]].push_back(v);
            }
        }
        if (m >= 2 && ch[base[m - 2]].size() > ch[base[m - 1]].size()) {
            swap(base[m - 2], base[m - 1]);
        }
        vector<int> nbase;
        for (int i = 0; i < m; i++) {
            for (int j : ch[base[i]]) {
                nbase.push_back(j);
            }
        }
        if (!iso || ch[base[m - 1]].size() >= 2 || ch[base[m - 2]].size() == 1) {
            base = nbase;
            continue;
        }
        if (ch[base[m - 1]].empty()) {
            piv = base[m - 1];
        } else {
            ll res = query(pe[ch[base[m - 1]][0]], pe[base[m - 1]]);
            if (res) {
                swap(base[m - 2], base[m - 1]);
                swap(ch[base[m - 2]], ch[base[m - 1]]);
            }
            piv = base[m - 2];
        }
        iso = 0;
        base = nbase;
    }
    cout << '!' << endl;
    cout << 1 << ' ' << 2 << endl;
    for (int u = 1; u <= n; u++) {
        for (int v : ch[u]) {
            cout << u << ' ' << v << endl;
        }
    }
}
--------------------------------------------------
Problem ID: 1919G
Editorial Content:
1919G - Tree LGM
Hint 1
Think about how you would construct matrix $$$s$$$ if you were given the tree.
Hint 2
If $$$s_{i, i} = \mathtt{0}$$$, what should the value of $$$s_{j, i}$$$ be for all $$$1\le j\le n$$$?
Hint 3
For some $$$i$$$ where $$$s_{i, i} = \mathtt{1}$$$, let $$$Z$$$ be a set containing all the vertices $$$j$$$ where $$$s_{j, i} = \mathtt{0}$$$. More formally, $$$Z = \{j\ |\ 1\le j\le n\text{ and } s_{j, i} = \mathtt{0}\}$$$. Does $$$Z$$$ have any special properties?
Hint 4
Using hint 3, can we break down the problem into smaller sub-problems?
Hint 5
Try solving the problem if the values in each column are a constant. In other words, $$$s_{i, j} = s_{j, j}$$$ for all $$$1\le i\le n$$$ and $$$1\le j\le n$$$.
Solution
Let us consider how we can code the checker for this problem. In other words, if we are given a tree, how can we construct matrix $$$s$$$? We can solve this using dynamic programming. $$$s_{i, j} = \mathtt{1}$$$ if and only if at least one child $$$c$$$ of vertex $$$j$$$ (when the tree is rooted at vertex $$$i$$$) has $$$s_{i, c} = \mathtt{0}$$$. This is because the player can move the coin from vertex $$$j$$$ to vertex $$$c$$$ which will cause the opponent to be in a losing state.
For convenience, we will call a vertex $$$i$$$ special if there exists some $$$1\le j\le n$$$ where $$$s_{j, i} \neq s_{i, i}$$$. Suppose there exist some $$$i$$$ where $$$s_{i, i} = \mathtt{0}$$$. This means that moving the coin to any of the neighbours of $$$i$$$ results in a winning state for the opponent. If the tree was rooted at some other vertex $$$j\neq i$$$, it will still be a losing state as it reduces the options that the player can move the coin to, so $$$s_{j, i}$$$ should be $$$\mathtt{0}$$$ for all $$$1\le j\le n$$$. This means that special vertices must have $$$s_{i, i} = \mathtt{1}$$$
Now, let us take a look at special vertices. Let $$$x$$$ be a special vertex, meaning $$$s_{x, x} = \mathtt{1}$$$ and there exist some $$$j$$$ where $$$s_{j, x} = \mathtt{0}$$$. Let $$$Z$$$ be a set containing all the vertices $$$j$$$ where $$$s_{j, x} = \mathtt{0}$$$. More formally, $$$Z = \{j\ |\ 1\le j\le n\text{ and } s_{j, x} = \mathtt{0}\}$$$. $$$Z$$$ cannot be empty due to the property of special vertices. Notice that whenever we choose to root at some vertex $$$j\neq x$$$, the number of children of $$$x$$$ decreases by exactly $$$1$$$. This is because the neighbour that lies on the path from vertex $$$x$$$ to vertex $$$j$$$ becomes the parent of $$$x$$$ instead of the child of $$$x$$$. If rooting the tree at vertex $$$x$$$ is a winning state but rooting the tree at some other vertex $$$j$$$ results in a losing state instead, it means that the only winning move is to move the coin from vertex $$$x$$$ to the neighbour that is on the path from vertex $$$x$$$ to $$$j$$$.
Let $$$y$$$ denote the only neighbour of vertex $$$x$$$ where we can move the coin from vertex $$$x$$$ to vertex $$$y$$$ and win. In other words, $$$y$$$ is the neighbour of vertex $$$x$$$ where $$$y$$$ lies on the path of the vertices in set $$$Z$$$ and $$$x$$$. This means that $$$Z$$$ is the set of vertices that are in the subtree of $$$y$$$ rooted at vertex $$$x$$$.
Now, let us try to find vertex $$$y$$$. Notice that $$$s_{y, y} = \mathtt{1}$$$. This is because $$$s_{y, x} = \mathtt{0}$$$, so the coin can be moved from vertex $$$y$$$ to vertex $$$x$$$ to result in a losing state for the opponent. Furthermore, $$$s_{j, y} = \mathtt{0}$$$ if and only if $$$j$$$ is not in $$$Z$$$, otherwise $$$s_{j, y} = \mathtt{1}$$$. This is because $$$s_{x, y} = \mathtt{0}$$$ since moving the coin from vertex $$$x$$$ to vertex $$$y$$$ is a winning move for the first player. For all other vertex $$$u\in Z$$$ that is not $$$y$$$, this property will not hold as even if $$$s_{u, u} = \mathtt{1}$$$ and $$$s_{x, u} = \mathtt{0}$$$, $$$s_{y, u}$$$ will be equal to $$$\mathtt{0}$$$ as well as the tree being rooted at $$$x$$$ has the same effect as if it was rooted at $$$y$$$. Since $$$y \in Z$$$, $$$s_{y, u} = \mathtt{0}$$$ does not satisfy $$$s_{j, u} = \mathtt{1}$$$ for all $$$j$$$ in $$$Z$$$.
Since $$$y$$$ is a neighbour of vertex $$$x$$$, we know that there is an edge between vertex $$$y$$$ and $$$x$$$. Furthermore, we know that if the edge between vertex $$$y$$$ and $$$x$$$ is removed, the set of vertices $$$Z$$$ forms a single connected component containing $$$y$$$, while the set of vertices not in $$$Z$$$ forms another connected component containing $$$x$$$. This means that we can recursively solve the problem for the two connected components to check whether the values in the matrix $$$s$$$ are valid within their components.
After recursively solving for each connected component, we are only left with non-special vertices ($$$s_{j, i} = s_{i, i}$$$ for all $$$1\le j\le n$$$) and some special vertices that already have an edge that connects to outside the component. Non-special vertices with $$$s_{i, i} = \mathtt{1}$$$ has to be connected to at least $$$2$$$ non-special vertices with $$$s_{i, i} = \mathtt{0}$$$. The most optimal way to do this is to form a line 0 — 1 — 0 — 1 — 0 as it requires the least amount of $$$s_{i, i} = \mathtt{0}$$$. If there is not enough $$$s_{i, i} = \mathtt{0}$$$ to form the line, a solution does not exist. Otherwise, connect the left-over $$$s_{i, i} = \mathtt{0}$$$ to any of $$$s_{i, i} = \mathtt{1}$$$. On the other hand, special vertices can either be connected to nothing, connected to other special vertices, or connected to non-special vertices with $$$s_{i, i} = \mathtt{1}$$$.
For the final step, we need to check whether $$$s_{i, j}$$$ is consistent when $$$i$$$ and $$$j$$$ are in different components (i.e. ($$$i\in Z$$$ and $$$j\notin Z$$$) or ($$$i\notin Z$$$ and $$$j\in Z$$$)). Notice that $$$s_{i, j} = s_{x, j}$$$ for all $$$i\in Z$$$ and $$$j\notin Z$$$ and $$$j\neq x$$$, and $$$s_{i, j} = s_{y, j}$$$ for all $$$i\notin Z$$$ and $$$j\in Z$$$ and $$$j\neq y$$$. From the steps above, we managed to account for every value in the matrix, hence if matrix $$$s$$$ is consistent through all the steps, the constructed tree would be valid as well.
We can make use of xor hash to find vertex $$$x$$$ together with its corresponding vertex $$$y$$$. With xor hash, the time complexity is $$$O(n^2)$$$. Well-optimised bitset code with time complexity of $$$O(\frac{n^3}{w})$$$ can pass as well.
Code
#include <bits/stdc++.h> 
using namespace std;
 
const int MAXN = 5005;

mt19937_64 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());
 
int n;
unsigned long long r[MAXN], hsh[MAXN], totr;
string s[MAXN];
vector<pair<int, int>> ans;
 
bool done[MAXN];
bool solve(vector<int> grp) {
    int pr = -1, pl = -1;
    vector<int> lft, rht;
    for (int i : grp) {
        if (s[i][i] == '0' || done[i] || hsh[i] == totr) {
            continue;
        }
        rht.clear();
        for (int j : grp) {
            if (s[j][i] == '0') {
                lft.push_back(j);
            } else {
                rht.push_back(j);
            }
        }
        if (!lft.empty()) {
            pr = i;
            break;
        }
    }
    if (pr == -1) {
        vector<int> dv, zero, one;
        for (int i : grp) {
            if (done[i]) {
                dv.push_back(i);
            } else if (s[i][i] == '0') {
                zero.push_back(i);
            } else {
                one.push_back(i);
            }
        }
        for (int i = 1; i < dv.size(); i++) {
            ans.push_back({dv[i - 1], dv[i]});
        }
        if (one.empty() && zero.empty()) {
            return 1;
        }
        if (one.size() >= zero.size()) {
            return 0;
        }
        if (one.empty()) {
            if (zero.size() >= 2 || !dv.empty()) {
                return 0;
            }
            return 1;
        }
        for (int i = 0; i < one.size(); i++) {
            ans.push_back({zero[i], one[i]});
            ans.push_back({one[i], zero[i + 1]});
        }
        for (int i = one.size() + 1; i < zero.size(); i++) {
            ans.push_back({one[0], zero[i]});
        }
        if (!dv.empty()) {
            ans.push_back({one[0], dv[0]});
        }
        return 1;
    }
    for (int i : lft) {
        if (s[i][i] == '0' || done[i] || ((hsh[i] ^ hsh[pr]) != totr)) {
            continue;
        }
        vector<int> trht;
        for (int j : grp) {
            if (s[j][i] == '0') {
                trht.push_back(j);
            }
        }
        if (trht == rht) {
            pl = i;
            break;
        }
    }
    if (pl == -1) {
        return 0;
    }
    for (int i : lft) {
        for (int j : rht) {
            if (j == pr) {
                continue;
            }
            if (s[i][j] != s[pr][j]) {
                return 0;
            }
        }
    }
    for (int i : rht) {
        for (int j : lft) {
            if (j == pl) {
                continue;
            }
            if (s[i][j] != s[pl][j]) {
                return 0;
            }
        }
    }
    ans.push_back({pl, pr});
    done[pl] = done[pr] = 1;
    return solve(lft) && solve(rht);
}
 
int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> s[i];
    }
    for (int i = 0; i < n; i++) {
        r[i] = rnd();
        totr ^= r[i];
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (s[i][j] == '1') {
                hsh[j] ^= r[i];
            }
        }
    }
    bool pos = 1;
    for (int i = 0; i < n; i++) {
        if (s[i][i] == '1') {
            continue;
        }
        for (int j = 0; j < n; j++) {
            if (s[j][i] == '1') {
                pos = 0;
                break;
            }
        }
    }
    if (!pos) {
        cout << "NO\n";
        return 0;
    }
    vector<int> v(n, 0);
    iota(v.begin(), v.end(), 0);
    if (!solve(v)) {
        cout << "NO\n";
        return 0;
    }
    cout << "YES\n";
    for (auto [u, v] : ans) {
        cout << u + 1 << ' ' << v + 1 << '\n';
    }
}
--------------------------------------------------
Problem ID: 1919F2
Editorial Content:
1919F2 - Wine Factory (Hard Version)
Hint 1
Try modelling this problem into a maximum flow problem.
Hint 2
Try using minimum cut to find the maximum flow.
Hint 3
Speed up finding the minimum cut using a segment tree.
Solution
Consider a flow graph with $$$n + 2$$$ vertices. Let the source vertex be $$$s = n + 1$$$ and the sink vertex be $$$t = n + 2$$$. For each $$$i$$$ from $$$1$$$ to $$$n$$$, add edge $$$s\rightarrow i$$$ with capacity $$$a_i$$$ and another edge $$$i\rightarrow t$$$ with capacity $$$b_i$$$. Then for each $$$i$$$ from $$$1$$$ to $$$n - 1$$$, add edge $$$i\rightarrow i + 1$$$ with capacity $$$c_i$$$. The maximum flow from $$$s$$$ to $$$t$$$ will be the answer to the problem.
Let us try to find the minimum cut of the above graph instead.
Claim
: The minimum cut will contain exactly one of $$$s\rightarrow i$$$ or $$$i\rightarrow t$$$ for all $$$1\le i\le n$$$.
Proof
: If the minimum cut does not contain both $$$s\rightarrow i$$$ and $$$i\rightarrow t$$$, $$$s$$$ can reach $$$t$$$ through vertex $$$i$$$ and hence it is not a minimum cut. Now, we will prove why the minimum cut cannot contain both $$$s\rightarrow i$$$ and $$$i\rightarrow t$$$. Suppose there exists a minimum cut where there exists a vertex $$$1\le i\le n$$$ where $$$s\rightarrow i$$$ and $$$i\rightarrow t$$$ are both in the minimum cut. We will consider two cases:
Case 1: $$$s$$$ can reach $$$i$$$ (through some sequence of vertices $$$s\rightarrow j\rightarrow j+1\rightarrow \ldots \rightarrow i$$$ where $$$j < i$$$). If our minimum cut only contains $$$i\rightarrow t$$$ without $$$s\rightarrow i$$$, nothing changes as $$$s$$$ was already able to reach $$$i$$$ when $$$s\rightarrow i$$$ was removed. Hence, $$$s$$$ will still be unable to reach $$$t$$$ and we found a minimum cut that has equal or smaller cost.
Case 2: $$$s$$$ cannot reach $$$i$$$. If our minimum cut only contains $$$s\rightarrow i$$$ without $$$i\rightarrow t$$$, nothing changes as $$$s$$$ is still unable to reach $$$i$$$, so we cannot make use of the edge $$$i\rightarrow t$$$ to reach $$$t$$$ from $$$s$$$. Hence, $$$s$$$ will still be unable to reach $$$t$$$ and we found a minimum cut that has equal or smaller cost.
Now, all we have to do is select for each $$$1\le i\le n$$$, whether to cut the edge $$$s\rightarrow i$$$ or the edge $$$i\rightarrow t$$$. Let us use a string $$$x$$$ consisting of characters $$$\texttt{A}$$$ and $$$\texttt{B}$$$ to represent this. $$$x_i = \texttt{A}$$$ means we decide to cut the edge $$$s\rightarrow i$$$ for a cost of $$$a_i$$$ and $$$x_i = \texttt{B}$$$ means we decide to cut the edge from $$$i\rightarrow t$$$ for a cost of $$$b_i$$$. Notice that whenever we have $$$x_i = \texttt{B}$$$ and $$$x_{i + 1} = \texttt{A}$$$, $$$s$$$ can reach $$$t$$$ through $$$s\rightarrow i\rightarrow i + 1\rightarrow t$$$. To prevent this, we have to cut the edge $$$i\rightarrow i + 1$$$ for a cost of $$$c_i$$$.
To handle updates, we can use a segment tree. Each node of the segment tree stores the minimum possible cost for each of the four combinations of the two endpoints being $$$\texttt{A}$$$ or $$$\texttt{B}$$$. When merging the segment tree nodes, add a cost of $$$c$$$ when the right endpoint of the left node is $$$\texttt{B}$$$ and the left endpoint of the right node is $$$\texttt{A}$$$. The final time complexity is $$$O(n\log n)$$$ as only a segment tree is used.
Code
#include <bits/stdc++.h> 
using namespace std;

typedef long long ll;
const ll LINF = 1000000000000000005ll;
const int MAXN = 500005;

int n, q;
int a[MAXN], b[MAXN];
ll c[MAXN];

ll st[MAXN * 4][2][2];
void merge(int u, int lo, int hi) {
    int mid = lo + hi >> 1, lc = u << 1, rc = u << 1 ^ 1;
    for (int l = 0; l < 2; l++) {
        for (int r = 0; r < 2; r++) {
            st[u][l][r] = min({st[lc][l][0] + st[rc][0][r],
                    st[lc][l][1] + st[rc][1][r],
                    st[lc][l][0] + st[rc][1][r],
                    st[lc][l][1] + st[rc][0][r] + c[mid]});
        }
    }
}
void init(int u = 1, int lo = 1, int hi = n) {
    if (lo == hi) {
        st[u][0][0] = a[lo];
        st[u][1][1] = b[lo];
        st[u][1][0] = st[u][0][1] = LINF;
        return;
    }
    int mid = lo + hi >> 1, lc = u << 1, rc = u << 1 ^ 1;
    init(lc, lo, mid);
    init(rc, mid + 1, hi);
    merge(u, lo, hi);
}
void upd(int p, int u = 1, int lo = 1, int hi = n) {
    if (lo == hi) {
        st[u][0][0] = a[lo];
        st[u][1][1] = b[lo];
        st[u][1][0] = st[u][0][1] = LINF;
        return;
    }
    int mid = lo + hi >> 1, lc = u << 1, rc = u << 1 ^ 1;
    if (p <= mid) {
        upd(p, lc, lo, mid);
    } else {
        upd(p, rc, mid + 1, hi);
    }
    merge(u, lo, hi);
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> q;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> b[i];
    }
    for (int i = 1; i < n; i++) {
        cin >> c[i];
    }
    init();
    while (q--) {
        int p, x, y; ll z; cin >> p >> x >> y >> z;
        a[p] = x; b[p] = y; c[p] = z;
        upd(p);
        cout << min({st[1][0][0], st[1][0][1], st[1][1][0], st[1][1][1]}) << '\n';
    }
}
--------------------------------------------------
Problem ID: 1919F1
Editorial Content:
1919F1 - Wine Factory (Easy Version)
Hint 1
When $$$c_i$$$ and $$$z$$$ equals $$$10^{18}$$$, it means that all the remaining water will always flow into the next water tower. Hence, the answer will be the sum of $$$a_i$$$ minus the amount of water remaining at tower $$$n$$$ after the process.
Solution 1
From hint 1, our new task now is to determine the amount of water remaining at tower $$$n$$$ after the process. Let $$$v_i = a_i - b_i$$$. The remaining amount of water remaining at tower $$$n$$$ is the maximum suffix sum of $$$v$$$, or more formally $$$\max\limits_{1\le k\le n}\ \sum\limits_{i = k}^n v_i$$$. We can use a segment tree where position $$$p$$$ of the segment tree stores $$$\sum\limits_{i = p}^n v_i$$$. The updates can be done using range prefix increment and the queries can be done using range maximum.
Solution 2
Code ReLU segment tree. A similar method can be used to solve the full problem if you combine even more ReLUs. However, it is not very elegant and is much more complicated than the intended solution below.
What is ReLU segment tree?
ReLU is a common activation function used in neural networks which is defined by $$$f(x) = \max(x, 0)$$$. The objective of ReLU segment tree is to compose ReLU-like functions together. More precisely, ReLU segment tree can solve the following problem:
You are given two arrays $$$a$$$ and $$$b$$$ of length $$$n$$$. You are required to answer the following queries:
- $$$\texttt{1 p x y}$$$. Update $$$a_p = x$$$ and $$$b_p = y$$$.
- $$$\texttt{2 l r c}$$$. Output the value of $$$f_l(f_{l+1}(\ldots f_{r-1}(f_r(c))))$$$, where $$$f_i(x) = \max(x - a_i, b_i)$$$.
The main idea to solve the problem is to observe that composing ReLU functions still results in a ReLU function, so we just need to store in each node the resultant function $$$f(x) = \max(x - p, q)$$$ after composing the functions that fall in the range of the segment tree node. For the merge function, we just need to figure out the details of composing two ReLU functions together.
What is ReLU segment tree?
ReLU is a common activation function used in neural networks which is defined by $$$f(x) = \max(x, 0)$$$. The objective of ReLU segment tree is to compose ReLU-like functions together. More precisely, ReLU segment tree can solve the following problem:
You are given two arrays $$$a$$$ and $$$b$$$ of length $$$n$$$. You are required to answer the following queries:
- $$$\texttt{1 p x y}$$$. Update $$$a_p = x$$$ and $$$b_p = y$$$.
- $$$\texttt{2 l r c}$$$. Output the value of $$$f_l(f_{l+1}(\ldots f_{r-1}(f_r(c))))$$$, where $$$f_i(x) = \max(x - a_i, b_i)$$$.
The main idea to solve the problem is to observe that composing ReLU functions still results in a ReLU function, so we just need to store in each node the resultant function $$$f(x) = \max(x - p, q)$$$ after composing the functions that fall in the range of the segment tree node. For the merge function, we just need to figure out the details of composing two ReLU functions together.
Code (Solution 1)
#include <bits/stdc++.h> 
using namespace std;

typedef long long ll;
const ll LINF = 1000000000000000005;
const int MAXN = 500005;

int n, q;
int a[MAXN], b[MAXN];
ll c[MAXN];
ll v[MAXN], sv[MAXN];

ll mx[MAXN * 4], lz[MAXN * 4];
void init(int u = 1, int lo = 1, int hi = n) {
    lz[u] = 0;
    if (lo == hi) {
        mx[u] = sv[lo];
    } else {
        int mid = lo + hi >> 1;
        init(u << 1, lo, mid);
        init(u << 1 ^ 1, mid + 1, hi);
        mx[u] = max(mx[u << 1], mx[u << 1 ^ 1]);
    }
}
void propo(int u) {
    if (lz[u] == 0) {
        return;
    }
    lz[u << 1] += lz[u];
    lz[u << 1 ^ 1] += lz[u];
    mx[u << 1] += lz[u];
    mx[u << 1 ^ 1] += lz[u];
    lz[u] = 0;
}
void incre(int s, int e, ll x, int u = 1, int lo = 1, int hi = n) {
    if (lo >= s && hi <= e) {
        mx[u] += x;
        lz[u] += x;
        return;
    }
    propo(u);
    int mid = lo + hi >> 1;
    if (s <= mid) {
        incre(s, e, x, u << 1, lo, mid);
    }
    if (e > mid) {
        incre(s, e, x, u << 1 ^ 1, mid + 1, hi);
    }
    mx[u] = max(mx[u << 1], mx[u << 1 ^ 1]);
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> q;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> b[i];
    }
    for (int i = 1; i < n; i++) {
        cin >> c[i];
    }
    ll sma = 0;
    for (int i = n; i >= 1; i--) {
        v[i] = a[i] - b[i];
        sv[i] = v[i] + sv[i + 1];
        sma += a[i];
    }
    init();
    while (q--) {
        int p, x, y; ll z; cin >> p >> x >> y >> z;
        sma -= a[p];
        incre(1, p, -v[p]);
        a[p] = x;
        b[p] = y;
        v[p] = a[p] - b[p];
        sma += a[p];
        incre(1, p, v[p]);
        cout << sma - max(0ll, mx[1]) << '\n';
    }
}
--------------------------------------------------
Problem ID: 1919E
Editorial Content:
1919E - Counting Prefixes
Hint 1
Try solving the problem if the sum of elements of array $$$a$$$ is equal to $$$s$$$. If we can do this in $$$O(n)$$$ time, we can iterate through all possible values of $$$p_1 \le s \le p_n$$$ and sum up the number of ways for each possible sum.
Hint 2
Consider starting with array $$$a = [1, 1, \ldots, 1, -1, -1, \ldots, -1]$$$ where there are $$$p_n$$$ occurences of $$$1$$$ and $$$p_n - s$$$ occurrences of $$$-1$$$. Then, try inserting $$$(-1, 1)$$$ into the array to fix the number of occurrences of prefix sum starting from the largest value ($$$p_n$$$) to the smallest value ($$$p_1$$$).
Solution
Let us try to solve the problem if the sum of elements of array $$$a$$$ is equal to $$$s$$$. Consider starting array $$$a = [1, 1, \ldots, 1, -1, -1, \ldots, -1]$$$ where there are $$$p_n$$$ occurrences of $$$1$$$ and $$$p_n - s$$$ occurrences of $$$-1$$$. Notice that when we insert $$$(-1, 1)$$$ into array $$$a$$$ between positions $$$i$$$ and $$$i + 1$$$ where the sum of $$$a$$$ from $$$1$$$ to $$$i$$$ is $$$s$$$, two new prefix sums $$$s - 1$$$ and $$$s$$$ will be formed while the remaining prefix sums remain the same. Let us try to fix the prefix sums starting from the largest prefix sum to the smallest prefix sum.
In the starting array $$$a$$$, we only have $$$1$$$ occurrence of prefix sum with value $$$p_n$$$. We can insert $$$(-1, 1)$$$ right after it $$$k$$$ times to increase the number of occurrences of prefix sum with value $$$p_n$$$ by $$$k$$$. In the process of doing so, the number of occurrences of prefix sum with value $$$p_n - 1$$$ also increased by $$$k$$$. Now, we want to fix the number of occurrences of prefix sum with value $$$p_n - 1$$$. If we already have $$$x$$$ occurrences but we require $$$y > x$$$ occurrences, we can choose to insert $$$y - 1$$$ pairs of $$$(-1, 1)$$$ right after any of the $$$x$$$ occurrences. We can calculate the number of ways using
stars and bars
to obtain the formula $$$y - 1\choose y - x$$$.
We continue using a similar idea to fix the number of occurrences of $$$p_n - 2, p_n - 3, \ldots, p_1$$$, each time considering the additional occurrences that were contributed from the previous layer. Each layer can be calculated in $$$O(1)$$$ time after precomputing binomial coefficients, so the entire calculation to count the number of array $$$a$$$ whose sum is $$$s$$$ and has prefix sum consistent to the input takes $$$O(n)$$$ time. Then, we can iterate through all possible $$$p_1 \le s \le p_n$$$ and sum up the answers to obtain a solution that works in $$$O(n^2)$$$ time.
Code
#include <bits/stdc++.h> 
using namespace std;

typedef long long ll;
const int INF = 1000000005;
const int MAXN = 200005;
const int MOD = 998244353;

ll fact[MAXN * 2], ifact[MAXN * 2];
int t;
int n;
int f[MAXN * 2], d[MAXN * 2];

inline ll ncr(int n, int r) {
    if (r < 0 || n < r) {
        return 0;
    }
    return fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;
}
// count number of a_1 + a_2 + ... + a_n = x
inline ll starbar(int n, int x) {
    if (n == 0 && x == 0) {
        return 1;
    }
    return ncr(x + n - 1, x);
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    fact[0] = 1;
    for (int i = 1; i < MAXN * 2; i++) {
        fact[i] = fact[i - 1] * i % MOD;
    }
    ifact[0] = ifact[1] = 1;
    for (int i = 2; i < MAXN * 2; i++) {
        ifact[i] = MOD - MOD / i * ifact[MOD % i] % MOD;
    }
    for (int i = 2; i < MAXN * 2; i++) {
        ifact[i] = ifact[i - 1] * ifact[i] % MOD;
    }
    cin >> t;
    while (t--) {
        cin >> n;
        for (int i = 0; i < n * 2 + 5; i++) {
            f[i] = 0;
        }
        n++;
        for (int i = 1; i < n; i++) {
            int s; cin >> s;
            f[s + n]++;
        }
        f[n]++;
        int mn = INF, mx = -INF;
        for (int i = 0; i <= 2 * n; i++) {
            if (f[i]) {
                mn = min(mn, i);
                mx = max(mx, i);
            }
        }
        bool bad = 0;
        for (int i = mn; i <= mx; i++) {
            if (!f[i]) {
                bad = 1;
                break;
            }
        }
        if (bad || mn == mx) {
            cout << 0 << '\n';
            continue;
        }
        ll ans = 0;
        for (int x = mx; x >= mn; x--) {
            d[mx - 1] = f[mx] + (mx > n) - (mx == x);
            for (int i = mx - 2; i >= mn - 1; i--) {
                d[i] = f[i + 1] - d[i + 1] + (i >= x) + (i >= n);
            }
            if (d[mn - 1] != 0) {
                continue;
            }
            ll res = 1;
            for (int i = mx - 1; i >= mn; i--) {
                res = res * starbar(d[i], f[i] - d[i]) % MOD;
            }
            ans += res;
            if (ans >= MOD) {
                ans -= MOD;
            }
        }
        cout << ans << '\n';
    }
}
Bonus
Solve the problem in $$$O(n)$$$ time.
Unfortunately, it seems like
ARC146E
is identical to this problem :(
--------------------------------------------------
Problem ID: 1919D
Editorial Content:
1919D - 01 Tree
Hint 1
What does the distance of two leaves that share the same parent look like?
Hint 2
What happens if we delete two leaves that share the same parent?
Solution
Consider two leaves that share the same parent. They will be adjacent to each other in the dfs order, so their distances will be adjacent in array $$$a$$$. Furthermore, their distances to the root will differ by exactly $$$1$$$ since one of the edges from the parent to its children will have weight $$$0$$$ while the other will have weight $$$1$$$.
If we delete two leaves that share the same parent, the parent itself will become the leaf. Since one of the edges from the parent to the child has weight $$$0$$$, the distance from the parent to the root is equal to the smaller distance between its two children. This means that deleting two leaves that share the same parent is the same as selecting an index $$$i$$$ such that $$$a_i = a_{i - 1} + 1$$$ or $$$a_i = a_{i + 1} + 1$$$, then removing $$$a_i$$$ from array $$$a$$$.
Consider the largest value in $$$a$$$. If it is possible to delete it (meaning there is a value that is exactly one smaller than it to its left or right), we can delete it immediately. This is because keeping the largest value will not help to enable future operations as it can only help to delete elements that are $$$1$$$ greater than it, which is not possible for the largest value.
Now, all we have to do is to maintain all elements that can be deleted and choose the element with the largest value each time. Then, whenever we delete an element, we need to check whether the two adjacent elements become deletable and update accordingly. We can do this using a priority_queue and a linked list in $$$O(n\log n)$$$. Note that many other implementations exist, including several $$$O(n)$$$ solutions.
Code
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 200005;

int n;
int a[MAXN];
int prv[MAXN],nxt[MAXN];
bool in[MAXN];

bool good(int i) {
    if (i < 1 || i > n) {
        return 0;
    }
    return a[prv[i]] == a[i] - 1 || a[nxt[i]] == a[i] - 1;
}
int main(){
    ios::sync_with_stdio(0), cin.tie(0);
    int t; cin >> t;
    while (t--) {
        cin >> n;
        priority_queue<pair<int, int>> pq;
        for (int i = 1; i <= n; i++) {
            prv[i] = i - 1;
            nxt[i] = i + 1;
            in[i] = 0;
            cin >> a[i];
        }
        a[n + 1] = a[0] = -2;
        for (int i = 1; i <= n; i++) {
            if (good(i)) {
                in[i] = 1;
                pq.push({a[i], i});
            }
        }
        while (!pq.empty()) {
            auto [_, i] = pq.top(); pq.pop();
            nxt[prv[i]] = nxt[i];
            prv[nxt[i]] = prv[i];
            if (!in[prv[i]] && good(prv[i])) {
                in[prv[i]]=1;
                pq.push({a[prv[i]], prv[i]});
            }
            if (!in[nxt[i]] && good(nxt[i])) {
                in[nxt[i]]=1;
                pq.push({a[nxt[i]], nxt[i]});
            }
        }
        int mn = n, bad = 0;
        for (int i = 1; i <= n; i++) {
            bad += !in[i];
            mn = min(a[i], mn);
        }
        if (bad == 1 && mn == 0) {
            cout << "YES\n";
        } else {
            cout << "NO\n";
        }
    }
}
--------------------------------------------------
Problem ID: 1919C
Editorial Content:
1919C - Grouping Increases
Hint 1
Consider a greedy approach.
Solution 1
Consider the following approach. We start with empty arrays $$$b$$$ and $$$c$$$, then insert elements of the array $$$a$$$ one by one to the back of $$$b$$$ or $$$c$$$. Our penalty function only depends on adjacent elements, so at any point in time, we only care about the value of the last element of arrays $$$b$$$ and $$$c$$$. Suppose we already inserted $$$a_1, a_2, \ldots, a_{i - 1}$$$ into arrays $$$b$$$ and $$$c$$$ and we now want to insert $$$a_i$$$. Let $$$x$$$ and $$$y$$$ be the last element of arrays $$$b$$$ and $$$c$$$ respectively (if they are empty, use $$$\infty$$$). Note that swapping arrays $$$b$$$ and $$$c$$$ does not matter, so without loss of generality, assume that $$$x\le y$$$. We will use the following greedy approach.
If $$$a_i\le x$$$, insert $$$a_i$$$ to the back of the array with a smaller last element.
If $$$y < a_i$$$, insert $$$a_i$$$ to the back of the array with a smaller last element.
If $$$x < a_i\le y$$$, insert $$$a_i$$$ to the back of the array with a bigger last element.
The proof of why the greedy approach is optimal is given below:
$$$a_i\le x$$$. In this case, $$$a_i$$$ is not greater than the last element of both arrays, so inserting $$$a_i$$$ to the back of either array will not add additional penalties. However, it is better to insert $$$a_i$$$ into the array with a smaller last element so that in the future, we can insert a wider range of values into the new array without additional penalty.
$$$y < a_i$$$. In this case, $$$a_i$$$ is greater than the last element of both arrays, so inserting $$$a_i$$$ to the back of either array will contribute to $$$1$$$ additional penalty. However, it is better to insert $$$a_i$$$ into the array with a smaller last element so that in the future, we can insert a wider range of values into the new array without additional penalty.
$$$x < a_i\le y$$$. In this case, if we insert $$$a_i$$$ to the back of the array with the larger last element, there will not be any additional penalty. However, if we insert $$$a_i$$$ to the back of the array with the smaller last element, there will be an additional penalty of $$$1$$$. The former option is always better than the latter. This is because if we consider making the same choices for the remaining elements $$$a_{i+1}$$$ to $$$a_n$$$ in both scenarios, there will be at most one time where the former scenario will add one penalty more than the latter scenario as the former scenario has a smaller last element after inserting $$$a_i$$$. After that happens, the back of the arrays in both scenarios will become the same and hence, the former case will never be less optimal.
Following the greedy approach for all 3 cases will result in a correct solution that runs in $$$O(n)$$$ time.
Hint 1
Consider a dynamic programming approach.
Hint 2
Let $$$dp_{i, v}$$$ represent the minimum penalty when we are considering splitting $$$a_{1\ldots i}$$$ into two subarrays where the last element of one subarray is $$$a_i$$$ while the last element of the second subarray is $$$v$$$.
Hint 3
Speed up the transition by storing the state in a segment tree.
Solution 2
Let us consider a dynamic programming solution. Let $$$dp_{i, v}$$$ represent the minimum penalty when we are considering splitting $$$a_{1\ldots i}$$$ into two subarrays where the last element of one subarray is $$$a_i$$$ while the last element of the second subarray is $$$v$$$. Then, our transition will be $$$dp_{i, v} = dp_{i - 1, v} + [a_{i - 1} < a_i]$$$ for all $$$1\le v\le n, v\neq a_{i - 1}$$$ and $$$dp_{i, a_{i - 1}} = \min(dp_{i - 1, a_{i - 1}} + [a_{i - 1} < a_i], \min_{1\le x\le n}(dp_{i - 1, x} + [x < a_i]))$$$.
To speed this up, we use a segment tree to store the value of $$$dp_{i - 1, p}$$$ at position $$$p$$$. To transition to $$$dp_i$$$, notice that the first transition is just a range increment on the entire range $$$[1, n]$$$ of the segment tree if $$$a_{i - 1} < a_i$$$. For the second transition, we can do two range minimum queries on ranges $$$[1, a_i - 1]$$$ and $$$[a_i, n]$$$. The final time complexity is $$$O(n\log n)$$$.
Code (Solution 1)
#include <bits/stdc++.h> 
using namespace std;

const int INF = 1000000005;
const int MAXN = 200005;

int t;
int n;
int a[MAXN];

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> t;
    while (t--) {
        cin >> n;
        for (int i = 1; i <= n; i++) {
            cin >> a[i];
        }
        int t1 = INF, t2 = INF;
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            if (t1 > t2) {
                swap(t1, t2);
            }
            if (a[i] <= t1) {
                t1 = a[i];
            } else if (a[i] <= t2) {
                t2 = a[i];
            } else {
                t1 = a[i];
                ans++;
            }
        }
        cout << ans << '\n';
    }
}
Code (Solution 2)
#include <bits/stdc++.h> 
using namespace std;

const int INF = 1000000005;
const int MAXN = 200005;

int t;
int n;
int a[MAXN];

int mn[MAXN * 4], lz[MAXN * 4];
void init(int u = 1, int lo = 1, int hi = n) {
    mn[u] = lz[u] = 0;
    if (lo != hi) {
        int mid = lo + hi >> 1;
        init(u << 1, lo, mid);
        init(u << 1 ^ 1, mid + 1, hi);
    }
}
void propo(int u) {
    if (lz[u] == 0) {
        return;
    }
    lz[u << 1] += lz[u];
    lz[u << 1 ^ 1] += lz[u];
    mn[u << 1] += lz[u];
    mn[u << 1 ^ 1] += lz[u];
    lz[u] = 0;
}
void incre(int s, int e, int x, int u = 1, int lo = 1, int hi = n) {
    if (lo >= s && hi <= e) {
        mn[u] += x;
        lz[u] += x;
        return;
    }
    propo(u);
    int mid = lo + hi >> 1;
    if (s <= mid) {
        incre(s, e, x, u << 1, lo, mid);
    }
    if (e > mid) {
        incre(s, e, x, u << 1 ^ 1, mid + 1, hi);
    }
    mn[u] = min(mn[u << 1], mn[u << 1 ^ 1]);
}
int qmn(int s, int e, int u = 1, int lo = 1, int hi = n) {
    if (s > e) {
        return INF;
    }
    if (lo >= s && hi <= e) {
        return mn[u];
    }
    propo(u);
    int mid = lo + hi >> 1;
    int res = INF;
    if (s <= mid) {
        res = min(res, qmn(s, e, u << 1, lo, mid));
    }
    if (e > mid) {
        res = min(res, qmn(s, e, u << 1 ^ 1, mid + 1, hi));
    }
    return res;
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> t;
    while (t--) {
        cin >> n;
        for (int i = 1; i <= n; i++) {
            cin >> a[i];
        }
        init();
        for (int i = 1; i <= n; i++) {
            int ndp = min(qmn(1, a[i] - 1) + 1, qmn(a[i], n));
            if (i > 1) {
                if (a[i - 1] < a[i]) {
                    incre(1, n, 1);
                }
                int dp = qmn(a[i - 1], a[i - 1]);
                if (ndp < dp) {
                    incre(a[i - 1], a[i - 1], ndp - dp);
                }
            }
        }
        cout << qmn(1, n) << '\n';
    }
}
Bonus
Solve the problem if you have to split the array into $$$k$$$ subsequences, where $$$k$$$ is given in the input ($$$k = 2$$$ for the original problem).
Solution
Modified statement
There is an array $$$A$$$ of size $$$N$$$ and an array $$$T$$$ of size $$$K$$$. Initially, $$$T_i = \infty$$$ for all $$$1 \le i \le K$$$. For each time $$$t$$$ from $$$1$$$ to $$$N$$$, the following will happen:
Select an index $$$1 \le i \le K$$$. If $$$A_t > T_i$$$, we increase the cost by $$$1$$$. Then, we set $$$T_i := A_t$$$.
Find the minimum possible cost after time $$$N$$$ if we select the indices optimally.
Greedy
The order of $$$T$$$ does not matter. Hence for convenience, we will maintain $$$T$$$ in non-decreasing order. At each time $$$t$$$, we will use the following algorithm:
If $$$A_t > T_K$$$, do the operation on index $$$1$$$.
Otherwise, find the smallest index $$$1 \le i \le K$$$ where $$$A_t \le T_i$$$ and do the operation on index $$$i$$$.
Proof
Suppose there exists an optimal solution that does not follow our algorithm. We will let $$$OT_{t, i}$$$ denote the value of $$$T_i$$$ before the operation was done at time $$$t$$$ in the optimal solution. Let $$$et$$$ be the earliest time that the operation done by the optimal solution differs from that of the greedy solution.
Case 1: $$$A_{et} > OT_{et,K}$$$. Since we are maintaining $$$T$$$ in the sorted order, having $$$A_{et} > OT_{et,K}$$$ means that $$$A_{et}$$$ is larger than all elements of $$$T$$$. This means that no matter which index $$$i$$$ we choose to do the operation on, the cost will always increase by $$$1$$$. Suppose an index $$$i > 1$$$ was chosen in the optimal solution. We can always choose to do the operation on index $$$1$$$ instead of index $$$i$$$ and the answer will not be less optimal. This is because if we let $$$T'$$$ be the array $$$T$$$ after the operation was done on index $$$1$$$, $$$T'_p \le OT_{et+1,p}$$$ for all $$$1 \le p \le K$$$ since $$$T'_p = \begin{cases}OT_{et,p+1}&\text{if }p<K\newline A_{et}&\text{if }p=K\end{cases}$$$ while $$$OT_{et+1,p} = \begin{cases}OT_{et,p}&\text{if }p<i\newline OT_{et,p+1}&\text{if }i\le p<K\newline A_{et}&\text{if }p=K\end{cases}$$$.
Case 2: $$$A_{et} \le OT_{et,K}$$$. For convenience, we will denote that the operation was done on index $$$i$$$ in the greedy solution while the operation was done on index $$$j$$$ based on the optimal solution during time $$$et$$$.
Case 2A: $$$i < j$$$. In this case, the cost does not increase for both the optimal solution and the greedy solution. However, we can always do an operation on index $$$i$$$ instead of index $$$j$$$ and the answer will not be less optimal. This is because if we let $$$T'$$$ be the array $$$T$$$ after the operation was done on index $$$i$$$, $$$T'_p\le OT_{et+1,p}$$$ for all $$$1\le p\le K$$$ since $$$T'_p = \begin{cases}OT_{et,p}&\text{if }p\neq i\newline A_{et}&\text{if }p=i\end{cases}$$$ while $$$OT_{et+1,p} = \begin{cases}OT_{et,p}&\text{if }p<i\newline A_{et}&\text{if }p=i\newline OT_{et,p-1}&\text{if }i< p\le j\newline OT_{et,p}&\text{if }j<p\le K\end{cases}$$$.
Case 2B: $$$i > j$$$. For this case, the cost increases for the optimal solution while the cost does not change for the greedy solution. However, it is not trivial to prove that the greedy solution is more optimal as even though it has a smaller cost, it results in a less optimal array $$$T$$$. Hence, we will prove this case below.
Case 2B
We want to come up with a modified solution that does the same operations as the optimal solution for time $$$1\le t<et$$$ and does an operation on index $$$i$$$ during time $$$et$$$. Adopting a similar notation to $$$OT$$$, we will let $$$MT_{t, i}$$$ denote the value of $$$T_i$$$ before the operation was done at time $$$t$$$ in this modified solution. Then, $$$MT_{et+1,p} = \begin{cases}OT_{et,p}&\text{if }p\neq i\newline A_{et}&\text{if } p=i\end{cases}$$$ and $$$OT_{et+1,p}=\begin{cases}OT_{et,p} &\text{if } p<j\newline OT_{et,p+1}&\text{if }j\le p<i-1\newline A_{et}&\text{if }p=i-1\newline OT_{et,p}&\text{if }i\le p\le K\end{cases}$$$. Note that in this case, $$$MT_{et+1,p}\le OT_{et+1,p}$$$ for all $$$1\le p\le K$$$, which means that our modified solution results in a less optimal state than the optimal solution. However, since our modified solution requires one less cost up to this point, we will be able to prove that our modified solution will not perform worse than the optimal solution.
Notice that $$$OT_{et+1,p}\le MT_{et+1,p+1}$$$ for all $$$1\le p<K$$$. We denote that the index that the optimal solution operates on during time $$$t$$$ is $$$x_t$$$. Let $$$r$$$ be the minimum time where $$$et+1\le r\le N$$$ and $$$e_r=N$$$. Due to the above property that $$$OT_{et+1,p}\le MT_{et+1,p+1}$$$ for all $$$1\le p<K$$$, we can let our modified solution do the operation on index $$$x_t+1$$$ for all time $$$et+1\le t<r$$$ and the cost will not be more than the optimal solution. This is because the property that $$$OT_{t+1,p}\le MT_{t+1,p+1}$$$ for all $$$1\le p<K$$$ still holds throughout that time range even after each update. Note that if such an $$$r$$$ does not exist, we can let our modified solution do the operation on index $$$x_t+1$$$ for all time $$$et+1\le t\le K$$$ and we completed coming up with the modified solution with a cost not more than the optimal solution.
However, if such an $$$r$$$ exists, then at time $$$r$$$, since $$$x_r=N$$$, we are no longer able to use the same method. However, let us consider what happens if we let our modified solution do an operation on index $$$1$$$ during time $$$r$$$.
If $$$A_r>MT_{r,K}$$$, it will mean that $$$MT_{r+1,p}=\begin{cases}MT_{r,p+1}&\text{if }p<K\newline A_r&\text{if }p=K\end{cases}$$$ while $$$OT_{r+1,p}=\begin{cases}OT_{r,p}&\text{if }p<K\newline A_r&\text{if }p=K\end{cases}$$$ since $$$OT_{r,K-1}\le MT_{r,K}<A_r$$$. Even though during this time, it might be possible that the cost of the modified solution increases by $$$1$$$ while the cost of the optimal solution remains the same, recall that previously during time $$$i$$$ our modified solution used one less cost than the optimal solution. As a result, the modified solution will end up having a cost of not more than the optimal solution. At the same time, $$$OT_{r+1,p}\le MT_{r+1,p}$$$ for all $$$1\le p\le K$$$. Hence, for all time $$$r<t\le K$$$, we can let our modified solution do the operation on the same index as the optimal solution $$$x_t$$$ and the cost of our modified solution will not be more than that of the optimal solution.
On the other hand, suppose $$$A_r\le MT_{r,K}$$$. Let $$$v$$$ be the minimum position such that $$$A_r\le MT_{r,v}$$$ and let $$$w$$$ be the minimum position such that $$$A_r\le OT_{r,w}$$$. Then, $$$MT_{r+1,p}=\begin{cases}MT_{r,p+1}&\text{if }p<v-1\newline A_r&\text{if }p=v-1\newline MT_{r,p}&\text{if }p\ge v\end{cases}$$$ and $$$OT_{r+1,p}=\begin{cases}OT_{r,p}&\text{if }p<w\newline A_r&\text{if }p=w\newline OT_{r,p-1}&\text{if }p>w\end{cases}$$$. In the same way, the cost of our modified solution might increase while the cost of the optimal solution stays the same, however, $$$OT_{r+1,p}\le MT_{r+1,p}$$$ for all $$$1\le p\le K$$$. - For $$$p<v-1$$$ and $$$p>w$$$, the condition holds since $$$OT_{r,p}\le MT_{r,p+1}$$$ for all $$$1\le p<K$$$. Note that $$$v-1\le w$$$ because of the same inequality as well. - Suppose $$$v-1=w$$$. Then for $$$p=v-1$$$, $$$OT_{r+1,p}=A_r\le A_r=MT_{r+1,p}$$$. From now on, we suppose $$$v-1\neq w$$$ - For $$$p=v-1$$$, $$$OT_{r,v-1}\le A_r$$$ as $$$w$$$ is defined as the minimum position that $$$A_r\le OT_{r,w}$$$ and $$$v-1< w$$$. - For $$$v\le p<w$$$, $$$OT_{r,p}\le MT_{r,p}$$$ as $$$OT_{r,p}<A_r\le MT_{r,p}$$$ - For $$$p=w$$$, $$$A_r\le MT_{r,w}$$$ as $$$v$$$ is defined as the minimum position that $$$A_r\le MT_{r,v}$$$ and $$$v-1<w$$$
Now that we managed to construct a modified solution which follows the greedy algorithm from time $$$1\le t\le et$$$ and is not less optimal than the optimal solution, we can let the optimal solution be our modified solution and find the new $$$et$$$ to get a new modified solution. Hence by induction, our greedy solution is optimal.
Solution
Modified statement
There is an array $$$A$$$ of size $$$N$$$ and an array $$$T$$$ of size $$$K$$$. Initially, $$$T_i = \infty$$$ for all $$$1 \le i \le K$$$. For each time $$$t$$$ from $$$1$$$ to $$$N$$$, the following will happen:
Select an index $$$1 \le i \le K$$$. If $$$A_t > T_i$$$, we increase the cost by $$$1$$$. Then, we set $$$T_i := A_t$$$.
Find the minimum possible cost after time $$$N$$$ if we select the indices optimally.
Greedy
The order of $$$T$$$ does not matter. Hence for convenience, we will maintain $$$T$$$ in non-decreasing order. At each time $$$t$$$, we will use the following algorithm:
If $$$A_t > T_K$$$, do the operation on index $$$1$$$.
Otherwise, find the smallest index $$$1 \le i \le K$$$ where $$$A_t \le T_i$$$ and do the operation on index $$$i$$$.
Proof
Suppose there exists an optimal solution that does not follow our algorithm. We will let $$$OT_{t, i}$$$ denote the value of $$$T_i$$$ before the operation was done at time $$$t$$$ in the optimal solution. Let $$$et$$$ be the earliest time that the operation done by the optimal solution differs from that of the greedy solution.
Case 1: $$$A_{et} > OT_{et,K}$$$. Since we are maintaining $$$T$$$ in the sorted order, having $$$A_{et} > OT_{et,K}$$$ means that $$$A_{et}$$$ is larger than all elements of $$$T$$$. This means that no matter which index $$$i$$$ we choose to do the operation on, the cost will always increase by $$$1$$$. Suppose an index $$$i > 1$$$ was chosen in the optimal solution. We can always choose to do the operation on index $$$1$$$ instead of index $$$i$$$ and the answer will not be less optimal. This is because if we let $$$T'$$$ be the array $$$T$$$ after the operation was done on index $$$1$$$, $$$T'_p \le OT_{et+1,p}$$$ for all $$$1 \le p \le K$$$ since $$$T'_p = \begin{cases}OT_{et,p+1}&\text{if }p<K\newline A_{et}&\text{if }p=K\end{cases}$$$ while $$$OT_{et+1,p} = \begin{cases}OT_{et,p}&\text{if }p<i\newline OT_{et,p+1}&\text{if }i\le p<K\newline A_{et}&\text{if }p=K\end{cases}$$$.
Case 2: $$$A_{et} \le OT_{et,K}$$$. For convenience, we will denote that the operation was done on index $$$i$$$ in the greedy solution while the operation was done on index $$$j$$$ based on the optimal solution during time $$$et$$$.
Case 2A: $$$i < j$$$. In this case, the cost does not increase for both the optimal solution and the greedy solution. However, we can always do an operation on index $$$i$$$ instead of index $$$j$$$ and the answer will not be less optimal. This is because if we let $$$T'$$$ be the array $$$T$$$ after the operation was done on index $$$i$$$, $$$T'_p\le OT_{et+1,p}$$$ for all $$$1\le p\le K$$$ since $$$T'_p = \begin{cases}OT_{et,p}&\text{if }p\neq i\newline A_{et}&\text{if }p=i\end{cases}$$$ while $$$OT_{et+1,p} = \begin{cases}OT_{et,p}&\text{if }p<i\newline A_{et}&\text{if }p=i\newline OT_{et,p-1}&\text{if }i< p\le j\newline OT_{et,p}&\text{if }j<p\le K\end{cases}$$$.
Case 2B: $$$i > j$$$. For this case, the cost increases for the optimal solution while the cost does not change for the greedy solution. However, it is not trivial to prove that the greedy solution is more optimal as even though it has a smaller cost, it results in a less optimal array $$$T$$$. Hence, we will prove this case below.
Case 2B
We want to come up with a modified solution that does the same operations as the optimal solution for time $$$1\le t<et$$$ and does an operation on index $$$i$$$ during time $$$et$$$. Adopting a similar notation to $$$OT$$$, we will let $$$MT_{t, i}$$$ denote the value of $$$T_i$$$ before the operation was done at time $$$t$$$ in this modified solution. Then, $$$MT_{et+1,p} = \begin{cases}OT_{et,p}&\text{if }p\neq i\newline A_{et}&\text{if } p=i\end{cases}$$$ and $$$OT_{et+1,p}=\begin{cases}OT_{et,p} &\text{if } p<j\newline OT_{et,p+1}&\text{if }j\le p<i-1\newline A_{et}&\text{if }p=i-1\newline OT_{et,p}&\text{if }i\le p\le K\end{cases}$$$. Note that in this case, $$$MT_{et+1,p}\le OT_{et+1,p}$$$ for all $$$1\le p\le K$$$, which means that our modified solution results in a less optimal state than the optimal solution. However, since our modified solution requires one less cost up to this point, we will be able to prove that our modified solution will not perform worse than the optimal solution.
Notice that $$$OT_{et+1,p}\le MT_{et+1,p+1}$$$ for all $$$1\le p<K$$$. We denote that the index that the optimal solution operates on during time $$$t$$$ is $$$x_t$$$. Let $$$r$$$ be the minimum time where $$$et+1\le r\le N$$$ and $$$e_r=N$$$. Due to the above property that $$$OT_{et+1,p}\le MT_{et+1,p+1}$$$ for all $$$1\le p<K$$$, we can let our modified solution do the operation on index $$$x_t+1$$$ for all time $$$et+1\le t<r$$$ and the cost will not be more than the optimal solution. This is because the property that $$$OT_{t+1,p}\le MT_{t+1,p+1}$$$ for all $$$1\le p<K$$$ still holds throughout that time range even after each update. Note that if such an $$$r$$$ does not exist, we can let our modified solution do the operation on index $$$x_t+1$$$ for all time $$$et+1\le t\le K$$$ and we completed coming up with the modified solution with a cost not more than the optimal solution.
However, if such an $$$r$$$ exists, then at time $$$r$$$, since $$$x_r=N$$$, we are no longer able to use the same method. However, let us consider what happens if we let our modified solution do an operation on index $$$1$$$ during time $$$r$$$.
If $$$A_r>MT_{r,K}$$$, it will mean that $$$MT_{r+1,p}=\begin{cases}MT_{r,p+1}&\text{if }p<K\newline A_r&\text{if }p=K\end{cases}$$$ while $$$OT_{r+1,p}=\begin{cases}OT_{r,p}&\text{if }p<K\newline A_r&\text{if }p=K\end{cases}$$$ since $$$OT_{r,K-1}\le MT_{r,K}<A_r$$$. Even though during this time, it might be possible that the cost of the modified solution increases by $$$1$$$ while the cost of the optimal solution remains the same, recall that previously during time $$$i$$$ our modified solution used one less cost than the optimal solution. As a result, the modified solution will end up having a cost of not more than the optimal solution. At the same time, $$$OT_{r+1,p}\le MT_{r+1,p}$$$ for all $$$1\le p\le K$$$. Hence, for all time $$$r<t\le K$$$, we can let our modified solution do the operation on the same index as the optimal solution $$$x_t$$$ and the cost of our modified solution will not be more than that of the optimal solution.
On the other hand, suppose $$$A_r\le MT_{r,K}$$$. Let $$$v$$$ be the minimum position such that $$$A_r\le MT_{r,v}$$$ and let $$$w$$$ be the minimum position such that $$$A_r\le OT_{r,w}$$$. Then, $$$MT_{r+1,p}=\begin{cases}MT_{r,p+1}&\text{if }p<v-1\newline A_r&\text{if }p=v-1\newline MT_{r,p}&\text{if }p\ge v\end{cases}$$$ and $$$OT_{r+1,p}=\begin{cases}OT_{r,p}&\text{if }p<w\newline A_r&\text{if }p=w\newline OT_{r,p-1}&\text{if }p>w\end{cases}$$$. In the same way, the cost of our modified solution might increase while the cost of the optimal solution stays the same, however, $$$OT_{r+1,p}\le MT_{r+1,p}$$$ for all $$$1\le p\le K$$$. - For $$$p<v-1$$$ and $$$p>w$$$, the condition holds since $$$OT_{r,p}\le MT_{r,p+1}$$$ for all $$$1\le p<K$$$. Note that $$$v-1\le w$$$ because of the same inequality as well. - Suppose $$$v-1=w$$$. Then for $$$p=v-1$$$, $$$OT_{r+1,p}=A_r\le A_r=MT_{r+1,p}$$$. From now on, we suppose $$$v-1\neq w$$$ - For $$$p=v-1$$$, $$$OT_{r,v-1}\le A_r$$$ as $$$w$$$ is defined as the minimum position that $$$A_r\le OT_{r,w}$$$ and $$$v-1< w$$$. - For $$$v\le p<w$$$, $$$OT_{r,p}\le MT_{r,p}$$$ as $$$OT_{r,p}<A_r\le MT_{r,p}$$$ - For $$$p=w$$$, $$$A_r\le MT_{r,w}$$$ as $$$v$$$ is defined as the minimum position that $$$A_r\le MT_{r,v}$$$ and $$$v-1<w$$$
Now that we managed to construct a modified solution which follows the greedy algorithm from time $$$1\le t\le et$$$ and is not less optimal than the optimal solution, we can let the optimal solution be our modified solution and find the new $$$et$$$ to get a new modified solution. Hence by induction, our greedy solution is optimal.
--------------------------------------------------
Problem ID: 1919B
Editorial Content:
1919B - Plus-Minus Split
Hint 1
Try to find a lower bound.
Solution
The answer is $$$|a_1 + a_2 + \ldots + a_n|$$$. Intuitively, whenever we have a subarray with a sum equal to $$$0$$$, it will be helpful for us as its penalty will become $$$0$$$. Hence, we can split $$$a$$$ into subarrays with a sum equal to $$$0$$$ and group up the remaining elements into individual subarrays of size $$$1$$$. A formal proof is given below.
Let us define an alternative penalty function $$$p2(l, r) = |a_l + a_{l+1} + \ldots + a_r|$$$. We can see that $$$p2(l, r) \le p(l, r)$$$ for all $$$1\le l\le r\le n$$$. Since the alternative penalty function does not have the $$$(r - l + 1)$$$ term, there is no reason for us to partition $$$a$$$ into two or more subarrays as $$$|x| + |y| \ge |x + y|$$$ for all integers $$$x$$$ and $$$y$$$, so the answer for the alternative penalty function is $$$|a_1 + a_2 + \ldots + a_n|$$$.
Since $$$p2(l, r)\le p(l, r)$$$, this means that the answer to our original problem cannot be smaller than $$$|a_1 + a_2 + \ldots + a_n|$$$. In fact, this lower bound is always achievable. Let us prove this by construction.
Note that if we flip every "$$$\mathtt{+}$$$" to "$$$\mathtt{-}$$$" and every "$$$\mathtt{-}$$$" to "$$$\mathtt{+}$$$", our answer will remain the same since our penalty function involves absolute values. Hence, we can assume that the sum of elements of $$$a$$$ is non-negative.
If the sum of elements of $$$a$$$ is $$$0$$$, we can split $$$a$$$ into a single array equal to itself $$$b_1 = a$$$ and obtain a penalty of $$$0$$$. Otherwise, we find the largest index $$$i$$$ where $$$a_1 + a_2 + \ldots + a_i = 0$$$. Then we let the first subarray be $$$b_1 = [a_1, a_2, \ldots, a_i]$$$ and the second subarray be $$$b_2 = [a_{i + 1}]$$$, so we have $$$p(b_1) = 0$$$ and $$$p(b_2) = 1$$$. Since $$$i$$$ is the largest index, $$$a_{i + 1}$$$ has to be equal to $$$1$$$ as if $$$a_{i + 1}$$$ is $$$-1$$$ instead, there has to be a larger index where the prefix sum becomes $$$0$$$ again for the prefix sum to go from negative to the final positive total sum. This means that for the remaining elements of the array $$$a_{i+2\ldots n}$$$, the sum of its elements decreases by $$$1$$$, so we can continue to use the same procedure to split the remaining elements which decrease the sum by $$$1$$$ and increase the penalty by $$$1$$$ each time until the sum of elements becomes $$$0$$$. Hence, the total penalty will be equal to the sum of elements of $$$a$$$.
Code
#include <bits/stdc++.h> 
using namespace std;

int t;
int n;
string s;

int main() {
    cin >> t;
    while (t--) {
        cin >> n;
        cin >> s;
        int sm = 0;
        for (int i = 0; i < n; i++) {
            sm += s[i] == '+' ? 1 : -1;
        }
        cout << abs(sm) << '\n';
    }
}
--------------------------------------------------
Problem ID: 1919A
Editorial Content:
1919A - Wallet Exchange
Hint 1
When does the game end?
Solution
Depending on whether the player chooses to exchange wallets with their opponent on step $$$1$$$, $$$1$$$ coins will be removed from either the opponent's wallet or the player's wallet. This means that if either of the players still has remaining coins, the game will not end as at least one of the choices will still be valid.
The only way that the game ends is when both players have $$$0$$$ coins. Since each operation decreases the total amount of coins by exactly $$$1$$$, the only way for Alice to win the game is if $$$a + b$$$ is odd.
Code
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t; cin >> t;
    while (t--) {
        int a, b; cin >> a >> b;
        if ((a + b) % 2 == 0) {
            cout << "Bob\n";
        } else {
            cout << "Alice\n";
        }
    }
}
--------------------------------------------------
Problem ID: 1918G
Editorial Content:
1918G — Permutation of Given
Tutorial
At first, you can manually find answers for small values of $$$n$$$. For $$$n = 2, 4, 6$$$, the answer will be "YES" and the arrays will be $$$[-1, 1]$$$, $$$[-1, -2, 2, 1]$$$, $$$[-1, -2, 2, 1, -1, 1]$$$. It is not difficult to prove by case analysis that the answer is "NO" for $$$3$$$ and $$$5$$$. It can be assumed that for all odd $$$n$$$, the answer is "NO", but if you try to prove the absence of an array or find an array for $$$n = 7$$$, it turns out that the array exists: $$$[-5, 8, 1, -3, -4, -2, 5]$$$. In fact, an array exists for all $$$n$$$ except $$$3$$$ and $$$5$$$.
It would be easy if it were possible to make the number in each cell unchanged. But the presence of array edges and the prohibition of zeros make this impossible. Furthermore, it can be noticed that an infinite array in which the sequence of six numbers $$$1, -3, -4, -1, 3, 4$$$ is repeated, generates the same number in each cell as it was there. In general, any sequence of six numbers of the form $$$a, -b, -a-b, -a, b, a+b$$$ will have this property. Thus, it is possible to transform the internal cells of the array into cells with the same numbers, the question is what to do at the edges. In the author's solution, suitable edges (possibly consisting of several numbers) were manually selected for each remainder of division by $$$6$$$. And then the solution for each value of $$$n$$$ was created as follows: take the edges for $$$n \mod 6$$$ and insert into the middle as many sequences of six numbers that transition into themselves as needed.
Solution by
green_gold_dog
:
The idea is that any correct array can be extended by $$$2$$$ elements to remain correct. Let the array end with the numbers $$$a$$$ and $$$b$$$. Then it can be extended by two elements as follows: \begin{equation*} [\ldots,\;a,\;b] \to [\ldots, a,\; b,\; -b,\; a-b] \end{equation*} This array transitions into its permutation: the entire old array, except for $$$a$$$, is generated by the old array; the last three cells generate $$$a-b$$$, $$$a$$$, $$$-b$$$, i.e., two new elements, and the missing element $$$a$$$. It is also necessary for the new elements to be non-zero. If the last two elements of the old array were different, then the new elements are non-zero; moreover, the new elements cannot be the same, as $$$a$$$ and $$$b$$$ are non-zero, so this operation can be repeated many times.
To start, two arrays are sufficient: $$$[1, 2]$$$ for $$$n = 2$$$ and $$$[1, 2, -3, 2, 4, -5, -2]$$$ for $$$n = 7$$$. Then these arrays can be extended by $$$2$$$ to obtain the answer for even or odd $$$n$$$.
Both solutions print an array using simple rules and work in $$$O(n)$$$ time.
Solution by ooaa
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    if(n%6 == 0)
    {
        cout << "YES\n";
        cout << "2 1 -1 ";
        for(int j = 0;j < n/6-1;++j)
        {
            cout << "1 -1 -2 -1 1 2 ";
        }
        cout << "1 -1 -2" << "\n";
        return 0;
    }
    else if(n%6 == 1)
    {
        cout << "YES\n";
        cout << "-5 8 1 -3 -4 ";
        for(int j = 0;j < n/6-1;++j)
        {
            cout << "-1 3 4 1 -3 -4 ";
        }
        cout << "-2 5" << "\n";
        return 0;
    }
    else if(n%6 == 2)
    {
        cout << "YES\n";
        for(int j = 0;j < n/6;++j)
        {
            cout << "1 -1 -2 -1 1 2 ";
        }
        cout << "1 -1" << "\n";
        return 0;
    }
    else if(n%6 == 3)
    {
        if(n == 3)
            cout << "NO\n";
        else
        {
            cout << "YES\n";
            cout << "2 1 1 -3 -4 -1 3 ";
            for(int j = 0;j < n/6-1;++j)
            {
                cout << "4 1 -3 -4 -1 3 ";
            }
            cout << "3 -2" << "\n";
            return 0;
        }
    }
    else if(n%6 == 4)
    {
        cout << "YES\n";
        for(int j = 0;j < n/6;++j)
        {
            cout << "1 -1 -2 -1 1 2 ";
        }
        cout << "1 -1 1 2" << "\n";
        return 0;
    }
    else if(n%6 == 5)
    {
        if(n == 5)
        {
            cout << "NO\n";
        }
        else
        {
            cout << "YES\n";
            cout << "-2 1 1 -3 -4 -1 3 ";
            for(int j = 0;j < n/6-1;++j)
            {
                cout << "4 1 -3 -4 -1 3 ";
            }
            cout << "2 -1 2 4" << "\n";
            return 0;
        }
    }

}
Solution by green_gold_dog
//#pragma GCC optimize("Ofast")
//#pragma GCC target("avx,avx2,sse,sse2,sse3,ssse3,sse4,abm,popcnt,mmx")
#include <bits/stdc++.h>
 
using namespace std;
 
typedef long long ll;
typedef double db;
typedef long double ldb;
typedef complex<double> cd;
 
constexpr ll INF64 = 9'000'000'000'000'000'000, INF32 = 2'000'000'000, MOD = 1'000'000'007;
constexpr db PI = acos(-1);
constexpr bool IS_FILE = false, IS_TEST_CASES = false;
 
random_device rd;
mt19937 rnd32(rd());
mt19937_64 rnd64(rd());
 
template<typename T>
bool assign_max(T& a, T b) {
	if (b > a) {
		a = b;
		return true;
	}
	return false;
}
 
template<typename T>
bool assign_min(T& a, T b) {
	if (b < a) {
		a = b;
		return true;
	}
	return false;
}
 
template<typename T>
T square(T a) {
	return a * a;
}
 
template<>
struct std::hash<pair<ll, ll>> {
	ll operator() (pair<ll, ll> p) const {
		return ((__int128)p.first * MOD + p.second) % INF64;
	}
};
 
void solve() {
	ll n;
	cin >> n;
	if (n == 5 || n == 3) {
		cout << "NO\n";
		return;
	}
	cout << "YES\n";
	vector<ll> arr;
	if (n % 2 == 0) {
		arr.push_back(1);
		arr.push_back(2);
	} else {
		arr.push_back(1);
		arr.push_back(2);
		arr.push_back(-3);
		arr.push_back(2);
		arr.push_back(4);
		arr.push_back(-5);
		arr.push_back(-2);
	}
	while (arr.size() != n) {
		ll x = arr[arr.size() - 2];
		ll y = x - arr.back();
		ll z = y - x;
		arr.push_back(z);
		arr.push_back(y);
	}
	for (auto i : arr) {
		cout << i << ' ';
	}
	cout << '\n';
}
 
int main() {
	if (IS_FILE) {
		freopen("", "r", stdin);
		freopen("", "w", stdout);
	}
    	ios_base::sync_with_stdio(false);
    	cin.tie(0);
    	cout.tie(0);
	ll t = 1;
	if (IS_TEST_CASES) {
		cin >> t;
	}
	for (ll i = 0; i < t; i++) {
		solve();
	}
}
--------------------------------------------------
Problem ID: 1918F
Editorial Content:
1918F — Caterpillar on a Tree
Tutorial
First, it can be noticed that it is enough to visit all the leaves of the tree. After all, if the caterpillar skips some internal node, then it will not be able to reach the subtree of this node and visit the leaves in it. Therefore, it makes no sense to teleport to the root from a non-leaf (otherwise it would be more profitable to move to the root earlier, and all the leaves would remain visited).
The optimal path of the caterpillar on the tree can be divided into movements from the root to a leaf, movements from one leaf to another, and teleportations from a leaf to the root. Let the order of visiting the leaves in the optimal path be fixed. Then it makes no sense to teleport from the last leaf, as all the leaves have already been visited. In addition, it is not profitable to move not along the shortest path in the sections of transition from the root to a leaf without visiting other leaves, or in movements from one leaf to another without visiting other leaves. If the leaf $$$v$$$ is visited after the leaf $$$u$$$, then teleporting from $$$u$$$ saves time of transition from $$$u$$$ to $$$v$$$ minus the time of moving to $$$v$$$ from the root. It is possible to choose $$$k$$$ leaves, without the last visited leaf, which give the maximum savings (if there are fewer leaves in the tree, or the savings become negative, then take fewer than $$$k$$$ leaves), and teleport from them. Thus, if the order of visiting the leaves is known, the optimal time can be found.
It turns out that if you take the tree and sort the children of each node in ascending (not descending) order of the depth of the subtree, and then write down all the leaves from left to right (in depth-first order), then this will be one of the optimal leaf orders. This order of sorting the tree and its leaves will be called the order of sorting by the subtree depth.
The tree can be sorted in this way in one depth-first traversal. For each leaf, it is possible to calculate how much time teleporting from it saves. To do this, it is enough to move from this leaf to the root until the first node, for which the previous node is not the rightmost child. Then the savings are the length of the path traveled minus the remaining distance to the root. Such paths for different leaves do not intersect along the edges, and the remaining distance to the root can be precalculated in a depth-first search for all nodes at once. Therefore, the algorithm works in $$$O(n \log n)$$$ time, where the logarithm arises from sorting the children of each node by the depth of the subtree.
Theorem.
There exists a shortest route for the caterpillar, in which the leaves are visited in the order of sorting the children of each node by the depth of the subtree.
Proof
Let $$$u_1, \ldots, u_m$$$ be all the leaves of the tree in the order that will result if the children of each node are sorted in ascending order of the depth of the subtree. Consider the shortest route of the caterpillar visiting all the nodes of the tree. Let $$$v_1, \ldots, v_m$$$ be the leaves of the tree, in the order of visiting in this route. Consider the maximum prefix of leaves that coincides with the order of sorting by the depth of the subtree: $$$v_1 = u_1,\ldots, v_i = u_i$$$. If $$$i = m$$$, then the theorem is proven. Now, let's assume that the next leaf is the incorrect leaf $$$v_{i+1} \neq u_{i+1}$$$.
The goal is to change the route in such a way that the time of traversing the tree does not increase, so that the first $$$i$$$ visited leaves do not change and remain in the same order, and so that the leaf $$$u_{i+1}$$$ is encountered earlier in the route than before the change. Then it is possible to move the leaf $$$u_{i+1}$$$ to its $(i+1)$s place, while maintaining the order of the first $$$i$$$ visited leaves. Then, in the same way, one can put all the leaves $$$u_{i+1}, \ldots, u_m$$$ in their places one by one and get the shortest route of the caterpillar with the desired order of visiting leaves.
Lemma.
Let the node $$$w$$$ be the ancestor of the node $$$u$$$. Let the caterpillar in the shortest route on the tree crawl from $$$u$$$ to $$$w$$$. Then the caterpillar enters the subtree of the node $$$u$$$ only once, traverses this subtree depth-first, and returns to $$$w$$$.
Proof of the lemma.
If the caterpillar crawls from $$$w$$$ to $$$u$$$ only once, then it cannot leave the subtree of $$$u$$$ until all the nodes in this subtree are visited, and it cannot jump on a trampoline, as it still needs to move from $$$u$$$ to $$$w$$$. All this cannot be done faster than the number of steps equal to twice the number of nodes in the subtree of $$$u$$$, because the caterpillar needs to reach each node via an edge from the ancestor and to return to the ancestor. And any route without teleportations, which uses each edge twice, is one of the depth-first traversals.
If the caterpillar crawls from $$$w$$$ to $$$u$$$ two or more times, then the route can be shortened, as shown in figure.
The lemma is proven.
At the moment, the leaf $$$v_{i+1}$$$ lies in the order of visiting the leaves in the optimal route of the caterpillar in the place of the leaf $$$u_{i+1}$$$. The goal is to move the leaf $$$u_{i+1}$$$ closer to the beginning of the route, without changing the first $$$i$$$ visited leaves: $$$u_1, \ldots, u_i$$$.
Let $$$w$$$ be the least common ancestor of the leaves $$$u_{i+1}$$$ and $$$v_{i+1}$$$, let $$$u$$$ be the child of $$$w$$$, in the subtree of which the node $$$u_{i+1}$$$ is located, and $$$v$$$ be the child of $$$w$$$, in the subtree of which the node $$$v_{i+1}$$$ is located, as shown in figure. To move the leaf $$$u_{i+1}$$$ closer to the beginning of the route, let us consider cases.
Case 1:
The caterpillar in the current version of the optimal route crawls from $$$u$$$ to $$$w$$$.
In this case, according to the lemma, the caterpillar enters the subtree of vertex $$$u$$$ only once, and traverses it in the depth-first manner before returning to $$$w$$$. There are no leaves $$$u_1, \ldots, u_i$$$ in the subtree of $$$u$$$, because all the leaves of the subtree of $$$u$$$ are visited consecutively during the depth-first traversal, and the leaf $$$v_{i+1}$$$ not from the subtree of $$$u$$$ is visited after $$$u_1, \ldots, u_i$$$, but before $$$u_{i+1}$$$. Then the route can be changed as follows: the cycle $$$w \to \text{ (traversal of the subtree of } u\text{) } \to w$$$ is cut out from where it is located, and inserted at the moment of the first visit to $$$w$$$ after the visit to the leaf $$$u_i$$$. The leaf $$$u_i$$$ is not in the subtree of the node $$$v$$$, because the subtree of $$$u$$$ has a smaller depth ($$$u_{i+1}$$$ is earlier in the desired leaf order than $$$v_{i+1}$$$), and there are still unvisited leaves in it. Then, before entering $$$v_{i+1}$$$, the caterpillar will have to come from the leaf $$$u_i$$$ to the node $$$w$$$, and at that moment a depth-first traversal of the subtree of $$$u$$$ with the visit to the leaf $$$u_{i+1}$$$ will occur. This traversal was moved to an earlier time, before visiting $$$v_{i+1}$$$, which means that in the order of visiting the leaves in the caterpillar's route, the leaf $$$u_{i+1}$$$ has been moved closer to the beginning.
Case 2:
The caterpillar in the current version of the optimal route does not crawl from $$$u$$$ to $$$w$$$, but crawls from $$$v$$$ to $$$w$$$.
Then the entire subtree of $$$v$$$ is traversed in a depth-first traversal. Since the leaf $$$u_{i+1}$$$ is earlier in the desired order than $$$v_{i+1}$$$, the subtree of $$$v$$$ is deeper than the subtree of $$$u$$$, and in the desired order all the leaves of $$$v$$$ come after $$$u_{i+1}$$$. Moreover, since the caterpillar does not crawl from $$$u$$$ to $$$w$$$, it is impossible to leave the subtree of $$$u$$$ except by teleporting to the root. The last jump on the trampoline from the subtree of the node $$$u$$$ is considered (or stopping at the end of the route). At this moment, all the leaves of the subtree of $$$u$$$ are visited. The route can be changed as follows: cut out the depth-first traversal of the subtree of $$$v$$$, cancel the last jump or stop in the subtree of $$$u$$$, descend from there to $$$w$$$, perform a depth-first traversal of the subtree of $$$v$$$ in such a way that the deepest node of this subtree is visited last, and teleport to the root (or stop at the end of the route). This will not be longer, because a section of transition from a leaf in the subtree of $$$u$$$ to $$$w$$$ has been added, and a section of movement from the deepest leaf in the subtree of $$$v$$$ to $$$w$$$ has disappeared, here it is important that the subtree of $$$v$$$ is deeper than the subtree of $$$u$$$. And the node $$$u_{i+1}$$$ has become closer to the beginning of the list of visited leaves, because all the leaves of the subtree of $$$v$$$, including $$$v_{i+1}$$$, have moved somewhere after all the leaves of the subtree of $$$u$$$.
Case 3:
The caterpillar in the current version of the optimal route does not crawl either from $$$u$$$ to $$$w$$$, nor from $$$v$$$ to $$$w$$$.
Then all the sections of the route that move into the subtrees of the nodes $$$u$$$ and $$$v$$$ do not leave these subtrees and end with teleportation to the root or stopping at the end of the route. Among them, there is a section that starts with a step from $$$w$$$ to $$$u$$$, in which the leaf $$$u_{i+1}$$$ is visited, and a section that starts with a step from $$$w$$$ to $$$v$$$, in which the leaf $$$v_{i+1}$$$ is visited. In the current route, the section with $$$v_{i+1}$$$ comes earlier. The route can be changed very simply: swap the section visiting the leaf $$$u_{i+1}$$$ and the section visiting the leaf $$$v_{i+1}$$$. If both sections end with teleportations, then a correct caterpillar route will result. If the caterpillar stopped at the end of the section visiting $$$u_{i+1}$$$, and teleported to the root from the section with $$$v_{i+1}$$$, then now it will teleport after completing the section with $$$u_{i+1}$$$ and stop at the end of the section with $$$v_{i+1}$$$. The positions of the leaves $$$u_1, \ldots, u_i$$$ in the route will not change: they are not in the subtree of $$$v$$$, and they are not in the section with $$$u_{i+1}$$$, visited after $$$v_{i+1}$$$. And the leaf $$$u_{i+1}$$$ will get a place closer to the beginning in the order of visiting the leaves, because the section with its visit now occurs earlier in the route.
In all cases, it was possible to move the leaf $$$u_{i+1}$$$ in the optimal route of the caterpillar closer to the beginning, while maintaining the order of the first $$$i$$$ visited leaves, which means that there exists an optimal route of the caterpillar in which the leaves are visited in the order of sorting the subtrees of the tree by depth. The theorem is proven.
Proof
Let $$$u_1, \ldots, u_m$$$ be all the leaves of the tree in the order that will result if the children of each node are sorted in ascending order of the depth of the subtree. Consider the shortest route of the caterpillar visiting all the nodes of the tree. Let $$$v_1, \ldots, v_m$$$ be the leaves of the tree, in the order of visiting in this route. Consider the maximum prefix of leaves that coincides with the order of sorting by the depth of the subtree: $$$v_1 = u_1,\ldots, v_i = u_i$$$. If $$$i = m$$$, then the theorem is proven. Now, let's assume that the next leaf is the incorrect leaf $$$v_{i+1} \neq u_{i+1}$$$.
The goal is to change the route in such a way that the time of traversing the tree does not increase, so that the first $$$i$$$ visited leaves do not change and remain in the same order, and so that the leaf $$$u_{i+1}$$$ is encountered earlier in the route than before the change. Then it is possible to move the leaf $$$u_{i+1}$$$ to its $(i+1)$s place, while maintaining the order of the first $$$i$$$ visited leaves. Then, in the same way, one can put all the leaves $$$u_{i+1}, \ldots, u_m$$$ in their places one by one and get the shortest route of the caterpillar with the desired order of visiting leaves.
Lemma.
Let the node $$$w$$$ be the ancestor of the node $$$u$$$. Let the caterpillar in the shortest route on the tree crawl from $$$u$$$ to $$$w$$$. Then the caterpillar enters the subtree of the node $$$u$$$ only once, traverses this subtree depth-first, and returns to $$$w$$$.
Proof of the lemma.
If the caterpillar crawls from $$$w$$$ to $$$u$$$ only once, then it cannot leave the subtree of $$$u$$$ until all the nodes in this subtree are visited, and it cannot jump on a trampoline, as it still needs to move from $$$u$$$ to $$$w$$$. All this cannot be done faster than the number of steps equal to twice the number of nodes in the subtree of $$$u$$$, because the caterpillar needs to reach each node via an edge from the ancestor and to return to the ancestor. And any route without teleportations, which uses each edge twice, is one of the depth-first traversals.
If the caterpillar crawls from $$$w$$$ to $$$u$$$ two or more times, then the route can be shortened, as shown in figure.
The lemma is proven.
At the moment, the leaf $$$v_{i+1}$$$ lies in the order of visiting the leaves in the optimal route of the caterpillar in the place of the leaf $$$u_{i+1}$$$. The goal is to move the leaf $$$u_{i+1}$$$ closer to the beginning of the route, without changing the first $$$i$$$ visited leaves: $$$u_1, \ldots, u_i$$$.
Let $$$w$$$ be the least common ancestor of the leaves $$$u_{i+1}$$$ and $$$v_{i+1}$$$, let $$$u$$$ be the child of $$$w$$$, in the subtree of which the node $$$u_{i+1}$$$ is located, and $$$v$$$ be the child of $$$w$$$, in the subtree of which the node $$$v_{i+1}$$$ is located, as shown in figure. To move the leaf $$$u_{i+1}$$$ closer to the beginning of the route, let us consider cases.
Case 1:
The caterpillar in the current version of the optimal route crawls from $$$u$$$ to $$$w$$$.
In this case, according to the lemma, the caterpillar enters the subtree of vertex $$$u$$$ only once, and traverses it in the depth-first manner before returning to $$$w$$$. There are no leaves $$$u_1, \ldots, u_i$$$ in the subtree of $$$u$$$, because all the leaves of the subtree of $$$u$$$ are visited consecutively during the depth-first traversal, and the leaf $$$v_{i+1}$$$ not from the subtree of $$$u$$$ is visited after $$$u_1, \ldots, u_i$$$, but before $$$u_{i+1}$$$. Then the route can be changed as follows: the cycle $$$w \to \text{ (traversal of the subtree of } u\text{) } \to w$$$ is cut out from where it is located, and inserted at the moment of the first visit to $$$w$$$ after the visit to the leaf $$$u_i$$$. The leaf $$$u_i$$$ is not in the subtree of the node $$$v$$$, because the subtree of $$$u$$$ has a smaller depth ($$$u_{i+1}$$$ is earlier in the desired leaf order than $$$v_{i+1}$$$), and there are still unvisited leaves in it. Then, before entering $$$v_{i+1}$$$, the caterpillar will have to come from the leaf $$$u_i$$$ to the node $$$w$$$, and at that moment a depth-first traversal of the subtree of $$$u$$$ with the visit to the leaf $$$u_{i+1}$$$ will occur. This traversal was moved to an earlier time, before visiting $$$v_{i+1}$$$, which means that in the order of visiting the leaves in the caterpillar's route, the leaf $$$u_{i+1}$$$ has been moved closer to the beginning.
Case 2:
The caterpillar in the current version of the optimal route does not crawl from $$$u$$$ to $$$w$$$, but crawls from $$$v$$$ to $$$w$$$.
Then the entire subtree of $$$v$$$ is traversed in a depth-first traversal. Since the leaf $$$u_{i+1}$$$ is earlier in the desired order than $$$v_{i+1}$$$, the subtree of $$$v$$$ is deeper than the subtree of $$$u$$$, and in the desired order all the leaves of $$$v$$$ come after $$$u_{i+1}$$$. Moreover, since the caterpillar does not crawl from $$$u$$$ to $$$w$$$, it is impossible to leave the subtree of $$$u$$$ except by teleporting to the root. The last jump on the trampoline from the subtree of the node $$$u$$$ is considered (or stopping at the end of the route). At this moment, all the leaves of the subtree of $$$u$$$ are visited. The route can be changed as follows: cut out the depth-first traversal of the subtree of $$$v$$$, cancel the last jump or stop in the subtree of $$$u$$$, descend from there to $$$w$$$, perform a depth-first traversal of the subtree of $$$v$$$ in such a way that the deepest node of this subtree is visited last, and teleport to the root (or stop at the end of the route). This will not be longer, because a section of transition from a leaf in the subtree of $$$u$$$ to $$$w$$$ has been added, and a section of movement from the deepest leaf in the subtree of $$$v$$$ to $$$w$$$ has disappeared, here it is important that the subtree of $$$v$$$ is deeper than the subtree of $$$u$$$. And the node $$$u_{i+1}$$$ has become closer to the beginning of the list of visited leaves, because all the leaves of the subtree of $$$v$$$, including $$$v_{i+1}$$$, have moved somewhere after all the leaves of the subtree of $$$u$$$.
Case 3:
The caterpillar in the current version of the optimal route does not crawl either from $$$u$$$ to $$$w$$$, nor from $$$v$$$ to $$$w$$$.
Then all the sections of the route that move into the subtrees of the nodes $$$u$$$ and $$$v$$$ do not leave these subtrees and end with teleportation to the root or stopping at the end of the route. Among them, there is a section that starts with a step from $$$w$$$ to $$$u$$$, in which the leaf $$$u_{i+1}$$$ is visited, and a section that starts with a step from $$$w$$$ to $$$v$$$, in which the leaf $$$v_{i+1}$$$ is visited. In the current route, the section with $$$v_{i+1}$$$ comes earlier. The route can be changed very simply: swap the section visiting the leaf $$$u_{i+1}$$$ and the section visiting the leaf $$$v_{i+1}$$$. If both sections end with teleportations, then a correct caterpillar route will result. If the caterpillar stopped at the end of the section visiting $$$u_{i+1}$$$, and teleported to the root from the section with $$$v_{i+1}$$$, then now it will teleport after completing the section with $$$u_{i+1}$$$ and stop at the end of the section with $$$v_{i+1}$$$. The positions of the leaves $$$u_1, \ldots, u_i$$$ in the route will not change: they are not in the subtree of $$$v$$$, and they are not in the section with $$$u_{i+1}$$$, visited after $$$v_{i+1}$$$. And the leaf $$$u_{i+1}$$$ will get a place closer to the beginning in the order of visiting the leaves, because the section with its visit now occurs earlier in the route.
In all cases, it was possible to move the leaf $$$u_{i+1}$$$ in the optimal route of the caterpillar closer to the beginning, while maintaining the order of the first $$$i$$$ visited leaves, which means that there exists an optimal route of the caterpillar in which the leaves are visited in the order of sorting the subtrees of the tree by depth. The theorem is proven.
Solution
#include <bits/stdc++.h>

using namespace std;

const int maxn = 200005;
int d[maxn];
int h[maxn];
int p[maxn];
vector<int> leaf_jump_gains;
vector<vector<int> > children;

bool comp_by_depth(int u,int v)
{
    return d[u] < d[v];
}

void sort_subtrees_by_depth(int v)
{
    d[v] = 0;
    if(v == 1)
        h[v] = 0;
    else
        h[v] = h[p[v]]+1;
    for(int i = 0; i < int(children[v].size()); ++i)
    {
        int u = children[v][i];
        sort_subtrees_by_depth(u);
        d[v] = max(d[v],d[u]+1);
    }
    sort(children[v].begin(),children[v].end(),comp_by_depth);
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int n,k;
    cin >> n >> k;
    children.resize(n+1);
    for(int i = 2; i <= n; ++i)
    {
        cin >> p[i];
        children[p[i]].push_back(i);
    }
    sort_subtrees_by_depth(1);
    for(int i = 1; i <= n; ++i)
    {
        if(children[i].size() == 0)
        {
            int jump_gain = 0;
            int v = i;
            while(v != 1)
            {
                int s = children[p[v]].size();
                if(children[p[v]][s-1] == v)
                {
                    v = p[v];
                    ++jump_gain;
                }
                else
                {
                    jump_gain = jump_gain+1-h[p[v]];
                    break;
                }
            }
            leaf_jump_gains.push_back(jump_gain);
        }
    }
    sort(leaf_jump_gains.begin(),leaf_jump_gains.end());
    int s = leaf_jump_gains.size();
    ++k; //non-returning from the last leaf is like one more jump
    int res = 2*(n-1);
    for(int i = s-1; i >= max(0,s-k); --i)
        res -= max(leaf_jump_gains[i],0);
    cout << res << '\n';
    return 0;
}
--------------------------------------------------
Problem ID: 1918E
Editorial Content:
1918E — ace5 and Task Order
Tutorial
Randomized solution:
We will use the quicksort algorithm. We will choose a random element from the array, let its index be $$$i$$$, and we will perform $$$?$$$ $$$i$$$ until we get the answer $$$=$$$ (i.e., $$$x = a_i$$$). Now we will ask about all the other elements, thereby finding out whether they are greater than or less than $$$a_i$$$ (don't forget to return $$$x = a_i$$$, i.e., perform $$$?$$$ $$$i$$$ after each query about the element). After this, we will divide all the elements into two parts, where $$$a_i > x$$$ and $$$a_i < x$$$. We will recursively run the algorithm on each part. The parts will become smaller and smaller, and in the end, we will sort our permutation, allowing us to guess it.
Non-randomized solution:
We will find the element $$$1$$$ in the array in $$$3n$$$ queries. To do this, we will go through the array, asking about each element each time. If the answer is $$$<$$$, we will continue asking until the answer becomes $$$=$$$, and if the answer is $$$=$$$ or $$$>$$$, we will move on to the next element. Then the last element on which the answer was $$$<$$$ is the element $$$1$$$. $$$x$$$ will increase by a maximum of $$$n$$$ in the process (a maximum of $$$1$$$ from each element), so it will decrease by a maximum of $$$2n$$$, i.e., a maximum of $$$3n$$$ queries. Similarly, we will find the element $$$n$$$. Now we will run an algorithm similar to the randomized solution, but now we can set $$$x = n/2$$$ instead of taking $$$x$$$ as a random element.
Both solutions comfortably fit within the limit of $$$40n$$$ queries.
Randomized solution
#include <bits/stdc++.h>

using namespace std;

mt19937 rnd(593);

char query(int i)
{
    cout << "? " << i+1 << endl;
    char c;
    cin >> c;
    return c;
}

void quicksort(vector<int> &a,vector<int> &ord)
{
    if(a.size() == 0)
        return ;
    int mid = rnd()%a.size();
    while(query(a[mid]) != '=')
        ;
    vector<int> l,r;
    for(int i = 0;i < a.size();++i)
    {
        if(i == mid)
            continue;
        if(query(a[i]) == '<')
        {
            l.push_back(a[i]);
        }
        else
        {
            r.push_back(a[i]);
        }
        query(a[mid]);
    }
    vector<int> l_ord;
    vector<int> r_ord;
    quicksort(l,l_ord);
    quicksort(r,r_ord);
    for(int i = 0;i < l_ord.size();++i)
    {
        ord.push_back(l_ord[i]);
    }
    ord.push_back(a[mid]);
    for(int i = 0;i < r_ord.size();++i)
    {
        ord.push_back(r_ord[i]);
    }
    return ;
}


int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        vector<int> a;
        vector<int> ord;
        for(int i = 0;i < n;++i)
        {
            a.push_back(i);
        }
        quicksort(a,ord);
        cout << "! ";
        vector<int> ans(n);
        for(int i = 0;i < n;++i)
        {
            ans[ord[i]] = i;
        }
        for(int i = 0;i < n;++i)
        {
            cout << ans[i]+1 << ' ';
        }
        cout << endl;
    }
}
Non-randomized solution
#include <bits/stdc++.h>

using namespace std;

char query(int pos)
{
    cout << "? " << pos << endl;
    char ans;
    cin >> ans;
    return ans;
}

void dnq(int l,int r,vector<int> pos,vector<int> & res,int pos1,int posn)
{
    int m = (l+r)/2;
    vector<int> lh;
    vector<int> rh;
    for(int i = 0;i < pos.size();++i)
    {
        char x = query(pos[i]);
        if(x == '>')
        {
            rh.push_back(pos[i]);
            query(pos1);
        }
        else if(x == '<')
        {
            lh.push_back(pos[i]);
            query(posn);
        }
        else
        {
            res[pos[i]] = m;
        }
    }
    if(lh.size() != 0)
    {
        int m2 = (l+m-1)/2;
        for(int j = 0;j < m-m2;++j)
            query(pos1);
        dnq(l,m-1,lh,res,pos1,posn);
        query(posn);
    }
    if(rh.size() != 0)
    {
        int m2 = (m+1+r)/2;
        for(int j = 0;j < m2-m;++j)
            query(posn);
        dnq(m+1,r,rh,res,pos1,posn);
    }
    return ;
}


int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        int pos1 = -1;
        for(int i = 1;i <= n;++i)
        {
            char ans = query(i);
            if(ans == '<')
            {
                i--;
            }
            else if(ans == '=')
            {
                pos1 = i;
            }
            else
            {
                if(pos1 != -1)
                {
                    query(pos1);
                }
            }
        }
        int posn = -1;
        for(int i = 1;i <= n;++i)
        {
            char ans = query(i);
            if(ans == '>')
            {
                i--;
            }
            else if(ans == '=')
            {
                posn = i;
            }
            else
            {
                if(posn != -1)
                {
                    query(posn);
                }
            }
        }
        vector<int> res(n+1);
        vector<int> pos(n);
        for(int j = 0;j < n;++j)
            pos[j] = j+1;
        int m = (1+n)/2;
        for(int k = 0;k < n-m;++k)
        {
            query(pos1);
        }
        dnq(1,n,pos,res,pos1,posn);
        cout << "! ";
        for(int j = 1;j <= n;++j)
            cout << res[j] << ' ';
        cout << endl;
    }
}
--------------------------------------------------
Problem ID: 1918D
Editorial Content:
1918D — Blocking Elements
Tutorial
Let's do a binary search. Suppose we know that the minimum possible cost is at least $$$l$$$ and not greater than $$$r$$$. Let's choose $$$m = (l+r)/2$$$. We need to learn how to check if the answer is less than or equal to $$$m$$$. We will calculate $$$dp_i$$$–the minimum sum of blocked elements in the prefix up to $$$i$$$ if position $$$i$$$ is blocked, and on each of the subsegments without blocked elements, the sum of elements is less than or equal to $$$m$$$. Then $$$dp_i = a_i + \min(dp_j)$$$ for all $$$j$$$ such that the sum on the subsegment from $$$j+1$$$ to $$$i-1$$$ is less than or equal to $$$m$$$. Such $$$j$$$ form a segment, since $$$a_j$$$ is positive. We will maintain the boundaries of this segment. We will also maintain all $$$dp_j$$$ for $$$j$$$ inside this subsegment in the set. When moving from $$$i$$$ to $$$i+1$$$, we will move the left boundary of the subsegment until the sum on it becomes less than or equal to $$$m$$$, and remove $$$dp_j$$$ from the set, and also add $$$dp_i$$$ to the set. The minimum sum of blocked elements under the condition that the sum on all subsegments without blocked elements is less than or equal to $$$m$$$ can be found as the minimum among all $$$dp_i$$$ such that the sum from $$$i$$$ to $$$n$$$ is less than or equal to $$$m$$$. If this answer is less than or equal to $$$m$$$, then the answer to the problem is less than or equal to $$$m$$$, otherwise the answer is greater than $$$m$$$.
Time complexity: $$$O(n \log n \log 10^9)$$$ per test case.
Solution
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        int64_t a[n+1];
        for(int i = 0;i < n;++i)
        {
            cin >> a[i];
        }
        int64_t l = 0,r = int64_t(1e9)*n;
        while(l < r)
        {
            int64_t m = (l+r)/2;
            set<pair<int64_t,int>> pos;
            int64_t dp[n+1];
            int p2 = n;
            dp[n] = 0;
            pos.insert({dp[n],n});
            int64_t sum = 0;
            for(int j = n-1;j >= 0;--j)
            {
                while(sum > m)
                {
                    sum -= a[p2-1];
                    pos.erase({dp[p2],p2});
                    p2--;
                }
                dp[j] = pos.begin()->first + a[j];
                pos.insert({dp[j],j});
                sum += a[j];
            }
            sum = 0;
            int yes = 0;
            for(int j =0;j < n;++j)
            {
                if(sum <= m && dp[j] <= m)
                    yes = 1;
                sum += a[j];
            }
            if(yes)
                r = m;
            else
                l = m+1;
        }
        cout << l << "\n";
    }
}
--------------------------------------------------
Problem ID: 1918C
Editorial Content:
1918C — XOR-distance
Tutorial
Let's consider the bitwise representation of numbers $$$a$$$, $$$b$$$, $$$x$$$. Let's look at any $$$2$$$ bits at the same position in $$$a$$$ and $$$b$$$, if they are the same, then regardless of what is in $$$x$$$ on this position, the number $$$|({a \oplus x}) - ({b \oplus x})|$$$ will have a $$$0$$$ at this position. Therefore, it is advantageous to set $$$0$$$ at all such positions in $$$x$$$ (since we want $$$x \leq r$$$, and the answer does not depend on the bit). If the bits in $$$a$$$ and $$$b$$$ at the same position are different, then at this position there will be a $$$1$$$ either in $$$a \oplus x$$$ or in $$$b \oplus x$$$ depending on what is at this position in $$$x$$$.
Let $$$a$$$ < $$$b$$$, if not, then we will swap them. Then at the highest position, where the bits differ, there is a $$$0$$$ in $$$a$$$ and a $$$1$$$ in $$$b$$$. There are $$$2$$$ options, either to set a $$$1$$$ at this position in $$$x$$$ (and then there will be a $$$1$$$ in $$$a \oplus x$$$), or to set a $$$0$$$ in $$$x$$$ (and then there will be a $$$0$$$ in $$$a \oplus x$$$).
Suppose we set $$$0$$$ in $$$x$$$, then $$$a \oplus x$$$ will definitely be less than $$$b \oplus x$$$ (because in the highest differing bit, $$$a \oplus x$$$ has $$$0$$$, and $$$b \oplus x$$$ has $$$1$$$). Therefore, it is advantageous to set $$$1$$$ in $$$a \oplus x$$$ on all next positions, as this will make their difference smaller. Therefore, we can go through the positions in descending order, and if the position is differing, then we will set a $$$1$$$ in $$$a \oplus x$$$ at this position if possible (if after this $$$x$$$ does not exceed $$$r$$$).
The second case (when we set $$$1$$$ in $$$x$$$ at the position of the first differing bit) is analyzed similarly, but in fact it is not needed, because the answer will not be smaller, and $$$x$$$ will become larger.
Time complexity: $$$O(\log 10^{18})$$$ per test case.
Solution
#include <bits/stdc++.h>

using namespace std;

const int maxb = 60;

bool get_bit(int64_t a,int i)
{
    return a&(1ll<<i);
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while(t--)
    {
        int64_t a,b,r;
        cin >> a >> b >> r;
        int64_t x = 0;
        bool first_bit = 1;
        if(a > b)
            swap(a,b);
        for(int i = maxb-1;i >= 0;--i)
        {
            bool bit_a = get_bit(a,i);
            bool bit_b = get_bit(b,i);
            if(bit_a != bit_b)
            {
                if(first_bit)
                {
                    first_bit = 0;
                }
                else
                {
                    if(!bit_a && x+(1ll<<i) <= r)
                    {
                        x += (1ll<<i);
                        a ^= (1ll<<i);
                        b ^= (1ll<<i);
                    }
                }
            }
        }
        cout << b-a << "\n";
    }
}
--------------------------------------------------
Problem ID: 1918B
Editorial Content:
1918B — Minimize Inversions
Tutorial
Notice that by performing operations of the form: swap $$$a_i$$$ with $$$a_j$$$ and $$$b_i$$$ with $$$b_j$$$ simultaneously, we can rearrange the array $$$a$$$ how we want, but the same $$$a_i$$$ will correspond to the same $$$b_i$$$ (because we are changing both $$$a_i$$$ and $$$b_i$$$ at the same time). Let's sort the array $$$a$$$ using these operations. Then the sum of the number of inversions in $$$a$$$ and $$$b$$$ will be the number of inversions in $$$b$$$, since $$$a$$$ is sorted. It is claimed that this is the minimum sum that can be achieved.
Proof: Consider two pairs of elements $$$a_i$$$ with $$$a_j$$$ and $$$b_i$$$ with $$$b_j$$$ ($$$i$$$ < $$$j$$$). In each of these pairs, there can be either $$$0$$$ or $$$1$$$ inversions, so among the two pairs, there can be $$$0$$$, $$$1$$$, or $$$2$$$ inversions. If there were $$$0$$$ inversions before the operation, then there will be $$$2$$$ after the operation; if there was $$$1$$$, then there will still be $$$1$$$; if there were $$$2$$$, then it will become $$$0$$$. If the permutation $$$a_i$$$ is sorted, then in each pair of indices $$$i$$$ and $$$j$$$ there will be a maximum of 1 inversion, so any pair of indices will give no more inversions than if they were swapped. Since the number of inversions in each pair is the minimum possible, the total number of inversions is also the minimum possible.
Time complexity: $$$O(n \log n)$$$ per test case.
Solution
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        pair<int,int> ab[n];
        for(int i = 0;i < n;++i)
        {
            cin >> ab[i].first;
        }
        for(int i = 0;i < n;++i)
        {
            cin >> ab[i].second;
        }
        sort(ab,ab+n);
        for(int i = 0;i < n;++i)
        {
            cout << ab[i].first << ' ';
        }
        cout << "\n";
        for(int i = 0;i < n;++i)
        {
            cout << ab[i].second << ' ';
        }
        cout << "\n";
    }
}
--------------------------------------------------
Problem ID: 1918A
Editorial Content:
1918A — Brick Wall
Tutorial
The stability of the wall is the number of horizontal bricks minus the number of vertical bricks. Since a horizontal brick has a length of at least $$$2$$$, no more than $$$\lfloor\frac{m}{2}\rfloor$$$ horizontal bricks can be placed in one row. Therefore, the answer does not exceed $$$n \cdot \lfloor\frac{m}{2}\rfloor$$$. On the other hand, if horizontal bricks of length $$$2$$$ are placed in a row, and when $$$m$$$ is odd, the last brick has a length of $$$3$$$, then in each row there will be exactly $$$\lfloor\frac{m}{2}\rfloor$$$ horizontal bricks, and there will be no vertical bricks in the wall at all. This achieves the maximum stability of $$$n \cdot \lfloor\frac{m}{2}\rfloor$$$. The solution is one formula, so it works in $$$O(1)$$$ time.
Solution
#include <bits/stdc++.h>

using namespace std;


int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while(t--)
    {
        int64_t n,m;
        cin >> n >> m;
        cout << n*(m/2) << '\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1917F
Editorial Content:
1917F - Construct Tree
--------------------------------------------------
Problem ID: 1917E
Editorial Content:
1917E - Construct Matrix
--------------------------------------------------
Problem ID: 1917D
Editorial Content:
1917D - Yet Another Inversions Problem
--------------------------------------------------
Problem ID: 1917C
Editorial Content:
1917C - Watering an Array
--------------------------------------------------
Problem ID: 1917B
Editorial Content:
1917B - Erase First or Second Letter
--------------------------------------------------
Problem ID: 1917A
Editorial Content:
1917A - Least Product
--------------------------------------------------
Problem ID: 1916H2
Editorial data not available.
--------------------------------------------------
Problem ID: 1916H1
Editorial data not available.
--------------------------------------------------
Problem ID: 1916G
Editorial data not available.
--------------------------------------------------
Problem ID: 1916F
Editorial data not available.
--------------------------------------------------
Problem ID: 1916E
Editorial data not available.
--------------------------------------------------
Problem ID: 1916D
Editorial data not available.
--------------------------------------------------
Problem ID: 1916C
Editorial data not available.
--------------------------------------------------
Problem ID: 1916B
Editorial data not available.
--------------------------------------------------
Problem ID: 1916A
Editorial data not available.
--------------------------------------------------
Problem ID: 1915G
Editorial Content:
1915G - Велосипеды
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"

const int64_t inf = 1e18;

void solve() {
    int n, m; std::cin >> n >> m;
    std::vector<std::pair<int, int>> adj[n];
    for(int i = 0; i < m; ++i) {
        int u, v, w; std::cin >> u >> v >> w; --u, --v;
        adj[u].emplace_back(v, w);
        adj[v].emplace_back(u, w);
    }
    std::vector<int> s(n);
    for(int& i: s) std::cin >> i;

    std::vector<std::vector<int64_t>> dist(n, std::vector<int64_t>(1001, inf));
    std::vector<std::vector<bool>> vis(n, std::vector<bool>(1001, false));
    
    dist[0][s[0]] = 0;
    std::priority_queue<std::array<int64_t, 3>> q;
    q.push({0, 0, s[0]});
    while(!q.empty()) {
        int u = q.top()[1], k = q.top()[2];
        q.pop();
        if(vis[u][k] || dist[u][k] == inf) continue;
        vis[u][k] = true;
        for(auto x: adj[u]) {
            int v = x.first, w = x.second;
            int c = std::min(s[v], k);
            if(dist[v][c] > dist[u][k] + 1LL * w * k) {
                dist[v][c] = dist[u][k] + 1LL * w * k;
                q.push({-dist[v][c], v, c});
            }
        }
    }
    int64_t ans = inf;
    for(int k = 1; k <= 1000; ++k) 
        ans = std::min(ans, dist[n - 1][k]);
    std::cout << ans << "\n";
}   
 
int main() {
    std::ios_base::sync_with_stdio(0);std::cin.tie(0);
    int t = 1; std::cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1915F
Editorial Content:
1915F - Приветствия
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
 
typedef __gnu_pbds::tree<int, __gnu_pbds::null_type, less<int>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> ordered_set;
 
int t, n;
 
vector<pair<int, int>> arr;
 
long long ans;
 
ordered_set st;
 
void solve(){
    cin >> n;
 
    arr.assign(n, {});
 
    for(auto &p : arr) cin >> p.second >> p.first;
 
    sort(arr.begin(), arr.end());
 
    ans = 0;
    st.clear();
 
    for(auto p : arr){
        ans += st.size() - st.order_of_key(p.second);
 
        st.insert(p.second);
    }
 
    cout << ans << "\n";
}
 
int main(){
    ios_base::sync_with_stdio(false);cin.tie(NULL);
 
    cin >> t;
 
    while(t--){
        solve();
    }
}
--------------------------------------------------
Problem ID: 1915E
Editorial Content:
1915E - Романтические стаканы
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
#define ll long long
 
#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()

void solve() {
    int n; cin >> n;
    vector<int> a(n);
    for(int i = 0; i < n; ++i) cin >> a[i];
    map<ll, ll> m;
    ll s = 0;
    m[0] = 1;
    for(int i = 0; i < n; ++i) {
        a[i] *= ((i % 2) ? -1 : 1);
        s += a[i];
        if(m[s]) {
            cout << "YES\n";
            return;
        }
        ++m[s];
    }
    cout << "NO\n";
}
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1915D
Editorial Content:
1915D - Нестандартная обработка языка
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

const int MAX = 200'007;
const int MOD = 1'000'000'007;

void solve() {
	int n;
	cin >> n;
	string s;
	cin >> s;
	string res = "";
	while (!s.empty()) {
		int x;
		if (s.back() == 'a' || s.back() == 'e') {x = 2;}
		else {x = 3;}
		
		while (x--) {
			res += s.back();
			s.pop_back();
		}
		res += '.';
	}
	res.pop_back();
	reverse(res.begin(), res.end());
	cout << res << '\n';
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1915C
Editorial Content:
1915C - Можно ли построить квадрат?
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
#define ll long long
 
#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()

bool is_square(ll x) {
    ll l = 1, r = 1e9;
    while(l <= r) {
        ll mid = l + (r - l) / 2;
        if(mid * mid == x) return true;
        if(mid * mid > x) r = mid - 1;
        else l = mid + 1;
    }      
    return false;  
}
void solve() {
    ll n; cin >> n;
    ll s = 0;
    for(int i = 0, x; i < n; ++i) {
        cin >> x; s += x;
    }
    if(is_square(s)) cout << "YES\n";
    else cout << "NO\n";
}
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1915B
Editorial Content:
1915B - Не совсем латинский квадрат
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

const int MAX = 200'007;
const int MOD = 1'000'000'007;

void solve() {
	int cnt[3] = {};
	for (int i = 0; i < 9; i++) {
		char c;
		cin >> c;
		if (c != '?') {cnt[c - 'A']++;}
	}	
	for (int i = 0; i < 3; i++) {
		if (cnt[i] < 3) {cout << (char)('A' + i) << '\n';}
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1915A
Editorial Content:
1915A - Выброс
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

const int MAX = 200'007;
const int MOD = 1'000'000'007;

void solve() {
	int a, b, c;
	cin >> a >> b >> c;
	cout << (a ^ b ^ c) << '\n';
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1914G2
Editorial Content:
1914G2 - Light Bulbs (Hard Version)
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
const int MOD = 998244353;
 
int add(int x, int y)
{
	return (((x + y) % MOD) + MOD) % MOD;
}
 
int mul(int x, int y)
{
	return (x * 1ll * y) % MOD;
}
 
mt19937_64 rnd(98275314);
 
long long gen()
{
	long long x = 0;
	while(x == 0)
		x = rnd();
	return x;
}
 
vector<int> c;
vector<int> g;
 
int process_block(int l, int r)
{
	int ans = 0;
	while(l < r)
	{
		if(g[l] != -1 && g[l] < r)
			l = g[l];
		else
		{
			ans++;
			l++;
		}
	}
	return ans;
}
 
void solve()
{
	int n;
	scanf("%d", &n);
	int size = 0, cnt = 1;
	c.resize(n * 2);
	g.resize(n * 2, -1);
	for(int i = 0; i < 2 * n; i++)
	{
		scanf("%d", &c[i]);
		--c[i];
	}
	
	vector<long long> val(n);
	for(int i = 0; i < n; i++) val[i] = gen();
	
	map<long long, int> last;
	long long cur = 0;
	last[0] = 0;
	for(int i = 0; i < n * 2; i++)
	{
		cur ^= val[c[i]];
		if(cur == 0)
		{
			size++;
			cnt = mul(cnt, process_block(last[0], i + 1));
			last.clear();
		}
		else if(last.count(cur))
		{
			g[last[cur]] = i + 1;
		}
		last[cur] = i + 1;
	}
	
	printf("%d %d\n", size, cnt);
	c.clear();
	g.clear();
}
 
int main()
{
	int t;
	scanf("%d", &t);
	for(int i = 0; i < t; i++) solve();
}
--------------------------------------------------
Problem ID: 1914G1
Editorial Content:
1914G1 - Light Bulbs (Easy Version)
--------------------------------------------------
Problem ID: 1914F
Editorial Content:
1914F - Programming Competition
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 222222;
 
int n;
int sz[N];
vector<int> g[N];
 
void init(int v) {
  sz[v] = 1;
  for (int u : g[v]) {
    init(u);
    sz[v] += sz[u];
  }
}
 
int calc(int v, int k) {
  int tot = 0, mx = -1;
  for (int u : g[v]) {
    tot += sz[u];
    if (mx == -1 || sz[mx] < sz[u]) mx = u;
  }
  if (tot == 0) return 0;
  if (sz[mx] - k <= tot - sz[mx])
    return (tot - k) / 2;
  int add = tot - sz[mx];
  return add + calc(mx, max(0, k + add - 1));
}
 
int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    cin >> n;
    for (int i = 0; i < n; ++i) g[i].clear();
    for (int i = 1; i < n; ++i) {
      int p; cin >> p;
      g[p - 1].push_back(i);
    }
    init(0);
    cout << calc(0, 0) << '\n';
  }
}
--------------------------------------------------
Problem ID: 1914E2
Editorial Content:
1914E2 - Game with Marbles (Hard Version)
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>
 
using namespace std;
 
#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define sz(a) int((a).size())
 
typedef long long li;
 
// S = sum a_i - sum b_i
// if Bob made all steps: then S = 0 - sum (b_i - 1)
// each Alice step: S += (a_i - 1) + (b_i - 1) i. e. the bigger (a_i + b_i) the better
 
int n;
vector<int> a, b;
 
inline bool read() {
	if(!(cin >> n))
		return false;
	a.resize(n);
	b.resize(n);
	fore (i, 0, n)
		cin >> a[i];
	fore (i, 0, n)
		cin >> b[i];
	return true;
}
 
inline void solve() {
	vector<int> ids(n);
	iota(ids.begin(), ids.end(), 0);
	
	sort(ids.begin(), ids.end(), [&](int i, int j) {
		return a[i] + b[i] > a[j] + b[j];
	});
	
	li S = 0;
	fore (i, 0, n) {
		if (i & 1)
			S -= b[ids[i]] - 1;
		else
			S += a[ids[i]] - 1;
	}
	cout << S << endl;
}
 
int main() {
#ifdef _DEBUG
	freopen("input.txt", "r", stdin);
	int tt = clock();
#endif
//	ios_base::sync_with_stdio(false);
//	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(15);
	int t;
	cin >> t;
	for(int i = 0; i < t; i++)
	{
	if(read()) {
		solve();
		
#ifdef _DEBUG
		cerr << "TIME = " << clock() - tt << endl;
		tt = clock();
#endif
	}
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1914E1
Editorial Content:
1914E1 - Game with Marbles (Easy Version)
--------------------------------------------------
Problem ID: 1914D
Editorial Content:
1914D - Three Activities
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	n = int(input())
	a = list(map(int, input().split()))
	b = list(map(int, input().split()))
	c = list(map(int, input().split()))
	
	def get_best3(a):
		mx1, mx2, mx3 = -1, -1, -1
		for i in range(len(a)):
			if mx1 == -1 or a[i] > a[mx1]:
				mx3 = mx2
				mx2 = mx1
				mx1 = i
			elif mx2 == -1 or a[i] > a[mx2]:
				mx3 = mx2
				mx2 = i
			elif mx3 == -1 or a[i] > a[mx3]:
				mx3 = i
		return (mx1, mx2, mx3)
	
	ans = 0
	for x in get_best3(a):
		for y in get_best3(b):
			for z in get_best3(c):
				if x != y and x != z and y != z:
					ans = max(ans, a[x] + b[y] + c[z])
	print(ans)
--------------------------------------------------
Problem ID: 1914C
Editorial Content:
1914C - Quests
Tutorial
Tutorial is loading...
Solution (Neon)
fun main() = repeat(readLine()!!.toInt()) {
  val (n, k) = readLine()!!.split(" ").map { it.toInt() }
  val a = readLine()!!.split(" ").map { it.toInt() }
  val b = readLine()!!.split(" ").map { it.toInt() }
  var (res, sum, mx) = intArrayOf(0, 0, 0)
  for (i in 0 until minOf(n, k)) {
    sum += a[i]
    mx = maxOf(mx, b[i])
    res = maxOf(res, sum + mx * (k - i - 1))
  }
  println(res)
}
--------------------------------------------------
Problem ID: 1914B
Editorial Content:
1914B - Preparing for the Contest
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
void solve()
{
	int n, k;
	cin >> n >> k;
	vector<int> a(n);
	for(int i = 0; i < n; i++) a[i] = n - i;
	reverse(a.end() - k - 1, a.end());
	for(int i = 0; i < n; i++)
	{
		if(i) cout << " ";
		cout << a[i];
	}
	cout << endl;
}
 
int main()
{
	int t;
	cin >> t;
	for(int i = 0; i < t; i++)
		solve();
	return 0;
}
--------------------------------------------------
Problem ID: 1914A
Editorial Content:
1914A - Problemsolving Log
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
    n = int(input())
    s = input()
    print(sum([s.count(chr(ord('A') + i)) >= i + 1 for i in range(26)]))
--------------------------------------------------
Problem ID: 1913F
Editorial Content:
1913F - Palindromic Problem
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)
#define x first
#define y second

using namespace std;

struct sparse_table {
    vector<vector<int>> st;
    vector<int> pw;
    
    sparse_table() {}
    
    sparse_table(const vector<int> &a) {
        int n = a.size();
        int logn = 32 - __builtin_clz(n);
        st.resize(logn, vector<int>(n));
        forn(i, n)
            st[0][i] = a[i];
        for (int j = 1; j < logn; ++j) forn(i, n) {
            st[j][i] = st[j - 1][i];
            if (i + (1 << (j - 1)) < n)
                st[j][i] = min(st[j][i], st[j - 1][i + (1 << (j - 1))]);
        }
        pw.resize(n + 1);
        pw[0] = pw[1] = 0;
        for (int i = 2; i <= n; ++i)
            pw[i] = pw[i >> 1] + 1;
    }
    
    int get(int l, int r) {
        if (l >= r) return 1e9;
        int len = pw[r - l];
        return min(st[len][l], st[len][r - (1 << len)]);
    }
};

struct suffix_array {
    vector<int> c, pos;
    vector<pair<pair<int, int>, int>> p, nw;
    vector<int> cnt;
    int n;
    
    void radix_sort(int max_al) {
        cnt.assign(max_al, 0);
        forn(i, n) ++cnt[p[i].x.y];
        for (int i = 1; i < max_al; ++i) cnt[i] += cnt[i - 1];
        nw.resize(n);
        forn(i, n) nw[--cnt[p[i].x.y]] = p[i];
        cnt.assign(max_al, 0);
        forn(i, n) ++cnt[nw[i].x.x];
        for (int i = 1; i < max_al; ++i) cnt[i] += cnt[i - 1];
        for (int i = n - 1; i >= 0; --i) p[--cnt[nw[i].x.x]] = nw[i];
    }
    
    vector<int> lcp;
    sparse_table st;
    
    int get_lcp(int l, int r) {
        l = c[l], r = c[r];
        if (l > r) swap(l, r);
        return st.get(l, r);
    }
    
    suffix_array(const string &s) {
        n = s.size();
        c = vector<int>(s.begin(), s.end());
        int max_al = *max_element(c.begin(), c.end()) + 1;
        p.resize(n);
        for (int k = 1; k < n; k <<= 1) {
            for (int i = 0, j = k; i < n; ++i, j = (j + 1 == n ? 0 : j + 1))
                p[i] = make_pair(make_pair(c[i], c[j]), i);
            radix_sort(max_al);
            c[p[0].y] = 0;
            for (int i = 1; i < n; ++i) c[p[i].y] = c[p[i - 1].y] + (p[i].x != p[i - 1].x);
            max_al = c[p.back().y] + 1;
        }
        lcp.resize(n);
        int l = 0;
        forn(i, n) {
            l = max(0, l - 1);
            if (c[i] == n - 1)
                continue;
            while (i + l < n && p[c[i] + 1].y + l < n && s[i + l] == s[p[c[i] + 1].y + l])
                ++l;
            lcp[c[i]] = l;
        }
        pos.resize(n);
        forn(i, n)
            pos[i] = p[i].y;
        st = sparse_table(lcp);
    }
};

int main() {
    string s;
    int n;
    cin >> n;
    cin >> s;
    string t = s;
    reverse(t.begin(), t.end());
    auto sa = suffix_array(s + "#" + t + "$");
    vector<vector<int>> ev0(n), ev1(n);
    long long base = 0;
    vector<long long> dt(n + 2);
    vector<int> d1(n);
    forn(i, n){
        int len0 = sa.get_lcp(i, 2 * n - i + 1);
        base += len0;
        dt[i - len0] += 1;
        dt[i] -= 1;
        dt[i + 1] -= 1;
        dt[i + len0 + 1] += 1;
        if (i - len0 - 1 >= 0 && i + len0 < n){
            ev0[i - len0 - 1].push_back(i);
            ev0[i + len0].push_back(i);
        }
        int len1 = sa.get_lcp(i, 2 * n - i);
        d1[i] = len1;
        dt[i - len1 + 1] += 1;
        dt[i + 1] -= 2;
        dt[i + len1 + 1] += 1;
        base += len1;
        if (i - len1 >= 0 && i + len1 < n){
            ev1[i - len1].push_back(i);
            ev1[i + len1].push_back(i);
        }
    }
    vector<long long> dx(n + 1);
    long long curt = 0, val = 0;
    forn(i, n){
        curt += dt[i];
        val += curt;
        dx[i] = val;
    }
    long long ans = base;
    int pos = -1, nc = -1;
    bool gr = false;
    forn(i, n) forn(c, 26) if (c != s[i] - 'a'){
        long long cur = base;
        for (int j : ev0[i]){
            if (j <= i && c == s[2 * j - i - 1] - 'a')
                cur += 1 + sa.get_lcp(i + 1, 2 * n - (2 * j - i - 2));
            else if (j > i && c == s[2 * j - i - 1] - 'a')
                cur += 1 + sa.get_lcp(2 * j - i, 2 * n - (i - 1));
        }
        for (int j : ev1[i]){
            if (c != s[2 * j - i] - 'a') continue;
            if (j < i)
                cur += 1 + sa.get_lcp(i + 1, 2 * n - (2 * j - i - 1));
            else
                cur += 1 + sa.get_lcp(2 * j - i + 1, 2 * n - (i - 1));
        }
        cur += d1[i];
        cur -= dx[i];
        bool upd = false;
        if (cur > ans){
            upd = true;
        }
        else if (cur == ans){
            if (c < s[i] - 'a'){
                if (pos == -1 || gr)
                    upd = true;
            }
            else{
                if (pos < i && gr)
                    upd = true;
            }
        }
        if (upd){
            ans = cur;
            pos = i;
            nc = c;
            gr = c > s[i] - 'a';
        }
    }
    cout << ans << endl;
    if (pos != -1) s[pos] = nc + 'a';
    cout << s << endl;
    return 0;
}
--------------------------------------------------
Problem ID: 1913E
Editorial Content:
1913E - Matrix Problem
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

const int N = 111;

struct edge
{
    int y, c, w, f;
    edge() {};
    edge(int y, int c, int w, int f) : y(y), c(c), w(w), f(f) {};
};

vector<edge> e;
vector<int> g[N];

int rem(int x)
{
    return e[x].c - e[x].f;
}

void add_edge(int x, int y, int c, int w)
{
    g[x].push_back(e.size());
    e.push_back(edge(y, c, w, 0));
    g[y].push_back(e.size());
    e.push_back(edge(x, 0, -w, 0));
}

int n, m, s, t, v;

pair<int, long long> MCMF()
{
    int flow = 0;
    long long cost = 0;
    while(true)
    {
        vector<long long> d(v, (long long)(1e18));
        vector<int> p(v, -1);
        vector<int> pe(v, -1);
        queue<int> q;
        vector<bool> inq(v);
        q.push(s);
        inq[s] = true;
        d[s] = 0;
        while(!q.empty())
        {
            int k = q.front();
            q.pop();
            inq[k] = false;
            for(auto ei : g[k])
            {
                if(rem(ei) == 0) continue;
                int to = e[ei].y;
                int w = e[ei].w;
                if(d[to] > d[k] + w)
                {
                    d[to] = d[k] + w;
                    p[to] = k;
                    pe[to] = ei;
                    if(!inq[to])
                    {
                        inq[to] = true;
                        q.push(to);
                    }
                }
            }
        }
        if(p[t] == -1) break;
        flow++;
        cost += d[t];
        int cur = t;
        while(cur != s)
        {
            e[pe[cur]].f++;
            e[pe[cur] ^ 1].f--;
            cur = p[cur];
        }
    }
    return make_pair(flow, cost);
}

int get_sum(const vector<int>& v)
{
    int sum = 0;
    for(auto x : v) sum += x;
    return sum;
}

int main()
{
    cin >> n >> m;
    s = n + m;
    t = n + m + 1;
    v = n + m + 2;
    int sum_matrix = 0;
    vector<int> A(n), B(m);
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
        {
            int x;
            cin >> x;
            sum_matrix += x;
            if(x == 1)
                add_edge(i, j + n, 1, 0);
            else
                add_edge(i, j + n, 1, 1);
        }
    for(int i = 0; i < n; i++)
    {
        cin >> A[i];
        add_edge(s, i, A[i], 0);
    }
    for(int i = 0; i < m; i++) 
    {
        cin >> B[i];
        add_edge(i + n, t, B[i], 0);
    }
    
    auto res = MCMF();
    if(res.first != get_sum(A) || res.first != get_sum(B))
        cout << -1 << endl;
    else
        cout << sum_matrix - res.first + res.second * 2 << endl;
}
--------------------------------------------------
Problem ID: 1913D
Editorial Content:
1913D - Array Collapse
Tutorial
Tutorial is loading...
Solution (Roms)
#include <bits/stdc++.h>

using namespace std;

const int MOD = 998244353;

int normalize(long long x) {
    x %= MOD;
    if (x < 0) x += MOD;
    return x;
}

int main() {
    int t;
    cin >> t;
    for (int tc = 0; tc < t; ++tc) {
        int n;
        cin >> n;
        vector <int> a(n);
        vector <int> nextMin(n);
        vector <int> dpSum(n + 2);
        vector <int> dpNext(n);
        for (int i = 0; i < n; ++i)
            cin >> a[i];
        
        stack <int> stMin;
        nextMin[n - 1] = n;
        dpSum[n] = 1;
        for (int pos = n - 1; pos >= 0; --pos) {
            while(!stMin.empty() && a[stMin.top()] > a[pos])
                stMin.pop();
            nextMin[pos] = stMin.empty() ? n : stMin.top();
            stMin.push(pos);
            
            int nxtPos = nextMin[pos];
            int dpPos = normalize(dpSum[pos + 1] - dpSum[nxtPos + 1]);
            if (nxtPos != n) {
                dpPos = normalize(dpPos + dpNext[nxtPos]);
                dpNext[pos] = normalize(dpSum[nxtPos] - dpSum[nxtPos + 1] + dpNext[nxtPos]);
            }
            dpSum[pos] = normalize(dpPos + dpSum[pos + 1]);
            
            //cout << pos << ' ' << nxtPos << ' ' << dpPos << endl;
        }
        
        int res = 0;
        int mn = a[0];
        for(int i = 0; i < n; ++i) {
            mn = min(mn, a[i]);
            if (a[i] == mn) {
                res = normalize(res + dpSum[i] - dpSum[i + 1]);
            }
        }
        cout << res << endl;
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1913C
Editorial Content:
1913C - Game with Multiset
Tutorial
Tutorial is loading...
Solution (awoo)
from sys import stdin, stdout

LOG = 30
cnt = [0 for i in range(LOG)]
ans = []
for _ in range(int(stdin.readline())):
    t, v = map(int, stdin.readline().split())
    if t == 1:
        cnt[v] += 1
    else:
        nw = 0
        for i in range(LOG):
            r = (v % (2 << i)) // (1 << i)
            if r > nw + cnt[i]:
                ans.append(0)
                break
            v -= r
            nw = (nw + cnt[i] - r) // 2
        else:
            ans.append(nw >= (v >> 30))
stdout.write('\n'.join(["YES" if x else "NO" for x in ans]))
--------------------------------------------------
Problem ID: 1913B
Editorial Content:
1913B - Swap and Delete
Tutorial
Tutorial is loading...
Solution (adedalic)
for _ in range(int(input())):
    s = input()
    cnt = [0, 0]
    for i in range(len(s)):
        cnt[int(s[i])] += 1
    for i in range(len(s) + 1):
        if (i == len(s) or cnt[1 - int(s[i])] == 0):
            print(len(s) - i)
            break
        cnt[1 - int(s[i])] -= 1
--------------------------------------------------
Problem ID: 1913A
Editorial Content:
1913A - Rating Increase
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
    ab = input()
    for i in range(1, len(ab)):
        if ab[i] != '0' and int(ab[:i]) < int(ab[i:]):
            print(ab[:i], ab[i:])
            break
    else:
        print(-1)
--------------------------------------------------
Problem ID: 1912L
Editorial data not available.
--------------------------------------------------
Problem ID: 1912K
Editorial data not available.
--------------------------------------------------
Problem ID: 1912J
Editorial data not available.
--------------------------------------------------
Problem ID: 1912I
Editorial data not available.
--------------------------------------------------
Problem ID: 1912H
Editorial data not available.
--------------------------------------------------
Problem ID: 1912G
Editorial data not available.
--------------------------------------------------
Problem ID: 1912F
Editorial data not available.
--------------------------------------------------
Problem ID: 1912E
Editorial data not available.
--------------------------------------------------
Problem ID: 1912D
Editorial data not available.
--------------------------------------------------
Problem ID: 1912C
Editorial data not available.
--------------------------------------------------
Problem ID: 1912B
Editorial data not available.
--------------------------------------------------
Problem ID: 1912A
Editorial data not available.
--------------------------------------------------
Problem ID: 1910J
Editorial Content:
1910J - Two Colors
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
import kotlin.math.abs

fun main() {
    val n = readInt()
    val c = readInts()
    val g = List(n) { mutableListOf<Pair<Int, Int>>() }
    repeat(n - 1) {
        val (a, b, w) = readInts()
        g[a - 1].add(b - 1 to w)
        g[b - 1].add(a - 1 to w)
    }
    val size = List(2) { IntArray(n) }
    var ans = 0L
    fun dfs(v: Int, p: Int) {
        size[c[v]][v] = 1
        for ((u, w) in g[v]) {
            if (u != p) {
                dfs(u, v)
                size[0][v] += size[0][u]
                size[1][v] += size[1][u]
                ans += abs(size[0][u] - size[1][u]) * w.toLong()
            }
        }
    }
    dfs(0, 0)
    println(ans)
}

private fun readInt() = readln().toInt()
private fun readLongs() = readStrings().map { it.toLong() }
private fun readStrings() = readln().split(" ")
private fun readInts() = readStrings().map { it.toInt() }
--------------------------------------------------
Problem ID: 1910I
Editorial Content:
1910I - Inverse Problem
Tutorial
Tutorial is loading...
Solution (awoo)
val MOD = 998244353

fun main() {
	val (n, k, c) = readLine()!!.split(' ').map { it.toInt() }
	val t = readLine()!!
	val cnt = n / k + 1
	val dp = Array(2) { IntArray(cnt) {0} }
	val pw = IntArray(cnt) {1}
	dp[0][0] = 1
	for (ii in 0 until n % k) {
		val i = ii and 1
		val ni = i xor 1
		var sum = 0
		val cur = c - (t[ii].toInt() - 'a'.toInt()) - 1
		var pr = 1
		for (j in 1 until cnt) {
			pw[j] = (pw[j - 1] * (cur + 1).toLong() % MOD).toInt()
		}
		for (j in 0 until cnt) {
			sum = ((sum * cur.toLong() + pr * dp[i][j].toLong()) % MOD).toInt()
			pr = (pr * c.toLong() % MOD).toInt()
			dp[ni][j] = (sum * pw[cnt - j - 1].toLong() % MOD).toInt()
		}
	}
	var ans = 0
	for (i in 0 until cnt) {
		ans = (ans + dp[n % k % 2][i]) % MOD
	}
	for (i in 0 until n) {
		if (i % k >= n % k) {
			ans = (ans * c.toLong() % MOD).toInt()
		}
	}
	println(ans)
}
--------------------------------------------------
Problem ID: 1910H
Editorial Content:
1910H - Sum of Digits of Sums
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
private fun digitSum(a: Int) = a.toString().toCharArray().sumOf { it.digitToInt() }
private fun List<Int>.lowerBound(x: Int) = binarySearch { if (it < x) -1 else 1 }.inv()
fun main() {
    val n = readInt()
    val a = readInts()
    val pw10 = buildList<Int> {
        add(1)
        repeat(9) { add(last() * 10) }
        removeAt(0)
    }
    val d = pw10.map { p -> a.map { it % p }.sorted() }
    val ds = a.sumOf { digitSum(it) }
    println(a.map { x ->
        ds + n * digitSum(x) - 9 * pw10.indices.sumOf {
            n - d[it].lowerBound(pw10[it] - (x % pw10[it]))
        }
    }.joinToString(" "))
}

private fun readInt() = readln().toInt()
private fun readLongs() = readStrings().map { it.toLong() }
private fun readStrings() = readln().split(" ")
private fun readInts() = readStrings().map { it.toInt() }
--------------------------------------------------
Problem ID: 1910G
Editorial Content:
1910G - Pool Records
Tutorial
Tutorial is loading...
Solution (adedalic)
fun main() {
    repeat(readln().toInt()) {
        val n = readln().toInt()
        val t = readln().split(' ').map { it.toLong() }

        fun Long.genMoments() = List(n) { (it + 1) * this }

        val sPeriod = t[0]
        val lPeriod = t.firstOrNull { it % sPeriod != 0L }

        val sMoments = sPeriod.genMoments()
        val lMoments = lPeriod?.genMoments() ?: listOf()

        val req = sMoments.union(lMoments).sorted().take(n)
        println(if (req == t) "VALID" else "INVALID")
    }
}
--------------------------------------------------
Problem ID: 1910F
Editorial Content:
1910F - Build Railway Stations
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
fun main() {
    repeat(readInt()) {
        val (n, k) = readInts()
        val g = List(n) { mutableListOf<Int>() }
        repeat(n - 1) {
            val (a, b) = readInts().map { it - 1 }
            g[a].add(b)
            g[b].add(a)
        }
        val size = IntArray(n)
        fun dfs(v: Int, p:Int) : Int {
            size[v] = 1 + g[v].sumOf { if (it == p) 0 else dfs(it, v) }
            return size[v]
        }
        dfs(0, 0)
        val ns = size.map { it.toLong() * (n - it) }.sortedDescending()
        println(ns.subList(0, k - 1).sum() + ns.subList(k - 1, ns.size).sum() * 2)
    }
}

private fun readInt() = readln().toInt()
private fun readLongs() = readStrings().map { it.toLong() }
private fun readStrings() = readln().split(" ")
private fun readInts() = readStrings().map { it.toInt() }
--------------------------------------------------
Problem ID: 1910E
Editorial Content:
1910E - Maximum Sum Subarrays
Tutorial
Tutorial is loading...
Solution 1 (Neon)
fun main() = repeat(readLine()!!.toInt()) {
  val n = readLine()!!.toInt()
  val a = readLine()!!.split(" ").map { it.toLong() }
  val b = readLine()!!.split(" ").map { it.toLong() }
  val dp = Array(3) { LongArray(3) { 0 } }
  for ((x, y) in a zip b) {
    for (i in 0..2) for (j in 0..2) {
      dp[i][j] += maxOf(
      	(if (i == 1) x else 0) + (if (j == 1) y else 0),
      	(if (i == 1) y else 0) + (if (j == 1) x else 0)
      );
    }
    for (i in 0..2) for (j in 0..2) {
      if (i < 2) dp[i + 1][j] = maxOf(dp[i + 1][j], dp[i][j]);
      if (j < 2) dp[i][j + 1] = maxOf(dp[i][j + 1], dp[i][j]);
    }
  }
  println(dp[2][2]);
}
Solution 2 (PavelKunyavskiy)
fun best(a: List<Int>, k: Int): Long {
    val r = LongArray(4)
    var sum = 0L
    for (v in a) {
        sum += v
        r[0] = maxOf(r[0], -sum)
        r[1] = maxOf(r[1], r[0] + sum)
        r[2] = maxOf(r[2], r[1] - sum)
        r[3] = maxOf(r[3], r[2] + sum)
    }
    return r[2 * k - 1]
}

fun main() {
    repeat(readInt()) {
        readInt()
        val a = readInts()
        val b = readInts()
        val mins = a.zip(b).map { minOf(it.first, it.second) }
        val maxs = a.zip(b).map { maxOf(it.first, it.second) }
        println(maxOf(best(mins, 1) + best(maxs, 1), best(maxs, 2)))
    }
}

private fun readInt() = readln().toInt()
private fun readLongs() = readStrings().map { it.toLong() }
private fun readStrings() = readln().split(" ")
private fun readInts() = readStrings().map { it.toInt() }
--------------------------------------------------
Problem ID: 1910D
Editorial Content:
1910D - Remove and Add
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
private fun solve() : Boolean {
    val n = readInt()
    val a = readInts().toIntArray()
    var dropped = false
    for (i in 1 until n) {
        if (a[i] == a[i-1]) {
            a[i]++
        } else if (a[i] < a[i-1]) {
            if (dropped) return false
            dropped = true
            if (i != 1) {
                when {
                    a[i-2] > a[i] -> a[i] = a[i-1]
                    a[i-2] == a[i] -> a[i]++
                    else -> {}
                }
            }
        }
    }
    return true
}
fun main() {
    repeat(readInt()) {
        println(if (solve()) "YES" else "NO")
    }
}

private fun readInt() = readln().toInt()
private fun readLongs() = readStrings().map { it.toLong() }
private fun readStrings() = readln().split(" ")
private fun readInts() = readStrings().map { it.toInt() }
--------------------------------------------------
Problem ID: 1910C
Editorial Content:
1910C - Poisonous Swamp
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
fun main() {
    repeat(readInt()) {
        readInt()
        val s = readln() + '.' + readln()
        println(s.split(".").sumOf { maxOf(0, it.length - 1) })
    }
}
 
private fun readInt() = readln().toInt()
--------------------------------------------------
Problem ID: 1910B
Editorial Content:
1910B - Security Guard
Tutorial
Tutorial is loading...
Solution (Neon)
fun main() = repeat(readLine()!!.toInt()) {
  val s = readLine()!!.toCharArray()
  val x = s.indexOf('-').takeIf { it >= 0 } ?: 0
  val y = s.lastIndexOf('+').takeIf { it >= x } ?: x
  s[x] = s[y].also { s[y] = s[x] }
  val bal = s.runningFold(0) { cur, c -> cur + if (c == '-') -1 else 1 }
  println(if (bal.min() == 0) "$$${x + 1} $$${y + 1}" else "-1")
}
--------------------------------------------------
Problem ID: 1910A
Editorial Content:
1910A - Username
Tutorial
Tutorial is loading...
Solution (PavelKunyavskiy)
fun main() {
    repeat(readInt()) {
        println(readln().dropLastWhile { it == '0' }.dropLast(1))
    }
}

private fun readInt() = readln().toInt()
--------------------------------------------------
Problem ID: 1909I
Editorial Content:
1909I - Short Permutation Problem
Hint 1
Insert the elements into the permutation in some comfortable order.
Hint 2
Suppose $$$m$$$ is even. You can insert elements in the order $$$[m/2, m/2 - 1, m/2 + 1, m/2 - 2, \dots]$$$.
Hint 3
You can solve for a single $$$m$$$ with DP. Can you calculate the DP for multiple $$$m$$$ simultaneously?
Hint 4
The first part of the DP (where you insert both "small" and "big" elements) is the same for each $$$m$$$ (but with a different length), and for the second part (where you only insert "small" elements) you don't need DP.
Hint 5
The second part of the DP can be replaced with combinatorics formulas.
Hint 6
Binomials are compatible with NTT.
Solution
Let's solve for a single $$$m$$$. Suppose $$$m$$$ is even. Start from an empty array, and insert the elements in the order $$$[m/2, m/2 - 1, m/2 + 1, m/2 - 2, \dots]$$$. At any moment, all the elements are concatenated, and you can insert new elements either at the beginning, at the end or between two existing elements.
When you insert an element $$$\geq m/2$$$, the sum with any of the previous inserted elements is $$$\geq m$$$.
Otherwise, the sum is $$$< m$$$.
So you can calculate $$$dp_{i,j} =$$$ number of ways to insert the first $$$i$$$ elements (of $$$[m/2, m/2 - 1, m/2 + 1, m/2 - 2, \dots]$$$) and make $$$j$$$ "good" pairs (with sum $$$\geq m$$$).
You can split the ordering $$$[m/2, m/2 - 1, m/2 + 1, m/2 - 2, \dots]$$$ into two parts:
small and big elements alternate;
there are only small elements.
For the second part, you don't need DP. Suppose you have already inserted $$$i$$$ elements, and there are $$$j$$$ good pairs, but when you will have inserted all elements you want $$$k$$$ good pairs. The number of ways to insert the remaining elements can be computed with combinatorics in $$$O(1)$$$ after precomputing factorials and inverses (you have to choose which pairs to break and use stars and bars; we skip exact formulas because they are relatively easy to find).
If you rearrange the factorials correctly, you can get that all the answers for a fixed $$$m$$$ can be computed by multiplying two polynomials, one of which contains the $$$dp_{i,j}$$$, where $$$i$$$ is equal to the length of the "alternating" prefix. NTT is fast enough.
Complexity: $$$O(n^2 \log n)$$$
--------------------------------------------------
Problem ID: 1909H
Editorial Content:
1909H - Parallel Swaps Sort
Hint 1
Find a strategy which is as simple and "easy to handle" as possible.
Hint 2
Only perform operations such that all swapped pairs have $$$a_i > a_{i+1}$$$. Let's call such subarrays "swappable".
Hint 3
First, for each $$$i$$$ from left to right, do the operation on $$$[j, i]$$$, where $$$j$$$ is the minimum index such that $$$[j, i]$$$ is swappable.
Hint 4
Repeat the same algorithm from right to left.
Hint 5
After Hints 3 and 4, the array is sorted. Prove it (it will be useful).
Hint 6
Assign $$$\texttt{B}$$$ to the indices $$$i$$$ such that $$$a_i < a_{i-1}$$$ and $$$\texttt{A}$$$ to the other indices. During the process in Hint 3, after the operation on index $$$i$$$, which properties do $$$\texttt{A}$$$, $$$\texttt{B}$$$ have in the prefix $$$[1, i]$$$?
Hint 7
Answer to Hint 6:
the values of type $$$\texttt{A}$$$ are increasing;
there are no two consecutive elements of type $$$\texttt{B}$$$.
Hint 8
The rest of the proof (i.e., what happens during the process in Hint 4) is relatively easy.
Now let's find an efficient implementation. We have to use the properties in Hint 7.
Hint 9
You have to find the longest $$$\texttt{AB} \dots \texttt{AB}$$$ ending in position $$$i$$$, and perform the operation on it. What happens during the operation?
Hint 10
$$$\texttt{A}$$$ will always remain $$$\texttt{A}$$$. For each $$$\texttt{B}$$$, you have to detect when it becomes $$$\texttt{A}$$$.
Hint 11
For each $$$\texttt{B}$$$, you can precompute the number of moves needed to make it $$$\texttt{A}$$$.
Hint 12
For example, you can use a segment tree with the following information: the type of each element, the positions of the elements of type $$$\texttt{B}$$$, and the number of moves required for each $$$\texttt{B}$$$ to become $$$\texttt{A}$$$.
Solution
Let's only perform operations such that all swapped pairs have $$$a_i > a_{i+1}$$$. Let's call such subarrays "swappable".
First, for each $$$i$$$ from left to right, do the operation on $$$[j, i]$$$, where $$$j$$$ is the minimum index such that $$$[j, i]$$$ is swappable (let's call it "operation $$$1.i$$$").
Then, for each $$$i$$$ from right to left, do the operation on $$$[j, i]$$$, where $$$j$$$ is the minimum index such that $$$[j, i]$$$ is swappable (let's call it "operation $$$2.i$$$").
After these operations, the array is sorted. Let's prove it.
Assign $$$\texttt{B}$$$ to the indices $$$i$$$ such that $$$a_i < a_{i-1}$$$ and $$$\texttt{A}$$$ to the other indices. After operation $$$1.i$$$, only assign letters in the prefix $$$[1, i]$$$ and ignore the other elements. During the operations $$$2.i$$$, assign letters to all the elements.
Most of the following proofs are by induction. After the operation $$$1.i$$$ (supposing the properties were true after the operation $$$1.(i-1)$$$):
An element of type $$$\texttt{A}$$$ will always remain of type $$$\texttt{A}$$$. Proof: the only elements of type $$$\texttt{A}$$$ whose previous element changes are the ones in the subarray $$$[j, i]$$$, which are swapped with a smaller element of type $$$\texttt{B}$$$.
There are no two consecutive elements of type $$$\texttt{B}$$$. Proof: if you swap $$$[j, i]$$$, $$$p_{j-1}$$$ (if it exists) must be of type $$$\texttt{A}$$$ (otherwise $$$[j-2, i]$$$ is swappable).
The elements of type $$$\texttt{A}$$$ are increasing. Proof: it's true if no $$$\texttt{B}s$$$ become $$$\texttt{A}s$$$, and it's also true if some $$$\texttt{B}s$$$ become $$$\texttt{A}s$$$ because any of them is adjacent to two $$$\texttt{A}s$$$.
After the operation $$$2.i$$$:
The three properties above are still true.
The suffix $$$[i, n]$$$ contains the values in $$$[i, n]$$$ in order. Proof: $$$a_i$$$ is an $$$\texttt{A}$$$, so it must be the largest $$$p_i$$$ in $$$[1, i]$$$, which is $$$i$$$.
Now let's understand how we can implement the algorithm. Example implementation:
We maintain a segment tree. The $$$i$$$-th position of the segment tree contains information about the element which was initially $$$p_i$$$. Note that the relative position of $$$\texttt{B}s$$$ never changes: for example, if you want information about the last $$$k$$$ $$$\texttt{B}s$$$ in the current permutation, and you search them in the segment tree, you will find exactly the last $$$k$$$ $$$\texttt{B}s$$$, even though their indices will not correspond to the current indices.
We have to find the longest swappable subarray ending at $$$i$$$. It means we need the current positions of the $$$\texttt{B}s$$$. For each $$$\texttt{B}$$$ maintain the current position, and assume the position of all the $$$\texttt{A}s$$$ is $$$0$$$. Also maintain, for each element, if it is a $$$\texttt{B}$$$ or not. Note that the $$$\texttt{B}s$$$ that are affected by each operation can be found in a suffix of the segment tree.
In this way, finding the longest swappable subarray can be done with a binary search on the segment tree: since $$$\texttt{B}s$$$ cannot be consecutive, you have to find the longest suffix such that the sum of the positions of the $$$\texttt{B}s$$$ is the maximum possible (i.e., if there are $$$k$$$ $$$\texttt{B}s$$$ and the last of them is in position $$$i$$$, the sum of their positions must be $$$k(i-k+1)$$$).
After finding the longest subarray in the segment tree, you have to perform the operation on it, i.e., subtract $$$1$$$ from all the nonzero positions.
Some $$$\texttt{B}s$$$ may become $$$\texttt{A}s$$$. How to detect them? Since $$$\texttt{A}s$$$ never become $$$\texttt{B}s$$$, a $$$\texttt{B}$$$ becomes $$$\texttt{A}$$$ after it is swapped with all the elements greater than it on its left. So you can precompute the number of swaps that every $$$\texttt{B}$$$ needs to become $$$\texttt{A}$$$, and put it in the segment tree as well. Again, the operation is "subtract $$$1$$$ from a range".
Detecting $$$\texttt{A}s$$$ means detecting elements which need $$$0$$$ swaps to become $$$\texttt{A}s$$$. You can find them after each operation by traversing the segment tree (which must support "range min" on the number of swaps needed), and set their position to $$$0$$$ and the number of swaps needed to $$$\infty$$$.
Complexity: $$$2n-3$$$ moves, $$$O(n \log n)$$$ time.
--------------------------------------------------
Problem ID: 1909G
Editorial Content:
1909G - Pumping Lemma
Hint 1
If you remove the condition $$$s = x+y+z$$$, the problem becomes harder.
Hint 2
Solve for a fixed $$$|y|$$$ (length of $$$y$$$).
Hint 3
Suppose you have found a valid $$$y$$$. Shift it one position to the right. When is it still valid?
Hint 4
The valid $$$y$$$ with $$$|y| = l$$$ start in consecutive positions.
Hint 5
Using the same idea of the proof of Hint 4, you can find all the valid $$$y$$$.
Solution
Let's use $$$s[l, r]$$$ to indicate the substring $$$[l, r]$$$ of $$$s$$$. Let's use $$$(a, b)$$$ to indicate the triple of strings $$$(s[1, a], s[a+1, b], s[b+1, n])$$$.
Suppose $$$(a, b)$$$ is valid. Then, $$$(a+1, b+1)$$$ is valid if and only if $$$s_{b+1} = t_{b+1}$$$.
If $$$(a, b)$$$ is valid, $$$s[1, b] = t[1, b]$$$; so if $$$s_b \neq t_b$$$, $$$(a+k, b+k)$$$ is invalid for $$$k \geq 0$$$. Therefore, if $$$(a, b)$$$ is the first valid pair with $$$b-a=l$$$ (i.e., with $$$|y| = l$$$), and $$$k$$$ is the smallest positive integer such that $$$(a+k, b+k)$$$ is invalid, then $$$s_{b+k} \neq t_{b+k}$$$, so the only valid pairs with $$$|y| = l$$$ are the $$$(a+j, b+j)$$$ with $$$0 \leq j < k$$$ (i.e., the valid $$$y$$$ with $$$|y| = l$$$ start in consecutive positions).
Now let's find all the valid $$$y$$$ with $$$|y| = l$$$. Suppose $$$(a, b)$$$ is valid, and $$$c$$$ is the minimum index such that $$$s_c \neq t_c$$$. Then, $$$b < c$$$, and $$$(a+k, b+k)$$$ is valid for all $$$b \leq b+k < c$$$. Similarly, if $$$d$$$ is the minimum integer such that $$$s_{n-d} \neq t_{m-d}$$$, $$$(a+k, b+k)$$$ is valid for all $$$n-d < a+k \leq a \implies n-d+l < b+k \leq b$$$.
Therefore, it's enough to check only one pair for each length, with $$$b$$$ in $$$[n-d+l+1, c-1]$$$ (because either all these pairs are valid or they are all invalid). This is possible by precomputing the rolling hash of the two strings. Alternatively, you can use z-function.
Complexity: $$$O(n)$$$
--------------------------------------------------
Problem ID: 1909F2
Editorial Content:
1909F2 - Small Permutation Problem (Hard Version)
Hint 1
Find a clean way to visualize the problem.
Hint 2
Draw a $$$n \times n$$$ grid, with tokens in $$$(i, p_i)$$$. Which constraints on the tokens do you have?
Hint 3
You have some "L" shapes, and each of them must contain a fixed number of tokens (in
1909F1 - Small Permutation Problem (Easy Version)
the shapes are $$$1$$$ cell wide and must contain at most $$$2$$$ tokens). Iterate over the shapes in increasing order of $$$i$$$.
--------------------------------------------------
Problem ID: 1909F1
Editorial Content:
1909F1 - Small Permutation Problem (Easy Version)
1909F1 - Small Permutation Problem (Easy Version)
Hint 4
Split each shape into $$$2$$$ rectangles and iterate over the number of tokens in the first rectangle.
Solution
Draw a $$$n \times n$$$ grid, with tokens in $$$(i, p_i)$$$.
Consider any $$$a_i \neq -1$$$ and the nearest $$$a_j \neq -1$$$ on the left (if it does not exist, let's set $$$j = a_j = 0$$$). Then, there must be $$$a_i$$$ tokens in the subgrid $$$[1, i] \times [1, i]$$$. We can suppose we have already inserted the $$$a_j$$$ tokens in $$$[1, j] \times [1, j]$$$, and we have to insert $$$a_i - a_j$$$ tokens in the remaining cells of $$$[1, i] \times [1, i]$$$ (they make an "L" shape).
WLOG, the $$$a_j$$$ tokens in $$$[1, j] \times [1, j]$$$ are in the cells $$$(1, 1), \dots, (a_j, a_j)$$$. Then, we can put tokens in the blue cells in the picture.
Picture
The blue shape can be further split into these two rectangles:
Picture
Iterate over $$$k$$$, the number of tokens in the first rectangle ($$$0 \leq k \leq a_i - a_j$$$). Then, you have to insert $$$k$$$ tokens into a $$$h_1 \times w_1$$$ rectangle, and the remaining $$$a_i - a_j - k$$$ tokens into a $$$h_2 \times (w_2 - k)$$$ rectangle.
The number of ways to insert $$$k$$$ tokens into a $$$h \times w$$$ rectangle is equal to the product of the number of ways to choose $$$k$$$ rows, the number of ways to choose $$$k$$$ columns, and the number of ways to fill the resulting $$$k \times k$$$ subgrid: the result is $$$\binom{h}{k} \binom{w}{k} k!$$$.
$$$a_n = n$$$ automatically (if $$$a_n \neq n$$$ and $$$a_n \neq -1$$$, the answer is $$$0$$$). If the non-negative $$$a_i$$$ are non-decreasing, the sum of the $$$a_i - a_j + 1$$$ (i.e., the $$$k$$$ over which you have to iterate) is $$$O(n)$$$, so the algorithm is efficient enough. Otherwise, the answer is $$$0$$$.
Complexity: $$$O(n)$$$
Picture
Picture
--------------------------------------------------
Problem ID: 1909E
Editorial Content:
1909E - Multiple Lamps
Hint 1
Find a strategy that turns "few" lamps on in most cases.
Hint 2
Pressing all the buttons turns $$$\lfloor \sqrt n \rfloor$$$ lamps on.
Hint 3
If the strategy in Hint 2 does not work, at most $$$3$$$ lamps must be on at the end.
Hint 4
Iterate over all subsets of at most $$$3$$$ lamps that must be on at the end.
Solution
If you press all the buttons, lamp $$$i$$$ is toggled by all the divisors of $$$i$$$, so it will be on if $$$i$$$ has an odd number of divisors, i.e., if $$$i$$$ is a perfect square.
Then, the strategy of pressing all the buttons works if $$$\lfloor \sqrt n \rfloor \leq \lfloor n/5 \rfloor$$$, which is true for $$$n \geq 20$$$.
If $$$n \leq 19$$$, at most $$$\lfloor 19/5 \rfloor = 3$$$ lamps must be turned on at the end.
If you know which lamps must be turned on at the end, you can iterate over the buttons from $$$1$$$ to $$$n$$$ and press button $$$i$$$ if and only if lamp $$$i$$$ is in the wrong state. So you can iterate over all subsets of at most $$$3$$$ lamps, and check if the corresponding choice of buttons is valid (i.e., the $$$m$$$ constraints hold). You can remove a $$$\log n$$$ factor by precalculating the choice of buttons for all small subsets before running the testcases.
Complexity for each test: $$$O(\sum n + (\sum m \cdot k^{2k-4}))$$$ (if $$$\lfloor n/k \rfloor$$$ lamps must be on; in this case, $$$k = 5$$$).
--------------------------------------------------
Problem ID: 1909D
Editorial Content:
1909D - Split Plus K
Hint 1
Solve the problem with $$$k = 0$$$.
Hint 2
Solve the problem with generic $$$k$$$. When is the answer $$$-1$$$?
Hint 3
Do you notice any similarities between the cases with $$$k = 0$$$ and with generic $$$k$$$?
Solution
Consider the "shifted" problem, where each $$$x$$$ on the blackboard (at any moment) is replaced with $$$x' = x-k$$$.
Now, the operation becomes "replace $$$x$$$ with $$$y+z$$$ such that $$$y+z = x+k \implies (y'+k)+(z'+k) = (x'+k)+k \implies y'+z' = x'$$$". Therefore, in the shifted problem, $$$k' = 0$$$.
Now you can replace every $$$a'_i := a_i - k$$$ with any number of values with sum $$$a'_i$$$, and the answer is the amount of numbers on the blackboard at the end, minus $$$n$$$.
If we want to make all the values equal to $$$m'$$$, it must be a divisor of every $$$a'_i$$$.
If all the $$$a'_i$$$ are positive, it is optimal to choose $$$m' = \gcd a'_i$$$.
If all the $$$a'_i$$$ are zero, the answer is $$$0$$$.
If all the $$$a'_i$$$ are negative, it is optimal to choose $$$m' = -\gcd -a'_i$$$.
Otherwise, the answer is $$$-1$$$.
Alternative way to get this result:
You have to split each $$$a_i$$$ into $$$p_i$$$ pieces equal to $$$m$$$, and their sum must be equal to $$$a_i + k(p_i - 1) = (a_i - k) + kp_i = mp_i$$$. Then, $$$(a_i - k) = (m - k)p_i$$$, so $$$m' = m-k$$$ must be a divisor of every $$$a'_i = a_i - k$$$.
In both the positive and the negative case, you will only write positive elements (in the original setup), as wanted.
If all the $$$a'_i$$$ are positive, the numbers you will write on the shifted blackboard are positive, so they will be positive also in the original blackboard.
If all the $$$a'_i$$$ are negative, the numbers you will write on the shifted blackboard are greater than the numbers you will erase, so they will be greater than the numbers in input (and positive) in the original blackboard.
Complexity: $$$O(n + \log(\max a_i))$$$
--------------------------------------------------
Problem ID: 1909C
Editorial Content:
1909C - Heavy Intervals
Hint 1
Assign bigger costs to shorter intervals.
Hint 2
Solve the problem with $$$n = 2$$$.
Hint 3
Solve the following case: $$$l = [1, 2]$$$, $$$r = [3, 4]$$$, $$$c = [1, 2]$$$. Can you generalize it?
Solution
You have to match each $$$l_i$$$ with some $$$r_j > l_i$$$.
Construct $$$v = {l_1, l_2, \dots, l_n, r_1, r_2, \dots, r_n}$$$ and sort it. If you replace every $$$l_i$$$ with the symbol $$$\texttt{(}$$$ and every $$$r_i$$$ with the symbol $$$\texttt{)}$$$, you get a
regular bracket sequence
(sketch of proof: $$$l_i < r_i$$$ for each $$$i$$$, so each prefix of symbols contains at least as many $$$\texttt{(}$$$ as $$$\texttt{)}$$$, so the bracket sequence is regular).
Now match each $$$\texttt{(}$$$ with the
corresponding
$$$\texttt{)}$$$. You can show that this is the optimal way to rearrange the $$$l_i$$$ and the $$$r_i$$$. (From now, let the $$$l_i$$$, $$$r_i$$$ and $$$c_i$$$ be the values after your rearrangement.)
Proof:
If you match the brackets in any other way, you get two intervals such that their intersection is non-empty but it is different from both intervals (i.e., you get $$$l_i < l_j < r_i < r_j$$$).
You have also assigned some cost $$$c_i$$$ to $$$[l_i, r_i]$$$ and $$$c_j$$$ to $$$[l_j, r_j]$$$. Without loss of generality, $$$c_i \leq c_j$$$ (the other case is symmetrical).
If you swap $$$r_i$$$ and $$$r_j$$$, the cost does not increase.
Keep swapping endpoints until you get the "regular" bracket matching. You can show that the process ends in a finite number of steps. For example, you can show that $$$\sum ((r_i - l_i)^2)$$$ strictly increases after each step, and it is an integer $$$\leq \sum (r_i^2)$$$.
Picture
Now, you can get the minimum cost by sorting the intervals by increasing length and sorting the $$$c_i$$$ in decreasing order.
Alternative (more intuitive?) interpretation:
If you solve the problem with $$$n = 2$$$ and try to generalize, you can notice that it seems optimal to match every $$$r_i$$$ with the largest unused $$$l_i$$$ (if you iterate over $$$r_i$$$ in increasing order).
You can implement the solution by using either a stack (to simulate the bracket matching) or a set (to find the largest unused $$$l_i$$$).
Complexity: $$$O(n \log n)$$$
Picture
--------------------------------------------------
Problem ID: 1909B
Editorial Content:
1909B - Make Almost Equal With Mod
Hint 1
Find a value of $$$k$$$ that works in many cases.
Hint 2
$$$k = 2$$$ works in many cases. What if it does not work?
Hint 3
If $$$k = 2$$$ does not work, either all the numbers are even or all the numbers are odd. Which $$$k$$$ can you try now?
Solution
Let $$$f(k)$$$ be the number of distinct values after the operation, using $$$k$$$.
Let's try $$$k = 2$$$. It works in all cases, except when either all the numbers are even or all the numbers are odd.
Let's generalize. If $$$a_i \text{ mod } k = x$$$, one of the following holds:
$$$a_i \text{ mod } 2k = x$$$;
$$$a_i \text{ mod } 2k = x+k$$$;
It means that, if $$$f(k) = 1$$$ (i.e., all the values after the operations are $$$x$$$), either $$$f(2k) = 1$$$ (if either all the values become $$$x$$$, or they all become $$$x+k$$$), or $$$f(2k) = 2$$$.
Therefore, it is sufficient to try $$$k = 2^1, \dots, 2^{57}$$$. In fact, $$$f(1) = 1$$$ and $$$f(2^{57}) = n$$$, so there must exist $$$m < 57$$$ such that $$$f(2^m) = 1$$$ and $$$f(2^{m+1}) \neq 1 \implies f(2^{m+1}) = 2$$$.
Alternative (more intuitive?) interpretation:
$$$a_i \text{ mod } 2^j$$$ corresponds to the last $$$j$$$ digits in the binary representation of $$$a_i$$$. There must exist $$$j$$$ such that the last $$$j$$$ digits make exactly $$$2$$$ distinct blocks.
In the following picture, $$$a = [1005, 2005, 7005, 11005, 16005]$$$ and $$$k = 16$$$:
Picture
Complexity: $$$O(n \log(\max a_i))$$$
Picture
--------------------------------------------------
Problem ID: 1909A
Editorial Content:
1909A - Distinct Buttons
Hint 1
Suppose you can only use $$$\texttt{U}$$$, $$$\texttt{R}$$$, $$$\texttt{D}$$$. Which cells can you reach?
Solution
If you only use buttons $$$\texttt{U}$$$, $$$\texttt{R}$$$, $$$\texttt{D}$$$, you can never reach the points with $$$x < 0$$$. However, if all the special points have $$$x \geq 0$$$, you can reach all of them with the following steps:
visit all the special points with $$$x = 0$$$, using the buttons $$$\texttt{U}$$$, $$$\texttt{D}$$$;
press the button $$$\texttt{R}$$$ to reach $$$x = 1$$$;
visit all the special points with $$$x = 1$$$, using the buttons $$$\texttt{U}$$$, $$$\texttt{D}$$$;
$$$\dots$$$
visit all the special points with $$$x = 100$$$, using the buttons $$$\texttt{U}$$$, $$$\texttt{D}$$$.
Similarly, if you use at most $$$3$$$ buttons in total, you can reach all the special points if at least one of the following conditions is true:
all $$$x_i \geq 0$$$;
all $$$x_i \leq 0$$$;
all $$$y_i \geq 0$$$;
all $$$y_i \leq 0$$$.
Complexity: $$$O(n)$$$
--------------------------------------------------
Problem ID: 1907G
Editorial Content:
1907G - Lights
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define long long long int
#define DEBUG
using namespace std;

// @author: pashka

void solve(){
    int n;
    cin >> n;
    vector<bool> s(n);
    {
        string ss;
        cin >> ss;
        for (int i = 0; i < n; i++) {
            s[i] = ss[i] == '1';
        }
    }
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        a[i]--;
    }

    vector<int> res;
    vector<int> d(n);
    for (int i = 0; i < n; i++) {
        d[a[i]]++;
    }
    vector<int> z;
    for (int i = 0; i < n; i++) {
        if (d[i] == 0) z.push_back(i);
    }

    for (int i = 0; i < (int)z.size(); i++) {
        int x = z[i];
        int y = a[x];
        if (s[x]) {
            res.push_back(x);
            s[x] = !s[x];
            s[y] = !s[y];
        }
        d[y]--;
        if (d[y] == 0) {
            z.push_back(y);
        }
    }

    vector<bool> u(n);
    for (int i = 0; i < n; i++) {
        if (s[i] && !u[i]) {
            int x = i;
            vector<int> p;
            vector<bool> ps;
            int c = 0;
            while (!u[x]) {
                p.push_back(x);
                ps.push_back(s[x]);
                c += s[x];
                u[x] = true;
                x = a[x];
            }
            int k = p.size();
            p.push_back(x);
            ps.push_back(s[x]);
            if (c % 2 == 1) {
                cout << -1;
                return;
            }
            vector<int> v1;
            vector<bool> ps1 = ps;
            for (int j = 0; j < k; j++) {
                if (j == 0 || ps1[j]) {
                    v1.push_back(p[j]);
                    ps1[j] = !ps1[j];
                    ps1[j + 1] = !ps1[j + 1];
                }
            }
            vector<int> v2;
            vector<bool> ps2 = ps;
            for (int j = 0; j < k; j++) {
                if (j != 0 && ps2[j]) {
                    v2.push_back(p[j]);
                    ps2[j] = !ps2[j];
                    ps2[j + 1] = !ps2[j + 1];
                }
            }
            if (v1.size() < v2.size()) {
                for (auto x : v1) {
                    res.push_back(x);
                }
            } else {
                for (auto x : v2) {
                    res.push_back(x);
                }
            }
        }
    }
    cout << res.size() << "\n";
    for (auto x : res) cout << x + 1 << " ";
}

int main() {
    int t;
    cin >> t;
    for(int _ = 0; _ < t; ++_){
        solve();
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1907F
Editorial Content:
1907F - Shift and Reverse
Tutorial
Tutorial is loading...
Solution
t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    a = list(reversed(a))*2
    p = [0]
    q = [0]
    for i in range(n*2-1):
        p.append(p[-1]+1 if a[i]>=a[i+1] else 0)
        q.append(q[-1]+1 if a[i]<=a[i+1] else 0)
    minn = 1000000
    for i in range(n-1,len(p)):
        if p[i] == n-1:
            minn = min(minn, i-n+1, len(p)-i+1)
        if q[i] == n-1:
            minn = min(minn, len(p)-i, i-n+2)
    print(-1 if minn == 1000000 else minn)
--------------------------------------------------
Problem ID: 1907E
Editorial Content:
1907E - Good Triples
Tutorial
Tutorial is loading...
Solution
t = int(input())
for _ in range(t):
    n = int(input())
    cnt = 1
    while n > 0:
        d = n % 10
        n //= 10
        mul = 0
        for i in range(d + 1):
            for j in range(d + 1):
                if d - i - j >= 0:
                    mul += 1
        cnt *= mul
    print(cnt)
--------------------------------------------------
Problem ID: 1907D
Editorial Content:
1907D - Jumping Through Segments
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    seg = [list(map(int, input().split())) for x in range(n)]

    def check(k):
        ll, rr = 0, 0
        for e in seg:
            ll = max(ll - k, e[0])
            rr = min(rr + k, e[1])
            if ll > rr:
                return False
        return True

    l, r = -1, 10 ** 9
    while r - l > 1:
        mid = (r + l) // 2
        if check(mid):
            r = mid
        else:
            l = mid
    print(r)


for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1907C
Editorial Content:
1907C - Removal of Unattractive Pairs
Tutorial
Tutorial is loading...
Solution
orda = ord('a')

def solve():
    n = int(input())
    cnt = [0] * 26
    for c in input():
        cnt[ord(c) - orda] += 1
    mx = max(cnt)
    print(max(n % 2, 2 * mx - n))


for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1907B
Editorial Content:
1907B - YetnotherrokenKeoard
Tutorial
Tutorial is loading...
Solution
for _ in range(int(input())):
    s = list(input())
    n = len(s)
    upper = []
    lower = []
    for i in range(n):
        if s[i] == 'b':
            s[i] = ''
            if lower:
                s[lower.pop()] = ''
            continue
        if s[i] == 'B':
            s[i] = ''
            if upper:
                s[upper.pop()] = ''
            continue
        if 'a' <= s[i] <= 'z':
            lower += [i]
        else:
            upper += [i]
    print(''.join(s))
--------------------------------------------------
Problem ID: 1907A
Editorial Content:
1907A - Rook
Tutorial
Tutorial is loading...
Solution
for _ in range(int(input())):
    s = input()
    for c in "abcdefgh":
        if c != s[0]:
            print(c + s[1], end=' ')
    for c in "12345678":
        if c != s[1]:
            print(s[0] + c, end=' ')
    print()
--------------------------------------------------
Problem ID: 1906M
Editorial data not available.
--------------------------------------------------
Problem ID: 1906L
Editorial data not available.
--------------------------------------------------
Problem ID: 1906K
Editorial data not available.
--------------------------------------------------
Problem ID: 1906J
Editorial data not available.
--------------------------------------------------
Problem ID: 1906I
Editorial data not available.
--------------------------------------------------
Problem ID: 1906H
Editorial data not available.
--------------------------------------------------
Problem ID: 1906G
Editorial data not available.
--------------------------------------------------
Problem ID: 1906F
Editorial data not available.
--------------------------------------------------
Problem ID: 1906E
Editorial data not available.
--------------------------------------------------
Problem ID: 1906D
Editorial data not available.
--------------------------------------------------
Problem ID: 1906C
Editorial data not available.
--------------------------------------------------
Problem ID: 1906B
Editorial data not available.
--------------------------------------------------
Problem ID: 1906A
Editorial data not available.
--------------------------------------------------
Problem ID: 1905F
Editorial Content:

--------------------------------------------------
Problem ID: 1905E
Editorial Content:

--------------------------------------------------
Problem ID: 1905D
Editorial Content:

--------------------------------------------------
Problem ID: 1905C
Editorial Content:

--------------------------------------------------
Problem ID: 1905B
Editorial Content:

--------------------------------------------------
Problem ID: 1905A
Editorial Content:

--------------------------------------------------
Problem ID: 1904F
Editorial Content:
1904F - Beautiful Tree
Hint
Can we represent the conditions as a graph?
Solution
Lets rewrite the condition that node $$$a$$$ must be smaller than node $$$b$$$ as a directed edge from $$$a$$$ to $$$b$$$. Then, we can assign each node a value based on the topological sort of this new directed graph. If this directed graph had a cycle, it is clear that there is no way to order the nodes.
With this in mind, we can try to construct a graph that would have these properties. Once we have the graph, we can topological sort to find the answer.
For now, let's consider the problem if it only had type 1 requirements (type 2 requirements can be done very similarly).
Thus, the problem reduces to "given a path and a node, add a directed edge from the node to every node in that path." To do this, we can use binary lifting. For each node, create $$$k$$$ dummy nodes, the $$$i$$$th of which represents the minimum number from the path between node $$$a$$$ and the $$$2^i$$$th parent of $$$a$$$. Now, we can draw a directed edge from the the $$$i$$$th dummy node of $$$a$$$ to the $$$i-1$$$th dummy node of $$$a$$$ and the $$$i-1$$$th dummy node of the $$$2^{i-1}$$$th parent of $$$a$$$.
Now, to add an edge from any node to a vertical path of the tree, we can repeatedly add an edge from that node to the largest node we can. This will add $$$O(\log n)$$$ edges per requirement.
The final complexity is $$$O((n+m)\log n)$$$ time and $$$O((n+m)\log n)$$$.
Code
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
#pragma GCC target("sse4,popcnt,abm,mmx,tune=native")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;

#define pb push_back
#define ff first
#define ss second

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<ld, ld> pld;

const int INF = 1e9;
const ll LLINF = 1e18;
const int MOD = 1e9 + 7;

template<class K> using sset =  tree<K, null_type, less<K>, rb_tree_tag, tree_order_statistics_node_update>;

inline ll ceil0(ll a, ll b) {
    return a / b + ((a ^ b) > 0 && a % b);
}

void setIO() {
    ios_base::sync_with_stdio(0); cin.tie(0);
}

const int MAXN = 200'000;
const int LG = 18;
const int MAXM = 200'000;

vector<int> g[MAXN + 5];
int sz[MAXN + 5], in[MAXN + 5], par[MAXN + 5], depth[MAXN + 5], head[MAXN + 5], tim;
int n, m;

void dfs1(int x, int p){
    sz[x] = 1;
    for(int &i : g[x]){
        if(i == p) continue;
        dfs1(i, x);
        sz[x] += sz[i];
        if(g[x][0] == p || sz[i] > sz[g[x][0]]) swap(g[x][0], i);
    }
}
 
void dfs2(int x, int p){
    in[x] = tim++;
    par[x] = p;
    depth[x] = depth[p] + 1;
    for(int i : g[x]){
        if(i == p) continue;
        head[i] = (i == g[x][0] ? head[x] : i);
        dfs2(i, x);
    }
}

const int MAXSZ = MAXN + 2*MAXN*LG;
int down[LG][MAXN + 5];
int up[LG][MAXN + 5];
vector<int> dag[MAXSZ+ 5];
int lg[MAXN + 5];

void upd(int l, int r, int x, int t){
    if(l <= in[x] && in[x] <= r){
        if(l < in[x]) upd(l, in[x] - 1, x, t);
        if(in[x] < r) upd(in[x] + 1, r, x, t);
    } else {
        int sz = lg[r - l + 1];
        if(t == 2){
            dag[up[sz][l]].pb(x);
            dag[up[sz][r - (1 << sz) + 1]].pb(x);
        } else {
            dag[x].pb(down[sz][l]);
            dag[x].pb(down[sz][r - (1 << sz) + 1]);
        }
    }
}

//1 is down, 2 is up
void draw(int a, int b, int c, int t){
    while(head[a] != head[b]){
        if(depth[head[a]] > depth[head[b]]) swap(a, b);
        upd(in[head[b]], in[b], c, t);
        b = par[head[b]];
    }
    if(depth[a] > depth[b]) swap(a, b);
    upd(in[a], in[b], c, t);
}

bool vis[MAXSZ + 5], stk[MAXSZ + 5];
vector<int> ord;
bool fail;
int ind;

void dfs3(int x){
    if(fail) return;
    vis[x] = stk[x] = true;
    for(int i : dag[x]){
        if(i == x) continue;
        if(!vis[i]){
            dfs3(i);
        } else if(stk[i]){
            fail = true;
            break;
        }
    }
    stk[x] = false;
    if(x <= n) ord.pb(x);
}

int main(){
    setIO();
    cin >> n >> m;
    lg[1] = 0;
    for(int i = 2; i <= n; i++) lg[i] = lg[i/2] + 1;
    for(int i = 0; i < n - 1; i++){
        int a, b;
        cin >> a >> b;
        g[a].pb(b);
        g[b].pb(a);
    }
    tim = 0;
    dfs1(1, 1);
    head[1] = 1;
    dfs2(1, 1);
    for(int i = 1; i <= n; i++) down[0][in[i]] = up[0][in[i]] = i;
    ind = n + 1;
    for(int i = 1; i < LG; i++){
        for(int j = 0; j + (1 << i) <= n; j++){
            down[i][j] = ind++;
            up[i][j] = ind++;

            dag[down[i][j]].pb(down[i - 1][j]);
            dag[down[i][j]].pb(down[i - 1][j + (1 << (i - 1))]);

            dag[up[i - 1][j]].pb(up[i][j]);
            dag[up[i - 1][j + (1 << (i - 1))]].pb(up[i][j]);
        }
    }
    for(int i = 0; i < m; i++){
        int t, a, b, c;
        cin >> t >> a >> b >> c;
        draw(a, b, c, t);
    }
    fail = false;
    for(int i = 1; i <= n; i++){
        if(!vis[i]){
            dfs3(i);
            if(fail) break;
        }
    }
    if(fail){
        cout << -1 << endl;
        return 0;
    }
    reverse(ord.begin(), ord.end());
    int ans[n + 1];
    for(int i = 0; i < ord.size(); i++){
        ans[ord[i]] = i + 1;
    }
    for(int i = 1; i <= n; i++) cout << ans[i] << " ";
    cout << endl;
}
--------------------------------------------------
Problem ID: 1904E
Editorial Content:
1904E - Tree Queries
Hint 1
The solution doesn't involve virtual tree
Hint 2
What is an easy way to represent the tree?
Solution
Consider the Euler tour of the tree where $$$in[u]$$$ is the entry time of each node and $$$out[u]$$$ is the exit time. The interval $$$[in[u], out[u]]$$$ corresponds to the subtree of $$$u$$$.
Removing a node is equivalent to blocking some intervals on the Euler tour. There are two cases when $$$a$$$ is blocked with respect to query node $$$x$$$. If $$$a$$$ is an ancestor of $$$x$$$, then the set of reachable nodes is reduced to the interval $$$[in[nxt_a], out[nxt_a]]$$$, where $$$nxt_a$$$ is the first node on the path from $$$a$$$ to $$$x$$$. This is equivalent to blocking the intervals $$$[0, in[nxt_a])$$$ and $$$(out[nxt_a], n - 1]$$$. If $$$a$$$ is not an ancestor, then the interval $$$[in[a], out[a]]$$$ is blocked.
Lets build a lazy segment tree on the Euler tour of the tree. Each leaf node will correspond to the depth of a node on the tree. We can re-root the tree from $$$a$$$ to $$$b$$$ by subtracting one from all nodes the range $$$[in[b], out[b]]$$$ and adding one to all other nodes. Thus, we can traverse the tree while re-rooting and process our queries offline. When the query node $$$x$$$ is the root, block all the necessary intervals and then find the maximum value in the segment tree.
Code
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;

#define pb push_back
#define ff first
#define ss second

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<ld, ld> pld;

const int INF = 1e9;
const ll LLINF = 1e18;
const int MOD = 1e9 + 7;

template<class K> using sset =  tree<K, null_type, less<K>, rb_tree_tag, tree_order_statistics_node_update>;

inline ll ceil0(ll a, ll b) {
    return a / b + ((a ^ b) > 0 && a % b);
}

void setIO() {
    ios_base::sync_with_stdio(0); cin.tie(0);
}

const int MAXN = 2e5;
const int MAXQ = 2e5;

int seg[4*MAXN + 5];
int tag[4*MAXN + 5];
int tim;
vector<int> g[MAXN + 5];
int in[MAXN + 5], out[MAXN + 5];

void push_down(int cur){
    if(!tag[cur]) return;
    for(int i = cur*2 + 1; i <= cur*2 + 2; i++){
        seg[i] += tag[cur];
        tag[i] += tag[cur];
    }
    tag[cur] = 0;
}

void update(int l, int r, int v, int ul = 0, int ur = tim - 1, int cur = 0){
    if(l <= ul && ur <= r){
        seg[cur] += v;
        tag[cur] += v;
        return;
    }
    push_down(cur);
    int mid = (ul + ur)/2;
    if(l <= mid) update(l, r, v, ul, mid, cur*2 + 1);
    if(r > mid) update(l, r, v, mid + 1, ur, cur*2 + 2);
    seg[cur] = max(seg[cur*2 + 1], seg[cur*2 + 2]);
}

int query(int l, int r, int ul = 0, int ur = tim - 1, int cur = 0){
    if(l <= ul && ur <= r) return seg[cur];
    push_down(cur);
    int mid = (ul + ur)/2;
    if(r <= mid) return query(l, r, ul, mid, cur*2 + 1);
    if(l > mid) return query(l, r, mid + 1, ur, cur*2 + 2);
    return max(query(l, r, ul, mid, cur*2 + 1), query(l, r, mid + 1, ur, cur*2 + 2));
}

void dfs1(int x, int p = 0){
    in[x] = tim++;
    for(int i : g[x]){
        if(i == p) continue;
        dfs1(i, x);
    }
    out[x] = tim - 1;
}

vector<pair<int, vector<int>>> que[MAXN + 5];
int nxt[MAXN + 5];
int ans[MAXQ + 5];
int n, q;

void dfs2(int x, int p = 0){
    for(auto &i : que[x]){
        vector<pii> skip;
        bool found = false;
        for(int j : i.ss){
            if(j == x){
                found = true;
                break;
            }
            if(in[j] <= in[x] && in[x] <= out[j]){
                skip.pb({0, in[nxt[j]] - 1});
                skip.pb({out[nxt[j]] + 1, tim - 1});
            } else {
                skip.pb({in[j], out[j]});
            }
        }
        if(found) continue;
        sort(skip.begin(), skip.end());
        int prv = 0;
        for(pii j : skip){
            if(prv < j.ff) ans[i.ff] = max(ans[i.ff], query(prv, j.ff - 1));
            prv = max(prv, j.ss + 1);
        }
        if(prv <= tim - 1) ans[i.ff] = max(ans[i.ff], query(prv, tim - 1));
    }
    update(0, tim - 1, 1);
    for(int i : g[x]){
        if(i == p) continue;
        update(in[i], out[i], -2);
        nxt[x] = i;
        dfs2(i, x);
        update(in[i], out[i], 2);
    }
    update(0, tim - 1, -1);
}

int main(){
    setIO();
    cin >> n >> q;
    for(int i = 0; i < n - 1; i++){
        int a, b;
        cin >> a >> b;
        g[a].pb(b);
        g[b].pb(a);
    }
    tim = 0;
    dfs1(1);
    for(int i = 0; i < q; i++){
        int x, k;
        cin >> x >> k;
        vector<int> v(k);
        for(int j = 0; j < k; j++) cin >> v[j];
        que[x].pb({i, v});
    }
    for(int i = 2; i <= n; i++) update(in[i], out[i], 1);
    dfs2(1);
    for(int i = 0; i < q; i++){
        cout << ans[i] << endl;
    }
}
Hint 1
In a tree, one of the farthest nodes from some node $$$x$$$ is one of the two endpoints of the diameter.
Hint 2
Let's try to find the diameter of the connected subgraph node $$$x$$$ is in after the nodes $$$a_{1 \dots n}$$$ are removed.
Hint 3
Consider an euler tour of the tree and order the nodes by their inorder traversal. When $$$k$$$ nodes are removed, the remaining nodes form $$$O(k)$$$ contiguous intervals in the tour.
Solution
Let's build a segtree/sparse table where each node stores the diameter (as a pair of nodes) for the nodes with $$$in$$$ values in the range $$$[l, r]$$$. To merge two diameters, we can enumerate all $$$4 \choose 2$$$ ways to pick the new diameter and take the best one.
To answer a query, we can first generate a list of banned intervals (just like solution 1) and use that list to generate the list of unbanned intervals. Then we can query our segtree for the diameter of each of ranges. Finally, we can combine the answers of the seperate queries to obtain the diameter of the connected subgraph. We know the farthest node from node $$$x$$$ is one of the two endpoints, so it suffices to just manually check the distance of those two nodes.
Final complexity is $$$O(n \log^2 n + \sum k \log n)$$$.
Code
#include <bits/stdc++.h>

#define sz(x) ((int)(x.size()))
#define all(x) x.begin(), x.end()
#define pb push_back
#define eb emplace_back

const int MX = 2e5 +10, int_max = 0x3f3f3f3f;

using namespace std;

//lca template start
vector<int> dep, sz, par, head, tin, tout, tour;
vector<vector<int>> adj;
int n, ind, q;
void dfs(int x, int p){
	sz[x] = 1;
	dep[x] = dep[p] + 1;
	par[x] = p;
	for(auto &i : adj[x]){
		if(i == p) continue;
		dfs(i, x);
		sz[x] += sz[i];
		if(adj[x][0] == p || sz[i] > sz[adj[x][0]]) swap(adj[x][0], i);
	}
	if(p != 0) adj[x].erase(find(all(adj[x]), p));
}
void dfs2(int x, int p){
	tour[ind] = x;
	tin[x] = ind++;
	for(auto &i : adj[x]){
		if(i == p) continue;
		head[i] = (i == adj[x][0] ? head[x] : i);
		dfs2(i, x);
	}
	tout[x] = ind;
}

int k_up(int u, int k){
	if(dep[u] <= k) return -1;
	while(k > dep[u] - dep[head[u]]){
		k -= dep[u] - dep[head[u]] + 1;
		u = par[head[u]];
	}
	return tour[tin[u] - k];
}

int lca(int a, int b){
	while(head[a] != head[b]){
		if(dep[head[a]] > dep[head[b]]) swap(a, b);
		b = par[head[b]];
	}
	if(dep[a] > dep[b]) swap(a, b);
	return a;
}

int dist(int a, int b){
	return dep[a] + dep[b] - 2*dep[lca(a, b)];
}
//lca template end
//segtree template start
#define ff first
#define ss second
int dist(pair<int, int> a){
	return dist(a.ff, a.ss);
}
pair<int, int> merge(pair<int, int> a, pair<int, int> b){
	auto p = max(pair(dist(a), a), pair(dist(b), b));
	for(auto x : {a.ff, a.ss}){
		for(auto y : {b.ff, b.ss}){
			if(x == 0 || y == 0) continue;
			p = max(p, pair(dist(pair(x, y)), pair(x, y)));
		}
	}
	return p.ss;
}

pair<int, int> mx[MX*4];
#define LC(k) (2*k)
#define RC(k) (2*k +1)
void update(int p, int v, int k, int L, int R){
	if(L + 1 == R){
		mx[k] = {tour[p], tour[p]};
		return ;
	}
	int mid = (L + R)/2;
	if(p < mid) update(p, v, LC(k), L, mid);
	else update(p, v, RC(k), mid, R);
	mx[k] = merge(mx[LC(k)], mx[RC(k)]);
}

void query(int qL, int qR, vector<pair<int, int>>& ret, int k, int L, int R){
	if(qR <= L || R <= qL) return ;
	if(qL <= L && R <= qR){
		ret.push_back(mx[k]);
		return ;
	}
	int mid = (L + R)/2;
	query(qL, qR, ret, LC(k), L, mid);
	query(qL, qR, ret, RC(k), mid, R);
}

//segtree template end

int query(vector<int> arr, int x){
	vector<pair<int, int>> banned, ret;
	for(int u : arr){
		if(lca(u, x) == u){
			u = k_up(x, dep[x] - dep[u] - 1);
			banned.push_back({0, tin[u]});
			banned.push_back({tout[u], n});
		}else{
			banned.push_back({tin[u], tout[u]});
		}
	}
	sort(all(banned), [&](pair<int, int> a, pair<int, int> b){
		return (a.ff < b.ff) || (a.ff == b.ff && a.ss > b.ss);
			});
	vector<pair<int, int>> tbanned; //remove nested intervals
	int mx = 0;
	for(auto [a, b] : banned){
		if(b <= mx) continue;
		else if(a != b){
			tbanned.pb({a, b});
			mx = b;
		}
	}

	banned = tbanned;
	int tim = 0;
	for(auto [a, b] : banned){
		if(tim < a) 
			query(tim, a, ret, 1, 0, n);
		tim = b;
	}

	if(tim < n) 
		query(tim, n, ret, 1, 0, n);
	pair<int, int> dia = pair(x, x);
	for(auto p : ret) dia = merge(dia, p);
	int ans = max(dist(x, dia.ff), dist(x, dia.ss));
	return ans;
}

void solve(){
	cin >> n >> q;
	dep = sz = par = head = tin = tout = tour = vector<int>(n+1, 0);
	adj = vector<vector<int>>(n+1);
	for(int i = 1; i<n; i++){
		int a, b;
		cin >> a >> b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}
	
	dfs(1, 0);
	head[1] = 1;
	dfs2(1, 0);
	for(int i = 1; i<=n; i++){
		update(tin[i], dep[i], 1, 0, n);
	}
	for(int i = 1; i<=q; i++){
		int x, k;
		cin >> x >> k;
		vector<int> arr(k);
		for(int& y : arr) cin >> y;		
		cout << query(arr, x) << "\n";
	}
}

signed main(){
  cin.tie(0) -> sync_with_stdio(0);

  int T = 1;
  //cin >> T;
  for(int i = 1; i<=T; i++){
		//cout << "Case #" << i << ": ";
		solve();
	}
  return 0;
}
--------------------------------------------------
Problem ID: 1904D2
Editorial Content:
1904D2 - Set To Max (Hard Version)
Hint 1
Can we reduce the number of intervals we want to apply an operation on?
Hint 2
What is the necessary condition to perform an operation on an interval
Solution
If $$$b_i < a_i$$$ for any $$$i$$$, then it is clearly impossible.
In order for $$$a_i$$$ to become $$$b_i$$$, $$$i$$$ must be contained by an interval that also contains a $$$j$$$ where $$$a_j = b_i$$$. Note that if there is a triple $$$i \le j < k$$$ where $$$a_j = a_k = b_i$$$, then it is never optimal to apply the operation on interval $$$[i, k]$$$, since applying the operation on interval $$$[i, j]$$$ will be sufficient. Thus, for $$$i$$$ we only need to consider the closest $$$a_j = b_i$$$ to the right or left of $$$i$$$.
Lets find the necessary conditions for us to apply an operation on the interval $$$[i, j]$$$. First of all, $$$a_k \le b_i$$$ for $$$i \le k \le j$$$. Second, $$$b_k \ge b_i$$$ for all $$$i \le k \le j$$$. Turns out, these conditions are also sufficient, since we can apply these operations in increasing order of $$$b_i$$$ without them interfering with each other. If we check for every $$$i$$$ there exists an interval $$$[i, j]$$$ or $$$[j, i]$$$ that satisfies the necessary conditions, then there will exist a sequence of operations to transform $$$a$$$ into $$$b$$$. Checking for the conditions can be done with brute force for D1 or using monotonic stacks or segment trees for D2.
Code
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;

#define pb push_back
#define ff first
#define ss second

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<ld, ld> pld;

const int INF = 1e9;
const ll LLINF = 1e18;
const int MOD = 1e9 + 7;

template<class K> using sset =  tree<K, null_type, less<K>, rb_tree_tag, tree_order_statistics_node_update>;

inline ll ceil0(ll a, ll b) {
    return a / b + ((a ^ b) > 0 && a % b);
}

void setIO() {
    ios_base::sync_with_stdio(0); cin.tie(0);
}

int main(){
    setIO();
    int T;
    cin >> T;
    for(int tt = 1; tt <= T; tt++){
        int n;
        cin >> n;
        int a[n + 1], b[n + 1];
        for(int i = 1; i <= n; i++) cin >> a[i];
        for(int i = 1; i <= n; i++) cin >> b[i];
        bool val[n + 1];
        memset(val, false, sizeof(val));
        for(int t = 0; t < 2; t++){
            int prvb[n + 1]; //prev smaller
            int nxta[n + 1]; //next greater
            stack<pii> s;
            s.push({INF, n + 1});
            for(int i = n; i >= 1; i--){
                while(s.top().ff <= a[i]) s.pop();
                nxta[i] = s.top().ss;
                s.push({a[i], i});
            }
            while(!s.empty()) s.pop();
            s.push({0, 0});
            for(int i = 1; i <= n; i++){
                while(s.top().ff >= b[i]) s.pop();
                prvb[i] = s.top().ss;
                s.push({b[i], i});
            }
            int m[n + 1];
            memset(m, 0, sizeof(m));
            for(int i = 1; i <= n; i++){
                m[a[i]] = i;
                if(a[i] <= b[i] && m[b[i]]) val[i] |= prvb[i] < m[b[i]] && nxta[m[b[i]]] > i;
            }
            reverse(a + 1, a + n + 1);
            reverse(b + 1, b + n + 1);
            reverse(val + 1, val + n + 1);
        }
        bool ans = true;
        for(int i = 1; i <= n; i++) ans &= val[i];
        cout << (ans ? "YES" : "NO") << endl;
    }
}
--------------------------------------------------
Problem ID: 1904D1
Editorial Content:
1904D1 - Set To Max (Easy Version)
--------------------------------------------------
Problem ID: 1904C
Editorial Content:
1904C - Array Game
Solution
If $$$k\geq 3$$$, the answer is equal to $$$0$$$ since after performing an operation on the same pair $$$(i, j)$$$ twice, performing an operation on the two new values (which are the same) results in $$$0$$$.
Therefore, let's consider the case for $$$1\leq k\leq 2$$$.
For $$$k=1$$$, it is sufficient to sort the array and output the minimum between $$$a_i$$$ and $$$a_{i+1} - a_i$$$.
For $$$k=2$$$, let's brute force the first operation. If the newly created value is $$$v$$$, then it is sufficient to find the smallest $$$a_i$$$ satisfying $$$a_i\geq v$$$ and greatest $$$a_i$$$ satisfying $$$a_i\leq v$$$ and relax the answer on $$$|a_i - v|$$$. Also, remember to consider the cases of performing no operation or one operation. This runs in $$$O(N^2\log N)$$$. There also exists a solution in $$$O(N^2)$$$ using a two pointers approach.
Code
#include <bits/stdc++.h>
using namespace std;

#define int long long
 
signed main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        if (k >= 3) {
            cout << 0 << endl;
            continue;
        }
        sort(begin(a), end(a));
        int d = a[0];
        for (int i = 0; i < n - 1; i++) d = min(d, a[i + 1] - a[i]);
        if (k == 1) {
            cout << d << endl;
            continue;
        }
        for (int i = 0; i < n; i++) for (int j = 0; j < i; j++) {
            int v = a[i] - a[j];
            int p = lower_bound(begin(a), end(a), v) - begin(a);
            if (p < n) d = min(d, a[p] - v);
            if (p > 0) d = min(d, v - a[p - 1]);
        }
        cout << d << endl;
    }
}
--------------------------------------------------
Problem ID: 1904B
Editorial Content:
1904B - Collecting Game
Solution
Let's sort array $$$a$$$. The answer for the largest element is $$$n-1$$$ because the score, which is $$$a_n$$$, cannot be smaller than any of the other elements. Now, consider the second largest element. The answer is at least $$$n-2$$$ because every element that is not greater than $$$a_{n-1}$$$ can be taken. Then, we check if the score is at least $$$a_n$$$. This inspires the following solution: first, we find the prefix sum $$$p$$$ of array $$$a$$$. We calculate the answer in decreasing order of $$$a_i$$$. To calculate the answer for an $$$a_i$$$, we find the largest $$$j$$$ such that $$$p_i\geq a_j$$$ and set the answer for $$$i$$$ equal to the answer of $$$j$$$.
Code
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;

#define pb push_back
#define ff first
#define ss second

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<ld, ld> pld;

const int INF = 1e9;
const ll LLINF = 1e18;
const int MOD = 1e9 + 7;

template<class K> using sset =  tree<K, null_type, less<K>, rb_tree_tag, tree_order_statistics_node_update>;

inline ll ceil0(ll a, ll b) {
    return a / b + ((a ^ b) > 0 && a % b);
}

void setIO() {
    ios_base::sync_with_stdio(0); cin.tie(0);
}

int main(){
    setIO();
    int T;
    cin >> T;
    for(int tt = 1; tt <= T; tt++){
        int n;
        cin >> n;
        pii arr[n + 1];
        for(int i = 1; i <= n; i++) cin >> arr[i].ff, arr[i].ss = i;
        sort(arr + 1, arr + n + 1);
        int nxt[n + 1];
        ll sum[n + 1];
        int ans[n + 1];
        nxt[0] = sum[0] = 0;
        for(int i = 1; i <= n; i++){
            if(nxt[i - 1] >= i){
                nxt[i] = nxt[i - 1];
                sum[i] = sum[i - 1];
            } else {
                sum[i] = sum[i - 1] + arr[i].ff;
                nxt[i] = i;
                while(nxt[i] + 1 <= n && sum[i] >= arr[nxt[i] + 1].ff){
                    nxt[i]++;
                    sum[i] += arr[nxt[i]].ff;
                }
            }
            ans[arr[i].ss] = nxt[i];
        }
        for(int i = 1; i <= n; i++) cout << ans[i] - 1 << " ";
        cout << endl;
    }
}
--------------------------------------------------
Problem ID: 1904A
Editorial Content:
1904A - Forked!
Solution
There are at most $$$8$$$ positions of the knight that can attack a single cell. Therefore, we can find all $$$8$$$ positions that attack the king and the $$$8$$$ positions that attack the queen and count the number of positions that appear in both of these lists.
Code
#include <bits/stdc++.h>
using namespace std;
 
int dx[4] = {-1, 1, -1, 1}, dy[4] = {-1, -1, 1, 1};
 
int main(){
    int t; cin >> t;
    for(int i = 0; i < t; i++){
        int a, b; cin >> a >> b;
        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;
        set<pair<int, int>> st1, st2;
        for(int j = 0; j < 4; j++){
            st1.insert({x1+dx[j]*a, y1+dy[j]*b});
            st2.insert({x2+dx[j]*a, y2+dy[j]*b});
            st1.insert({x1+dx[j]*b, y1+dy[j]*a});
            st2.insert({x2+dx[j]*b, y2+dy[j]*a});
        }
        int ans = 0;
        for(auto x : st1)
            if(st2.find(x) != st2.end())
                ans++;
        cout << ans << '\n';
    }
}
--------------------------------------------------
Problem ID: 1903F
Editorial Content:
1903F - Babysitting
Hint
Use binary search the answer and 2-sat.
Solution
Tutorial is loading...
Code (C++)
#include <bits/stdc++.h>
using namespace std;
typedef int ll;
const ll INF = 1e9+7;
const ll MOD = 998244353;
typedef pair<ll,ll> ii;
#define iii pair<ii,ll>
#define f(i,a,b) for(ll i = a;i < b;i++)
#define pb push_back
#define vll vector<ll>
#define F first
#define S second
#define all(x) (x).begin(), (x).end()
vector<vector<ll> >adj,rev;
vector<ll>order;
vector<ll>vis,comp;
ll c;
ll cur;
ll val(ll idx,bool v){
    return cur + (2 * idx + v);
}
void dfs1(ll idx){
    vis[idx] = true;
    for(auto x:adj[idx]){
        if(!vis[x]){
            dfs1(x);
        }
    }
    order.pb(idx);
}
void dfs2(ll idx){
    comp[idx] = c;
    for(auto x:rev[idx]){
        if(!comp[x]){
            dfs2(x);
        }
    }
}
void build(ll s,ll e,ll idx){
    if(s == e){
        adj[idx].pb(val(s,0));
        rev[val(s,0)].pb(idx);
        return;
    }
    ll mid = (s+e)/2;
    build(s,mid,idx*2);
    build(mid+1,e,idx*2+1);
    adj[idx].pb(idx*2);
    adj[idx].pb(idx*2+1);
    rev[idx*2].pb(idx);
    rev[idx*2+1].pb(idx);
}
void update(ll s,ll e,ll qs,ll qe,ll idx,ll k){
    if(qs <= s && e <= qe){
        adj[val(k,1)].pb(idx);
        rev[idx].pb(val(k,1));
        return;
    }
    if(s > qe || qs > e){
        return;
    }
    ll mid = (s+e)/2;
    update(s,mid,qs,qe,idx*2,k);
    update(mid+1,e,qs,qe,idx*2+1,k);
}
int main(void){
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    ll t;
    cin>>t;
    while(t--){
        ll n,m;
        cin>>n>>m;
        ll u[m],v[m];
        f(i,0,m){
            cin>>u[i]>>v[i];
        }
        ll l = 1,r = n;
        ll ans = 1;
        cur = 4*n;
        while(l <= r){
            ll mid = (l+r)/2;
            order.clear();
            vis.assign(6*n+5,0);
            comp.assign(6*n+5,0);
            adj.assign(6*n+5,vector<ll>());
            rev.assign(6*n+5,vector<ll>());
            f(i,0,m){
                adj[val(u[i],0)].pb(val(v[i],1));
                adj[val(v[i],0)].pb(val(u[i],1));
                rev[val(u[i],1)].pb(val(v[i],0));
                rev[val(v[i],1)].pb(val(u[i],0));
            }
            build(1,n,1);
            f(k,1,n+1){
                ll l = max(1,k - mid + 1),r = k-1;
                update(1,n,l,r,1,k);
                l = k+1;
                r = min(n,k + mid - 1);
                update(1,n,l,r,1,k);
            }
            bool ok = true;
            c = 1;
            f(i,1,n+1){
                if(!vis[val(i,0)]){
                    dfs1(val(i,0));
                }
                if(!vis[val(i,1)]){
                    dfs1(val(i,1));
                }
            }
            reverse(order.begin(),order.end());
            for(auto x:order){
                if(!comp[x]){
                    dfs2(x);
                    c++;
                }
            }
            f(i,1,n+1){
                ok &= comp[val(i,0)] != comp[val(i,1)];
            }
            if(ok){
                l = mid + 1;
                ans = max(ans,mid);
            }
            else{
                r = mid - 1;
            }
        }
        cout<<ans<<"\n";
    }
}
jeroenodb's solution O(M log N)
#pragma GCC optimize("O3")
#include "bits/stdc++.h"
using namespace std;
#define all(x) begin(x),end(x)
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { string sep; for (const T &x : v) os << sep << x, sep = " "; return os; }
#define debug(a) cerr << "(" << #a << ": " << a << ")\n";
typedef long long ll;
typedef vector<int> vi;
typedef vector<basic_string<int>> vvi;
typedef pair<int,int> pi;
const int mxN = 1e5+1, oo = 1e9;
template<int (*merge)(int,int), int (*init)(int)> struct DSU{
    vi sz, dat;
    DSU(int n) : sz(n,-1),dat(n) {
        for(int i=0;i<n;++i) dat[i] = init(i);
    }
    void link(int a, int b) {
        if(sz[a]>sz[b]) {
            swap(a,b);
        }
        sz[a]+=sz[b];
        sz[b]=a;
        dat[a] = merge(dat[a],dat[b]);
    }
    bool unite(int a, int b) {
        int pa = find(a),pb = find(b);
        if(pa!=pb) link(pa,pb);
        return pa!=pb;
    }
    int get(int i) {
        return dat[find(i)];
    }
    int find(int a) {
        if(sz[a]<0) return a;
        return sz[a] = find(sz[a]);
    }
};
int dec(int i) {return i-1;}
int inc(int i) {return i+1;}
int mymin(int a, int b) {return min(a,b);}
int mymax(int a, int b) {return max(a,b);}
bool solve(const vvi& adj, const vvi& rev, int mid) {
    int n = rev.size()/2;

    DSU<mymin, dec> dsuL(n);
    DSU<mymax, inc> dsuR(n);
    auto getL = [&](int i) {
        if(i>=n) i-=n;
        int l = dsuL.get(i);
        if(l==-1 or abs(i-l)>=mid) return 0;
        return l+1;
    };
    auto getR = [&](int i) {
        if(i>=n) i-=n;
        int r = dsuR.get(i);
        if(r==n or abs(i-r)>=mid) return 0;
        return r+1;
    };
    auto rem = [&](int at) {
        if(at>=n) at-=n;
        if(at) dsuR.unite(at-1,at);
        if(at+1<n) dsuL.unite(at,at+1);
    };
    vector<bool> vis(n*2);
    vi ord;
    auto dfs = [&](auto&& self, int at) -> void {
        vis[at]=1;
        if(at<n) {
            while(int l = getL(at)) self(self,l-1+n);
            while(int r = getR(at)) self(self,r-1+n);
        } else rem(at);
        for(int to : adj[at]) if(!vis[to]) self(self,to);
        ord.push_back(at);

    };
    for(int i=0;i<2*n;++i) if(!vis[i]) dfs(dfs,i);
    reverse(all(ord));

    fill(all(vis),0);
    dsuL = DSU<mymin,dec>(n);
    dsuR = DSU<mymax,inc>(n);
    int comp=0;
    vi comps(2*n);
    auto dfs2 = [&](auto&& self, int at) -> void {
        comps[at]=comp;
        vis[at]=1;
        if(at>=n) {
            while(int l = getL(at)) self(self,l-1);
            while(int r = getR(at)) self(self,r-1);
        } else rem(at);
        for(int to : rev[at]) if(!vis[to]) self(self,to);

    };

    for(int i : ord) if(!vis[i]) {
        dfs2(dfs2,i);
        comp++;
    }
    for(int i=0;i<n;++i) if(comps[i]==comps[i+n]) return false;
    return true;


}
void solve() {
    int n,m; cin >> n >> m;
    vvi adj(2*n),rev(2*n);
    auto addE = [&](int u, int v) {
        adj[u].push_back(v);
        rev[v].push_back(u);
    };
    for(int i=0;i<m;++i) {
        int u,v; cin >> u >> v;
        --u,--v;
        addE(u+n,v);
        addE(v+n,u);
    }

    int lo=1,hi=n;
    while(lo<hi) {
        int mid = (lo+hi+1)/2;
        if(solve(adj,rev,mid)) {
            lo= mid;
        } else hi = mid-1;
    }
    cout << lo << '\n';
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int t; cin >> t;
    while(t--) solve();
}
Rate this problem
Good
Mid
Bad
--------------------------------------------------
Problem ID: 1903E
Editorial Content:
1903E - Geo Game
Hint
Do mod $$$2$$$ in all coordinates and see how many different types of points you have in the end.
Solution
Tutorial is loading...
Code (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int sx,sy;
        cin>>sx>>sy;
        int x[n],y[n];
        set<int>p[2];
        for(int i = 0;i < n;i++){
            cin>>x[i]>>y[i];
            p[(x[i] % 2) ^ (y[i] % 2)].insert(i+1);
        }
        int v = (sx % 2) ^ (sy % 2);
        if(p[v].size() >= p[v^1].size()){
            cout<<"First"<<endl;
            v ^= 1;
            for(int i = 0;i < n;i++){
                if(i % 2 == 0){
                    int j;
                    if(!p[v].empty()){
                        j = (*p[v].begin());
                        p[v].erase(j);
                    }
                    else{
                        j = (*p[v^1].begin());
                        p[v^1].erase(j);
                    }
                    cout<<j<<endl;
                }
                else{
                    int j;
                    cin>>j;
                    if(p[0].count(j)){
                        p[0].erase(j);
                    }
                    else{
                        p[1].erase(j);
                    }
                }
            }
        }
        else{
            cout<<"Second"<<endl;
            for(int i = 0;i < n;i++){
                if(i % 2 == 1){
                    int j;
                    if(!p[v].empty()){
                        j = (*p[v].begin());
                        p[v].erase(j);
                    }
                    else{
                        j = (*p[v^1].begin());
                        p[v^1].erase(j);
                    }
                    cout<<j<<endl;
                }
                else{
                    int j;
                    cin>>j;
                    if(p[0].count(j)){
                        p[0].erase(j);
                    }
                    else{
                        p[1].erase(j);
                    }
                }
            }
        }
    }
}
Rate this problem
Good
Mid
Bad
--------------------------------------------------
Problem ID: 1903D2
Editorial Content:
1903D2 - Maximum And Queries (hard version)
Hint
Try optimizing the greedy approach from $$$O$$$($$$n$$$) to $$$O$$$($$$1$$$).
Solution
Tutorial is loading...
Code (C++)
#include<bits/stdc++.h>
using namespace std;
typedef long double ld;
typedef long long ll;
#define rep(a, b) for(ll a = 0; a < (b); ++a)
#define st first
#define nd second
#define pb push_back
#define all(a) a.begin(), a.end()
const int LIM=1e6+7;
ll dpsum[1<<20][20], dpcnt[1<<20], T[LIM];
int main() {
  ios_base::sync_with_stdio(0); cin.tie(0);
  ll n, q;
  cin >> n >> q;
  ll sto=0, sfrom=0;
  rep(i, n) {
    cin >> T[i];
    sto+=(1ll<<20ll)-T[i];
    sfrom+=T[i];
    ++dpcnt[T[i]];
    ll sum=0;
    rep(j, 20) {
      sum+=T[i]&(1ll<<j);
      dpsum[T[i]][j]+=sum;
    }
  }
  rep(i, 20) rep(j, 1<<20) if(!(j&(1<<i))) dpcnt[j]+=dpcnt[j+(1<<i)];
  rep(i, 20) rep(j, 1<<20) if(!(j&(1<<i))) rep(l, 20) dpsum[j][l]+=dpsum[j+(1<<i)][l];
  while(q--) {
    ll k;
    cin >> k;
    if(k>=sto) {
      k+=sfrom;
      cout << k/n << '\n';
      continue;
    }
    ll ans=0;
    for(ll i=19; i>=0; --i) {
      ll x=(n-dpcnt[ans|(1<<i)])*(1ll<<i);
      x-=dpsum[ans][i]-dpsum[ans|(1<<i)][i];
      if(x<=k) {
        k-=x;
        ans|=1<<i;
      }
    }
    cout << ans << '\n';
  }
}
Rate this problem
Good
Mid
Bad
--------------------------------------------------
Problem ID: 1903D1
Editorial Content:
1903D1 - Maximum And Queries (easy version)
Hint
Try using greedy to construct the answer bit by bit.
Solution
Tutorial is loading...
Code (C++)
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
#define rep(a, b) for(int a = 0; a < (b); ++a)
#define st first
#define nd second
#define pb push_back
#define all(a) a.begin(), a.end()
const int LIM=1e5+7;
ll T[LIM], P[LIM], n, k;
void solve() {
  rep(i, n) T[i]=P[i];
  ll ans=0;
  for(ll i=60; i>=0; --i) {
    ll sum=0;
    rep(j, n) {
      if(T[j]&(1ll<<i)) continue;
      ll p=(T[j]/(1ll<<i))*(1ll<<i)+(1ll<<i);
      p+=ans^(p&ans);
      sum+=p-T[j];
      if(sum > k){
          break;
      }
    }
    if(sum>k) continue;
    rep(j, n) {
      if(T[j]&(1ll<<i)) continue;
      ll p=(T[j]/(1ll<<i))*(1ll<<i)+(1ll<<i);
      p+=ans^(p&ans);
      T[j]=p;
    }
    ans+=1ll<<i;
    k-=sum;
  }
  cout << ans << '\n';
}
int main() {
  ios_base::sync_with_stdio(0); cin.tie(0);
  int q;
  cin >> n >> q;
  rep(i, n) cin >> P[i];
  while(q--) {
    cin >> k;
    solve();
  }
}
Rate this problem
Good
Mid
Bad
--------------------------------------------------
Problem ID: 1903C
Editorial Content:
1903C - Theofanis' Nightmare
Hint
Think of suffixes.
Solution
Tutorial is loading...
Code (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int arr[n];
        long long suf[n+1] = {0};
        for(int i = 0;i < n;i++){
            cin>>arr[i];
        }
        for(int i = n-1;i >= 0;i--){
            suf[i] = suf[i+1] + arr[i];
        }
        long long ans = suf[0];
        for(int i = 1;i < n;i++){
            if(suf[i] > 0){
                ans += suf[i];
            }
        }
        cout<<ans<<"\n";
    }
}
Rate this problem
Good
Mid
Bad
--------------------------------------------------
Problem ID: 1903B
Editorial Content:
1903B - StORage room
Hint
Think of each bit independently.
Solution
Tutorial is loading...
Code (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int m[n][n];
        int arr[n];
        for(int i = 0;i < n;i++){
            arr[i] = (1<<30) - 1;
        }
        for(int i = 0;i < n;i++){
            for(int j = 0;j < n;j++){
                cin>>m[i][j];
                if(i != j){
                    arr[i] &= m[i][j];
                    arr[j] &= m[i][j];
                }
            }
        }
        bool ok = true;
        for(int i = 0;i < n;i++){
            for(int j = 0;j < n;j++){
                if(i != j && (arr[i] | arr[j]) != m[i][j]){
                    ok = false;
                }
            }
        }
        if(!ok){
            cout<<"NO\n";
        }
        else{
            cout<<"YES\n";
            for(int i = 0;i < n;i++){
                cout<<arr[i]<<" ";
            }
            cout<<"\n";
        }
    }
}
Rate this problem
Good
Mid
Bad
--------------------------------------------------
Problem ID: 1903A
Editorial Content:
1903A - Halloumi Boxes
Hint
If $$$k$$$ is greater or equal to $$$2$$$ you can always swap adjacent elements.
Solution
Tutorial is loading...
Code (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        int n,k;
        cin>>n>>k;
        int arr[n];
        for(int i = 0;i < n;i++){
            cin>>arr[i];
        }
        if(is_sorted(arr,arr+n) || k > 1){
            cout<<"YES\n";
        }
        else{
            cout<<"NO\n";
        }
    }
    return 0;
}
Rate this problem
Good
Mid
Bad
--------------------------------------------------
Problem ID: 1902F
Editorial Content:
1902F - Trees and XOR Queries Again
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
const int N = 200043;
const int K = 20;
 
typedef array<int, K> base;
int a[N];
vector<int> g[N];
vector<int> path_up[N];
int tin[N], tout[N];
int T = 0;
int fup[N][K];
 
base make_empty()
{
    base b;
    for(int i = 0; i < K; i++)
        b[i] = 0;
    return b;
}
 
int reduce(const base& b, int x)
{
    for(int i = K - 1; i >= 0; i--)
        if(x & (1 << i))
            x ^= b[i];
    return x;
}   
 
bool add(base& b, int x)
{
    x = reduce(b, x);
    if(x != 0)
    {
        for(int i = K - 1; i >= 0; i--)
            if(x & (1 << i))
            {
                b[i] = x;
                return true;
            }
    }   
    return false;
}
 
bool check(const base& b, int x)
{
    return reduce(b, x) == 0;
}
 
vector<int> rebuild_path(const vector<int>& path, int v)
{
    base b = make_empty();
    vector<int> ans;
    if(add(b, a[v])) ans.push_back(v);
    for(auto x : path) if(add(b, a[x])) ans.push_back(x);
    return ans;
}
 
void dfs(int v, int u)
{
    tin[v] = T++;      
    if(u == v)
        path_up[v] = rebuild_path(vector<int>(0), v);
    else
        path_up[v] = rebuild_path(path_up[u], v);
    fup[v][0] = u;
    for(int i = 1; i < K; i++)
        fup[v][i] = fup[fup[v][i - 1]][i - 1];
    for(auto y : g[v])
        if(y != u)
            dfs(y, v);
    tout[v] = T++;   
}
 
bool is_ancestor(int u, int v)
{
    return tin[u] <= tin[v] && tout[u] >= tout[v];
}
 
int LCA(int x, int y)
{
    if(is_ancestor(x, y)) return x;
    for(int i = K - 1; i >= 0; i--)
        if(!is_ancestor(fup[x][i], y))
            x = fup[x][i];
    return fup[x][0];
}
 
bool query(int x, int y, int k)
{
    base b = make_empty();
    int z = LCA(x, y);
    for(auto v : path_up[x])
        if(!is_ancestor(v, y))
            add(b, a[v]);
    for(auto v : path_up[y])
        if(!is_ancestor(v, x))
            add(b, a[v]);
    add(b, a[z]);
    return check(b, k);            
}
 
int main()
{
    int n;
	scanf("%d", &n);
	for(int i = 0; i < n; i++) scanf("%d", &a[i]);
	for(int i = 0; i < n - 1; i++)
	{
		int x, y;
		scanf("%d %d", &x, &y);
		--x;
		--y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	dfs(0, 0);
	int q;
	scanf("%d", &q);
	for(int i = 0; i < q; i++)
	{
		int x, y, k;
		scanf("%d %d %d", &x, &y, &k);
		--x;
		--y;
		if(query(x, y, k)) puts("YES");
		else puts("NO");
	}
}
--------------------------------------------------
Problem ID: 1902E
Editorial Content:
1902E - Collapsing Strings
Tutorial
Tutorial is loading...
Solution (Roms)
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = int(1e6) + 99;
 
int nxt;
int to[N][26];
int sum[N];
long long res;
 
void add(const string& s) {
    int v = 0;
    ++sum[v];
    for (auto c : s) {
        int i = c - 'a';
        if (to[v][i] == -1)
            to[v][i] = nxt++;
        v = to[v][i];
        ++sum[v];
    }
}
 
void upd(const string& s) {
    int curLen = s.size();
    int v = 0;
    
    for (auto c : s) {
        int i = c - 'a';
        if (to[v][i] == -1) {
            res += sum[v] * 1LL * curLen;
            break;
        } else {
            int nxtV = to[v][i];
            res += (sum[v] - sum[nxtV]) * 1LL * curLen;
            --curLen;
            v = nxtV;
        }
    }
}
 
void solve(int n, vector <string> v) {
    int sumSizes = 0;
    for (int i = 0; i < n; ++i)
        sumSizes += v[i].size();
        
    nxt = 1;
    memset(sum, 0, sizeof sum);
    memset(to, -1, sizeof to);
    
    for(int i = 0; i < n; ++i) 
        add(v[i]);
    for (int i = 0; i < n; ++i) {
        reverse(v[i].begin(), v[i].end());
        upd(v[i]);
    }
}
 
int main() {
    ios_base::sync_with_stdio(false);
    int n;
    cin >> n;
    vector <string> v(n);
    for (int i = 0; i < n; ++i) 
        cin >> v[i];
    
    res = 0;
    solve(n, v);
    for(int i = 0; i < n; ++i)
        reverse(v[i].end(), v[i].end());
    solve(n, v);
    
    cout << res << endl;
    
    return 0;
}
--------------------------------------------------
Problem ID: 1902D
Editorial Content:
1902D - Robot Queries
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
#define x first
#define y second
 
using pt = pair<int, int>;
 
int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int n, q;
  cin >> n >> q;
  string s;
  cin >> s;
  vector<pt> pos(n + 1);
  for (int i = 0; i < n; ++i) {
    pos[i + 1].x = pos[i].x + (s[i] == 'R') - (s[i] == 'L');
    pos[i + 1].y = pos[i].y + (s[i] == 'U') - (s[i] == 'D');
  }
  map<pt, vector<int>> mp;
  for (int i = 0; i <= n; ++i) mp[pos[i]].push_back(i);
  auto check = [&](pt p, int l, int r) {
  	if (!mp.count(p)) return false;
  	auto it = lower_bound(mp[p].begin(), mp[p].end(), l);
  	return it != mp[p].end() && *it <= r;
  };
  while (q--) {
  	int x, y, l, r;
  	cin >> x >> y >> l >> r;
  	int nx = pos[r].x + pos[l - 1].x - x, ny = pos[r].y + pos[l - 1].y - y;
  	bool f = check({x, y}, 0, l - 1)
  	       | check({nx, ny}, l, r - 1)
  	       | check({x, y}, r, n);
  	cout << (f ? "YES" : "NO") << '\n';
  }
}
--------------------------------------------------
Problem ID: 1902C
Editorial Content:
1902C - Insert and Equalize
Tutorial
Tutorial is loading...
Solution (awoo)
from math import gcd
 
for _ in range(int(input())):
	n = int(input())
	a = list(map(int, input().split()))
	g = 0
	for i in range(n - 1):
		g = gcd(g, a[i + 1] - a[i])
	g = max(g, 1)
	a.sort()
	j = n - 1
	res = a[-1]
	while True:
		while j >= 0 and a[j] > res:
			j -= 1
		if j < 0 or a[j] != res:
			break
		res -= g
	print((a[-1] * (n + 1) - (sum(a) + res)) // g)
--------------------------------------------------
Problem ID: 1902B
Editorial Content:
1902B - Getting Points
Tutorial
Tutorial is loading...
Solution (adedalic)
fun main(args: Array<String>) {
    repeat(readln().toInt()) {
        val (n, p, l, t) = readln().split(' ').map { it.toLong() }
        val cntTasks = (n + 6) / 7
        
        fun calc(k: Long) = k * l + minOf(2 * k, cntTasks) * t
        var lf = 0L
        var rg = n
        while (rg - lf > 1) {
            val mid = (lf + rg) / 2
            if (calc(mid) >= p)
                rg = mid
            else
                lf = mid
        }
        println(n - rg)
    }
}
--------------------------------------------------
Problem ID: 1902A
Editorial Content:
1902A - Binary Imbalance
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	n = int(input())
	s = input()
	print("NO" if s.count('1') == n else "YES")
--------------------------------------------------
Problem ID: 1901F
Editorial Content:
1901F - Landscaping
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>
 
using namespace std;
 
#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define sz(a) int((a).size())
#define all(a) (a).begin(), (a).end()
 
#define x first
#define y second
 
typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;
 
template<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {
	return out << "(" << p.x << ", " << p.y << ")";
}
template<class A> ostream& operator <<(ostream& out, const vector<A> &v) {
	fore(i, 0, sz(v)) {
		if(i) out << " ";
		out << v[i];
	}
	return out;
}
 
pt operator+ (const pt &a, const pt &b) {
	return {a.x + b.x, a.y + b.y};
}
pt operator- (const pt &a, const pt &b) {
	return {a.x - b.x, a.y - b.y};
}
li operator *(const pt &a, const pt &b) {
	return a.x * 1ll * b.x + a.y * 1ll * b.y;
}
li operator %(const pt &a, const pt &b) {
	return a.x * 1ll * b.y - a.y * 1ll * b.x;
}
 
const int INF = int(1e9);
const li INF64 = li(1e18);
const ld EPS = 1e-9;
 
int n;
vector<pt> old, nw;
 
inline bool read() {
	if(!(cin >> n))
		return false;
	old.resize(n);
	nw.resize(n);
	fore (i, 0, n) {
		old[i].x = i;
		cin >> old[i].y;
	}
	fore (i, 0, n) {
		nw[i].x = i;
		cin >> nw[i].y;
	}
	return true;
}
 
inline ld getTr(const pt &a, const pt &b) {
	pt tmp = b - a;
	pt v = {-tmp.y, tmp.x};
	ld c = v * a;
	ld y0 = (c - v.x * 0) / v.y;
	ld y1 = (c - v.x * li(n - 1)) / v.y;
	return (y0 + y1);
}
 
vector<pt> hull(const vector<pt> &ps, int l, int r) {
	vector<pt> h;
	fore (i, l, r) {
		while (sz(h) > 1 && (h[sz(h) - 1] - h[sz(h) - 2]) % (ps[i] - h[sz(h) - 1]) >= 0)
			h.pop_back();
		h.push_back(ps[i]);
	}
	return h;
}
 
inline void solve() {
	vector<ld> maxTr(n - 1, 0);
	fore (t, 0, 2) {
		auto h = hull(old, n / 2, n);
 
		auto best = [&](const pt &p) {
			int l = -1, r = sz(h) - 1;
			while (r - l > 1) {
				int mid = (l + r) >> 1;
				if ((h[mid] - p) % (h[mid + 1] - h[mid]) >= 0)
					l = mid;
				else
					r = mid;
			}
			return h[r].x;
		};
		
		vector<ld> bs(n / 2 + 1, 0);
		for (int i = n / 2 - 1; i >= 0; i--) {
			int j = best(old[i]);
			bs[i] = getTr(old[i], old[j]);
			bs[i] = max(bs[i], bs[i + 1]);
		}
		
		ld lans = 0;
		fore (i, 0, n / 2) {
			int j = best(nw[i]);
			lans = max(lans, getTr(nw[i], old[j]));
			maxTr[i] = max({maxTr[i], lans, bs[i + 1]});
		}
		
		reverse(all(old));
		reverse(all(nw));
		swap(old, nw);
		fore (i, 0, n)
			old[i].x = nw[i].x = i;
		
		reverse(all(maxTr));
	}
			
	maxTr.push_back(maxTr.back());
	cout << maxTr << endl;
}
 
int main() {
#ifdef _DEBUG
	freopen("input.txt", "r", stdin);
	int tt = clock();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(12);
	
	if(read()) {
		solve();
		
#ifdef _DEBUG
		cerr << "TIME = " << clock() - tt << endl;
		tt = clock();
#endif
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1901E
Editorial Content:
1901E - Compressed Tree
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
using li = long long;
 
const li INF = 1e18;
const int N = 555555;
 
int n;
int a[N];
vector<int> g[N];
li dp[N];
li ans;
 
void calc(int v, int p) {
  vector<li> sum(4, -INF);
  sum[0] = 0;
  for (int u : g[v]) if (u != p) {
    calc(u, v);
    for (int i = 3; i >= 0; --i) {
      sum[min(i + 1, 3)] = max(sum[min(i + 1, 3)], sum[i] + dp[u]);
    }
  }
  dp[v] = -INF;
  for (int j = 0; j < 4; ++j) {
    dp[v] = max(dp[v], sum[j] + (j == 1 ? 0 : a[v]));
    ans = max(ans, sum[j] + (j == 2 ? 0 : a[v]));
  }
}
 
int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    cin >> n;
    for (int i = 0; i < n; ++i) cin >> a[i];
    for (int i = 0; i < n; ++i) g[i].clear();
    for (int i = 0; i < n - 1; ++i) {
      int x, y;
      cin >> x >> y;
      --x; --y;
      g[x].push_back(y);
      g[y].push_back(x);
    }
    ans = 0;
    calc(0, -1);
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1901D
Editorial Content:
1901D - Yet Another Monster Fight
Tutorial
Tutorial is loading...
Solution (vovuh)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
#ifdef _DEBUG
    freopen("input.txt", "r", stdin);
//  freopen("output.txt", "w", stdout);
#endif
    
    int n;
    cin >> n;
    vector<int> a(n);
    for (auto &it : a) cin >> it;
    
    vector<int> pref(n), suf(n);
    for (int i = 0; i < n; ++i) {
        pref[i] = a[i] + (n - i - 1);
        suf[i] = a[i] + i;
    }
    for (int i = 1; i < n; ++i) {
        pref[i] = max(pref[i], pref[i - 1]);
    }
    for (int i = n - 2; i >= 0; --i) {
        suf[i] = max(suf[i], suf[i + 1]);
    }
    
    int ans = 2e9;
    for (int i = 0; i < n; ++i) {
        int cur = a[i];
        if (i > 0) cur = max(cur, pref[i - 1]);
        if (i + 1 < n) cur = max(cur, suf[i + 1]);
        ans = min(ans, cur);
    }
    
    cout << ans << endl;
    
    return 0;
}
--------------------------------------------------
Problem ID: 1901C
Editorial Content:
1901C - Add, Divide and Floor
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	n = int(input())
	a = list(map(int, input().split()))
	x, y = min(a), max(a)
	res = []
	while x != y:
		res.append(x % 2)
		x = (x + res[-1]) // 2
		y = (y + res[-1]) // 2
	print(len(res))
	if len(res) <= n:
		print(*res)
--------------------------------------------------
Problem ID: 1901B
Editorial Content:
1901B - Chip and Ribbon
Tutorial
Tutorial is loading...
Solution (Roms)
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 200'000;
 
int t;
 
int main() {
    cin >> t;
    for (int tc = 0; tc < t; ++tc) {
        int n;
        cin >> n;
        vector <int> cnt(n);
        long long res = 0;
        int cur = 0;
        for (int i = 0; i < n; ++i) {
            cin >> cnt[i];
            if (cnt[i] > cur) 
                res += cnt[i] - cur;
            cur = cnt[i];
        }
        
        cout << res - 1 << endl;
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1901A
Editorial Content:
1901A - Line Trip
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    int n, x;
    cin >> n >> x;
    int prev = 0, ans = 0;
    for (int i = 0; i < n; ++i) {
      int a; cin >> a;
      ans = max(ans, a - prev);
      prev = a;
    }
    ans = max(ans, 2 * (x - prev));
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1900F
Editorial Content:
1900F - Local Deletions
Hint 1
Solve the problem for $$$q=1$$$.
Hint 2
We can just simulate the process. Each operation removes at least half of the elements, meaning that we will perform at most $$$log n$$$ operations.
Hint 3
Solve the problem if each $$$l_i = 1$$$. So basically, solve the problem for each prefix.
Hint 4
Keep values that are in the array after $$$1$$$, $$$2$$$, $$$3$$$, $$$\cdots$$$, $$$log n$$$ operations. Let's call those array's layers. Layer $$$0$$$ is an array after $$$0$$$ operations, layer $$$1$$$ after $$$1$$$ operation, and so on. When we add a value to the end of the layer, only $$$1$$$ number that was previously local extreme (local minimum or maximum, depending on layer) might unbecome local extreme if the new value becomes local extreme. So we can just propagate this update to all layers.
Hint 5
Try to simulate the process of updating described in hint $$$4$$$. Also, notice that if the array is longer than $$$3$$$, we can handle prefix and suffix updates separately.
Solution
Read the hints.
Now we will precompute and store the array after each operation on the entire permutation. We will call those array layers.
We can now solve queries in $$$O(log n)$$$.
If a query involves a small number of elements, we can just brute force it. Otherwise, we do the following:
Now let's define our queries a bit differently. We are given some array $$$x$$$, which will be a subarray of some layer, and $$$2$$$ values, $$$a$$$ and $$$b$$$. We will get array $$$y$$$ by appending $$$a$$$ to the start of $$$x$$$ and appending $$$b$$$ to the end of $$$x$$$. We are interested in the value of $$$f$$$($$$y$$$). It is easy to see that all queries involving $$$3$$$ or more elements can be converted into the modified query.
If $$$|y|$$$ is small, we can just brute force it. Otherwise, we can transform it into a query on the next layer in constant time, or in $$$O(log n)$$$.
Now, the first thing to notice is that all elements in $$$x$$$ that are neither first nor last will be deleted only if they were deleted when we performed operations on the whole permutation. That means that they will represent some interval on the next layer, let's call it $$$z$$$. (That interval can be found either with binary search or in $$$O(1)$$$ with precomputation) It holds that $$$ |z| $$$ is around half of $$$|x|$$$. Now, notice that among $$$a$$$ and the first element of $$$x$$$, there has to be at least one deletion. The same goes for the last element of $$$x$$$ and $$$b$$$.
So now we have transformed the query onto the next level in $$$O(1)$$$, or $$$O(log n)$$$. As we will do at most $$$O(log n)$$$ such transformations, the complexity of a single query is either $$$O(log n)$$$ or $$$O(log^2 n)$$$ depending on the way we find the next interval, both of which should be fast enough to pass.
Total time complexity: $$$O(n + q log n)$$$ or $$$O(n + q log^2 n)$$$. Total memory complexity: $$$O(n+q)$$$
Bonus
Imagine that you already decided for each layer which indices will be on it. Come up with a generator that will uniformly randomly pick one permutation that satisfies those conditions.
--------------------------------------------------
Problem ID: 1900E
Editorial Content:
1900E - Transitive Graph
Hint 1
Try to simplify graph $$$H$$$.
Hint 2
Look at strongly connected components of $$$G$$$, and what happens with them.
Hint 3
Use dp to find the answer.
Solution
The main observation is what $$$H$$$ looks like. All the strongly connected components (SCC) in $$$G$$$ will become fully connected subgraphs in $$$H$$$. Secondly, take any two vertices $$$a$$$ and $$$b$$$ such that $$$a$$$ and $$$b$$$ are not in the same SCC. We can let $$$S_a$$$ be a set of vertices that are in the same SCC as $$$a$$$ ($$$a$$$ included). Similarly, $$$S_b$$$ is a set of vertices that are in the same SCC as $$$b$$$. If there is an edge going from $$$a$$$ to $$$b$$$, then for any two vertices $$$x$$$ and $$$y$$$ such that $$$x$$$ belongs to $$$S_a$$$ and $$$y$$$ belongs to $$$S_b$$$, there is an edge going from $$$x$$$ to $$$y$$$. Both of the previously stated facts about the graph can be proven by induction.
Now, let's say that there is the longest path that goes through at least one vertex of an SCC. Then that path goes through all the vertices in the SCC, due to all vertices in SCC being connected to the same vertices outside the SCC and due to the fact that SCC is a complete subgraph.
Now we can construct the graph $$$H'$$$. Each of the SCCs from $$$H$$$ will be a vertex in $$$H'$$$. The number on the vertex will be equal to the sum of all numbers on the vertices of the SCC that it was constructed from. Edges between two new vertexes will be added if there is an edge between their original SCCs. The edge will have a weight equal to the size of the SCC that it is going into. An additional vertex will be added at index $$$0$$$ and an edge will be made between it and all other vertices with $$$0$$$ ingoing edges. Weight will be determined based on the size of the SCC of the vertex that the edge is going into.
Due to the previous observations, the answer for the $$$H'$$$ will be the same as the answer for the $$$H$$$. However, notice that $$$H'$$$ is a DAG. That means that the answer for it can be computed using DP after topological ordering.
Total time and memory complexity is $$$O(n)$$$.
Bonus
We will define the value of the path as the biggest value of a vertex on the path. Among the values of all the longest paths, find the median one. It is guaranteed that there are at most $$$10^{18}$$$ longest paths starting from each node. (So basically, you can ignore overflow in the number of paths) The rest of the constraints are the same.
--------------------------------------------------
Problem ID: 1900D
Editorial Content:
1900D - Small GCD
Hint 1
Let $$$m$$$ be the biggest value in the array. Calculate array $$$x$$$ such that $$$x_i$$$ ($$$1 \le i \le m$$$) is the number of triples which have $$$\gcd$$$ of $$$i$$$. Then the answer is the sum of $$$i \cdot x_i$$$ over all $$$i$$$ ($$$1 \le i \le m$$$).
Hint 2
Value of $$$\lfloor \frac{m}{1} \rfloor + \lfloor \frac{m}{2} \rfloor + \lfloor \frac{m}{3} \rfloor + \ldots + \lfloor \frac{m}{m} \rfloor$$$ is around $$$m log m$$$.
Solution part 1
We calculate $$$x_i$$$ from $$$x_m$$$ to $$$x_1$$$. For some $$$i$$$, we can first calculate the number of triples that have a value of function $$$f$$$ that is an integer multiple of $$$i$$$, and then from it subtract $$$x_{2i}, x_{3i}, x_{4i} \ldots$$$. Because of the previous hint, the subtractions will be quite fast.
Now the question is how to calculate the number of triples that have a value of function $$$f$$$ that is an integer multiple of $$$i$$$.
Hint 3
Numbers up to $$$100\,000$$$ can have at most $$$128$$$ divisors.
The rest of the solution
As the order in which numbers are given does not matter, we can sort the array. Now for each number $$$d$$$ ($$$1 \le d \le M$$$) store indices of all numbers that are divisible by $$$d$$$ in an array of vectors. Now we will for each number $$$d$$$ ($$$1 \le d \le m$$$) count the number of triples.
To find the number of triples that have a gcd value that is an integer multiple of $$$d$$$, we can do the following. We go over the index of the number that will be value $$$b$$$ in the function. We can utilize the vectors we calculated in the previous step for that. Say that the current index is $$$i$$$. Then for value $$$c$$$ we can pick any number with an index larger than $$$i$$$ as the array is sorted. For value $$$a$$$, we can pick any of the numbers divisible by $$$d$$$ with an index less than $$$i$$$, the number of which we can get from the vector. By multiplying those $$$2$$$ numbers we get the number of triples that have $$$a_i$$$ as their middle value.
As numbers can have up to $$$128$$$ divisors, the step above is quite fast.
Total time complexity is $$$O(m log m + n log n + 128 \cdot n)$$$. Total memory complexity is $$$O(m + 128 \cdot n)$$$.
Bonus
Solve the problem if $$$f(a,b,c) = \gcd (a,c)$$$.
--------------------------------------------------
Problem ID: 1900C
Editorial Content:
1900C - Anji's Binary Tree
Hint 1
Solve the problem if all of the characters on vertices are 'U'.
Hint 2
We can run DFS from the root. Using it we can calculate the number of edges that we have to traverse to get to every edge. Just output the smallest value among all the leaves.
Hint 3
Modify the DFS such that it takes into account that traversing some edges does not require an operation.
Hint 4
Add weights to the edges.
Solution
Read the hints.
We will make edges from a vertex to its children. The weight of that edge will be $$$1$$$ unless one of the following holds:
The weight of an edge between a vertex and its left child will be $$$0$$$ if the letter written on that vertex is 'L'.
The weight of an edge between a vertex and its right child will be $$$0$$$ if the letter written on that vertex is 'R'.
Now we run a modified DFS to find the distance of each vertex from the root, but with weighted edges. We output the minimal value among all the leaves.
Time and memory complexities are $$$O(N)$$$.
Bonus
Solve the problem if after reaching a leaf, Keksic can teleport to any other leaf that he chooses and then needs to get back to the root, or report that it is impossible for him to complete such a travel.
--------------------------------------------------
Problem ID: 1900B
Editorial Content:
1900B - Laura and Operations
Hint 1
Check if only digits $$$1$$$ can remain. The situation is similar for checking if only digits $$$2$$$ or only digits $$$3$$$ can remain.
Hint 2
Try to find something that stays the same after each operation.
Hint 3
Look at the parity of the numbers.
Hint 4
The parity of each number changes after an operation. That means that if $$$2$$$ numbers have the same parity, they will always have the same parity. If they had different parity, their parities stay different.
Solution
Read the hints.
If the parity of $$$b$$$ and $$$c$$$ is not the same, then it is impossible for only digits $$$1$$$ to remain on the board, as it would require $$$b = c = 0$$$. Otherwise, the following construction will leave only digits $$$1$$$ on the board.
First remove digits $$$2$$$ and $$$3$$$ and write digit $$$1$$$ while $$$b>0$$$ and $$$c>0$$$. If $$$b=c$$$, then we are done. Otherwise, without loss of generality assume $$$b>c$$$. That means that after the operations $$$c=0$$$ and $$$b$$$ is even (Because $$$b$$$ and $$$c$$$ are the same parity). Now we perform the following $$$2$$$ operations $$$\frac{b}{2}$$$ times to get only digits $$$1$$$ left. Remove digits $$$1$$$ and $$$2$$$ and add digit $$$3$$$. After that remove digits $$$2$$$ and $$$3$$$ and add digit $$$1$$$. An effective change of these $$$2$$$ operations is the reduction of $$$b$$$ by $$$2$$$.
Time and memory complexities are $$$O(1)$$$.
Bonus
Come up with a problem that uses a similar idea and try to solve it. A lot of beginner problems use a similar idea.
--------------------------------------------------
Problem ID: 1900A
Editorial Content:
1900A - Cover in Water
Hint 1
Assume that cells $$$i-1$$$, $$$i$$$, and $$$i+1$$$ are covered in water. What happens if you remove water from cell $$$i$$$?
Hint 2
The water at position $$$i$$$ is replaced as both cells $$$i-1$$$ and $$$i+1$$$ have water in them.
Solution
Read the hints.
If there are 3 consecutive empty cells $$$i-1$$$, $$$i$$$, $$$i+1$$$, we can place water in cells $$$i-1$$$ and $$$i+1$$$ and then move water from cell $$$i$$$ to all other cells. If there are no such cells, we have to place water on every empty cell.
So if we find substring ''...'' in the array, the answer is $$$2$$$, otherwise the answer is the number of empty cells.
Time and memory complexities are $$$O(N)$$$.
Bonus
Solve the problem if it is required that each cell is filled with water, or next to at least $$$1$$$ cell that is filled with water.
--------------------------------------------------
Problem ID: 1899G
Editorial Content:
1899G — Unusual Entertainment
Editorial
Let's start the depth-first search from vertex $$$1$$$ and write out the entry and exit times for each vertex. Then, the fact that vertex $$$b$$$ is a descendant of vertex $$$a$$$ is equivalent to the fact that $$$\mathrm{tin}[a] \leq \mathrm{tin}[b] \leq \mathrm{tout}[b] \leq \mathrm{tout}[b] \leq \mathrm{tout}[a]$$$, where $$$\mathrm{tin}$$$ and $$$\mathrm{tout}$$$ — entry and exit times, respectively. Then, let us create an array $$$a$$$, where $$$a_i = \mathrm{tin}[p_i]$$$, then the problem is reduced to checking that on the segment c $$$l$$$ through $$$r$$$ in array $$$a$$$ there is at least one number belonging to the segment $$$[\mathrm{tin}[x]; \mathrm{tout}[x]]$$$. This can be done, for example, using Merge Sort Tree, then the total complexity will be $$$O(n \log n + q \log^ 2 n)$$$.
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define sz(x) (int)x.size()
#define all(x) x.begin(), x.end()
 
struct SegmentTree {
    int n;
    vector<vector<int>> tree;
 
    void build(vector<int> &a, int x, int l, int r) {
        if (l + 1 == r) {
            tree[x] = {a[l]};
            return;
        }
 
        int m = (l + r) / 2;
        build(a, 2 * x + 1, l, m);
        build(a, 2 * x + 2, m, r);
        merge(all(tree[2 * x + 1]), all(tree[2 * x + 2]), back_inserter(tree[x]));
    }
 
    SegmentTree(vector<int>& a) : n(a.size()) {
        int SIZE = 1 << (__lg(n) + bool(__builtin_popcount(n) - 1));
        tree.resize(2 * SIZE - 1);
        build(a, 0, 0, n);
    }
 
    int count(int lq, int rq, int mn, int mx, int x, int l, int r) {
        if (rq <= l || r <= lq) return 0;
        if (lq <= l && r <= rq) return lower_bound(all(tree[x]), mx) - lower_bound(all(tree[x]), mn);
 
        int m = (l + r) / 2;
        int a = count(lq, rq, mn, mx, 2 * x + 1, l, m);
        int b = count(lq, rq, mn, mx, 2 * x + 2, m, r);
        return a + b;
    }
 
    int count(int lq, int rq, int mn, int mx) {
        return count(lq, rq, mn, mx, 0, 0, n);
    }
};
 
vector<vector<int>> g;
 
vector<int> tin, tout;
int timer;
void dfs(int v, int p) {
    tin[v] = timer++;
    for (auto u : g[v]) {
        if (u != p) {
            dfs(u, v);
        }
    }
    tout[v] = timer;
}
 
void solve() {
    int n, q;
    cin >> n >> q;
    
    g.assign(n, vector<int>());
    for (int i = 0; i < n - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--; v--;
        g[u].push_back(v);
        g[v].push_back(u);
    }
 
    timer = 0;
    tin.resize(n);
    tout.resize(n);
    dfs(0, -1);
    
    vector<int> p(n);
    for (int i = 0; i < n; i++) cin >> p[i];
 
    vector<int> a(n);
    for (int i = 0; i < n; i++) a[i] = tin[p[i] - 1];
    SegmentTree ST(a);
 
    for (int i = 0; i < q; i++) {
        int l, r, x;
        cin >> l >> r >> x;
        l--; x--;
        if (ST.count(l, r, tin[x], tout[x])) {
            cout << "YES\n";
        } else {
            cout << "NO\n";
        }
    }
}
 
int main() {
    int tests;
    cin >> tests;
    while (tests--) {
        solve();
        if(tests > 0) cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1899F
Editorial Content:
1899F — Alex's whims
Editorial
This problem can be solved in several similar ways, one of them is given below. First, it is most convenient to take a bamboo — vertices from $$$1$$$ to $$$n$$$ connected in order. Then, we will maintain the following construction. At each moment of time, vertices $$$1$$$ and $$$2$$$ will be connected by an edge, from vertex $$$2$$$ there will be at most two branches, which are sequentially connected vertices (bamboo). Thus, at any given time there will be at most three leaves in the tree, one of which is vertex $$$1$$$.
We will maintain vertices from two branches in two arrays. Then, let the current number from the query be $$$d$$$. If the distance from any of the leaves to vertex $$$1$$$ is $$$d$$$, we don't need to perform the operation. Otherwise, let's do the operation so that the distance from a leaf from, for example, the first branch to vertex $$$1$$$ is equal to $$$d$$$. If the current distance is greater than $$$d$$$, then we remove the extra vertices to the end of the second branch, and otherwise we add the necessary ones from the end of the second branch. Thus, after each operation, the distance from vertex $$$1$$$ to some of the sheets will be equal to $$$d$$$.
Transformations can be done by completely moving vertices, then the total complexity — $$$O(nq)$$$.
Solution
#include<bits/stdc++.h>
using namespace std;

int main() {
	int t;
	cin >> t;
	while (t--) {
		int n;
		cin >> n;
		vector<int> b1, b2;
		for (int i = 0; i < n; ++i) {
			b1.push_back(i);
		}
		b2.push_back(1);
		for (int i = 1; i < n; ++i) {
			cout << i << ' ' << i + 1 << endl;
		}
		int q;
		cin >> q;
		while (q--) {
			int d;
			cin >> d;
			d++;
			if (b1.size() == d) {
				cout << "-1 -1 -1\n";
			} else if (b1.size() < d) {
				d = d - b1.size();
				vector<int> qq(b2.end() - d, b2.end());
				int u = b2[b2.size() - d];
				int v1 = b2[b2.size() - d - 1];
				int v2 = b1.back();
				cout << u + 1 << ' ' << v1 + 1 << ' ' << v2 + 1 << '\n';
				for (int i = 0; i < d; ++i) b2.pop_back();
				for (auto i : qq) b1.push_back(i);
			} else {
				d = b1.size() - d;
				vector<int> qq(b1.end() - d, b1.end());
				int u = b1[b1.size() - d];
				int v1 = b1[b1.size() - d - 1];
				int v2 = b2.back();
				cout << u + 1 << ' ' << v1 + 1 << ' ' << v2 + 1 << '\n';
				for (int i = 0; i < d; ++i) b1.pop_back();
				for (auto i : qq) b2.push_back(i);
			}
		}
	}
}
--------------------------------------------------
Problem ID: 1899E
Editorial Content:
1899E — Queue Sort
Editorial
Consider the position of the first minimum in the array, let it be equal to $$$k$$$. All elements standing on positions smaller than $$$k$$$ are strictly greater, so we must apply operations to them, because otherwise the array will not be sorted. Suppose we have applied operations to all such elements, they have taken some positions after $$$k$$$ (since they are strictly greater than the minimum), i.e. now the minimum element that moved from position $$$k$$$ is at the beginning of the array. If we apply the operation to it, it will return to its current position, since it is less than or equal to all elements of the array, i.e. the array will not change.
Thus, after the array has its minimum at the beginning, it is useless to apply operations, and all the operations applied before that will move the element from the beginning of the array to some position after the position of the first minimum.
Then, if the part of the array after the position $$$k$$$ is not sorted, the answer is $$$-1$$$, because it is impossible to change the order of elements in it. Otherwise, the answer is equal to the number of elements standing before the first minimum, since the operation must be applied to them and they will be in the right place in the right part. Total complexity — $$$O(n)$$$.
Solution
def solve():
    n = int(input())
    a = [int(x) for x in input().split()]
    fm = 0
    for i in range(n):
        if a[i] < a[fm]:
            fm = i
    for i in range(fm + 1, n):
        if a[i] < a[i - 1]:
            print(-1)
            return
    print(fm)
 
 
for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1899D
Editorial Content:
1899D — Yarik and Musical Notes
Editorial
The problem requires to count the number of pairs of indices $$$(i, j)$$$ ($$$i < j$$$) such that $$$(2^a)^{(2^b)} = (2^b)^{(2^a)}$$$, where $$$a = b_i, b = b_j$$$. Obviously, when $$$a = b$$$ this equality is satisfied. Let $$$a \neq b$$$, then rewrite the equality: $$$(2^a)^{(2^b)} = (2^b)^{(2^a)} \Leftrightarrow 2^{(a \cdot 2^b)} = 2^{(b \cdot 2^a)} \Leftrightarrow a \cdot 2^b = b \cdot 2^a \Leftrightarrow \frac{a}{b} = \frac{2^a}{2^b}$$$. Obviously, $$$a$$$ and $$$b$$$ must differ by powers of two, otherwise the equality cannot be satisfied, since the ratio of powers of two is on the right. Without loss of generality, suppose that $$$b = a \cdot 2^k$$$ ($$$k > 0$$$), then the equation takes the form $$$\frac{a}{a \cdot 2^k} = \frac{2^a}{2^{a \cdot 2^k}} \Leftrightarrow \frac{1}{2^k} = \frac{1}{2^{(2^k - 1)a}} \Leftrightarrow 2^k = 2^{(2^k - 1)a}$$$. If $$$k = 1$$$, then $$$a = 1$$$, $$$b = 2$$$. If $$$k > 1$$$, then $$$2^k - 1 > k$$$, and so the equality cannot be satisfied.
Thus, the only possible cases where the equality is satisfied are if $$$b_i = b_j$$$ or $$$b_i = 1, b_j = 2$$$ (and vice versa). The number of such pairs can be counted for $$$O(n \log n)$$$.
Solution
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
 
void solve() {
	int n;
	cin >> n;
	vector<int> a(n);
	for (int& x : a) cin >> x;
	ll ans = 0;
	map<int, int> cnt;
	for (int i = 0; i < n; i++) {
		ans += cnt[a[i]];
		if (a[i] == 1) ans += cnt[2];
		else if (a[i] == 2) ans += cnt[1];
		cnt[a[i]]++;
	}
	cout << ans << "\n";
}
 
signed main() {
	int t;
	cin >> t;
	while (t--) solve();
}
--------------------------------------------------
Problem ID: 1899C
Editorial Content:
1899C — Yarik and Array
Editorial
There are "bad" positions in the array, i.e., those on which two numbers of the same parity are next to each other. Note that all matching segments cannot contain such positions, in other words, we need to solve the problem of finding a sub segment with maximal sum on some number of non-intersecting sub segments of the array, the boundaries of which are between two neighboring elements of the same parity.
The problem of finding a sub segment with maximal sum can be solved using the classical algorithm with keeping minimal prefix sum on the prefix. The problem can be solved in a single pass over the array by simply dropping the keeped values when we are in a bad position.
Total complexity — $$$O(n)$$$.
Solution
#include <iostream>
#include <vector>
#include <algorithm>
 
using namespace std;
 
void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    int ans = a[0];
    int mn = min(0, a[0]), sum = a[0];
    for (int i = 1; i < n; ++i) {
        if (abs(a[i] % 2) == abs(a[i - 1] % 2)) {
            mn = 0;
            sum = 0;
        }
        sum += a[i];
        ans = max(ans, sum - mn);
        mn = min(mn, sum);
    }
    cout << ans << endl;
}
 
int main() {
    int tc = 1;
    cin >> tc;
    for (int t = 1; t <= tc; t++) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1899B
Editorial Content:
1899B — 250 Thousand Tons of TNT
Editorial
Solution #1:
Since $$$k$$$ is a divisor of $$$n$$$, there are $$$O(\sqrt[3]{n})$$$ such $$$k$$$. We can enumerate all k, calculate a given value in $$$O(n)$$$, and take the maximum of them. Total complexity — $$$O(n \cdot \sqrt[3]{n})$$$.
Solution #2:
Without using the fact that $$$k$$$ is a divisor of $$$n$$$, we can simply loop over $$$k$$$ and then calculate the values using prefix sums, and at the end check that there are exactly $$$k$$$ elements in each segment. Such a solution works in $$$O(\frac{n}{1} + \frac{n}{2} + \frac{n}{3} + \cdots + \frac{n}{n}) = O(n \log n)$$$.
Solution
#include<bits/stdc++.h>
using namespace std;
 
using ll = long long;
#define all(x) x.begin(), x.end()
 
void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];
    ll ans = -1;
    for (int d = 1; d <= n; ++d) {
        if (n % d == 0) {
            ll mx = -1e18, mn = 1e18;
            for (int i = 0; i < n; i += d) {
                ll sm = 0;
                for (int j = i; j < i + d; ++j) {
                    sm += a[j];
                }
                mx = max(mx, sm);
                mn = min(mn, sm);
            }
            ans = max(ans, mx - mn);
        }
    }
    cout << ans << '\n';
}
 
int32_t main() {
    int t;
    cin >> t;
    while (t--) solve();
}
--------------------------------------------------
Problem ID: 1899A
Editorial Content:
1899A — Game with Integers
Editorial
Consider the remainder from dividing $$$n$$$ by $$$3$$$ before the first move. If it is equal to $$$1$$$ or $$$2$$$, then Vanya can make the number $$$n$$$ divisible by $$$3$$$ after the first move, i.e. he wins. Let the remainder be $$$0$$$, then Vanya must change the number after which it will not be divisible by $$$3$$$. Then Vova can do the same operation as Vanya and make it divisible by $$$3$$$ again. This will go on indefinitely, so Vova wins.
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
void solve() {
    int n;
    cin >> n;
    if (n % 3) {
        cout << "First\n";
    } else {
        cout << "Second\n";
    }
}
 
int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1898F
Editorial Content:
1898F - Вова и побег из матрицы
Hint
To solve the problem for matrices of $$$3$$$-rd type, find the shortest path to $$$2$$$ closest exits with a modification of BFS. Block all cells not belonging to the path with obstacles.
Solution
For a matrix of type $$$1$$$, Misha can block all empty cells (except the one Vova stands on).
For a matrix of type $$$2$$$, Misha finds the shortest path to some exit with a single BFS and then blocks every other cell.
Matrices of type $$$3$$$ are more complicated. We want to find two shortest paths to the two closest exits and block the remaining empty cells.
But, notice how the paths will likely share their beginnings. We do not have to count those cells twice. Let's take a look at the junction where the two paths merge. If we first fix the junction, finding the shortest path to Vova can be done by running a single BFS and precalculating the shortest distances from each cell to Vova. Finding the shortest path from the junction to the two closest exits can also be done with BFS and precalculation. We modify the BFS, making it multi-source, with a source in each exit. Also, we will allow each cell to be visited twice (but by different exits). We will need to maintain the following data for each cell:
How many times was it visited;
The last exit/source that visited it;
The sum of paths from all exits/sources that visited the cell so far.
Running the BFS with proper implementation produces the answer. When everything said is precalculated, we fix the junction in $$$O(nm)$$$ ways (each empty cell can be a valid junction), and then calculate the shortest path from Vova to the two closest cells in $$$O(1)$$$ per junction.
Total complexity is $$$O(nm)$$$.
Bonus
Solve the problem with LCA, or report that such a solution does not exist.
--------------------------------------------------
Problem ID: 1898E
Editorial Content:
1898E - София и строки
Hint
Notice how sorting only the substrings of length $$$2$$$ is enough. Try a greedy approach.
Solution
We sort only the substrings of length $$$2$$$. We can swap two adjacent characters if the first is greater than or equal to the second. Let us fix some character $$$s_i$$$ and presume we want to change its position to $$$j$$$. We have to perform the described swaps if they are possible. More formally:
if $$$j<i$$$, then every character in the segment $$$s_j s_{j+1} \ldots s_{i-1}$$$ must be greater than or equal to $$$s_i$$$;
if $$$i<j$$$, then every character in the segment $$$s_{i+1} s_{i+2} \ldots s_j$$$ must be smaller than or equal to $$$s_i$$$.
We want to reorder the string $$$s$$$ and get the string $$$s'$$$. Then, we check if we can delete some characters in $$$s'$$$ to achieve $$$t$$$. In other words, we want $$$t$$$ to be a subsequence of $$$s'$$$. A general algorithm that checks if the string $$$a$$$ is a subsequence of the string $$$b$$$ is as follows. We iterate through $$$a$$$, and for each character, we find its first next appearance in $$$b$$$. If such a character does not exist, we conclude that $$$a$$$ is not a subsequence of $$$b$$$. If we complete the iteration gracefully, then $$$a$$$ is a subsequence of $$$b$$$. We will try to check if $$$t$$$ is a subsequence of $$$s$$$, but we allow ourselves to modify $$$s$$$ along the way.
We maintain $$$26$$$ queues for positions of each lowercase English letter in the string $$$s$$$. We iterate through the string $$$t$$$, and for every character $$$t_i$$$, we try to move the first available equivalent character in $$$s$$$ to position $$$i$$$. In other words, at every moment, the prefix of string $$$s$$$ is equal to the prefix of string $$$t$$$ (if possible). For the current character $$$t_i$$$ and the corresponding $$$s_j$$$, prefixes $$$t_1t_2\dots t_{i-1}$$$ and $$$s_1s_2\dots s_{i-1}$$$ are the same, which means that $$$j\geq i$$$. To move $$$s_j$$$ to position $$$i$$$, we need to delete all characters between $$$s_i$$$ and $$$s_j$$$ that are smaller than $$$s_j$$$. We will delete them and all characters from the current prefix $$$s_1s_2\dots s_{i-1}$$$ from the queues because they are no longer candidates for $$$s_j$$$. By doing so, $$$s_j$$$ will be the first character in the corresponding queue. If at some moment in our greedy algorithm, the queue we are looking for becomes empty, then the answer is "NO". Otherwise, we will make the prefix $$$s_1s_2\dots s_m$$$ equal to the $$$t$$$ and delete the remaining characters from $$$s$$$.
Why is this greedy approach optimal? Let's suppose for some character $$$t_{i_1}$$$ we chose $$$s_{j_1}$$$ and for $$$t_{i_2}$$$ we chose $$$s_{j_2}$$$, such that $$$i_1< i_2$$$, $$$j_1>j_2$$$ and $$$t_{i_1}=t_{i_2}=s_{j_1}=s_{j_2}$$$. We need to prove that if we can move $$$s_{j_1}$$$ to position $$$i_1$$$ and $$$t_{i_2}$$$ to position $$$i_2$$$, when we can move $$$s_{j_2}$$$ to $$$i_1$$$ and $$$s_{j_1}$$$ to $$$i_2$$$. In the moment when we chose $$$s_{j_1}$$$, prefixes $$$t_1t_2\dots t_{i_1-1}$$$ and $$$s_1s_2\dots s_{i_1-1}$$$ are the same, so $$$j_1\geq i_1$$$. Similarly, $$$j_2\geq i_2$$$, which means the only possibility is $$$i_1<i_2\leq j_2<j_1$$$.
If we can move $$$s_{j_1}$$$ to position $$$i_1$$$, than we can also move $$$s_{j_2}$$$ to $$$i_1$$$ because $$$s_{j_1}=s_{j_2}$$$ and $$$j_2<j_1$$$. Also, if we can move $$$s_{j_1}$$$ to $$$i_1$$$, than we can move $$$s_{j_1}$$$ to $$$i_2$$$ because $$$i_1<i_2$$$, from which it follows that we can move $$$s_{j_2}$$$ to $$$i_2$$$, because $$$s_{j_2}=s_{j_1}$$$ and $$$j_2<j_1$$$.
The overall complexity is $$$O(\alpha \cdot (n+m))$$$, where $$$\alpha$$$ is the alphabet size ($$$\alpha=26$$$ in this problem).
Bonus
Solve the problem when the size of the alphabet is arbitrary (up to $$$n$$$).
--------------------------------------------------
Problem ID: 1898D
Editorial Content:
1898D - Абсолютная красота
Hint
If $$$a_i > b_i$$$, swap them. Imagine the pairs $$$(a_i,b_i)$$$ as intervals. How can we visualize the problem?
Solution
The pair $$$(a_i,b_i)$$$ represents some interval, and $$$|a_i - b_i|$$$ is its length. Let us try to maximize the sum of the intervals' lengths. We present three cases of what a swap does to two arbitrary intervals.
Notice how the sum of the lengths increases only in the first case. We want the distance between the first interval's right endpoint and the second interval's left endpoint to be as large as possible. So we choose integers $$$i$$$ and $$$j$$$ such that $$$i \neq j$$$ and $$$a_j - b_i$$$ is maximized. We add twice the value, if it is positive, to the original absolute beauty. If the value is $$$0$$$ or negative, we simply do nothing.
To quickly find the maximum of $$$a_j - b_i$$$ over all $$$i$$$ and $$$j$$$, we find the maximum of $$$a_1,a_2,\ldots a_n$$$ and the minimum of $$$b_1,b_2, \ldots b_n$$$. Subtracting the two extremum values produces the desired result.
Bonus
How to handle point updates? (change a single value in either $$$a$$$ or $$$b$$$, and print the answer after each query.)
--------------------------------------------------
Problem ID: 1898C
Editorial Content:
1898C - Разноцветная сетка
Hint
The solution does not exist only for "small" $$$k$$$ or when $$$n+m-k$$$ is an odd integer. Try to find a construction otherwise.
Solution
Read the hint for the condition of the solution's existence. We present a single construction that solves the problem for each valid $$$k$$$.
One can verify that the pattern holds in general.
Bonus
How would you write a checker? That is, how would you check that a valid walk of length $$$k+1$$$ exists in the given grid (with all the edges colored beforehand)?
--------------------------------------------------
Problem ID: 1898B
Editorial Content:
1898B - Милена и поклонник
Hint
Try a greedy approach. That is, split each $$$a_i$$$ only as many times as necessary (and try to create almost equal parts).
Solution
We will iterate over the array from right to left. Then, as described in the hint section, we will split the current $$$a_i$$$ and create almost equal parts. For example, $$$5$$$ split into three parts forms the subarray $$$[1,2,2]$$$. Splitting $$$8$$$ into four parts forms the subarray $$$[2,2,2,2]$$$. Notice that the subarrays must be sorted. Because we want to perform as few splits as possible, the rightmost endpoint value should be as high as possible (as long as it is lower than or equal to the leftmost endpoint of the splitting of $$$a_{i+1}$$$ if it exists).
When we iterate over the array, it is enough to set the current $$$a_i$$$ to the leftmost endpoint of the splitting (the smallest current value). It will help to calculate the optimal splitting of $$$a_{i-1}$$$. For the current $$$a_i$$$, we want to find the least $$$k$$$ such that we can split $$$a_{i-1}$$$ into $$$k$$$ parts so the rightmost endpoint is less than or equal to $$$a_i$$$. More formally, we want $$$\lceil \frac{a_{i-1}}{k} \rceil \leq a_i$$$ to hold. Afterwards, we set $$$a_{i-1}$$$ to $$$\lfloor \frac{a_{i-1}}{k} \rfloor$$$ and continue with our algorithm. The simplest way to find the desired $$$k$$$ is to apply the following formula:
$$$k=\lceil \frac{a_{i-1}}{a_i} \rceil$$$
The answer is the sum over all $$$k-1$$$.
Bonus
There are $$$q \leq 2\cdot 10^5$$$ queries: given an index $$$i$$$ and an integer $$$x>1$$$, set $$$a_i := \lceil \frac{a_i}{x} \rceil$$$. Modify the array and print the answer to the original problem. Please note that the queries stack.
--------------------------------------------------
Problem ID: 1898A
Editorial Content:
1898A
-
Milica and String
Hint
In one move, Milica can replace the whole string with $$$\texttt{AA} \ldots \texttt{A}$$$. In her second move, she can replace a prefix of length $$$k$$$ with $$$\texttt{BB} \ldots \texttt{B}$$$. The process takes no more than $$$2$$$ operations. The question remains — when can we do better?
Solution
In the
hint
section, we showed that the minimum number of operations is $$$0$$$, $$$1$$$, or $$$2$$$. We have $$$3$$$ cases:
No operations are needed if $$$s$$$ already contains $$$k$$$ characters $$$\texttt{B}$$$.
Else, we can use brute force to check if changing some prefix leads to $$$s$$$ having $$$k$$$ $$$\texttt{B}$$$s. If we find such a prefix, we print it as the answer, and use only one operation. There are $$$O(n)$$$ possibilities. Implementing them takes $$$O(n)$$$ or $$$O(n^2)$$$ time.
Else, we use the two operations described in the hint section.
Bonus
A fun fact is that only one operation is enough. Can you prove it?
--------------------------------------------------
Problem ID: 1896H2
Editorial Content:
1896H2 - Cyclic Hamming (Hard Version)
Hint 1
For any $$$c$$$ which is a cyclic shift of $$$t$$$, what will happen if $$$h(s,c)>2^k$$$?
Hint 2
Try finding some useful relationship between $$$1$$$-s of $$$s$$$ and $$$1$$$-s of $$$c$$$.
Hint
There are exactly $$$n/2$$$ positions $$$i$$$ such that $$$s[i]=c[i]=1$$$.
Hint
There are exactly $$$n/2$$$ positions $$$i$$$ such that $$$s[i]=c[i]=1$$$.
Hint 3
Think about polynomial multiplication.
Hint 1
Consider $$$S\cdot T$$$, where $$$S=\sum s[i]x^i$$$ and $$$T=\sum t[2n-i-1]x^i$$$ (reversed coefficients).
Hint 2
What are some properties that the coefficients of $$$S\cdot T$$$ tell us?
Hint
Denote $$$A=S\cdot T$$$, we have $$$A[x^i]+A[x^{i+2n}]=n/2$$$.
Hint 3
Try factoring $$$S\cdot T$$$ into some irreducible polynomials.
Hint 1
Consider $$$S\cdot T$$$, where $$$S=\sum s[i]x^i$$$ and $$$T=\sum t[2n-i-1]x^i$$$ (reversed coefficients).
Hint 2
What are some properties that the coefficients of $$$S\cdot T$$$ tell us?
Hint
Denote $$$A=S\cdot T$$$, we have $$$A[x^i]+A[x^{i+2n}]=n/2$$$.
Hint
Denote $$$A=S\cdot T$$$, we have $$$A[x^i]+A[x^{i+2n}]=n/2$$$.
Hint 3
Try factoring $$$S\cdot T$$$ into some irreducible polynomials.
Hint 4
Sort $$$0,1,\ldots,2n-1$$$ based on their bit-reversal values and build a binary tree on top of it. What condition should be satisfied on each level of the tree?
Solution
Consider the polynomial product $$$A=S\cdot T$$$, where $$$S=\sum s[i]x^i$$$ and $$$T=\sum t[2n-i-1]x^i$$$ (reversed coefficients).
Claim 1.
For all $$$0\le i<2n$$$, we have $$$A[x^i]+A[x^{i+2n}]=n/2$$$, where $$$A[x^k]$$$ denote the coefficient of $$$x^k$$$ in $$$A$$$.
Claim 2.
We can express $$$A=(x+1)(x^2+1)(x^4+1)\ldots (x^n+1)(n/2+C(x-1))$$$ where $$$C$$$ is some polynomial with degree not greater than $$$2n-2$$$.
Proof
$$$ \begin{align} &(x+1)(x^2+1)(x^4+1)\ldots (x^n+1)(n/2+C(x-1))\\ =\ &C(x^{2n}-1)+n/2\cdot (x^0+x^1+x^2+\ldots+x^{2n-1}) \end{align} $$$
It is easy to see that this satisfies claim 1.
Claim 3.
Since $$$x^{2^p}+1$$$ is cyclotomic polynomial and hence irreducible for all $$$p$$$, each factor in $$$x+1,x^2+1,\ldots,x^n+1$$$ must divide at least one of $$$S$$$ and $$$T$$$. And under the constraints that each of $$$s$$$ and $$$t$$$ must have exactly $$$n$$$ $$$1$$$-s, this condition is also sufficient.
Proof
Let $$$A=(x+1)(x^2+1)(x^4+1)\ldots (x^n+1)\cdot D$$$. We have $$$A(1)=n^2$$$, hence $$$D(1)=n/2$$$, which means that $$$D$$$ has the form of $$$n/2+C(x-1)$$$. Therefore $$$A$$$ satisfies claim 2.
Recall $$$n=2^k$$$, define $$$f_s(mask)$$$ ($$$0\le mask<2n$$$) as the number of string $$$s$$$ such that for each $$$p$$$ where $$$p$$$-th bit of $$$mask$$$ is on, $$$S$$$ is divisible by $$$x^{p}+1$$$. Define $$$f_t$$$ similarly for $$$T$$$. Define $$$f^{\prime}_t$$$ such that $$$f^{\prime}_t(mask)=f_t(mask\oplus (2n-1))$$$ where $$$\oplus$$$ denotes bitwise XOR.
The answer to the problem is $$$\displaystyle\sum_{mask} f_s(mask)\cdot \mu(f^{\prime}_t(mask))$$$ where $$$\mu$$$ denote
Mobius transform
. The reason we need Mobius transform is that $$$mask_s$$$ does not represent all divisors, just a subset of it.
Let rearrange elements of $$$s$$$ into a new array $$$s^{\prime}$$$ so that $$$s^{\prime}[\text{reverse_bit}(i)]=s[i]$$$ (for example, with $$$n=8$$$, the new order will be $$$[0,8,4,12,2,6,10,14,1,9,5,13,3,11,7,15]$$$). Construct a perfect binary tree based on the array $$$s^{\prime}$$$. This binary will have $$$k+2$$$ levels from $$$0$$$ to $$$k+1$$$, starting at the root.
Claim 4.
$$$S$$$ is divisible by $$$x^{2^p}+1$$$ if only if for every tree node at $$$p$$$-th level, the number of $$$1$$$-s of $$$s^{\prime}$$$ under both children are equal (the proof is left as an exercise for readers).
Hint
Group the positions by the remainder when divided by $$$2^p$$$, find the necessary condition for each group, and consider its position on the tree.
Consider the following dynamic programming: $$$dp_s[i][mask][num]$$$, where the levels in $$$mask$$$ satisfy claim 4 and $$$num$$$ is the number of $$$1$$$-s under $$$i$$$-th node on the tree. Denote $$$l$$$ as level of $$$i$$$-th node, transitions are:
$$$dp_s[i][mask][num_1+num_2]\text{ += }dp_s[2i][mask][num_1]\cdot dp_s[2i+1][mask][num_2]$$$
$$$dp_s[i][mask+2^l][2\cdot num]\text{ += }dp_s[2i][mask][num]\cdot dp_s[2i+1][mask][num]$$$
The above dp took $$$\mathcal{O}(n^3)$$$, which is sufficient to solve the easy version.
To solve the hard version, we will optimize the above transitions:
The first transition is actually the convolution of $$$dp_s[2i][mask]$$$ and $$$dp_s[2i+1][mask]$$$, we can use FFT to optimize it.
In the second transition, because $$$num$$$ is multiplied by $$$2$$$ every time, we can omit it and just make the transition to $$$dp_s[i][mask+2^l][num]$$$, reduce the length of $$$dp_s[i][mask+2^l]$$$ by two.
By careful analysis, we can show that the time complexity is now $$$\mathcal{O}(3^k\cdot k)$$$ (recall $$$n=2^k$$$) with a fair constant factor, which solved the hard version.
Proof
$$$ \begin{align} &(x+1)(x^2+1)(x^4+1)\ldots (x^n+1)(n/2+C(x-1))\\ =\ &C(x^{2n}-1)+n/2\cdot (x^0+x^1+x^2+\ldots+x^{2n-1}) \end{align} $$$
It is easy to see that this satisfies claim 1.
Proof
Let $$$A=(x+1)(x^2+1)(x^4+1)\ldots (x^n+1)\cdot D$$$. We have $$$A(1)=n^2$$$, hence $$$D(1)=n/2$$$, which means that $$$D$$$ has the form of $$$n/2+C(x-1)$$$. Therefore $$$A$$$ satisfies claim 2.
Hint
Group the positions by the remainder when divided by $$$2^p$$$, find the necessary condition for each group, and consider its position on the tree.
--------------------------------------------------
Problem ID: 1896H1
Editorial Content:

--------------------------------------------------
Problem ID: 1896G
Editorial Content:
1896G - Pepe Racing
Hint 1
Find the fastest pepe in $$$n + 1$$$ queries.
Hint
Divide $$$n^2$$$ pepes into $$$n$$$ groups $$$G_1, G_2, \dots, G_n$$$. For each group $$$G_i$$$, use $$$1$$$ query to find the fastest pepe in the group, let's call him the
head
of $$$G_i$$$. Finally, use $$$1$$$ query to find the fastest pepe of all the heads.
Hint
Divide $$$n^2$$$ pepes into $$$n$$$ groups $$$G_1, G_2, \dots, G_n$$$. For each group $$$G_i$$$, use $$$1$$$ query to find the fastest pepe in the group, let's call him the
head
of $$$G_i$$$. Finally, use $$$1$$$ query to find the fastest pepe of all the heads.
Hint 2
After knowing the fastest pepe, find the second fastest pepe in $$$n + 1$$$ queries.
Hint
Just remove the fastest pepe and repeat the process from hint 1. One of the groups will have size $$$n - 1$$$, but we can "steal" one non-head pepe from another already-queried group.
Hint
Just remove the fastest pepe and repeat the process from hint 1. One of the groups will have size $$$n - 1$$$, but we can "steal" one non-head pepe from another already-queried group.
Hint 3
Note that the above process for Hint 2 uses a lot of repeated queries. Can we optimize it to $$$2$$$ queries?
Hint
Assume that the fastest pepe is the head of $$$G_i$$$. After removing him, we can recalculate the head of $$$G_i$$$ using $$$1$$$ query similar to hint 2. Then, use the second query on all the heads, similar to the last query of hint 1.
Hint
Assume that the fastest pepe is the head of $$$G_i$$$. After removing him, we can recalculate the head of $$$G_i$$$ using $$$1$$$ query similar to hint 2. Then, use the second query on all the heads, similar to the last query of hint 1.
Hint 4
Solve the problem using $$$2n^2 - n + 1$$$ queries.
Hint
Our algorithm has three phases:
Phase 1: Divide $$$n^2$$$ pepes into $$$n$$$ groups $$$G_1, G_2, \dots, G_n$$$. For each group $$$G_i$$$, use $$$1$$$ query to find the fastest pepe in the group, let's call this guy the
head
of $$$G_i$$$.
Phase 2: Until there are $$$2n - 1$$$ pepes, repeat these two steps:
Use $$$1$$$ query to find the fastest pepe of the heads of all groups, then remove him. Assume that this pepe is the head of $$$G_i$$$.
Steal non-head pepes from other groups so that $$$|G_i| = n$$$, then use $$$1$$$ query to recalculate its head.
Phase 3: Until there are $$$n - 1$$$ pepes, repeatedly find the fastest pepe using $$$2$$$ queries (or $$$1$$$ if there are only $$$n$$$ pepes left), then remove him.
Total number of queries is $$$n + 2(n^2 - 2n + 1) + 2(n - 1) + 1 = 2n^2 - n + 1$$$.
Hint
Our algorithm has three phases:
Phase 1: Divide $$$n^2$$$ pepes into $$$n$$$ groups $$$G_1, G_2, \dots, G_n$$$. For each group $$$G_i$$$, use $$$1$$$ query to find the fastest pepe in the group, let's call this guy the
head
of $$$G_i$$$.
Phase 2: Until there are $$$2n - 1$$$ pepes, repeat these two steps:
Use $$$1$$$ query to find the fastest pepe of the heads of all groups, then remove him. Assume that this pepe is the head of $$$G_i$$$.
Steal non-head pepes from other groups so that $$$|G_i| = n$$$, then use $$$1$$$ query to recalculate its head.
Phase 3: Until there are $$$n - 1$$$ pepes, repeatedly find the fastest pepe using $$$2$$$ queries (or $$$1$$$ if there are only $$$n$$$ pepes left), then remove him.
Total number of queries is $$$n + 2(n^2 - 2n + 1) + 2(n - 1) + 1 = 2n^2 - n + 1$$$.
Solution 1
Call a pepe
slow
if it does not belong in the fastest $$$n^2 - n + 1$$$ pepes. Note that there are $$$n - 1$$$ slow pepes, and we do not care for their relative speed. After each query, we know that the fastest pepe cannot be slow.
We use the algorithm in hint 4 until there are $$$2n - 1$$$ pepes left. Since the head of $$$n$$$ groups cannot be slow, we are left with exactly $$$(2n - 1) - n = n - 1$$$ candidates for slow pepes. Once we determine the $$$n - 1$$$ slow pepes, we only need to find the ranking of the other $$$n$$$ pepes, which can be done using $$$n - 1$$$ queries.
Total number of queries is $$$n + 2(n^2 - 2n + 1) + (n - 1) = 2n^2 - 2n + 1$$$.
Solution 2
We will try to decrease the number of queries based on the fact that we can omit one query for recalculation when the size of a group decreases from $$$2$$$ to $$$1$$$.
We modify the algorithm in hint 4 to maintain an invariant: $$$|G_i| - |G_j| \le 1$$$ $$$\forall \, 1 \le i < j \le n$$$. In other words, we want to make the sizes of these groups as balanced as possible.
To maintain this, whenever we have $$$|G_j| - |G_i| = 2$$$ after removing some pepe, we can transfer any non-head pepe from $$$G_j$$$ to $$$G_i$$$ to balance these groups out. Next, to recalculate the head of $$$G_i$$$, we will "borrow" instead of "steal" from other groups. If the fastest pepe is borrowed from $$$G_j$$$, then we transfer a random non-head pepe in $$$G_i$$$ back to $$$G_j$$$. This works since the head of $$$G_j$$$ is faster than the head of $$$G_i$$$, which in turn is faster than the random pepe.
Finally, when there are $$$2n$$$ pepes left, all groups have the size of $$$2$$$, and we only need to use $$$1$$$ query for each pepe from later on.
Total number of queries is $$$n + 2(n^2 - 2n) + (n + 1) = 2n^2 - 2n + 1$$$.
Implementation (Solution 1)
#include <bits/stdc++.h>

using namespace std;

const int N = 30;

vector<int> buc[N];
int buc_id[N * N], buc_max[N];
int n;

int ask(vector<int> que) {
  cout << "?";
  for (int i : que) cout << ' ' << i + 1;
  cout << endl;
  int res; cin >> res;
  return res - 1;
}

int ask_all() {
  vector<int> que;
  for (int i = 0; i < n; i++)
    if (buc[i].size())
      que.push_back(buc_max[i]);
  for (int i = 0; i < n; i++)
    for (int j : buc[i])
      if (int(que.size()) < n && j != buc_max[i])
        que.push_back(j);
  return ask(que);
}

void answer(vector<int> ans) {
  cout << "!";
  for (int i : ans) cout << ' ' << i + 1;
  cout << endl;
}

void add(int id, int pepe) {
  buc[id].push_back(pepe);
  buc_id[pepe] = id;
}

void remove(int id, int pepe) {
  buc[id].erase(find(buc[id].begin(), buc[id].end(), pepe));
}

void send(int id, vector<int> &que) {
  for (int pepe : buc[id])
    if (int(que.size()) < n && pepe != buc_max[id])
      que.push_back(pepe);
}

void check_balance() {
  size_t min_size = n, max_size = 0;
  for (int id = 0; id < n; id++) {
    min_size = min(min_size, buc[id].size());
    max_size = max(max_size, buc[id].size());
  }
  assert(max_size - min_size <= 1);
}


int main() {
  cout << endl;
  int t; cin >> t;
  while (t--) {
    cin >> n;
    for (int id = 0; id < n; id++)
      buc[id].clear();
      
    for (int pepe = 0; pepe < n * n; pepe++) {
      buc_id[pepe] = pepe / n;
      buc[pepe / n].push_back(pepe);
    }
    
    for (int id = 0; id < n; id++)
      buc_max[id] = ask(buc[id]);
      
    vector<int> ans;
    
    /// balancing phase
    for (int step = 0; step < n * n - 2 * n; step++) {
      ans.push_back(ask_all());
      int last_id = buc_id[ans.back()];
      remove(last_id, ans.back());
      
      vector<int> que;
              
      for (int pepe : buc[last_id])
        que.push_back(pepe);
        
      /// find bucket with largest size != last_id
      int max_id = (last_id == 0);
      for (int id = 0; id < n; id++)
        if (id != last_id && buc[id].size() > buc[max_id].size())
          max_id = id;
          
      
      send(max_id, que);
      
      for (int id = 0; id < n; id++)
        if (id != max_id && id != last_id)
          send(id, que);
      
      buc_max[last_id] = ask(que);
      int move_id = buc_id[buc_max[last_id]];
      if (move_id != last_id) {
        remove(move_id, buc_max[last_id]);
        add(move_id, buc[last_id].back());
        remove(last_id, buc[last_id].back());
        add(last_id, buc_max[last_id]);
      }        
      
      if (buc[last_id].size() == buc[max_id].size() - 2) {
        if (move_id == max_id) {
          add(last_id, buc[move_id].back());
          remove(move_id, buc[move_id].back());
        } else {
          for (int pepe : buc[max_id])
            if (pepe != buc_max[max_id]) {
              add(last_id, pepe);
              remove(max_id, pepe);
              break;
            }
        }
      }
      
      check_balance();
    }
  
    
    for (int step = 0; step < n + 1; step++) {
      ans.push_back(ask_all());
      int last_id = buc_id[ans.back()];
      remove(last_id, ans.back());
      if (buc[last_id].size())
        buc_max[last_id] = buc[last_id][0];
    }
    
    answer(ans);
  }
}
Implementation (Solution 2)
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define ll long long
#define ii pair<ll,ll>
#define iii pair<ii,ll>
#define fi first
#define se second
#define debug(x) cout << #x << ": " << x << endl

#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define lb lower_bound
#define ub upper_bound

#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

mt19937 rng(chrono::system_clock::now().time_since_epoch().count());

int n;
vector<int> v[25];

int ask(vector<int> v){
	cout<<"? "; for (auto it:v) cout<<it<<" "; cout<<endl;
	int res; cin>>res;
	return res;
}

vector<int> fix(vector<int> v){
	int t=ask(v);
	rep(x,0,n) if (v[x]==t) swap(v[0],v[x]);
	return v;
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin.exceptions(ios::badbit | ios::failbit);
	
	int TC;
	cin>>TC;
	while (TC--){
		cin>>n;
		rep(x,0,n){
			v[x].clear();
			rep(y,1,n+1) v[x].pub(x*n+y);
		}
		
		rep(x,0,n) v[x]=fix(v[x]);
		
		vector<int> ans;
		rep(x,0,n*n-2*n+1){
			vector<int> t;
			rep(x,0,n) t.pub(v[x][0]);
			int best=ask(t);
			
			int idx=-1;
			rep(x,0,n) if (t[x]==best) idx=x;
			
			ans.pub(best);
			v[idx].erase(v[idx].begin());
			
			rep(x,0,n) if (x!=idx){
				while (sz(v[x])>1 && sz(v[idx])<n){
					v[idx].pub(v[x].back());
					v[x].pob();
				}
			}
			v[idx]=fix(v[idx]);
		}
		
		vector<int> a,b;
		rep(x,0,n){
			rep(y,0,sz(v[x])){
				if (y==0) a.pub(v[x][y]);
				else b.pub(v[x][y]);
			}
		}
		set<int> bad=set<int>(all(b));
		
		rep(x,0,n-1){
			a=fix(a);
			ans.pub(a[0]);
			a.erase(a.begin());
			a.pub(b.back()); b.pob();
		}
		
		for (auto it:a) if (!bad.count(it)) ans.pub(it);
		
		cout<<"! "; for (auto it:ans) cout<<it<<" "; cout<<endl;
	}
	
}
--------------------------------------------------
Problem ID: 1896F
Editorial Content:
1896F - Bracket Xoring
Hint 1
The operation is equivalent to toggling $$$s$$$ at every odd $$$i$$$ where $$$b_i$$$ is an open bracket and every even $$$i$$$ where $$$b_i$$$ is a closed bracket.
Proof
Suppose there are $$$x$$$ open brackets and $$$y$$$ close brackets between positions $$$1$$$ and $$$i$$$. Note that $$$x \ge y$$$ by definition of balanced bracket sequences. - Case 1: $$$b_i$$$ is an open bracket. Position $$$i$$$ will be toggled exactly $$$x - y$$$ times as $$$y$$$ of the open brackets will be matched before position $$$i$$$, and the remaining $$$x - y$$$ open brackets will only be matched after position $$$i$$$. This means that position $$$i$$$ will be toggled only if $$$x - y$$$ is odd, and hence, $$$x - y + 2y = x + y = i$$$ must be odd as well. - Case 2: $$$b_i$$$ is a close bracket. Position $$$i$$$ will be toggled exactly $$$x - y + 1$$$ times as $$$y - 1$$$ of the open brackets will be matched before $$$i$$$, $$$1$$$ of the open bracket will be matched with position $$$i$$$, and the remaining $$$x - y$$$ open brackets will be matched after position $$$i$$$. This means that position $$$i$$$ will be toggled only if $$$x - y$$$ is even, and hence, $$$x - y + 2y = x + y = i$$$ must be even as well.
Proof
Suppose there are $$$x$$$ open brackets and $$$y$$$ close brackets between positions $$$1$$$ and $$$i$$$. Note that $$$x \ge y$$$ by definition of balanced bracket sequences. - Case 1: $$$b_i$$$ is an open bracket. Position $$$i$$$ will be toggled exactly $$$x - y$$$ times as $$$y$$$ of the open brackets will be matched before position $$$i$$$, and the remaining $$$x - y$$$ open brackets will only be matched after position $$$i$$$. This means that position $$$i$$$ will be toggled only if $$$x - y$$$ is odd, and hence, $$$x - y + 2y = x + y = i$$$ must be odd as well. - Case 2: $$$b_i$$$ is a close bracket. Position $$$i$$$ will be toggled exactly $$$x - y + 1$$$ times as $$$y - 1$$$ of the open brackets will be matched before $$$i$$$, $$$1$$$ of the open bracket will be matched with position $$$i$$$, and the remaining $$$x - y$$$ open brackets will be matched after position $$$i$$$. This means that position $$$i$$$ will be toggled only if $$$x - y$$$ is even, and hence, $$$x - y + 2y = x + y = i$$$ must be even as well.
Hint 2
Every operation will always toggle $$$s_1$$$ and $$$s_n$$$. Furthermore, every operation will always toggle an even number of positions.
Proof
If $$$s$$$ is toggled at an open bracket, $$$s$$$ will be toggled at its matching close bracket as well.
Proof
If $$$s$$$ is toggled at an open bracket, $$$s$$$ will be toggled at its matching close bracket as well.
Hint 3
If $$$s_1 \neq s_n$$$ or there is an odd number of $$$\texttt{1}$$$s in $$$s$$$, it is not possible to change all elements of $$$s$$$ to $$$\texttt{0}$$$. Otherwise, it is always possible.
Hint 4
If it is possible to change all elements of $$$s$$$ to $$$\texttt{0}$$$, at most $$$3$$$ operations are needed.
Solution 1
From hint 3, we know the cases where it is impossible to change all elements of $$$s$$$ to $$$\texttt{0}$$$. We will now only consider the case where it is possible to change all elements of $$$s$$$ to $$$\texttt{0}$$$.
Using hint 1, we can easily check whether it is possible to change all elements of $$$s$$$ to $$$\texttt{0}$$$ using only one operation by first constructing the bracket sequence and then checking whether the resultant bracket sequence is balanced. From now on, we will assume that it is not possible to change all elements of $$$s$$$ to $$$\texttt{0}$$$ using one operation.
Suppose $$$s_1 = s_n = \texttt{1}$$$. We know from hint 2 that each operation will always toggle $$$s_1$$$ and $$$s_n$$$, so since it is not possible to change all elements of $$$s$$$ to $$$\texttt{0}$$$ using one operation, we will need three operations. If we let the first operation be $$$b=\texttt{(()()}\ldots\texttt{()())}$$$, $$$s_1$$$ and $$$s_n$$$ will be toggled while the remaining elements stay the same. Now, $$$s_1 = s_n = \texttt{0}$$$, so if we can solve this case using only two operations, it means that we can solve the $$$s_1 = s_n = \texttt{1}$$$ case using only three operations.
To solve the final case where $$$s_1 = s_n = \texttt{0}$$$, we will look at a special balanced bracket sequences $$$b = \texttt{(()()}\ldots\texttt{()())}$$$. Notice that if we do an operation using this bracket sequence, only $$$s_1$$$ and $$$s_n$$$ will be toggled. Suppose there exist an index $$$i$$$ between $$$2$$$ and $$$2n - 2$$$ where we want to toggle both $$$s_i$$$ and $$$s_{i + 1}$$$. We can take the special balanced bracket sequence $$$b = \texttt{(()()}\ldots\texttt{()())}$$$, then swap $$$b_i$$$ and $$$b_{i + 1}$$$. This will always result in a balanced bracket sequence that will toggle $$$s_1$$$, $$$s_n$$$, as well as the desired $$$s_i$$$ and $$$s_{i + 1}$$$. This will allow us to change all elements of $$$s$$$ to $$$\texttt{0}$$$ in $$$2n$$$ moves as we can scan from $$$i = 2$$$ to $$$i = 2n - 2$$$ and do an operation toggling $$$s_i$$$ and $$$s_{i+1}$$$ if $$$s_i = \texttt{1}$$$. Since there is an even number of $$$\texttt{1}$$$s in $$$s$$$ from hint 3, toggling adjacent positions will always change all elements of $$$s$$$ to $$$\texttt{0}$$$.
To reduce the number of operations from $$$2n$$$ to $$$2$$$, notice that a lot of the operations can be parallelized into a single operation. Let $$$A_0$$$ represent the set of even indices between $$$2$$$ and $$$2n - 2$$$ where we want to toggle $$$s_i$$$ and $$$s_{i + 1}$$$. Similarly, let $$$A_1$$$ represent the set of odd indices between $$$2$$$ and $$$2n - 2$$$ where we want to toggle $$$s_i$$$ and $$$s_{i + 1}$$$. In a single operation, we can take the special balanced bracket sequence $$$b = \texttt{(()()}\ldots\texttt{()())}$$$, and swap $$$b_i$$$ and $$$b_{i + 1}$$$ for all $$$i$$$ that is in the set $$$A_0$$$. Since $$$A_0$$$ only contains even indices, the swaps are non-intersecting, and hence, the resultant bracket sequence will still be balanced and $$$s_1$$$, $$$s_n$$$, as well as $$$s_i$$$ and $$$s_{i + 1}$$$ will be toggled for all the desired even indices $$$i$$$. We can use the same strategy with $$$A_1$$$, starting with the same special balanced bracket sequence and then swapping $$$b_i$$$ and $$$b_{i + 1}$$$ for all $$$i$$$ that is in set $$$A_1$$$. Hence, after using these two operations, all elements of $$$s$$$ will change to $$$\texttt{0}$$$.
Solution 2
We will demonstrate a way to use $$$2$$$ bracket sequence to solve any binary string whose first and last element is $$$\texttt{0}$$$ and who also has an even number of $\texttt{1}$s.
Defined the balance of an (incomplete) bracket sequence as the number of open brackets minus the number of closed brakcets. For example,
((()
has balance $$$2$$$,
(()()((
has balance $$$3$$$ and
()
has balance $$$0$$$.
Using hint $$$1$$$ we can see that the resulting binary string will contain
0
at position $$$i$$$ iff the character at position $$$i$$$ in both bracket sequences is the same. Suppose the balance of your current bracket sequences is $$$(a,b)$$$. You can change it $$$(a\pm 1, b\pm 1)$$$. If both $$$\pm$$$ have the same parity, then the resulting binary string will contain $$$\texttt{0}$$$ at that position.
Now, we will demonstrate a greedy algorithm.
$$$(0,0) \to (1,1) \to (0,2),(2,2) \to (1,3),(1,1) \to (0,2),(2,2) \to \ldots \to (1,1) \to (0,0)$$$
One can show by a simple parity argument that the second last balance must necessarily be $$$(1,1)$$$ since the number of $\texttt{1}$s in the string is even.
Solution 3
Similar to solution 2, we will demonstrate a way to use $$$2$$$ bracket sequence to solve any binary string whose first and last element is $$$\texttt{0}$$$ and who also has an even number of $\texttt{1}$s.
Using the same greedy argument in solution 2 (or by guessing), we know that we can always use two bracket sequences where the number of open brackets minus the number of close brackets is always between $$$0$$$ and $$$3$$$ for all prefixes of the bracket sequence. For convenience, we will define "balance" as the number of open brackets minus the number of close brackets.
Hence, we can do dynamic programming using the states $$$dp[i][balance1][balance2]$$$ which returns whether it is possible to create two bracket sequences $$$b1$$$ and $$$b2$$$ of length $$$i$$$ such that the balance of $$$b1$$$ and $$$b2$$$ are $$$balance1$$$ and $$$balance2$$$ respectively and $$$s[1, i]$$$ becomes all $$$\mathtt{0}$$$. The transition can be done by making sure that the balances stay between $$$0$$$ and $$$3$$$ and that $$$b1_i \neq b2_i$$$ if $$$s_i=\mathtt{1}$$$ and vice versa.
Implementation
#include <bits/stdc++.h>
using namespace std;

void solve(int n, string s) {
	vector<int> a;
	for (char &i : s) {
		a.push_back(i & 1);
	}
	
	if (a.front() != a.back()) {
		cout << -1 << endl;
		return ;
	}
	
	if (count(a.begin(), a.end(), 1) % 2) {
		cout << -1 << endl;
		return ;
	}
	
	bool flipped = false;
	if (a.front() == 1 && a.back() == 1) {
		for (int &i : a) i ^= 1;
		flipped = true;
	}
	
	string l(2 * n, '-'), r(2 * n, '-');
	int cnt = 0;
	for (int i = 0; i < 2 * n; i++) {
		if (a[i]) {
			l[i] = (cnt) ? '(' : ')';
			r[i] = (cnt ^ 1) ? '(' : ')';
			cnt ^= 1;
		}
	}
	
	int tot = count(a.begin(), a.end(), 0) / 2;
	cnt = 0;
	for (int i = 0; i < 2 * n; i++) {
		if (!a[i]) {
			if (cnt < tot) l[i] = '(', r[i] = '(';
			else l[i] = ')', r[i] = ')';
			cnt++;
		}
	}
	
	if (flipped) {
		cout << 3 << endl;
		cout << l << endl;
		cout << r << endl;
		for (int i = 0; i < n; i++) cout << "()";
		cout << endl;
	} else {
		cout << 2 << endl;
		cout << l << endl;
		cout << r << endl;
	}
}

int main() {	
	int t;
	cin >> t;
	while (t--) {
		int n;
		cin >> n;
		string s;
		cin >> s;
		solve(n, s);
	}
	
	return 0;
}
--------------------------------------------------
Problem ID: 1896E
Editorial Content:
1896E - Permutation Sorting
Hint 1
For each index $$$i$$$ from $$$1$$$ to $$$n$$$, let $$$h_i$$$ denote the number of cyclic shifts needed to move $$$a_i$$$ to its correct spot. In other words, $$$h_i$$$ is the minimum value such that $$$(i + h_i - 1)\ \%\ n + 1 = a_i$$$. How can we get the answer from $$$h_i$$$?
Solution
For convenience, we will assume that the array is cyclic, so $$$a_j = a_{(j - 1)\ \%\ n + 1}$$$. The answer for each index $$$i$$$ from $$$1$$$ to $$$n$$$ is $$$h_i$$$ (defined in hint 1) minus the number of indices $$$j$$$ where $$$i < j < i + h_i$$$ and $$$i < a_j < i + h_i$$$ (or $$$i < a_j + n < i + h_i$$$ to handle cyclic case when $$$i + h_i > n$$$). This is because the value that we are calculating is equal to the number of positions that $$$a_i$$$ will skip during the rotation as the index is already good.
To calculate the above value, it is convenient to define an array $$$b$$$ of size $$$2n$$$ where $$$b_i = a_i$$$ for all $$$i$$$ between $$$1$$$ to $$$n$$$, and $$$b_i = a_{i - n} + n$$$ for all $$$i$$$ between $$$n + 1$$$ to $$$2n$$$ to handle cyclicity. We will loop from $$$i = 2n$$$ to $$$i = 1$$$, and do a point increment to position $$$a_i$$$ if $$$a_i \ge i$$$, otherwise, do a point increment to position $$$a_i + n$$$. Then, to get the answer for index $$$i$$$, we do a range sum query from $$$i + 1$$$ to $$$i + h_i - 1$$$. Point increment and range sum query can be done using a binary indexed tree in $$$O(\log n)$$$ time per query/update. Hence, the problem can be solved in $$$O(n\log n)$$$ time.
Implementation
#include <bits/stdc++.h> 
using namespace std;
 
#define REP(i, s, e) for (int i = (s); i < (e); i++)
#define RREP(i, s, e) for (int i = (s); i >= (e); i--)
#define ALL(_a) _a.begin(), _a.end()
#define SZ(_a) (int) _a.size()
 
const int INF = 1000000005;
const int MAXN = 1000005;
 
int t;
int n;
int p[MAXN];
int ans[MAXN];
 
int fw[MAXN * 2];
void incre(int i, int x) {
    for (; i <= 2 * n; i += i & -i) {
        fw[i] += x;
    }
}
int qsm(int i) {
    int res = 0;
    for (; i > 0; i -= i & -i) {
        res += fw[i];
    }
    return res;
}
inline int qsm(int s, int e) {
    return qsm(e) - qsm(s - 1);
}
 
int main() {
#ifndef DEBUG
    ios::sync_with_stdio(0), cin.tie(0);
#endif
    cin >> t;
    while (t--) {
        cin >> n;
        REP (i, 1, n + 1) {
            cin >> p[i];
        }
        REP (i, 0, 2 * n + 5) {
            fw[i] = 0;
        }
        vector<pair<int, int>> rgs;
        REP (i, 1, n + 1) {
            if (i <= p[i]) {
                rgs.push_back({i, p[i]});
                rgs.push_back({i + n, p[i] + n});
            } else {
                rgs.push_back({i, p[i] + n});
            }
        }
        sort(ALL(rgs), greater<pair<int, int>>());
        for (auto [l, r] : rgs) {
            if (l <= n) {
                ans[p[l]] = r - l - qsm(l, r);
            }
            incre(r, 1);
        }
        REP (i, 1, n + 1) {
            cout << ans[i] << ' ';
        }
        cout << '\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1896D
Editorial Content:
1896D - Ones and Twos
Hint 1
Consider some small examples and write down every possible value of subarray sums. Can you see some patterns?
Solution
Denote $$$s[l,r]$$$ as the sum of subarray from $$$l$$$ to $$$r$$$.
Claim
: If there is any subarray with sum $$$v\ge 2$$$, we can find a subarray with sum $$$v-2$$$.
Proof
: Suppose $$$s[l,r]=v$$$, consider 3 cases:
$$$a[l]=2$$$, we have $$$s[l+1,r]=v-2$$$.
$$$a[r]=2$$$, we have $$$s[l,r-1]=v-2$$$.
$$$a[l]=a[r]=1$$$, we have $$$s[l+1,r-1]=v-2$$$.
So to check if there exists a subarray whose sum equals $$$v$$$, we can find the maximum subarray sum having the same parity with $$$v$$$ and compare it with $$$v$$$.
The case where $$$(s[1,n]-v)\%2=0$$$ is obvious, suppose the opposite happens. If array $$$a$$$ is full of $$$2$$$-s, the answer is $$$\texttt{NO}$$$. Otherwise, let $$$x$$$ and $$$y$$$ be the positions of the first $$$1$$$ and last $$$1$$$ in $$$a$$$. Any subarray with $$$l\le x\le y\le r$$$ will have a different parity with $$$v$$$. So we will compare $$$\max(s[x+1, n],s[1,y-1])$$$ with $$$v$$$ to get the answer.
Implementation
#include <bits/stdc++.h>

using namespace std;

int main() {
    cin.tie(0)->sync_with_stdio(0);
    int t; cin >> t;
    while (t--) {
        int n, q; cin >> n >> q;
        vector<int> a(n);
        set<int> pos;
        for (int i = 0; i < n; i++) {
            cin >> a[i];
            if (a[i] == 1) pos.insert(i);
        }
        while (q--) {
            int cmd; cin >> cmd;
            if (cmd == 1) {
                int v; cin >> v;
                int num = pos.size();
                if ((v - num) & 1) {
                    if (num == 0) cout << "NO";
                    else {
                        int s1 = 2 * *pos.rbegin() - (num - 1);
                        int s2 = 2 * (n - *pos.begin() - 1) - (num - 1);
                        if (v <= max(s1, s2)) cout << "YES";
                        else cout << "NO";
                    }
                } else {
                    if (v <= 2 * n - num) cout << "YES";
                    else cout << "NO";
                }
                cout << '\n';
            } else {
                int i; cin >> i; i--;
                pos.erase(i);
                cin >> a[i];
                if (a[i] == 1) pos.insert(i);
            }
        }
    }
}
--------------------------------------------------
Problem ID: 1896C
Editorial Content:
1896C - Matching Arrays
Hint 1
Consider a greedy algorithm.
Solution
For simplicity, assume that both arrays $$$a$$$ and $$$b$$$ are sorted in increasing order. The final answer can be obtained by permuting the answer array using the same permutation to permute sorted array $$$a$$$ to the original array $$$a$$$.
Claim
: If the rearrangement $$$b_{x + 1}, b_{x + 2}, \ldots, b_n, b_1, b_2, \ldots, b_x$$$ does not have beauty $$$x$$$, it is not possible to rearrange $$$b$$$ to make the beauty equals to $$$x$$$.
Proof
: Suppose there exists an alternative rearrangement different from above represented by permutation $$$p$$$ where $$$b_{p_1}, b_{p_2}, \ldots, b_{p_n}$$$ results in a beauty of $$$x$$$. Let array $$$q$$$ represent the $$$x$$$ indices where $$$a_i > b_{p_i}$$$ in increasing order. In other words, $$$1 \le q_1 < q_2 < \ldots < q_x \le n$$$ and $$$a_{q_i} > b_{p_{q_i}}$$$. Let $$$i$$$ be the largest index where $$$q_i \neq n - i + 1$$$ ($$$q_i < n - i + 1$$$ also holds due to strict inequality above). We know that $$$a_{q_i} > b_{p_{q_i}}$$$ and $$$a_{n - i + 1} \le b_{p_{n - i + 1}}$$$. Since $$$a$$$ is sorted and $$$q_i < n - i + 1$$$, we have $$$a_{q_i} \le a_{n - i + 1}$$$, and hence, $$$a_{n - i + 1} > b_{p_{q_i}}$$$ and $$$a_{q_i} \le b_{p_{n - i + 1}}$$$. This means that we can swap $$$p_{q_i}$$$ with $$$p_{n - i + 1}$$$ without changing the beauty of the array, while allowing $$$q_i = n - i + 1$$$. Hence, by doing the swapping repeatedly, we will get $$$q_i = n - i + 1$$$ for all $$$i$$$ between 1 and $$$x$$$.
An alternative interpretation to the result above is that we managed to obtain a solution where for all $$$i$$$ between $$$1$$$ and $$$n - x$$$, we have $$$a_i \le b_{p_i}$$$. On the other hand, for all $$$i$$$ between $$$n - x + 1$$$ and $$$n$$$, we have $$$a_i > b_{p_i}$$$. Let $$$i$$$ be the largest index between $$$1$$$ and $$$n - x$$$ where $$$p_i \neq i + x$$$ ($$$p_i < i + x$$$ due to maximality). Then, let $$$j$$$ be the index where $$$p_j = i + x$$$. Consider two cases:
$$$j \le n - x$$$. Since $$$i$$$ is the largest index where $$$p_i \neq i + x$$$, this means that $$$j < i$$$ and hence $$$a_j \le a_i$$$. We have $$$a_i \le b_{p_i} \le b_{i + x} = b_{p_j}$$$ and $$$a_j \le a_i \le b_{p_i}$$$. Hence, we can swap $$$p_i$$$ and $$$p_j$$$ without changing the beauty of the array, while allowing $$$p_i = i + x$$$.
$$$j > n - x$$$. We have $$$a_i \le b_{p_i} \le b_{i + x} = b_{p_j}$$$ and $$$a_j > b_{p_j} = b_{i + x} > b_{p_i}$$$. Hence, we can swap $$$p_i$$$ and $$$p_j$$$ without changing the beauty of the array, while allowing $$$p_i = i + x$$$.
By repeating the above repeatedly, we can obtain a solution where $$$p_i = i + x$$$ for all $$$i$$$ between $$$1$$$ and $$$n - x$$$. Let $$$i$$$ be the smallest index between $$$n - x + 1$$$ and $$$n$$$ where $$$p_i \neq i - n + x$$$ ($$$p_i > i - n + x$$$ by minimality). Then, let $$$j$$$ be the index where $$$p_j = i - n + x$$$. Note that $$$j > n - x$$$ as well since $$$p_i = i + x$$$ for all $$$i$$$ between $$$1$$$ and $$$n - x$$$. Since $$$i$$$ is the smallest index where $$$p_i \neq i - n + x$$$, this means that $$$i < j$$$ and hence $$$a_i \le a_j$$$. We have $$$a_i > b_{p_i} \ge b_{i - n + x} = b_{p_j}$$$ and $$$a_j \ge a_i > b_{p_i}$$$. Hence, we can swap $$$p_i$$$ and $$$p_j$$$ without changing the beauty of the array, while allowing $$$p_i = i - n + x$$$. By doing this repeatedly, we can obtain a solution where $$$p_i = i - n + x$$$ for all $$$i$$$ between $$$n - x + 1$$$ and $$$n$$$. Now, $$$p = [x + 1, x + 1, \ldots, n, 1, 2, \ldots, x]$$$, which matches the rearrangement in our claim.
Implementation
#include <bits/stdc++.h> 
using namespace std;
 
#define REP(i, s, e) for (int i = (s); i < (e); i++)
#define RREP(i, s, e) for (int i = (s); i >= (e); i--)
 
const int INF = 1000000005;
const int MAXN = 200005;
 
int t;
int n, x;
int a[MAXN], b[MAXN], aid[MAXN];
int ans[MAXN];
 
int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> t;
    while (t--) {
        cin >> n >> x;
        REP (i, 0, n) {
            cin >> a[i];
        }
        REP (i, 0, n) {
            cin >> b[i];
        }
        iota(aid, aid + n, 0);
        sort(aid, aid + n, [&] (int l, int r) {
                return a[l] < a[r];
                });
        sort(b, b + n);
        REP (i, 0, x) {
            ans[aid[n - x + i]] = b[i];
        }
        REP (i, x, n) {
            ans[aid[i - x]] = b[i];
        }
        REP (i, 0, n) {
            x -= a[i] > ans[i];
        }
        if (x == 0) {
            cout << "YES\n";
            REP (i, 0, n) {
                cout << ans[i] << ' ';
            }
            cout << '\n';
        } else {
            cout << "NO\n";
        }
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1896B
Editorial Content:
1896B - AB Flipping
Hint 1
What happens when $$$s$$$ starts with some $$$\texttt{B}$$$ and ends with some $$$\texttt{A}$$$?
Solution
If the string consists of only $$$\texttt{A}$$$ or only $$$\texttt{B}$$$, no operations can be done and hence the answer is $$$0$$$. Otherwise, let $$$x$$$ be the smallest index where $$$s_x = \texttt{A}$$$ and $$$y$$$ be the largest index where $$$x_y = \texttt{B}$$$. If $$$x > y$$$, this means that the string is of the form $$$s=\texttt{B}\ldots\texttt{BA}\ldots\texttt{A}$$$. Since all the $$$\texttt{B}$$$ are before the $$$\texttt{A}$$$, no operation can be done and hence the answer is also $$$0$$$.
Now, we are left with the case where $$$x < y$$$. Note that $$$s[1,x-1] = \texttt{B}\ldots\texttt{B}$$$ and $$$s[y+1,n] = \texttt{A}\ldots\texttt{A}$$$ by definition. Since the operation moves $$$\texttt{A}$$$ to the right and $$$\texttt{B}$$$ to the left, this means that $$$s[1,x - 1]$$$ will always consist of all $$$\texttt{B}$$$ and $$$s[y + 1, n]$$$ will always consist of all $$$\texttt{A}$$$. Hence, no operation can be done from index $$$1$$$ to $$$x - 1$$$ as well as from index $$$y$$$ to $$$n - 1$$$.
The remaining indices where an operation could be done are from $$$x$$$ to $$$y - 1$$$. It can be proven that all $$$y - x$$$ operations can be done if their order is chosen optimally. Let array $$$b$$$ store the indices of $$$s$$$ between $$$x$$$ and $$$y$$$ that contain $$$\texttt{B}$$$ in increasing order. In other words, $$$x < b_1 < b_2 < \ldots < b_k = y$$$ and $$$b_i = \texttt{B}$$$, where $$$k$$$ is the number of occurences of $$$\texttt{B}$$$ between $$$x$$$ and $$$y$$$. For convenience, we let $$$b_0 = x$$$. Then, we do the operations in the following order:
$$$b_1 - 1, b_1 - 2, \ldots, b_0 + 1, b_0,$$$
$$$b_2 - 1, b_2 - 2, \ldots, b_1 + 1, b_1,$$$
$$$b_3 - 1, b_3 - 2, \ldots, b_2 + 1, b_2,$$$
$$$\vdots$$$
$$$b_k - 1, b_k - 2, \ldots, b_{k - 1} + 1, b_k$$$
It can be seen that the above ordering does operation on all indices between $$$x$$$ and $$$y - 1$$$. To see why all of the operations are valid, we look at each row separately. Each row starts with $$$b_i - 1$$$, which is valid as $$$s_{b_i} = \texttt{B}$$$ and $$$s_{b_i - 1} = \texttt{A}$$$ (assuming that it is not the last operation of the row). Then, the following operations in the same row move $$$\texttt{B}$$$ to the left until position $$$b_{i - 1}$$$. To see why the last operation of the row is valid as well, even though $$$s_{b_{i - 1}}$$$ might be equal to $$$\texttt{B}$$$ initially by definition, either $$$i = 1$$$ which means that $$$s_{b_0} = s_x = \texttt{A}$$$, or an operation was done on index $$$b_{i - 1} - 1$$$ in the previous row which moved $$$\texttt{A}$$$ to index $$$b_{i - 1}$$$. Hence, all operations are valid.
Implementation
#include <bits/stdc++.h>
using namespace std;
 
char s[200005];
 
signed main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int tc, n; cin >> tc;
	while (tc--) {
		cin >> n; s[n + 1] = 'C';
		for (int i = 1; i <= n; ++i) cin >> s[i];
		int pt1 = 1, pt2 = 1, ans = 0;
		while (s[pt1] == 'B') ++pt1, ++pt2;
		while (pt1 <= n) {
			int cntA = 0, cntB = 0;
			while (s[pt2] == 'A') ++pt2, ++cntA;
			while (s[pt2] == 'B') ++pt2, ++cntB;
			if (s[pt2 - 1] == 'B') ans += pt2 - pt1 - 1;
			if (cntB) pt1 = pt2 - 1;
			else break;
		}
		cout << ans << '\n';
	}
}
--------------------------------------------------
Problem ID: 1896A
Editorial Content:
1896A - Jagged Swaps
Hint 1
Look at the samples.
Solution
Observe that since we are only allowed to choose $$$i \ge 2$$$ to swap $$$a_i$$$ and $$$a_{i+1}$$$, it means that $$$a_1$$$ cannot be modified by the operation. Hence, $$$a_1 = 1$$$ must hold. We can prove that as long as $$$a_1 = 1$$$, we will be able to sort the array.
Consider the largest element of the array. Let its index be $$$i$$$. Our objective is to move $$$a_i$$$ to the end of the array. If $$$i = n$$$, it means that the largest element is already at the end. Otherwise, since $$$a_i$$$ is the largest element, this means that $$$a_{i-1} < a_i$$$ and $$$a_i > a_{i+1}$$$. Hence, we can do an operation on index $$$i$$$ and move the largest element one step closer to the end. We repeatedly do the operation until we finally move the largest element to the end of the array. Then, we can pretend that the largest element does not exist and do the same algorithm for the prefix of size $$$n - 1$$$. Hence, we will able to sort the array by doing this repeatedly.
Implementation
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector <ll> vi;
int main() {
    int t;
    cin >> t;
    while (t --> 0) {
        int n;
        cin >> n;
        vi arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        if (arr[0] == 1) {
            cout << "YES";
        } else {
            cout << "NO";
        }
        cout << '\n';
    }
}
--------------------------------------------------
Problem ID: 1895G
Editorial Content:
1895G - Two Characters, Two Colors
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

mt19937 rnd(42);

struct node
{
  long long x;
  int y;
  int cnt;
  int sum;
  int push;
  node* l;
  node* r;
  node() {};
  node(long long x, int y, int cnt, int sum, int push, node* l, node* r) : x(x), y(y), cnt(cnt), sum(sum), push(push), l(l), r(r) {};
};

typedef node* treap;
typedef pair<treap, treap> ptt;

int getSum(treap t)
{
  return (t ? t->sum : 0);
}

int getCnt(treap t)
{
  return (t ? t->cnt : 0);
}

treap fix(treap t)
{
  if(!t) return t;
  int p = t->push;
  if(p != 0)
  {
    if(t->l) t->l->push += p;
    if(t->r) t->r->push += p;
    t->x += p;
    t->push = 0;
  }
  t->sum = getSum(t->l) + t->cnt + getSum(t->r);
  return t;
}

treap merge(treap a, treap b)
{
  a = fix(a);
  b = fix(b);
  if(!a) return b;
  if(!b) return a;
  if(a->y > b->y)
  {
    a->r = merge(a->r, b);
    return fix(a);
  }
  else
  {
    b->l = merge(a, b->l);
    return fix(b);
  }
}

bool hasKey(treap t, long long x)
{
  t = fix(t);
  if(!t) return false;
  if(t->x == x) return true;
  if(t->x < x) return hasKey(t->r, x);
  return hasKey(t->l, x);
}

ptt splitKey(treap t, long long x)
{
  t = fix(t);
  if(!t) return make_pair(t, t);
  if(t->x < x)
  {
    ptt p = splitKey(t->r, x);
    t->r = p.first;
    return make_pair(fix(t), p.second);
  }
  else
  {
    ptt p = splitKey(t->l, x);
    t->l = p.second;
    return make_pair(p.first, fix(t));
  }
}

long long kthMax(treap t, int k)
{
  t = fix(t);
  if(!t) return -1;
  int sumR = getSum(t->r);
  if(sumR >= k) return kthMax(t->r, k);
  if(sumR + t->cnt >= k) return t->x;
  return kthMax(t->l, k - sumR - t->cnt);
}

int getCntByKey(treap t, long long x)
{
  t = fix(t);
  if(!t) return 0;
  if(t->x == x) return t->cnt;
  if(t->x > x) return getCntByKey(t->l, x);
  return getCntByKey(t->r, x);
}

treap increaseKey(treap t, long long x, int cnt)
{
  t = fix(t);
  if(!t) return t;
  if(t->x == x)
  {
    t->cnt += cnt;
  }
  else if(t->x > x)
  {
    t->l = increaseKey(t->l, x, cnt);
  }
  else
  {
    t->r = increaseKey(t->r, x, cnt);
  }
  return fix(t);
}

treap insert(treap t, long long x, int y, int cnt)
{
  t = fix(t);
  if(!t || t->y < y)
  {
    ptt p = splitKey(t, x);
    treap res = new node(x, y, cnt, cnt, 0, p.first, p.second);
    return fix(res);
  }
  if(t->x > x)
    t->l = insert(t->l, x, y, cnt);
  else
    t->r = insert(t->r, x, y, cnt);
  return fix(t);
}

treap insertMain(treap t, long long x, int cnt)
{
  if(hasKey(t, x))
    return increaseKey(t, x, cnt);
  else
    return insert(t, x, rnd(), cnt);
}

treap eraseKey(treap t, long long x)
{
  t = fix(t);
  if(!t) return NULL;
  if(t->x > x)
  {
    t->l = eraseKey(t->l, x);
    return fix(t);
  }
  if(t->x < x)
  {
    t->r = eraseKey(t->r, x);
    return fix(t);
  }
  treap tnew = merge(t->l, t->r);
  delete t;
  return tnew;
}

ptt splitSum(treap t, int k)
{
  t = fix(t);
  if(!t) return make_pair(t, t);
  if(k == 0) return make_pair(t, treap(NULL));
  long long x = kthMax(t, k);
  int cnt = getCntByKey(t, x);
  t = eraseKey(t, x);
  ptt p = splitKey(t, x);
  k -= getSum(p.second);
  if(k > 0) p.second = merge(new node(x, rnd(), k, k, 0, NULL, NULL), p.second);
  if(k < cnt) p.first = merge(p.first, new node(x, rnd(), cnt - k, cnt - k, 0, NULL, NULL));
  return p;
}

long long minKey(treap t)
{
  t = fix(t);
  if(!t) return 1e18;
  if(t->l) return minKey(t->l);
  return t->x;
}

treap decreaseUpToKLargest(treap t, int k, int& res)
{
  if(!k) return t;
  t = fix(t);
  k = min(k, getSum(t));
  res = k;
  ptt p = splitSum(t, k);
  if(p.second)
  {
    p.second->push--;
    for(int i = 0; i < 2; i++)
    {
        long long x = minKey(p.second);
        int cntMin = getCntByKey(p.second, x);
        p.second = eraseKey(p.second, x);
        if(x != 0 && cntMin != 0)
          p.first = insertMain(p.first, x, cntMin);
    }
  }
  return merge(p.first, p.second);
}

void destroy(treap t)
{
  if(!t) return;
  if(t->l) destroy(t->l);
  if(t->r) destroy(t->r);
  delete t;
}

void solve()
{
  int n;
  cin >> n;
  string s;
  cin >> s;
  vector<long long> r(n), b(n);
  for(int i = 0; i < n; i++) cin >> r[i];
  for(int i = 0; i < n; i++) cin >> b[i];
  long long sum = 0;
  for(int i = 0; i < n; i++) sum += r[i] + b[i];
  long long flow = 0;
  treap t = NULL;
  for(int i = 0; i < n; i++)
  {
    long long d = min(r[i], b[i]);
    flow += d;
    r[i] -= d;
    b[i] -= d;
    if(s[i] == '0')
    {
      int add = 0;
      if(r[i] > 1e9) r[i] = 1e9;
      t = decreaseUpToKLargest(t, r[i], add);
      flow += add;
    }
    else
    {
      if(r[i] != 0) t = insertMain(t, r[i], 1);
    }
  }
  cout << sum - flow << endl;
}

int main()
{
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int t;
  cin >> t;
  for(int i = 0; i < t; i++) solve();
}
--------------------------------------------------
Problem ID: 1895F
Editorial Content:
1895F - Fancy Arrays
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

#define forn(i, n) for (int i = 0; i < int(n); ++i)

const int MOD = 1e9 + 7;
const int N = 40;

using mat = array<array<int, N>, N>;

int add(int x, int y) {
  x += y;
  if (x >= MOD) x -= MOD;
  if (x < 0) x += MOD;
  return x;
}

int mul(int x, int y) {
  return x * 1LL * y % MOD;
}

mat mul(mat x, mat y) {
  mat res;
  forn(i, N) forn(j, N) res[i][j] = 0;
  forn(i, N) forn(j, N) forn(k, N)
    res[i][j] = add(res[i][j], mul(x[i][k], y[k][j]));
  return res;
}

template<class T>
T binpow(T x, int y, T e) {
  T res = e;
  while (y) {
    if (y & 1) res = mul(res, x);
    x = mul(x, x);
    y >>= 1;
  }
  return res;
}

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n, x, k;
    cin >> n >> x >> k;
    mat a, e;
    forn(i, N) forn(j, N) a[i][j] = (i < x && abs(i - j) <= k);
    forn(i, N) forn(j, N) e[i][j] = (i == j);
    mat b = binpow(a, n - 1, e);
    int ans = mul(x + k, binpow(2 * k + 1, n - 1, 1));
    forn(i, x) forn(j, x) ans = add(ans, -b[i][j]);
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1895E
Editorial Content:
1895E - Infinite Card Game
Tutorial
Tutorial is loading...
Solution (awoo)
//

#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

struct card{
  int x, y;
  card() {}
  card(int x, int y) : x(x), y(y) {}
};

void dfs(int v, const vector<int> &g, vector<int> &res, vector<char> &used){
  if (used[v]) return;
  used[v] = true;
  dfs(g[v], g, res, used);
  res[v] = -res[g[v]];
}

void solve(){
  vector<vector<card>> a(2);
  vector<vector<int>> prpos(2);
  forn(z, 2){
    int n;
    scanf("%d", &n);
    a[z].resize(n);
    forn(i, n) scanf("%d", &a[z][i].x);
    forn(i, n) scanf("%d", &a[z][i].y);
    sort(a[z].begin(), a[z].end(), [](const card &a, const card &b){
      return a.x > b.x;
    });
    prpos[z].resize(n + 1, -1);
    forn(i, n){
      if (prpos[z][i] == -1 || a[z][i].y > a[z][prpos[z][i]].y)
        prpos[z][i + 1] = i;
      else
        prpos[z][i + 1] = prpos[z][i];
    }
  }
  int n = a[0].size();
  vector<int> g(n + a[1].size());
  forn(z, 2) forn(i, a[z].size()){
    int cnt = lower_bound(a[z ^ 1].begin(), a[z ^ 1].end(), card(a[z][i].y, -1), [](const card &a, const card &b){
      return a.x > b.x;
    }) - a[z ^ 1].begin();
    g[i + z * n] = prpos[z ^ 1][cnt] == -1 ? -1 : prpos[z ^ 1][cnt] + (z ^ 1) * n;
  }
  vector<int> res(g.size());
  vector<char> used(g.size());
  forn(i, g.size()) if (g[i] == -1) res[i] = 1, used[i] = true;
  int w = 0, l = 0;
  forn(i, n){
    if (!used[i]) dfs(i, g, res, used);
    w += res[i] == 1;
    l += res[i] == -1;
  }
  printf("%d %d %d\n", w, n - l - w, l);
}

int main(){
  int t;
  scanf("%d", &t);
  while (t--) solve();
}
--------------------------------------------------
Problem ID: 1895D
Editorial Content:
1895D - XOR Construction
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

const int LOG = 20;

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int n;
  cin >> n;
  vector<int> a(n);
  for (int i = 1; i < n; ++i) {
    cin >> a[i];
    a[i] ^= a[i - 1];
  }
  vector<array<int, 2>> t({{-1, -1}});
  auto add = [&](int x) {
    int v = 0;
    for (int i = LOG - 1; i >= 0; --i) {
      int j = (x >> i) & 1;
      if (t[v][j] == -1) {
        t[v][j] = t.size();
        t.push_back({-1, -1});
      }
      v = t[v][j];
    }
  };  
  for (int x : a) add(x);
  auto get = [&](int x) {
    int v = 0;
    for (int i = LOG - 1; i >= 0; --i) {
      int j = (x >> i) & 1;
      if (t[v][j ^ 1] != -1) j ^= 1;
      x ^= j << i;
      v = t[v][j];
    }
    return x;
  };
  for (int x = 0; x < n; ++x) {
    if (get(x) == n - 1) {
      for (int i : a) cout << (x ^ i) << ' ';
      break;
    }
  }
}
--------------------------------------------------
Problem ID: 1895C
Editorial Content:
1895C - Torn Lucky Ticket
Tutorial
Tutorial is loading...
Solution (awoo)
n = int(input())
s = input().split()
ans = 0
cnt = [[0 for k in range(46)] for k in range(6)]
for y in s:
    cnt[len(y)][sum([int(c) for c in y])] += 1
for L in s:
    for lenr in range(len(L) % 2, len(L) + 1, 2):
        l = len(L) + lenr
        suml = sum([int(c) for c in L[:l // 2]])
        sumr = sum([int(c) for c in L[l // 2:]])
        if suml - sumr >= 0:
            ans += cnt[lenr][suml - sumr]
for R in s:
    for lenl in range(len(R) % 2, len(R), 2):
        l = len(R) + lenl
        suml = sum([int(c) for c in R[-l // 2:]])
        sumr = sum([int(c) for c in R[:-l // 2]])
        if suml - sumr >= 0:
            ans += cnt[lenl][suml - sumr]
print(ans)
--------------------------------------------------
Problem ID: 1895B
Editorial Content:
1895B - Points and Minimum Distance
Tutorial
Tutorial is loading...
Solution (fcspartakm)
#include <bits/stdc++.h>

using namespace std;

int n;
vector<int> a;

inline void read() {
  cin >> n;
  a.clear();
  for (int i = 0; i < 2 * n; i++) {
      int x;
      cin >> x;
      a.pb(x);
  }
}
inline void solve() {
    sort(all(a));
    vector<pair<int, int> > pts;
    for (int i = 0; i < n; i++) {
        pts.pb(mp(a[i], a[i + n]));
    }
    int ans = 0;
    for (int i = 1; i < n; i++) {
        ans += abs(pts[i].ft - pts[i - 1].ft) + abs(pts[i].sc - pts[i - 1].sc);
    }
    cout << ans << endl;
    for (int i = 0; i < n; i++) {
        cout << pts[i].ft << ' ' << pts[i].sc << endl;
    }
}
 
int main () {
    int t;
    cin >> t;
    while (t--){
        read();
        solve();
    }
}
--------------------------------------------------
Problem ID: 1895A
Editorial Content:
1895A - Treasure Chest
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
    x, y, k = map(int, input().split())
    if y < x:
      print(x)
    else:
      print(y + max(0, y - x - k))
--------------------------------------------------
Problem ID: 1894B
Editorial Content:
1894B - Two Out of Three
Hint 1
Everything is symmetrical, so you can fix beforehand any exact two conditions you are aimed to satisfy.
Hint 2
You need to not satisfy $$$3$$$rd condition, so it doesnt really make sense to color any elements that not used in satisfying conditions $$$1$$$ and $$$2$$$ in colors $$$b_i = 2, b_i = 3$$$. And to satisfy conditions $$$1$$$ and $$$2$$$ one element is enough.
Tutorial
Tutorial is loading...
Solution
231849397
#include <bits/stdc++.h>
 
using namespace std;
const int N = 100;
 
void solve() {
  int n;
  cin >> n;
  vector<int> a(n);
  for (int i = 0; i < n; i++) {
    cin >> a[i];
  }
  vector<int> b(n, 1);
  vector<vector<int>> inds(N + 1);
  for (int i = 0; i < n; i++) {
    inds[a[i]].push_back(i);
  }
  int k = 2;
  for (int x = 1; x <= N; x++) {
    if ((int) inds[x].size() >= 2) {
      b[inds[x][0]] = k;
      k++;
      if (k > 3) {
        break;
      }
    }
  }
  if (k <= 3) {
    cout << "-1\n";
  } else {
    for (int i = 0; i < n; i++) {
      cout << b[i] << ' ';
    }
    cout << '\n';
  }
}
 
signed main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);
  int t;
  cin >> t;
  while (t--) {
    solve();
  }
}
--------------------------------------------------
Problem ID: 1894A
Editorial Content:
1894A - Secret Sport
Hint 1
You can always bruteforce $$$X$$$ and $$$Y$$$, and check every pair of $$$(X, Y)$$$ separately, but there is a tRiCkY solution that involves zero implementation.
Hint 2
Have you ever watched a game of tennis, a game of volleyball, e.t.c?
Tutorial
Tutorial is loading...
Solution
231849364
#include <bits/stdc++.h>
 
using namespace std;
 
void solve() {
  int n;
  cin >> n;
  string s;
  cin >> s;
  cout << s.back() << '\n';
}
 
signed main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);
  int t;
  cin >> t;
  while (t--) {
    solve();
  }
}
--------------------------------------------------
Problem ID: 1893E
Editorial Content:
1893E - Cacti Symphony
Hint 1
Cacti is a trap, don't think about it for now, it will help later.
Hint 2
Well, you need to make some observations. Start with observations about determining edges weights, it seems reasonable because edge always have exactly $$$2$$$ adjacent vertices.
Hint 3
Edge is good <=> Exactly one of the adjacent vertexes have a same weight as an edge.
Hint 4
Direct edges, such that every edge goes from vertex with same weight as edge to another vertex. In this reality try to find easier equivalent condition for ``vertice is good``.
Hint 5
Vertex is good <=> InDegree of vertex is an odd integer.
Hint 6
Now you just have two separate problems: 1) Direct all edges, such that InDegree of each vertex is odd; 2) Color all vertexes in 3 colors such that any 2 adjacent vertexes have different color. Time to remember about cacti.
Tutorial
Tutorial is loading...
Solution
231849553
#include <bits/stdc++.h>
 
typedef long long ll;
#define pb push_back
 
using namespace std;
 
const int M = 998244353;
const int N = 500500;
vector<pair<int, int>> g[N];
set<int> bridgesV[N];
bitset<N> used;
int h[N], d[N];
ll bridges = 0;
ll solo = 0;
 
int binpow(ll a, ll x) {
  ll ans = 1;
  while (x) {
    if (x % 2) {
      ans *= a;
      ans %= M;
    }
    a *= a;
    a %= M;
    x /= 2;
  }
  return (int) ans;
}
 
void dfs(int v, int p = -1) {
  if (p != -1) {
    d[v] = h[p] + 1;
    h[v] = h[p] + 1;
  }
  used[v] = true;
  for (auto &[u, w] : g[v]) {
    if (u == p) continue;
    if (!used[u]) {
      dfs(u, v);
      d[v] = min(d[v], d[u]);
      if (h[v] < d[u]) {
        bridgesV[v].insert(u);
        bridgesV[u].insert(v);
        bridges += w + 1;
        solo += w;
      }
    } else {
      d[v] = min(d[v], h[u]);
    }
  }
}
 
int calc_dp(ll n) {
  n %= (M - 1);
  if (n == 1) return 3;
  if (n == 2) return 0;
  int val = binpow(2, n);
  if (n % 2 == 1) {
    val += M - 2;
  } else {
    val += 2;
  }
  val %= M;
  return val;
}
 
signed main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);
  int n, m;
  cin >> n >> m;
  for (int i = 0; i < m; i++) {
    int a, b, w;
    cin >> a >> b >> w;
    a--;
    b--;
    g[a].pb({b, w});
    g[b].pb({a, w});
  }
  if (n % 2 != m % 2) {
    cout << "0\n";
    return 0;
  }
  dfs(0);
  used.reset();
 
  ll ans = 1;
  for (int v = 0; v < n; v++) {
    if (!used[v]) {
      ll cs = 0;
      vector<int> q = {v};
      used[v] = true;
      while (!q.empty()) {
        int u = q.back();
        q.pop_back();
        for (auto &[uu, w] : g[u]) {
          if (bridgesV[u].find(uu) != bridgesV[u].end()) continue;
          cs += w + 1;
          if (!used[uu]) {
            used[uu] = true;
            q.pb(uu);
          }
        }
      }
      cs /= 2;
      cs = max(cs, 1LL);
      ans *= calc_dp(cs);
      ans %= M;
    }
  }
  ans *= binpow(3, solo);
  ans %= M;
  int w = (2 * binpow(3, M - 2)) % M;
  ans *= binpow(w, bridges);
  ans %= M;
  int cycles = (m + 1) - n;
  ans *= binpow(2, cycles);
  ans %= M;
  cout << ans << '\n';
}
--------------------------------------------------
Problem ID: 1893D
Editorial Content:
1893D - Colorful Constructive
Hints: Natural Way
Hint 1
Solve the problem if $$$s_i = d_i$$$ for all $$$i$$$.
Hint 1.1
Simple greedy should work.
Hint 2
Solve the problem if $$$s_i = 2 \cdot d_i$$$ for all $$$i$$$.
Hint 3
Solve the problem if $$$d_i$$$ divides $$$s_i$$$ for all $$$i$$$.
Hint 4
You can treat remainder $$$(s_i \mod d_i)$$$ separately, as an individual shelf.
Hint 1
Solve the problem if $$$s_i = d_i$$$ for all $$$i$$$.
Hint 1.1
Simple greedy should work.
Hint 2
Solve the problem if $$$s_i = 2 \cdot d_i$$$ for all $$$i$$$.
Hint 3
Solve the problem if $$$d_i$$$ divides $$$s_i$$$ for all $$$i$$$.
Hint 4
You can treat remainder $$$(s_i \mod d_i)$$$ separately, as an individual shelf.
Hints: Believers Way
Hint -1
What is the most obvious greedy you can do?
Hint -2
What is the second most obvious greedy you can do?
Hint -3
What is the third most obvious greedy you can do?
Hint -4
It's probably correct at this point, just proof by AC!
Hint -1
What is the most obvious greedy you can do?
Hint -2
What is the second most obvious greedy you can do?
Hint -3
What is the third most obvious greedy you can do?
Hint -4
It's probably correct at this point, just proof by AC!
Tutorial
Tutorial is loading...
Solution
231849510
#include <bits/stdc++.h>
 
#define pb push_back
#define all(x) x.begin(), (x).end()
#define rall(x) x.rbegin(), (x).rend()
using namespace std;
 
void solve() {
  int n, m;
  cin >> n >> m;
  vector<int> a(n);
  for (int i = 0; i < n; i++) {
    cin >> a[i];
  }
  vector<int> s(m), d(m);
  for (int i = 0; i < m; i++) {
    cin >> s[i];
  }
  for (int i = 0; i < m; i++) {
    cin >> d[i];
  }
  vector<int> cnt(n + 1);
  for (int i = 0; i < n; i++) {
    cnt[a[i]]++;
  }
 
  set<pair<int, int>> cubes;
  for (int x = 1; x <= n; x++) {
    if (cnt[x] == 0) continue;
    cubes.insert({cnt[x], x});
  }
 
  vector<vector<int>> ans(m);
 
  for (int i = 0; i < m; i++) {
    ans[i].assign(s[i], 0);
    for (int j = 0; j < s[i]; j++) {
      if (j >= d[i]) {
        if (cnt[ans[i][j - d[i]]] > 0) {
          cubes.insert({cnt[ans[i][j - d[i]]], ans[i][j - d[i]]});
        }
      }
      if (cubes.empty()) {
        cout << "-1\n";
        return;
      }
      ans[i][j] = (*cubes.rbegin()).second;
      cubes.erase(*cubes.rbegin());
      cnt[ans[i][j]]--;
    }
    for (int j = s[i]; j < s[i] + d[i]; j++) {
      if (cnt[ans[i][j - d[i]]] > 0) {
        cubes.insert({cnt[ans[i][j - d[i]]], ans[i][j - d[i]]});
      }
    }
  }
 
  for (int i = 0; i < m; i++) {
    for (int j = 0; j < s[i]; j++) {
      cout << ans[i][j] << ' ';
    }
    cout << '\n';
  }
 
}
 
 
signed main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);
  int t;
  cin >> t;
  while (t--) {
    solve();
  }
}
--------------------------------------------------
Problem ID: 1893C
Editorial Content:
1893C - Freedom of Choice
Hint 1
It makes sense to try to solve case $$$m = 1$$$ first, to get general understanding of the problem, some observations will be usefull in full solution.
Hint 1.1
What size can a multiset $$$X$$$ have?
Hint 1.2
If $$$r - l > n$$$, the answer to the problem is $$$0$$$. Now we are left in the case of $$$r - l \leq n$$$. So we can iterate over all sizes from $$$l$$$ to $$$r$$$, for each of them find the minimum anti-beauty that can have a set of this size, and take the minimum of all this for the answer.
Hint 2
For bigger $$$m$$$ you need to find a fast enough way to count minimal anti-beauty with fixed size, everything else remains the same.
Tutorial
Tutorial is loading...
Solution
231849477
#include <bits/stdc++.h>
 
#define pb push_back
#define int long long
#define all(x) x.begin(), (x).end()
using namespace std;
 
void solve() {
  int m;
  cin >> m;
  vector<int> n(m), l(m), r(m);
  vector<vector<int>> a(m);
  vector<vector<int>> c(m);
  vector<int> sumc(m);
  int suml = 0, sumr = 0, sumn = 0;
  for (int i = 0; i < m; i++) {
    cin >> n[i] >> l[i] >> r[i];
    sumn += n[i];
    suml += l[i];
    sumr += r[i];
    a[i].resize(n[i]);
    for (int j = 0; j < n[i]; j++) {
      cin >> a[i][j];
    }
    c[i].resize(n[i]);
    for (int j = 0; j < n[i]; j++) {
      cin >> c[i][j];
      sumc[i] += c[i][j];
    }
  }
  
  if (sumr - suml > sumn) {
    cout << "0\n";
    return;
  }
 
  map<int, int> sumr_a;
  map<int, vector<pair<int, int>>> indexes;
  for (int i = 0; i < m; i++) {
    for (int j = 0; j < n[i]; j++) {
      sumr_a[a[i][j]] += r[i];
      indexes[a[i][j]].pb({i, j});
    }
  }
 
  int ans = (int) 2e18;
  for (int len = suml; len <= sumr; len++) {
    int xsize = 0, must_len = 0;
    xsize += sumr - sumr_a[len];
    for (auto &[i, pos] : indexes[len]) {
      int cnt_not_len = sumc[i] - c[i][pos];
      if (cnt_not_len < l[i]) {
        xsize += l[i];
        must_len += l[i] - cnt_not_len;
      } else {
        xsize += min(cnt_not_len, r[i]);
      }
    }
    ans = min(ans, must_len + max(0LL, len - xsize));
  }
  cout << ans << '\n';
}
 
signed main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);
  int t;
  cin >> t;
  while (t--) {
    solve();
  }
}
--------------------------------------------------
Problem ID: 1893B
Editorial Content:
1893B - Neutral Tonality
Hint 1
Lower bound for answer: $$$LIS(a)$$$
Hint 2
Upper bound for answer: $$$LIS(a)+1$$$, you can insert $$$b$$$'s in decreasing order anywhere. When you can't achieve $$$LIS(a)$$$?
Hint 3
Solve for $$$m = 1$$$
Tutorial
Tutorial is loading...
Solution
231849445
#include <bits/stdc++.h>
 
#define pb push_back
#define all(x) x.begin(), (x).end()
#define rall(x) x.rbegin(), (x).rend()
using namespace std;
 
void solve() {
  int n, m;
  cin >> n >> m;
  vector<int> a(n), b(m), c(n + m);
  for (int i = 0; i < n; i++) {
    cin >> a[i];
  }
  for (int i = 0; i < m; i++) {
    cin >> b[i];
  }
  sort(rall(b));
  merge(all(a), all(b), c.begin(), greater<int>());
  for (int i = 0; i < n + m; i++) {
    cout << c[i] << ' ';
  }
  cout << '\n';
}
 
signed main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);
  int t;
  cin >> t;
  while (t--) {
    solve();
  }
}
--------------------------------------------------
Problem ID: 1893A
Editorial Content:
1893A - Anonymous Informant
Hint 1
How to rollback one operation? Is rollback uniquely determined?
Hint 1.1
Of course it is.
Hint 2
After performing operation $$$a_x = x$$$ always becomes a last element of array.
Tutorial
Tutorial is loading...
Solution
231849420
#include <bits/stdc++.h>
 
using namespace std;
 
void solve() {
  int n, k;
  cin >> n >> k;
  vector<int> a(n);
  for (int i = 0; i < n; i++) {
    cin >> a[i];
  }
  k = min(k, n);
  int last = n - 1;
  for (int _ = 0; _ < k; _++) {
    if (a[last] > n) {
      cout << "No\n";
      return;
    }
    last += n - a[last];
    if (last >= n) {
      last -= n;
    }
  }
  cout << "Yes\n";
}
 
signed main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);
  int t;
  cin >> t;
  while (t--) {
    solve();
  }
}
--------------------------------------------------
Problem ID: 1891F
Editorial Content:

--------------------------------------------------
Problem ID: 1891E
Editorial Content:

--------------------------------------------------
Problem ID: 1891D
Editorial Content:

--------------------------------------------------
Problem ID: 1891C
Editorial Content:

--------------------------------------------------
Problem ID: 1891B
Editorial Content:

--------------------------------------------------
Problem ID: 1891A
Editorial Content:

--------------------------------------------------
Problem ID: 1890B
Editorial Content:
1890B - Qingshan Loves Strings
Solution
Tutorial is loading...
Code
By
Imakf
#include <bits/stdc++.h>

bool ok(std::string s) {
  for (size_t i = 1; i < s.length(); ++i)
    if (s[i] == s[i - 1])
      return false;
  return true;
}

void solve() {
  std::string s, t;
  int l1, l2;
  std::cin >> l1 >> l2;
  std::cin >> s >> t;
  if (ok(s)) {
    std::cout << "Yes" << std::endl;
    return;
  }

  if (!ok(t) || *t.begin() != *t.rbegin()) {
    std::cout << "No" << std::endl;
    return;
  }

  int zz = 0, oo = 0;
  for (size_t i = 1; i < s.length(); ++i) {
    if (s[i] == s[i - 1]) {
      if (s[i] == '0') zz = true;
      if (s[i] == '1') oo = true;
    }
  }

  if (zz && t[0] == '0') {
    std::cout << "No" << std::endl;
    return;
  }
  if (oo && t[0] == '1') {
    std::cout << "No" << std::endl;
    return;
  }  

  std::cout << "Yes" << std::endl;
  return;
}

int main() {
  int t;
  std::cin >> t;
  while (t--) solve();
  return 0;
}
--------------------------------------------------
Problem ID: 1890A
Editorial Content:
1890A - Doremy's Paint 3
Solution
Tutorial is loading...
Code
By
Cocoly1990
// Time complexity O(nlogn) because of map
#include <bits/stdc++.h>

const int MX = 100 + 5;

int main() {
  int t;
  std::cin >> t;
  while (t--) {
    int n;
    std::cin >> n;
    std::map<int ,int> occ;
    for (int i = 1; i <= n; ++i) {
      int x;
      std::cin >> x;
      occ[x]++;
    }
    if (occ.size() >= 3) puts("No");
    else {
      if (std::abs(occ.begin()->second - occ.rbegin()->second) <= 1) {
        puts("Yes");
      } else {
        puts("No");
      }
    }
  }
  return 0;
}
--------------------------------------------------
Problem ID: 1889F
Editorial Content:
1889F - Doremy's Average Tree
Solution
Tutorial is loading...
Code
By
waaitg
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ch() getchar()
#define pc(x) putchar(x)
using namespace std;
template<typename T>void read(T&x){
	static char c;static int f;
	for(f=1,c=ch();c<'0'||c>'9';c=ch())if(c=='-')f=-f;
	for(x=0;c>='0'&&c<='9';c=ch()){x=x*10+(c&15);}x*=f;
}
template<typename T>void write(T x){
	static char q[64];int cnt=0;
	if(x==0)return pc('0'),void();
	if(x<0)pc('-'),x=-x;
	while(x)q[cnt++]=x%10+'0',x/=10;
	while(cnt--)pc(q[cnt]);
}
long long gcd(long long a,long long b){
	if(b==0)return a;
	return gcd(b,a%b);
}
struct Frac{
	long long a;
	int b;// a/b
	Frac(long long a=0,int b=1):
		a(a),b(b){}
	bool operator < (const Frac o)const{
		return a*o.b<o.a*b;
	}
	bool operator > (const Frac o)const{
		return a*o.b>o.a*b;
	}
	bool operator == (const Frac o)const{
		return a*o.b==o.a*b;
	}
	void output(){
		printf("%lld/%d",a,b);
	}
};
const int inf=0x3f3f3f3f;
struct Val{
	int p1,p2;Frac v1,v2;
	Val(int p1=inf,int p2=inf,Frac v1=Frac(),Frac v2=Frac()):
		p1(p1),p2(p2),v1(v1),v2(v2){}
	void output(void){
		printf("%d : ",p1);v1.output();puts("");
		printf("%d : ",p2);v2.output();puts("\n");
	}
};
Val Comb(Val A,Val B){
	if(A.p1>B.p1)swap(A,B);
	if(B.v1==A.v1)
		return Val(A.p1,A.p2<B.p2?A.p2:B.p2,A.v1,A.p2<B.p2?A.v2:B.v2);
	return Val(A.p1,A.p2<B.p1?A.p2:B.p1,A.v1,A.p2<B.p1?A.v2:B.v1);
}
const int maxn=10005,maxk=505;
struct Edge{
	int v,nt;
	Edge(int v=0,int nt=0):
		v(v),nt(nt){}
}e[maxn*2];
int hd[maxn],num;
void qwq(int u,int v){
	e[++num]=Edge(v,hd[u]),hd[u]=num;
}
long long sm[maxn];int sz[maxn];
int dp[maxn][maxk],wp[maxn][maxk],k,n;
Val va[maxn][maxk];
void Merge(int x,int l,int r,int L,int R){
	wp[x][0]=0;
	va[x][0]=Comb(va[l][0],va[r][0]);
	L=min(L,k);R=min(R,k);
	int up=min(L+R,k);
	for(int i=1;i<=up;++i){
		int t=wp[x][i]=min(L,i),cl=inf,cr=inf;
		while(t>0&&i-t<R){
			cl=min(cl,dp[l][t]);--t;
			cr=min(cr,dp[r][i-t]);
			if(cr<cl)wp[x][i]=t,cl=cr=inf;
		}
		t=wp[x][i-1];cl=cr=inf;
		if(wp[x][i-1]<wp[x][i]){
			while(t<wp[x][i])cl=min(cl,dp[l][++t]);
			dp[x][i]=cl;
		}
		else{
			while(i-t-1<i-wp[x][i])cr=min(cr,dp[r][i-(t--)]);
			dp[x][i]=cr;
		}
		va[x][i]=Comb(va[l][wp[x][i]],va[r][i-wp[x][i]]);
	}
}
int MN[maxn],rsz[maxn];
long long val[maxn];
void dfs(int u,int p){
	int l=0,fa=0;sm[u]=val[u];
	sz[u]=0;rsz[u]=1;MN[u]=0;
	for(int i=hd[u];i;i=e[i].nt){
		int v=e[i].v;
		if(v==p){fa=i;continue;}dfs(v,u);
		Merge(i,i^1,l,sz[v],sz[u]);
		sm[u]+=sm[v],sz[u]+=sz[v];
		rsz[u]+=rsz[v];
		l=i;
	}
	if(sz[u]==0){
		++sz[u];MN[u]=1;
		va[fa][0]=va[fa][1]=Val(u,inf,val[u]);
		dp[fa][1]=inf;
	}
	else{
		int up=min(sz[u],k);
		for(int i=0;i<=up;++i)
			va[fa][i]=Comb(va[l][i],Val(u,inf,val[u])),dp[fa][i]=dp[l][i];
		Frac tmp(sm[u],rsz[u]);
		for(int i=1;i<=up;++i)
			if(va[fa][i].v1>tmp||(va[fa][i].v1==tmp&&va[fa][i].v2>tmp))
				va[fa][i]=Val(va[fa][i].p1,inf,tmp),MN[u]=i;
		if(MN[u]){
			if(va[fa][0].v1==va[fa][1].v1)
				dp[fa][1]=va[fa][0].p2;
			else
				dp[fa][1]=va[fa][0].p1;
			for(int i=2;i<=MN[u];++i)
				dp[fa][i]=inf;
			if(MN[u]<up){
				if(va[fa][MN[u]].v1==va[fa][MN[u]+1].v1)
					dp[fa][MN[u]+1]=va[fa][MN[u]+1].p2;
				else
					dp[fa][MN[u]+1]=va[fa][MN[u]+1].p1;
			}
		}
	}/*
	int up=min(sz[u],k);
	printf("%d MN:%d\n",u,MN[u]);
	for(int i=1;i<=up;++i)
		printf("dp %d = %d\n",i,dp[fa][i]);*/
}
int st[maxn],ts;
int que[maxn],cnt;
void solve(int u,int p,int sk){
	if(sk==0)return;sk=min(sk,sz[u]);
	if(sk<=MN[u])return st[++ts]=u,void();
	int tnc=cnt;
	for(int i=hd[u];i;i=e[i].nt){
		int v=e[i].v;
		if(v==p)continue;
		que[cnt++]=i;
	}
	for(int j=cnt-1;j>=tnc;--j){
		int i=que[j];
		solve(e[i].v,u,wp[i][sk]);
		sk-=wp[i][sk];
	}
}
void imple(void){
	int r;
	read(n),read(r),read(k);
	for(int i=1;i<=n;++i)
		read(val[i]);
	qwq(r,0);
	for(int i=1;i<n;++i){
		int u,v;read(u),read(v);
		qwq(u,v);qwq(v,u);
	}
	dfs(r,0);
	solve(r,0,k);
	printf("%d\n",ts);
	for(int i=1;i<=ts;++i)
		printf("%d%c",st[i]," \n"[i==ts]);
	for(int i=0;i<=n;++i)hd[i]=0;
	num=cnt=ts=0;
}
int main(){
	// freopen("test","r",stdin);
	int T;read(T);
	while(T--)imple();
	return 0;
}
--------------------------------------------------
Problem ID: 1889E
Editorial Content:
1889E - Doremy's Swapping Trees
Solution
Tutorial is loading...
Code
By
waaitg
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=100005;
struct Edge{
    int v,nt;
    Edge(int v=0,int nt=0):
        v(v),nt(nt){}
}eG[maxn*160];
int hdG[maxn*40],numG;
void qwqG(int u,int v){
    eG[++numG]=Edge(v,hdG[u]);hdG[u]=numG;
}
int tot;
struct AnTree{
    struct Edge{
        int v,nt;
        Edge(int v=0,int nt=0):
            v(v),nt(nt){}
    }e[maxn*2];
    int hd[maxn],num;
    void qwq(int u,int v){
        e[++num]=Edge(v,hd[u]),hd[u]=num;
    }
    int n;
    void init(int n){
        this->n=n;
        for(int i=1;i<n;++i){
            int u,v;
            scanf("%d%d",&u,&v);
            qwq(u,v);qwq(v,u);
        }
    }
    int pa[maxn][20],id[maxn][20],dp[maxn];
    void dfs(int u,int p){
        if(p==0)dp[u]=0;
        for(int i=1;(1<<i)<=dp[u];++i)
            pa[u][i]=pa[pa[u][i-1]][i-1];
        for(int i=hd[u];i;i=e[i].nt){
            int v=e[i].v;
            if(v==p)continue;
            dp[v]=dp[u]+1;
            pa[v][0]=u;
            id[v][0]=++tot;
            dfs(v,u);
        }
    }
    int getid(int u,int d){
        int&re=id[u][d];
        if(re)return re;
        re=++tot;
        qwqG(re,getid(u,d-1));
        qwqG(re,getid(pa[u][d-1],d-1));
        return re;
    }
    void link(int x,int u,int v){
        if(dp[u]<dp[v])swap(u,v);
        for(int t=dp[u]-dp[v],cn=0;t;t>>=1,++cn)
            if(t&1)qwqG(x,getid(u,cn)),u=pa[u][cn];
        if(u==v)return;
        int t=0;while(dp[u]>>t)++t;
        while(t--){
            if(pa[u][t]!=pa[v][t]){
                qwqG(x,getid(u,t));
                qwqG(x,getid(v,t));
                u=pa[u][t];v=pa[v][t];
            }
        }
        qwqG(x,getid(u,0));
        qwqG(x,getid(v,0));
    }
    void erase(void){
        for(int i=1;i<=n;++i){
            hd[i]=0,dp[i]=0;int j=0;
            while(pa[i][j])pa[i][j++]=0;
            j=0;while(id[i][j])id[i][j++]=0;
        }
        num=0;
    }
    int parent(int u){
        return pa[u][0];
    }
    int identity(int u){
        return id[u][0];
    }
}T1,T2;
int dfn[maxn*40],low[maxn*40],cnt;
int st[maxn*40],tp,in[maxn*40];
int scc[maxn*40],scn;
int vis[maxn*40];
void tarjan(int u){
    dfn[u]=low[u]=++cnt;
    in[st[++tp]=u]=true;
    for(int i=hdG[u];i;i=eG[i].nt){
        int v=eG[i].v;
        if(!dfn[v]){
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else if(in[v])
            low[u]=min(low[u],dfn[v]);
    }
    if(dfn[u]==low[u]){
        ++scn;
        st[tp+1]=0;
        while(st[tp+1]!=u){
            in[st[tp]]=false;
            scc[st[tp]]=scn;
            --tp;
        }
    }
}
const int mod=1e9+7;
int power(int a,int x){
    int re=1;
    while(x){
        if(x&1)re=1ll*re*a%mod;
        a=1ll*a*a%mod,x>>=1;
    }
    return re;
}
void solve(void){
    int n;scanf("%d",&n);
    T1.init(n);T2.init(n);
    T1.dfs(1,0);T2.dfs(1,0);
    int rec=tot;
    for(int i=2;i<=n;++i){
        T2.link(T1.identity(i),i,T1.parent(i));
        T1.link(T2.identity(i),i,T2.parent(i));
    }
    for(int i=1;i<=tot;++i)
        if(!dfn[i])tarjan(i);
    for(int i=1;i<=rec;++i)
        ++vis[scc[i]];
    int ANS=0;
    for(int i=1;i<=scn;++i){
        if(vis[i])++ANS;
        vis[i]=0;
    }
    for(int u=1;u<=rec;++u){
        if(eG[hdG[u]].nt==0){
            int v=eG[hdG[u]].v;
            if(u<v&&eG[hdG[v]].nt==0){
                if(eG[hdG[v]].v==u){
                    --ANS;
                }
            }
        }
    }
    ANS=power(2,ANS);
    printf("%d\n",ANS);
    for(int i=1;i<=tot;++i){
        hdG[i]=0;
        dfn[i]=low[i]=scc[i]=0;
    }
    tot=cnt=scn=numG=0;
    T1.erase();T2.erase();
}
int main(){
    // freopen("test","r",stdin);
    // freopen("out","w",stdout);
    int T;scanf("%d",&T);
    while(T--)solve();
    return 0;
}
--------------------------------------------------
Problem ID: 1889D
Editorial Content:
1889D - Game of Stacks
Solution
Tutorial is loading...
Code
By
waaitg
#include<stack>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=100005;
stack<int>s[maxn];
int re[maxn],st[maxn],vis[maxn],tp;
int dfs(int u){
    if(re[u])
        return re[u];
    if(s[u].empty())
        return u;
    if(vis[u]){
        st[tp+1]=0;
        while(st[tp+1]!=u){
            s[st[tp]].pop();
            vis[st[tp]]=0;
            --tp;
        }
        return dfs(u);
    }
    st[vis[u]=++tp]=u;
    return dfs(s[u].top());
}
int main(){
    int n;scanf("%d",&n);
    for(int i=1;i<=n;++i){
        int k;scanf("%d",&k);
        while(k--){
            int c;scanf("%d",&c);
            s[i].push(c);
        }
    }
    for(int i=1;i<=n;++i){
        tp=0;int ok=dfs(i);
        for(int j=1;j<=tp;++j)
            re[st[j]]=ok;
        printf("%d%c",ok," \n"[i==n]);
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1889C2
Editorial Content:
1889C2 - Doremy's Drying Plan (Hard Version)
Easy Solution
Tutorial is loading...
Hard Solution
Tutorial is loading...
Code
By
Imakf
#include <bits/stdc++.h>

#define debug(...) fprintf(stderr, __VA_ARGS__)
#define LL long long

const int MX = 2e5 + 23;
const int INF = 1e9;

void chkmax(int &x, int y) {
  x = std::max(x, y);
}

struct Interval {
  int l, r;
} I[MX];

bool cmp(int x, int y) {
  return I[x].l > I[y].l;
}

std::vector<int> add[MX], del[MX];
int n, m, k, ban[MX];

int st[21][MX][18], lg[MX];

int query(int d, int l, int r) {
  int len = lg[r - l + 1];
  return std::max(st[d][l][len], st[d][r - (1 << len) + 1][len]);
}

void change(int d, int p, int val) {
  chkmax(st[d][p][0], val);
  for (int i = 1; p - (1 << i) + 1 >= 0; ++i) {
    st[d][p - (1 << i) + 1][i] = std::max(
          st[d][p - (1 << i) + 1][i - 1],
          st[d][p - (1 << (i - 1)) + 1][i - 1]);
  }
}

void init() {
  lg[0] = -1;
  for (int i = 1; i <= n + 1; ++i)
    lg[i] = lg[i - 1] + ((i & -i) == i); 
  for (int i = 1; i <= m; ++i) ban[i] = false;
  for (int i = 1; i <= n + 1; ++i) {
    add[i].clear();
    del[i].clear();
  }
  for (int i = 0; i <= k; ++i)
    for (int j = 0; j <= n; ++j)
      for (int _k = 0; _k < 18; ++_k)
        st[i][j][_k] = -INF;
}

void solve() {
  scanf("%d%d%d", &n, &m, &k);
  init();
  for (int i = 1; i <= m; ++i) {
    int l, r;
    scanf("%d%d", &l, &r);
    I[i] = (Interval){l, r};
    add[l].push_back(i);
    del[r + 1].push_back(i);
  }
  
  std::vector<int> cur, tmp;

  change(0, 0, 0);
  
  int uncover = 0, ans = 0;
  int cnti = 0;
  for (int i = 1; i <= n; ++i) {
    for (auto j : add[i]) {
      cur.push_back(j);
      ++cnti;
    }

    for (auto j : del[i]) {
      ban[j] = true;
      --cnti;
    }

    if (cnti > k) {
      for (int j = 0; j <= k; ++j)
        change(j, i, -INF);
      continue;
    }

    tmp.clear();
    for (auto j : cur) {
      if (!ban[j]) {
        tmp.push_back(j);
      }
    }
    cur = tmp;
    std::sort(cur.begin(), cur.end(), cmp);
    
    if (cur.empty()) {
      for (int j = 0; j <= k; ++j)
        change(j, i, -INF);
      ++uncover;
      continue;
    }
    
    if (I[cur[0]].l <= i - 1)
      for (int g = 0; g <= k; ++g) {
        int z = query(g, I[cur[0]].l, i - 1);
        chkmax(ans, z + 1);
        change(g, i, z + 1);
      }
    else {
      for (int g = 0; g <= k; ++g) {
        change(g, i, -INF);
      }
    }
    int cp = I[cur[0]].l - 1;
    

    for (int j = 0; j < cur.size(); ++j) {
      if (j + 1 != cur.size() && I[cur[j]].l == I[cur[j + 1]].l)
        continue;
      int np = (j + 1 == cur.size() ? 0 : I[cur[j + 1]].l);
      for (int g = j + 1; g <= k; ++g) {
        int z = query(g - (j + 1), np, cp);
        chkmax(ans, z + 1);
        change(g, i, z + 1);
        // change(root[g], i, z + 1);
      }
      cp = np - 1;
    }
  }
  printf("%d\n", ans + uncover);
}

int main() {
  int t; scanf("%d", &t);

  while (t--) solve();
  return 0;
}
--------------------------------------------------
Problem ID: 1889C1
Editorial Content:

--------------------------------------------------
Problem ID: 1889B
Editorial Content:
1889B - Doremy's Connecting Plan
Solution
Tutorial is loading...
Code
By
Cocoly1990
#include<bits/stdc++.h>
using i64 = long long;
using namespace std;
const int N = 5e5 + 7;
int T, n, C, p[N]; i64 a[N];
void solve () {
	cin >> n >> C;
	for (int i = 1; i <= n; i ++) cin >> a[i];
	iota (p + 1, p + n + 1, 1);
	sort (p + 1, p + n + 1, [&] (const int &u, const int &v) {
		return 1ll * u * C - a[u] < 1ll * v * C - a[v];
	});
	i64 now = a[1];
	for (int i = 1, u; i <= n; i ++) {
		u = p[i];
		if (u == 1) continue;
		if (1ll * u * C > now + a[u]) return cout << "No\n", void ();
		now += a[u];
	}
	return cout << "Yes\n", void ();
}
int main () {
	ios :: sync_with_stdio (false); cin.tie (0); cout.tie (0);
	cin >> T; while (T --) solve ();
}
--------------------------------------------------
Problem ID: 1889A
Editorial Content:
1889A - Qingshan Loves Strings 2
Solution
Tutorial is loading...
Code
By
Imakf
#include <bits/stdc++.h>

bool ok(std::string s) {
  for (size_t i = 1; i < s.length(); ++i)
    if (s[i] == s[i - 1])
      return false;
  return true;
}


std::string s;
void solve() {
  int n; std::cin >> n;
  std::cin >> s;
  int cnt0 = 0, cnt1 = 0;
  for (int i = 0; i < s.length(); ++i) {
    cnt0 += s[i] == '0';
    cnt1 += s[i] == '1';
  }
  if (cnt0 != cnt1) {
    std::cout << -1 << std::endl;
    return;
  }
  std::vector<int> z;
  std::deque<char> q;
  for (int i = 0; i < s.length(); ++i)
    q.push_back(s[i]);
  
  int d = 0;
  while (!q.empty()) {
    if (q.front() == q.back()) {
      if (q.front() == '0') {
        q.push_back('0');
        q.push_back('1');
        z.push_back(n - d);
      } else {
        q.push_front('1');
        q.push_front('0');
        z.push_back(0 + d);
      }
      n += 2;
    }
    while (!q.empty() && q.front() != q.back()) {
      q.pop_back();
      q.pop_front();
      ++d;
    }
  }

  std::cout << z.size() << std::endl;
  for (int i = 0; i < z.size(); ++i) {
    std::cout << z[i];
    if (i + 1 == z.size()) std::cout << std::endl;
    else std::cout << " ";
  }
}

int main() {
  int t;
  std::cin >> t;
  while (t--) solve();
  return 0;
}
--------------------------------------------------
Problem ID: 1887F
Editorial Content:

--------------------------------------------------
Problem ID: 1887E
Editorial Content:

--------------------------------------------------
Problem ID: 1887D
Editorial Content:

--------------------------------------------------
Problem ID: 1887C
Editorial Content:

--------------------------------------------------
Problem ID: 1887B
Editorial Content:

--------------------------------------------------
Problem ID: 1886F
Editorial Content:
1886F - Diamond Theft
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 3003;
 
int n;
int k[4];
vector<int> a[4];
 
struct segtree {
  int sz;
  int tot;
  vector<int> t, p;
  
  segtree(int sz) : sz(sz) {
    tot = 0;
    t = vector<int>(4 * sz);
    p = vector<int>(4 * sz);
    build(0, 0, sz);
  }
  
  void build(int v, int l, int r) {
    if (l + 1 == r) {
      t[v] = -l;
      return;
    }
    int m = (l + r) / 2;
    build(v * 2 + 1, l, m);
    build(v * 2 + 2, m, r);
    t[v] = max(t[v * 2 + 1], t[v * 2 + 2]);
  }
  
  void push(int v) {
    if (p[v] == 0) return;
    if (v + 1 < 2 * sz) {
      t[v * 2 + 1] += p[v];
      p[v * 2 + 1] += p[v];
      t[v * 2 + 2] += p[v];
      p[v * 2 + 2] += p[v];
      p[v] = 0;
    }
  } 
  
  void upd(int v, int l, int r, int L, int R, int x) {
    if (L >= R) return;
    if (l == L && r == R) {
      t[v] += x;
      p[v] += x;
      return;
    }
    push(v);
    int m = (l + r) / 2;
    upd(v * 2 + 1, l, m, L, min(m, R), x);
    upd(v * 2 + 2, m, r, max(L, m), R, x);
    t[v] = max(t[v * 2 + 1], t[v * 2 + 2]);
  }
  
  void upd(int pos, int x) { 
    tot += x;
    upd(0, 0, sz, max(0, pos), sz, x);
  }
  
  int get(int v, int l, int r, int L, int R) {
    if (L >= R) return -1e9;
    if (l == L && r == R) return t[v];
    push(v);
    int m = (l + r) / 2;
    return max(
      get(v * 2 + 1, l, m, L, min(m, R)),
      get(v * 2 + 2, m, r, max(L, m), R)
    );
  }
  
  int get(int L) {
    return get(0, 0, sz, max(0, L), sz);
  }
  
  int getBad(int v, int l, int r) {
    if (t[v] <= 0) return -1;
    if (l + 1 == r) return l;
    push(v);
    int m = (l + r) / 2;
    if (t[v * 2 + 1] > 0) {
      return getBad(v * 2 + 1, l, m);
    } else {
      return getBad(v * 2 + 2, m, r);
    }
  }
  
  int getBad() {
    return getBad(0, 0, sz);
  }
};  
 
int main() {
  cin >> n;
  int sz = 1;
  for (int i = 0; i < n; ++i) {
    int t, s;
    cin >> t >> s;
    a[t].push_back(s);
    sz = max(sz, s + 1);
  }
  for (int t = 1; t < 4; ++t) {
    sort(a[t].begin(), a[t].end());
    k[t] = a[t].size();
  }
  reverse(a[2].begin(), a[2].end());
  int ans = 1e4;
  for (int len = 1; len <= k[2] + k[3] + 1; ++len) {
    segtree L(sz), R(sz);
    multiset<int> used;
    for (int x : a[1]) L.upd(x, +1);
    for (int x : a[2]) R.upd(x, +1);
    for (int x : a[3]) {
      L.upd(x - len, +1);
      if (L.t[0] <= 0) {
        used.insert(x - len);
      } else {
        L.upd(x - len, -1);
        L.upd(x, +1);
        R.upd(x, +1);
      }
    }
    for (int i = 0; i <= k[2]; ++i) {
      if (L.t[0] <= 0 && R.t[0] <= 0 && R.tot + 1 <= len)
        ans = min(ans, n + (k[3] - (int)used.size()) + 2); 
      if (i == k[2]) break;
      R.upd(a[2][i], -1);
      L.upd(a[2][i] - len, +1);
      int pos;
      while ((pos = L.getBad()) != -1) {
        auto it = used.upper_bound(pos);
        if (it == used.begin()) break;
        --it;
        L.upd(*it, -1);
        L.upd(*it + len, +1);
        R.upd(*it + len, +1);
        used.erase(it);
      }
    }
  }
  if (ans == 1e4) ans = -1;
  cout << ans << '\n';
}
--------------------------------------------------
Problem ID: 1886E
Editorial Content:
1886E - I Wanna be the Team Leader
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
using namespace std;
 
int main() {
	int n, m;
	scanf("%d%d", &n, &m);
	vector<int> a(n), b(m);
	forn(i, n) scanf("%d", &a[i]);
	forn(i, m) scanf("%d", &b[i]);
	vector<int> ord(n);
	iota(ord.begin(), ord.end(), 0);
	sort(ord.begin(), ord.end(), [&a](int i, int j){
		return a[i] > a[j];
	});
	vector<vector<int>> mn(m, vector<int>(n + 2));
	forn(i, m){
		int r = 0;
		forn(l, n + 2){
			r = min(n + 1, max(r, l + 1));
			while (r <= n && a[ord[r - 1]] * (r - l) < b[i]) ++r;
			mn[i][l] = r;
		}
	}
	vector<int> dp(1 << m, n + 1);
	dp[0] = 0;
	vector<int> p(1 << m, -1);
	forn(mask, 1 << m) forn(i, m) if (!((mask >> i) & 1) && dp[mask | (1 << i)] > mn[i][dp[mask]]){
		dp[mask | (1 << i)] = mn[i][dp[mask]];
		p[mask | (1 << i)] = mask;
	}
	int mask = (1 << m) - 1;
	if (dp[mask] > n){
		puts("NO");
		return 0;
	}
	puts("YES");
	vector<vector<int>> ans(n);
	forn(_, m){
		int i = __builtin_ctz(mask ^ p[mask]);
		for (int j = dp[p[mask]]; j < dp[mask]; ++j)
			ans[i].push_back(ord[j]);
		mask = p[mask];
	}
	forn(i, m){
		printf("%d", int(ans[i].size()));
		for (int x : ans[i]) printf(" %d", x + 1);
		puts("");
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1886D
Editorial Content:
1886D - Monocarp and the Set
Tutorial
Tutorial is loading...
Solution (Roms)
#include <bits/stdc++.h>

using namespace std;

const int MOD = 998244353;

const int N = 300009;

int bp(int a, int n) {
    int res = 1;
    while(n > 0) {
        if (n & 1)
            res = (res * 1LL * a) % MOD;
        a = (a * 1LL * a) % MOD;
        n >>= 1;
    }
    return res;
}

int n, m;
string s;
int inv[N];

void upd(int &res, int x) {
    res = (res * 1LL * x) % MOD;
}

int main() {
    inv[1] = 1;
    for (int i = 2; i < N; ++i){
	    inv[i] = bp(i, MOD - 2);
    }
    
    cin >> n >> m >> s;
    
    int res = 1, k = n;
    bool isZero = false;
    for (int i = 0; i < s.size(); ++i) 
        if (s[i] == '?') {
            if (i == 0) {
                isZero = true;
            } else {
                upd(res, i);
            }
        }
    
    cout << (isZero? 0 : res) << endl;
    
    for(int i = 0; i < m; ++i) {
        int pos;
        char c;
        cin >> pos >> c;
        --pos;
        
        if (s[pos] == '?' && (c == '<' || c == '>')) {
            if (pos == 0)
                isZero = false;
            else
                upd(res, inv[pos]);
        } else if ((s[pos] == '<' || s[pos] == '>') && c == '?') {
            if (pos == 0)
                isZero = true;
            else
                upd(res, pos);
        }
        
        s[pos] = c;
        cout << (isZero? 0 : res) << endl;
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1886C
Editorial Content:
1886C - Decreasing String
Tutorial
Tutorial is loading...
Solution (Roms)
#include <bits/stdc++.h>

using namespace std;

const int N = 200000;

int t;

int main() {
    cin >> t;
    for (int tc = 0; tc < t; ++tc) {
        string s;
        long long pos;
        cin >> s >> pos;
        --pos;
        
        int curLen = s.size();
        vector <char> st;
        bool ok = pos < curLen;
        s += '$';
        
        for (auto c : s) {
            while (!ok && st.size() > 0 && st.back() > c) {
                pos -= curLen;
                --curLen;
                st.pop_back();
                
                if(pos < curLen) 
                    ok = true;
            }
            st.push_back(c);
        }
        
        cout << st[pos];
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1886B
Editorial Content:
1886B - Fear of the Dark
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  auto dist = [](int x1, int y1, int x2, int y2) {
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
  };
 
  int t;
  cin >> t;
  while (t--) {
    int px, py, ax, ay, bx, by;
    cin >> px >> py >> ax >> ay >> bx >> by;
    double pa = dist(px, py, ax, ay), pb = dist(px, py, bx, by);
    double oa = dist(0, 0, ax, ay), ob = dist(0, 0, bx, by);
    double ab = dist(ax, ay, bx, by);
    double ans = 1e9;
    ans = min(ans, max(pa, oa));
    ans = min(ans, max(pb, ob));
    ans = min(ans, max({ab / 2, pa, ob}));
    ans = min(ans, max({ab / 2, pb, oa}));
    cout << setprecision(10) << fixed << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1886A
Editorial Content:
1886A - Sum of Three
Tutorial
Tutorial is loading...
Solution (fcspartakm)
#include <bits/stdc++.h>

using namespace std;

int n;

inline void read() {
	cin >> n;
}

inline void solve() {
	for (int x = 1; x <= 20; x++) {
	    for (int y = 1; y <= 20; y++) {
	        if (x + y >= n || x == y) continue;
	        int z = n - x - y;
	        if (z == x || z == y) continue;
	        if (x % 3 == 0 || y % 3 == 0 || z % 3 == 0) {
	            continue;
	        }
	        puts("YES");
	        cout << x << ' ' << y << ' ' << z << endl;
	        return;
	    }
	}
	puts("NO");
}

int main () {
    int t;
    cin >> t;
    while (t--){
        read();
        solve();
    }
}
--------------------------------------------------
Problem ID: 1885A
Editorial data not available.
--------------------------------------------------
Problem ID: 1884E
Editorial Content:

--------------------------------------------------
Problem ID: 1884D
Editorial Content:

--------------------------------------------------
Problem ID: 1884C
Editorial Content:

--------------------------------------------------
Problem ID: 1884B
Editorial Content:

--------------------------------------------------
Problem ID: 1884A
Editorial Content:

--------------------------------------------------
Problem ID: 1883G2
Editorial Content:

--------------------------------------------------
Problem ID: 1883G1
Editorial Content:

--------------------------------------------------
Problem ID: 1883F
Editorial Content:

--------------------------------------------------
Problem ID: 1883E
Editorial Content:

--------------------------------------------------
Problem ID: 1883D
Editorial Content:

--------------------------------------------------
Problem ID: 1883C
Editorial Content:

--------------------------------------------------
Problem ID: 1883B
Editorial Content:

--------------------------------------------------
Problem ID: 1883A
Editorial Content:

--------------------------------------------------
Problem ID: 1882E2
Editorial Content:
1882E2 - Two Permutations (Hard Version)
Hint 1
The solution is completely different from E1. A brilliant idea is required. Maybe the fact that checker is implemented in linear time might be the hint.
Hint 2
Find a way changing the operation to 'swap'.
Hint 3
Add an extra character.
Tutorial
Add an extra character '$$$X$$$' in front of the permutation. Here position of $$$X$$$ won't be changed by the operation, and will always locate at left of $$$p_{1}$$$. Then in each operation, the permutation will change as: $$$[X [ A ] c [ B ]] \rightarrow [X [ B ] c [ A ]]$$$.
Now, let's consider the array made by $$$X$$$ and permutation as
circular
. This is possible because $$$X$$$ is always in left of $$$1$$$st element, so it marks the start of the permutation. Then $$$[X [ B ] c [ A ]]$$$ is equivalent with $$$[c [ A ] X [ B ]]$$$.
Then the operation is: $$$[X [ A ] c [ B ]] \rightarrow [c [ A ] X [ B ]]$$$, which is same with swapping $$$X$$$ and $$$c$$$.
Now we need to calculate the minimum odd number of swaps and even number of swaps(of $$$X$$$ and any element) each, turning $$$[X\,p_{1}\,p_{2}\,\cdots\,p_{n}]$$$ to one of $$$[X\,1\,2\,\cdots\,n]$$$, $$$[n\,X\,1\,2\,\cdots\,(n-1)]$$$, $$$[(n-1)\,n\,X\,1\,\cdots\,(n-2)]$$$, $$$\cdots$$$, $$$[1\,2\,\cdots\,n\,X]$$$.
To calculate the minimum number of swaps required to turn $$$[X\,p_{1}\,p_{2}\,\cdots\,p_{n}]$$$ to the given array, first renumber the initial array to $$$[X\,1\,2\,\cdots\,n]$$$, then change the given array in the same correspondence. Do permutation cycle decomposition. Then the answer is (sum of (size + 1) for cycles which have size $$$\ge$$$ 2 and don't contain $$$X$$$) + ($$$X$$$'s cycle size $$$-$$$ 1). This can be proven easily by counting the number of elements which go into the proper place in each operations.
Calculate this for all $$$[X\,1\,2\,\cdots\,n]$$$, $$$[n\,X\,1\,2\,\cdots\,(n-1)]$$$, $$$[(n-1)\,n\,X\,1\,\cdots\,(n-2)]$$$, $$$\cdots$$$, $$$[1\,2\,\cdots\,n\,X]$$$. Since we can't make the same array using different parity of number of swaps, we can achieve the goal by calculating the minimum odd number and minimum even number each.
The overall time complexity is $$$O(n^{2}+m^{2})$$$.
Challenge
Try solving E1 in $$$n,\,m \le 10^{5}$$$, using at most $$$1.5 \times 10^{5}$$$ operations. It is solvable :)
--------------------------------------------------
Problem ID: 1882E1
Editorial Content:
1882E1 - Two Permutations (Easy Version)
Hint 1
Let's think two permutations independently. The goal is to make sequence of operations for each permutation which have same parity of number of operations.
Hint 2
Try to sort single permutation of length $$$N$$$, using at most $$$3N$$$ operations. It is always possible.
Hint 3
If the permutation's length is odd, you can perform operation at index $$$1$$$ for $$$N$$$ times and return to the same permutation.
Hint 4
If the permutation's length is even, the parity of inversion number changes in each operations.
Tutorial
Hints above were the summary of the tutorial. Please check them.
First, let's do Hint 2. There are lots of ways to do this, and I'd like to introduce one which I thought first. It is possible to swap two elements using $$$3$$$ operations. Let's denote the two elements as $$$x$$$ and $$$y$$$, and permutation as $$$[[ A ] x [ B ] y [ C ]]$$$ ($$$[ A ], [ B ], [ C ]$$$ are subarrays). Then:
Perform the operation at $$$x$$$. Permutation becomes $$$[[ B ] y [ C ] x [ A ]]$$$.
Perform the operation at $$$y$$$. Permutation becomes $$$[[ C ] x [ A ] y [ B ]]$$$.
Perform the operation at $$$x$$$. Permutation becomes $$$[[ A ] y [ B ] x [ C ]]$$$.
Using this, we can sort the single permutation of length $$$N$$$ using at most $$$3N$$$ operations, since we can sort the permutation by $$$N$$$ swaps.
If this requires same parity of number of operations for $$$p$$$ and $$$q$$$, the problem is solved. At most $$$3 \max(m, n)$$$ operations are used.
Else, if $$$n$$$ or $$$m$$$ is odd, we can make the parity equal by method provided in Hint 3. At most $$$4 \max(m, n)$$$ operations are used.
Else, then $$$n$$$ and $$$m$$$ is both even. In this case, it's impossible because of Hint 4.
The overall time complexity is $$$\mathcal{O}(n + m)$$$ in this solution.
Lastly, here is the proof of Hint 4.
Proof: Let's consider the permutation of length $$$N$$$($$$N$$$ is even). Denote the permutation as $$$[[ A ] x [ B ]]$$$, and the length of $$$[ A ]$$$ and $$$[ B ]$$$ as $$$n_{A}$$$ and $$$n_{B}$$$. Here $$$n_{A} + n_{B} = N-1$$$ so one of $$$n_{A}$$$ and $$$n_{B}$$$ is even and one of them is odd. Permutation becomes $$$[[ B ] x [ A ]]$$$ after the operation.
First, the parity of inversion number from two elements of $$$[ A ]$$$ or two elements of $$$[ B ]$$$ doesn't change, because their order inside doesn't change.
Second, the parity of inversion number from one element of $$$[ A ]$$$ and one element of $$$[ B ]$$$ doesn't change, because sum of them are $$$n_{A} \times n_{B}$$$, which is even.
Third, the parity of inversion number from $$$x$$$ and one element of $$$[ A ]$$$ or $$$[ B ]$$$ changes, because sum of them are $$$n_{A} + n_{B}$$$, which is odd.
If we add these three, we can lead to the conclusion that the parity of inversion number must change. The text may look a bit complicated, but it will not be that hard if you write them in your own :)
--------------------------------------------------
Problem ID: 1882D
Editorial Content:
1882D - Tree XOR
Hint 1
Try to solve the problem for single root.
Hint 2
For any vertex $$$v$$$ which isn't the root, denote $$$par_{v}$$$ as the parent of $$$v$$$. Then value of $$$a_{v} \oplus a_{par_{v}}$$$ only changes if we perform the operation on $$$v$$$.
Hint 3
Since $$$x_{1} \oplus x_{2} \oplus \cdots \oplus x_{m} \le x_{1} + x_{2} + \cdots + x_{m}$$$ for any numbers $$$x_{1}, x_{2}, \cdots, x_{m}$$$, we can assume that there is at most operation performed in same vertex.
Tutorial
Let's solve the problem for single root first.
Denote the operation in the statement as $$$op(v, c)$$$, and size of $$$v$$$'s subtree as $$$s_{v}$$$.
The goal is to make $$$a_{v} \oplus a_{par_{v}} = 0$$$ for every non-root vertex $$$v$$$. This value is changed only when we select $$$v$$$. To make $$$a_{v} \oplus a_{par_{v}}$$$ to $$$0$$$, we should perform $$$op \left( v, a_{v} \oplus a_{par_{v}} \right)$$$ (Look Hint 3).
Therefore, the answer sill be $$$\sum_{i != root} s_{i} \times (a_{i} \oplus a_{par_{i}})$$$. Now our task is to calculate this for all roots. This can be done by lots of ways, and the following algorithm is one way.
Calculate the answer for $$$1$$$ as root first in $$$\mathcal{O}(n)$$$. Now, we will traverse the tree starting at vertex $$$1$$$ and keep updating the answer. If root changes from $$$q$$$ to $$$r$$$ ($$$q$$$ and $$$r$$$ are adjacent), every vertex except $$$q$$$ and $$$r$$$ will have same parents and subtree size, so will contribute same to the answer, so we only need to consider $$$q$$$ and $$$r$$$ to calculate the change. Edge connecting $$$q$$$ and $$$r$$$ will divide the tree into parts: each of size $$$X$$$ and $$$Y$$$. If root changes $$$q$$$ to $$$r$$$, $$$Y \times (a_{q} \oplus a_{r})$$$ will be subtracted, and $$$X \times (a_{q} \oplus a_{r})$$$ will be added to the answer. $$$X$$$ and $$$Y$$$ can be pre-calculated in $$$\mathcal{O}(n)$$$, so this update costs $$$\mathcal{O}(1)$$$.
Since changing root into the adjacent vertex costs $$$\mathcal{O}(1)$$$, answer for all roots can be calculated in $$$\mathcal{O}(n)$$$.
--------------------------------------------------
Problem ID: 1882C
Editorial Content:
1882C - Card Game
Hint 1
Fix the topmost card you'll pick in the initial deck.
Tutorial
Let's denote $$$i$$$-th card in the initial deck as card $$$i$$$.
Let the topmost card you'll pick in the initial deck as card $$$i$$$.
For all cards under card $$$i$$$ in initial deck, you can choose all and only cards with the positive value at odd index.
Proof: Here is the strategy. Before you pick card $$$i$$$, if positive card(under card $$$i$$$ in initial deck) in odd index exists, choose it. Repeat this until all positive cards(under card $$$i$$$ in initial deck) are in even index. Then if you choose card $$$i$$$, all index of positive cards(under card $$$i$$$ in initial deck) will be decreased by $$$1$$$, and will become odd. Now, choose them from the bottom to top, so that the choosing won't change the other positive cards' index.
Denote $$$prf_{j}$$$ as the sum of positive numbers among $$$a_{j}, a_{j+1}, \cdots, a_{n}$$$, and $$$prf_{n+1} = 0$$$. Since $$$prf_{j} = prf_{j+1} + \max \left( 0, a_{j}\right)$$$, $$$prf$$$ can be calculated in $$$\mathcal{O}(n)$$$.
You should necessarily pick card $$$i$$$ in index of $$$i$$$, and can pick all positive cards under card $$$i$$$ in initial deck, so your maximum final score will be $$$(i \% 2 == 1 ? a_{i} : 0) + prf_{i+1}$$$.
The answer is $$$\max \left( (i \% 2 == 1 ? a_{i} : 0) + prf_{i+1} \, | \, 1 \le i \le n \right)$$$.
There are lots of other solutions too.
--------------------------------------------------
Problem ID: 1882B
Editorial Content:
1882B - Sets and Union
Something to say
Sorry for everyone who got FSTs :( We tried our best to make pretest strong especially for this problem, but it wasn't enough.
Hint 1
Denote $$$T = S_{1} \cup S_{2} \cup \cdots \cup S_{n}$$$, then $$$S \subset T$$$. Since $$$S \neq T$$$, $$$i \in T$$$ and $$$i \notin S$$$ for some $$$i$$$.
Hint 2
Given an integer $$$i$$$, can you calculate the maximum size of $$$S$$$, such that $$$i \notin S$$$?
Tutorial
$$$i \in T$$$ and $$$i \notin S$$$ for some $$$i$$$. Here $$$1 \le i \le 50$$$.
For fixed $$$i$$$, select of all the sets among $$$S_{1}, S_{2}, \cdots, S_{n}$$$ which don't contain $$$i$$$. Size of their union will be the maximum size of $$$S$$$ such that $$$i \notin S$$$.
If we do this for all $$$i$$$ in $$$T$$$, maximum of them is the answer.
Time complexity is $$$\mathcal{O} \left( N \cdot \max \left( s_{i, j} \right) ^{2}\right)$$$.
--------------------------------------------------
Problem ID: 1882A
Editorial Content:
1882A - Increasing Sequence
Tutorial
Greedy solution. Continue constructing $$$b$$$ as small as possible.
If $$$a_{1} = 1$$$, $$$b_{1} = 2$$$. Else, $$$b_{1} = 1$$$.
For $$$i \ge 2$$$, if $$$a_{i} = b_{i-1} + 1$$$, $$$b_{i} = b_{i-1} + 2$$$. Else, $$$b_{i} = b_{i-1} + 1$$$.
$$$b_{n}$$$ calculated by this process is the answer.
Time complexity is $$$\mathcal{O}(n)$$$ per test case.
--------------------------------------------------
Problem ID: 1881G
Editorial Content:
1881G - Anya and the Mysterious String
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <string>
#include <set>
#include <cstring>
#define int long long

using namespace std;

const int L = 26;
const int MAXN = 200200;

int n, m;
string s;
set<int> M2, M3;
int fen[MAXN];

void fenadd(int i, int x) {
	x = (x % L + L) % L;
	for (; i < n; i |= (i + 1))
		fen[i] = (fen[i] + x) % L;
}

int fenget(int i) {
	int ans = 0;
	for (; i >= 0; i = (i & (i + 1)) - 1)
		ans = (ans + fen[i]) % L;
	return ans;
}

void relax(int l, int r) {
	l = max(l, 0LL);
	r = min(r, n);
	for (int i = l; i + 1 < r; ++i) {
		int c1 = fenget(i);
		int c2 = fenget(i + 1);

		if (c1 == c2) M2.insert(i);
		else M2.erase(i);

		if (i + 2 >= r) continue;

		int c3 = fenget(i + 2);
		if (c1 == c3) M3.insert(i);
		else M3.erase(i);
	}
}

void build() {
	M2.clear();
	M3.clear();
	memset(fen, 0, n * sizeof(int));
	fenadd(0, s[0] - 'a');
	for (int i = 1; i < n; ++i) {
		fenadd(i, s[i] - s[i - 1] + L);
	}
	for (int i = 0; i + 1 < n; ++i) {
		if (s[i] == s[i + 1]) M2.insert(i);
		if (i + 2 < n && s[i] == s[i + 2]) M3.insert(i);
	}
}

void update(int l, int r, int x) {
	fenadd(l, x);
	relax(l - 5, l + 5);
	fenadd(r, L - x);
	relax(r - 5, r + 5);
}

bool query(int l, int r) {
	auto it = M2.lower_bound(l);
	if (it != M2.end() && *it + 1 < r) return false;
	it = M3.lower_bound(l);
	if (it != M3.end() && *it + 2 < r) return false;
	return true;
}

signed main() {
	int t; cin >> t;
	while (t--) {
		cin >> n >> m >> s;
		build();
		while (m--) {
			int tp, l, r; cin >> tp >> l >> r, --l;
			if (tp == 1) {
				int x; cin >> x;
				update(l, r, x);
			} else {
				cout << (query(l, r) ? "YES" : "NO") << '\n';
			}
		}
	}
}
--------------------------------------------------
Problem ID: 1881F
Editorial Content:
1881F - Minimum Maximum Distance
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>

using namespace std;

int n;
vector<vector<int>> g;

void dfs(int v, int p, vector<int> &d){
	if(p != -1) d[v] = d[p] + 1;
	for(int u: g[v]){
		if(u != p){
			dfs(u, v, d);
		}
	}
}

int main(){
    int t;
	cin>>t;
	while(t--){
	    int k;
		cin>>n>>k;
		g.assign(n, vector<int>(0));
		vector<int> marked(k);
		for(int &e: marked) cin >> e, --e;
		for(int i=1;i<n;i++){
			int u, v;
			cin >> u >> v;
			--u, --v;
			g[u].push_back(v);
			g[v].push_back(u);
		}
		if(k==1){
			cout<<0<<"\n";
			continue;
		}
		vector<int> d1(n);
		dfs(marked[0], -1, d1);
		int mx = marked[0];
		for(int e: marked){
		    if(d1[e] > d1[mx]) mx = e;
		}
		vector<int> d2(n);
		dfs(mx, -1, d2);
		mx = marked[0];
		for(int e: marked){
		    if(d2[e] > d2[mx]) mx = e;
		}
		cout << (d2[mx] + 1) / 2 << "\n";
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1881E
Editorial Content:
1881E - Block Sequence
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    a = [int(x) for x in input().split()]
    dp = [n + 1] * n

    def get(pos):
        if pos > n:
            return n + 1
        if pos == n:
            return 0
        return dp[pos]

    dp[-1] = 1
    for i in range(n - 2, -1, -1):
        dp[i] = min(dp[i + 1] + 1, get(i + a[i] + 1))
    print(dp[0])


for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1881D
Editorial Content:
1881D - Divide and Equalize
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>
using namespace std;
const int maxv = 1000000;

void add_divs(int x, map<int, int>&divs){
    int i = 2;
    while(i * i <= x){
        while (x % i == 0){
            divs[i]++;
            x /= i;
        }
        i++;
    }
    if(x > 1) divs[x]++;
}

bool solve(){
    int n;
    cin >> n;
    vector<int>a(n);
    map<int, int> divs;
    for(int i = 0; i < n; i++) {
        cin >> a[i];
        add_divs(a[i], divs);
    }
    for(auto e: divs){
        if(e.second % n != 0) return false;
    }
    return true;
}

int main(){
    int t;
    cin >> t;
    while(t--) {
        cout << (solve() ? "YES" : "NO") << "\n";
    }
}
--------------------------------------------------
Problem ID: 1881C
Editorial Content:
1881C - Perfect Square
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
#define all(arr) arr.begin(), arr.end()

using namespace std;

const int MAXN = 1010;

int n;
string A[MAXN];

int solve() {
    int ans = 0;
    for (int i = 0; i * 2 < n; ++i)
        for (int j = 0; j * 2 < n; ++j) {
            vector<char> M {A[i][j], A[n - 1 - j][i], A[n - 1 - i][n - 1 - j], A[j][n - 1 - i]};
            char c = *max_element(all(M));
            for(char e: M)
                ans += c - e;
        }
    return ans;
}

int main() {
    int t; cin >> t;
    while (t--) {
        cin >> n;
        for (int i = 0; i < n; ++i)
            cin >> A[i];
        cout << solve() << endl;
    }
}
--------------------------------------------------
Problem ID: 1881B
Editorial Content:
1881B - Three Threadlets
Tutorial
Tutorial is loading...
Solution
for _ in range(int(input())):
    a, b, c = sorted(map(int, input().split()))
    if a == b and b == c:
        print('YES')
    elif b % a == 0 and c % a == 0 and (b // a - 1) + (c // a - 1) <= 3:
        print('YES')
    else:
        print('NO')
--------------------------------------------------
Problem ID: 1881A
Editorial Content:
1881A - Don't Try to Count
Tutorial
Tutorial is loading...
Solution
def solve():
    n, m = map(int, input().split())
    x = input()
    s = input()
    for i in range(6):
        if s in x:
            print(i)
            return
        x += x
    print(-1)


for _ in range(int(input())):
    solve()
--------------------------------------------------
Problem ID: 1879F
Editorial Content:
1879F - Last Man Standing
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

int main() {
	int t;
	scanf("%d", &t);
	while (t--){
		int n;
		scanf("%d", &n);
		vector<int> h(n), a(n);
		forn(i, n) scanf("%d", &h[i]);
		forn(i, n) scanf("%d", &a[i]);
		int mxa = *max_element(a.begin(), a.end()) + 1;
		
		int l = mxa == 1 ? 0 : (__lg(mxa - 1) + 1);
		vector<vector<pair<int, int>>> st(l, vector<pair<int, int>>(mxa, make_pair(0, -1)));
		vector<vector<int>> st2(l, vector<int>(mxa));
		forn(i, n){
			if (h[i] > st[0][a[i]].first){
				st2[0][a[i]] = st[0][a[i]].first;
				st[0][a[i]] = {h[i], i};
			}
			else if (h[i] > st2[0][a[i]]){
				st2[0][a[i]] = h[i];
			}
		}
		
		auto combine = [&st, &st2](int i, int x, int y){
			int mx = max(st[i][x].first, st[i][y].first);
			if (mx == st[i][x].first)
				return max(st2[i][x], st[i][y].first);
			return max(st[i][x].first, st2[i][y]);
		};
		
		for (int j = 1; j < l; ++j) forn(i, mxa){
			if (i + (1 << (j - 1)) < mxa){
				st[j][i] = max(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);
				st2[j][i] = combine(j - 1, i, i + (1 << (j - 1)));
			}
			else{
				st[j][i] = st[j - 1][i];
				st2[j][i] = st2[j - 1][i];
			}
		}
		vector<int> pw(mxa + 1);
		for (int i = 2; i <= mxa; ++i) pw[i] = pw[i / 2] + 1;
		
		auto getmx = [&st, &pw](int l, int r){
			int len = pw[r - l];
			return max(st[len][l], st[len][r - (1 << len)]);
		};
		auto getmx2 = [&st, &st2, &pw, &combine](int l, int r){
			int len = pw[r - l];
			if (st[len][l].second != st[len][r - (1 << len)].second)
				return combine(len, l, r - (1 << len));
			return max(st2[len][l], st2[len][r - (1 << len)]);
		};
		
		vector<long long> svmx(mxa), svmx2(mxa);
		vector<int> svwho(mxa, -1);
		for (int x = 1; x < mxa; ++x){
			for (int l = 1; l < mxa; l += x){
				int r = min(mxa, l + x);
				int ac = (l - 1) / x + 1;
				auto tmp = getmx(l, r);
				long long mx = tmp.first * 1ll * ac;
				int who = tmp.second;
				long long mx2 = getmx2(l, r) * 1ll * ac;
				if (who == -1) continue;
				if (mx > svmx[x]){
					svmx2[x] = svmx[x];
					svmx[x] = mx;
					svwho[x] = who;
				}
				else if (mx > svmx2[x]){
					svmx2[x] = mx;
				}
				svmx2[x] = max(svmx2[x], mx2);
			}
		}
		
		vector<long long> ans(n);
		forn(i, mxa) if (svwho[i] != -1)
			ans[svwho[i]] = max(ans[svwho[i]], svmx[i] - svmx2[i]);
		
		forn(i, n) printf("%lld ", ans[i]);
		puts("");
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1879E
Editorial Content:
1879E - Interactive Game with Coloring
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

const int N = 123;

int n;
int color[N];
int countColors[N][N];
int p[N];
vector<int> g[N];
int deg[N];

void add_edge(int x, int y)
{
	g[x].push_back(y);
	g[y].push_back(x);
}

bool tryTwoColors()
{
	int v1 = n + 1;
	int v2 = n + 2;
	for(int i = 2; i <= n; i++)
	{
		if(p[i] != 1)
		{
			add_edge(i, p[i]);
		}
	}
	for(int i = 2; i <= n; i++)
	{
		if(deg[i] == 1)
			add_edge(i, v1);
	}
	for(int i = 2; i <= n; i++)
	{
		if(p[i] != 1 && deg[p[i]] == 1)
			add_edge(i, v2);
	}
	add_edge(v1, v2);
	bool bad = false;
	for(int i = 2; i <= n + 2; i++)
		if(color[i] == 0)
		{
			color[i] = 1;
			queue<int> q;
			q.push(i);
			while(!q.empty())
			{
				int k = q.front();
				q.pop();
				for(auto y : g[k])
				{
					if(color[y] == 0)
					{
						color[y] = 3 - color[k];
						q.push(y);
					}
					else if(color[y] == color[k])
						bad = true;
				}
			}
		}
	if(bad)
		for(int i = 2; i <= n + 2; i++)
			color[i] = 0;
	return !bad;
}

void tryThreeColors()
{
	for(int i = 2; i <= n; i++)
		if(p[i] == 1)
			color[i] = 1;
		else
			color[i] = (color[p[i]] % 3) + 1;
}

int findVertex(const vector<int>& colors)
{
	int s = colors.size();
	for(int i = 2; i <= n; i++)
	{
		if(vector<int>(countColors[i], countColors[i] + s) == colors)
			return i;
	}
	return -1;
}

int main()
{
	cin >> n;
	for(int i = 2; i <= n; i++)
	{
		cin >> p[i];
		deg[p[i]]++;
	}
	
	if(*max_element(p + 2, p + n + 1) == 1)
	{
		for(int i = 2; i <= n; i++)
			color[i] = 1;
	}
	else if (!tryTwoColors())
		tryThreeColors();
	
	int colorsUsed = *max_element(color + 2, color + n + 1);
	
	cout << colorsUsed << endl;
	for(int i = 2; i <= n; i++)
	{
		cout << color[i];
		if(i == n) cout << endl;
		else cout << " ";
	}
	cout.flush();
	
	for(int i = 2; i <= n; i++)
	{
		countColors[i][color[i]]++;
		countColors[p[i]][color[i]]++;
	}
	
	while(true)
	{
		int resp;
		cin >> resp;
		if(resp == -1 || resp == 1)
			exit(0);
		vector<int> counts(colorsUsed + 1);
		for(int i = 1; i <= colorsUsed; i++)
			cin >> counts[i];
		int v = findVertex(counts);
		assert(v != -1);
		cout << color[v] << endl;
		cout.flush();
	}
}
--------------------------------------------------
Problem ID: 1879D
Editorial Content:
1879D - Sum of XOR Functions
Tutorial
Tutorial is loading...
Solution (Roms)
#include <bits/stdc++.h>

using namespace std;

const int N = 300005;
const int MOD = 998244353;
int n;
int a[N];

void add(int &a, int b) {
    a += b;
    if (a >= MOD)
        a -= MOD;
}

int sum(int a, int b) {
    a += b;
    if (a >= MOD)
        a -= MOD;
    if (a < 0)
        a += MOD;
    return a;
}

int mul(int a, int b) {
    return (a * 1LL * b) % MOD;
}

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i)
        cin >> a[i];
    
    int res = 0;    
    for (int b = 0; b < 30; ++b) {
        int cur = 0;
        vector <int> cnt(2);
        vector <int> sumOfL(2);
        cnt[0] = 1;
        int x = 0;
        for (int i = 0; i < n; ++i) {
            x ^= ((a[i] >> b) & 1);
            int sumOfR = mul(cnt[x ^ 1], i + 1);
            add(cur, sum(sumOfR, -sumOfL[x ^ 1]));
            
            ++cnt[x];
            add(sumOfL[x], i + 1);
        }
        
        add(res, mul(1 << b, cur));
    }
    
    cout << res << endl;
}
--------------------------------------------------
Problem ID: 1879C
Editorial Content:
1879C - Make it Alternating
Tutorial
Tutorial is loading...
Solution (Roms)
#include <bits/stdc++.h>

using namespace std;

const int MOD = 998'244'353;

void upd(int &a, int b) {
    a = (a * 1LL * b) % MOD;
}


int t;
string s;

int main() {
	cin >> t;
	for (int tc = 0; tc < t; ++tc) {
	    cin >> s;
	    int res = 1;
	    int k = s.size();
	    int n = s.size();
	    for (int l = 0; l < n; ) {
	        int r = l + 1;
	        while(r < n && s[l] == s[r])
	            ++r;
            upd(res, r - l);
            --k;
            l = r;
	    }
	    
	    for (int i = 1; i <= k; ++i)
	        upd(res, i);
        cout << k << ' ' << res << endl;
	}
}
--------------------------------------------------
Problem ID: 1879B
Editorial Content:
1879B - Chips on the Board
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

using li = long long;

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<li> a(n), b(n);
    for (auto& x : a) cin >> x;
    for (auto& x : b) cin >> x;
    li mnA = *min_element(a.begin(), a.end());
    li sA = accumulate(a.begin(), a.end(), 0LL);
    li mnB = *min_element(b.begin(), b.end());
    li sB = accumulate(b.begin(), b.end(), 0LL);
    li ans = min(mnA * n + sB, mnB * n + sA);
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1879A
Editorial Content:
1879A - Rigged!
Tutorial
Tutorial is loading...
Solution (Roms)
#include <bits/stdc++.h>
 
using namespace std;

const int N = 109;

int t;
int n;
int s[N], e[N];
 
int main() {
    cin >> t;
    for (int tc = 0; tc < t; ++tc) {
        cin >> n;
        for (int i = 0; i < n; ++i) {
            cin >> s[i] >> e[i];
        }
        
        bool ok = true;
        for (int i = 1; i < n; ++i) 
            if (s[i] >= s[0] && e[i] >= e[0])
                ok = false;
        
        if (!ok) {
            puts("-1");
            continue;
        }
        
        cout << s[0] << endl;
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1878G
Editorial Content:
1878G - wxhtzdy ORO Tree
Problem was authored and prepared by
Author:
wxhtzdy
Prepared by:
ognjentesic
,
OAleksa
,
AlphaMale06
Hints
Hint 1
How many vertices actually matter on the path from $$$x$$$ to $$$y$$$?
Hint 2
How do we find them?
Hint 3
Root the tree arbitrarily.
Hint 4
Try calculating the number of occurrences for each bit on the path from the root to a certain vertex.
Hint 5
Try binary search.
Hint 6
Try LCA (Lowest common ancestor).
Hint 1
How many vertices actually matter on the path from $$$x$$$ to $$$y$$$?
Hint 2
How do we find them?
Hint 3
Root the tree arbitrarily.
Hint 4
Try calculating the number of occurrences for each bit on the path from the root to a certain vertex.
Hint 5
Try binary search.
Hint 6
Try LCA (Lowest common ancestor).
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
#define f first
#define s second
using namespace std;
#define int long long
const int maxn = 2e5 + 69;
const int k = 19;
const int bits = 30;
vector<int> g[maxn];
int n, q, a[maxn], up[maxn][k], tin[maxn], tout[maxn], timer, d[maxn];
int r[maxn][k];
int bst[maxn][bits];
void dfs(int v, int p, vector<int> b) {
	tin[v] = ++timer;
	up[v][0] = p;
	r[v][0] = a[p];
	d[v] = d[p] + 1;
	for (int i = 0;i < bits;i++) {
		bst[v][i] = b[i];
		if (a[v] & (1 << i))
			b[i] = v;
	}
	for (int i = 1;i < k;i++) {
		up[v][i] = up[up[v][i - 1]][i - 1];
		r[v][i] = r[v][i - 1] | r[up[v][i - 1]][i - 1];
	}
	for (auto u : g[v]) {
		if (u != p)
			dfs(u, v, b);
	}
	tout[v] = timer;
}

bool is_anc(int u, int v) {
	return tin[u] <= tin[v] && tout[u] >= tout[v];
}

int lca(int u, int v) {
	if(is_anc(u, v))
		return u;
	else if(is_anc(v, u))
		return v;
	for (int i = k - 1;i >= 0;i--) {
		if (!is_anc(up[u][i], v) && up[u][i] > 0)
			u = up[u][i];
	}
	return up[u][0];
}

int OR(int u, int dis) {
	int res = a[u];
	for (int j = 0;j < bits;j++) {
		if (dis & (1 << j)) {
			res |= r[u][j];
			u = up[u][j];
		}
	}
	return res;
}

int Qry(int u, int v) {
	int lc = lca(u, v);
	return OR(u, d[u] - d[lc]) | OR(v, d[v] - d[lc]);
}

signed main()
{
	int tt = 1;
	cin >> tt;
	while(tt--) {
		cin >> n;
		timer = 0;
		for (int i = 1;i <= n;i++)
            g[i].clear();
		for (int i = 1;i <= n;i++)
			cin >> a[i];
		for (int i = 1;i <= n - 1;i++) {
			int x, y;
			cin >> x >> y;
			g[x].push_back(y);
			g[y].push_back(x);
		}
		vector<int> temp(30, -1);
		dfs(1, 0, temp);
		cin >> q;
		for (int i = 1;i <= q;i++) {
			int x, y;
			cin >> x >> y;
			int LCA = lca(x, y);
			vector<int> t;
			t.push_back(x);
			t.push_back(y);
			for (int i = 0;i < bits;i++) {
				if (bst[x][i] != -1 && is_anc(LCA, bst[x][i]))
					t.push_back(bst[x][i]);
				if (bst[y][i] != -1 && is_anc(LCA, bst[y][i]))
					t.push_back(bst[y][i]);
			}
			int ans =  __builtin_popcount(a[x]) + __builtin_popcount(a[y]);
			for (auto p : t) {
				int x1 = a[x], x2 = a[y];
				x1 |= Qry(x, p);
				x2 |= Qry(y, p);
				ans = max(ans, 1ll * __builtin_popcount(x1) + __builtin_popcount(x2));
			}
			cout << ans << " ";
		}
		cout << "\n";
	}
   return 0;
}
--------------------------------------------------
Problem ID: 1878F
Editorial Content:
1878F - Vasilije Loves Number Theory
Problem was authored and prepared by
Author:
ognjentesic
,
AlphaMale06
Prepared by:
ognjentesic
,
AlphaMale06
Hints
Hint 1
What does the condition $$$gcd(a, n) = 1$$$ allow us to do?
Hint 2
How does any allowed operation affect $$$d(a \cdot n)$$$?
Hint 3
Try to prove that the answer is "YES" if $$$d(n)$$$ divides $$$n$$$.
Hint 4
Try to prove that the answer is "NO" otherwise.
Hint 5
How can you find and maintain the number of divisors quickly?
Hint 6
To make the implementation easier, try using the condition $$$d(n) \le 10^9$$$.
Hint 1
What does the condition $$$gcd(a, n) = 1$$$ allow us to do?
Hint 2
How does any allowed operation affect $$$d(a \cdot n)$$$?
Hint 3
Try to prove that the answer is "YES" if $$$d(n)$$$ divides $$$n$$$.
Hint 4
Try to prove that the answer is "NO" otherwise.
Hint 5
How can you find and maintain the number of divisors quickly?
Hint 6
To make the implementation easier, try using the condition $$$d(n) \le 10^9$$$.
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using ll = long long;
using namespace std;

const int N = 1000003;
map<int, int> powers; //key is a prime number, value is te highest powert
map<int, int> original_divisors; //same as map powers but isn't updated during queries, it's used to reset the powers
int smallest_divisor[N]; //precalculated smallest divisors to make factorization O(logx) 
bool mark[N]; //marks numbers which aren't prime (used for sieve)
ll divisor_count = 1; //the number of divisors (updated during queries)

void prime(){ //calculates the smallers divisor for each number from 1 to N (sieve of erathosetenes)
	smallest_divisor[1]=1;
	smallest_divisor[2]=2;
	for(int i=4; i<N; i+=2){
		mark[i]=true;
		smallest_divisor[i]=2;
	}	
	for(int i=3; i<N; i+=2){
		if(!mark[i]){
			smallest_divisor[i]=i;
			for(ll j = i*1ll*i; j<N; j+=2*i){
				if(!mark[j]){
					smallest_divisor[j]=i;
					mark[j]=1;
				}
			}
		}
	}
}
//a function for factorizing a number (used to process queries and factorize n in the beginning)
//it also updates the highest prime which divides n (powers map), and the number of divisors of n (divisor_count)
void factorize(int x){ 
	int p=0;
	int current_divisor = 1;
	while(x>1){ //while x has non 1 divisors, divide it by it's smallest divisor which isn't 1(smallers divisor if always prime)
		if(smallest_divisor[x]!=current_divisor){
			if(p>0){
				divisor_count/=powers[current_divisor]+1;
				powers[current_divisor]+=p;
				divisor_count*=powers[current_divisor]+1;
			}
			p=1;
			current_divisor=smallest_divisor[x];
		}
		else{
			p++;
		}
		x/=smallest_divisor[x];
	}
	if(p>0){
		divisor_count/=powers[current_divisor]+1;
		powers[current_divisor]+=p;
		divisor_count*=powers[current_divisor]+1;
	}
	return;
}

int main(){
	prime(); //precalculate smallest divisors
	int t;
	cin >> t;
	while(t--){
	    //read n and q
    	int n; int q;
    	cin >> n >> q;
    	//factorize n
    	factorize(n);
    	//since factorize updates the powers map, update the origional_divisors map too
    	for(auto prime : powers){
    		original_divisors[prime.first]=prime.second;
    	}
    	int original_divisor_count = divisor_count; //since factorize updates the divisor_count we update the original_divisor_count too
    	vector<int> queries; //storing previous queries
    	//processing queries
    	while(q--){
    		int query_type;
    		cin >> query_type;
    		if(query_type==1){ //query of type 1 (multiply n by x)
    			int x;
    			cin >> x;
    			factorize(x); //factorize x, update the powers map, and the number of divisors
    			queries.push_back(x); //add x to the list of previous queries
    			ll num=n;
    			for(int query : queries){ //check if the product of all previous queries and n is divisible by d(n)
    				num*=query;
    				num%=divisor_count;
    			}
    			if(num==0){ //if it is the answer is yes else the answer is no
    				cout << "YES\n";
    			}
    			else cout << "NO\n";
    		}
    		else{ //here we should reset everything related to the type 1 query
    			powers.clear(); //clear the powers map and set it to original divisors and powers
    			for(auto original_div : original_divisors){
    				powers[original_div.first]=original_div.second;
    			}
    			divisor_count=original_divisor_count; //restart the divisor_count
    			queries.clear(); //clear the queries (since we only need the queries since the previous type 2 query)
    		}
    	}
    	original_divisors.clear();
    	powers.clear();
    	divisor_count=1;
    	original_divisor_count =1;
    	if(t) cout << "\n";
	}
}
--------------------------------------------------
Problem ID: 1878E
Editorial Content:
1878E - Iva & Pav
Problem was authored and prepared by
Author:
AndrewPav
,
AlphaMale06
Prepared by:
ognjentesic
,
AndrewPav
,
OAleksa
,
AlphaMale06
Hints
Hint 1
Try calculating $$$f(l, r)$$$ bit by bit
Hint 2
Which condition has to hold true for all elements on a subsegment $$$[l,r]$$$, and for a certain bit, for that bit to be present in $$$f(l,r)$$$?
Hint 3
How can we check if that condition is true for a certain bit fast?
Hint 4
Try prefix sums.
Hint 5
Try binary search.
Hint 1
Try calculating $$$f(l, r)$$$ bit by bit
Hint 2
Which condition has to hold true for all elements on a subsegment $$$[l,r]$$$, and for a certain bit, for that bit to be present in $$$f(l,r)$$$?
Hint 3
How can we check if that condition is true for a certain bit fast?
Hint 4
Try prefix sums.
Hint 5
Try binary search.
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
 
 
const int N =200003;
const int bits=30;
int pref[N][bits];
int a[N];
void Buildprefix(int n){ //Builds the prefix sums for each bit
    for(int i=0; i< n; i++){
        for(int j=0; j<30; j++){
            if(a[i]&(1<<j)){
                pref[i+1][j]=pref[i][j]+1;
            }
            else{
                pref[i+1][j]=pref[i][j];
            }
        }
    }
}
void solve(){
    int n;
    cin >> n;
    for(int i=0; i< n; i++){
        cin >> a[i];
    }
    Buildprefix(n);
    int q;
    cin >> q;
    while(q--){
        int l, k;
        cin >> l >> k;
        if(a[l-1]<k){
            cout << -1 << '\n';
            continue;
        }
        int lo=l;
        int hi=n;
        int ans=l;
        while(lo<=hi){
            int s=(lo+hi)/2;
            int num=0;
            for(int j=0; j< bits; j++){
                if(pref[s][j]-pref[l-1][j]==s-l+1){
                    num+=(1<<j);
                }
            }
            if(num>=k){
                lo=s+1;
                ans=max(ans, s);
            }
            else hi=s-1;
        }
        cout << ans << '\n';
    }
}
 
int main(){
    int t = 1;
    cin >> t;
    while(t--){
        solve();
    }
}
--------------------------------------------------
Problem ID: 1878D
Editorial Content:
1878D - Reverse Madness
Problem was authored and prepared by
Author:
AlphaMale06
Prepared by:
ognjentesic
,
AlphaMale06
Hints
Hint 1
For each $$$i$$$, ($$$1 \le i \le k$$$), we can treat the substring $$$[l_i, r_i]$$$ as a seperate test case.
Hint 2
What happens when we make the same modification twice?
Hint 3
Does the order of the operations matter?
Hint 4
Try pre-processing the queries
Hint 1
For each $$$i$$$, ($$$1 \le i \le k$$$), we can treat the substring $$$[l_i, r_i]$$$ as a seperate test case.
Hint 2
What happens when we make the same modification twice?
Hint 3
Does the order of the operations matter?
Hint 4
Try pre-processing the queries
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
int main(){
	int t; //number of test cases
	cin >> t;
	while(t--){
		int n, k; //read the input
		cin >> n >> k;
		string s;
		cin >> s;
		int a[k]; int b[k];
		for(int i=0; i< k; i++){cin >> a[i]; a[i]--;}
		for(int i=0; i< k; i++){cin >> b[i]; b[i]--;}
		int q;
		cin >> q;
		int cnt[n+1]={0}; //read and preprocess queries
		for(int i=0; i< q; i++){
			int x; cin >> x; cnt[x-1]++;
		}
		string ans="";
		for(int i=0; i<k; i++){ //treat each interval as a seperate test case
			string s1=s.substr(a[i], b[i]-a[i]+1);
			int sum=0;
			int l=a[i];
			int r=b[i];
			for(int j=l; j<=(l+r)/2; j++){
				sum+=cnt[j]+cnt[r-j+l];
				if(sum&1)swap(s1[j-l], s1[r-j]);
			}
			ans+=s1;
		}
		cout << ans << '\n';
	}
}
--------------------------------------------------
Problem ID: 1878C
Editorial Content:
1878C - Vasilije in Cacak
Problem was authored and prepared by
Author:
AlphaMale06
Prepared by:
ognjentesic
,
AlphaMale06
Hints
Hint 1
Prove that the answer for the second test case is "NO".
Hint 2
$$$ 1 + 2 + 3 > 5$$$
Hint 3
Determine the minimum and maximum sum achievable.
Hint 4
Prove that it's possible to construct the desired sequence for any requested sum between the minimum and maximum possible sum.
Hint 1
Prove that the answer for the second test case is "NO".
Hint 2
$$$ 1 + 2 + 3 > 5$$$
Hint 3
Determine the minimum and maximum sum achievable.
Hint 4
Prove that it's possible to construct the desired sequence for any requested sum between the minimum and maximum possible sum.
Tutorial
Tutorial is loading...
Solution
#include <iostream>

using namespace std;

int main(){
	int t; //read the number of test cases
	cin >> t;
	while(t--){
		long long n, x, k; //read n, x, k for each test case
		cin >> n >> x >> k;
		if(2*k>=x*(x+1) && 2*k<=n*(n+1)-(n-x)*(n-x+1)){ //check if k is between the minimum and maximum sum 
			cout << "YES\n";
		}
		else cout << "NO\n";
	}	
}
--------------------------------------------------
Problem ID: 1878B
Editorial Content:
1878B - Aleksa and Stack
Problem was authored and prepared by
Author:
ognjentesic
Prepared by:
ognjentesic
,
AlphaMale06
Hints
Hint 1
Watch parity.
Hint 2
What does the parity of $$$3 \cdot x$$$ depend on?
Hint 3
What parity are numbers which divide odd numbers?
Hint 1
Watch parity.
Hint 2
What does the parity of $$$3 \cdot x$$$ depend on?
Hint 3
What parity are numbers which divide odd numbers?
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

int main(){
	int t; //read the number of test cases
	cin >> t;
	while(t--){
		int n; //read n
		cin >> n;
		for(int i=0; i< n; i++)cout << i*2+1 << " "; //write the first n odd numbers in order
		cout << '\n';
	}
}
--------------------------------------------------
Problem ID: 1878A
Editorial Content:
1878A - How Much Does Daytona Cost?
Problem was authored and prepared by
Author:
wxhtzdy
Prepared by:
ognjentesic
,
AndrewPav
,
AlphaMale06
Hints
Hint 1
When is the answer definitely "NO"?
Hint 2
What happens if there is no element equal to $$$k$$$ in the array?
Hint 3
What happens if there is an element equal to $$$k$$$ in the array?
Hint 1
When is the answer definitely "NO"?
Hint 2
What happens if there is no element equal to $$$k$$$ in the array?
Hint 3
What happens if there is an element equal to $$$k$$$ in the array?
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

int main(){
	int t; //read the number of test cases
	cin >> t;
	while(t--){
		int n, k;
		cin >> n >> k; //read n and k
		bool ys=0; //bool value if true then there exists a subsegment which satisfies the condition, else it doesn't exist
		for(int i=0; i< n; i++){
			int a; //read the i-th element of the array
			cin >> a;
			if(a==k)ys=1; //if the element is equal to k, then the subsegment [i, i] has the most common element equal to k
		}
		if(ys)cout << "YES\n"; //output the answer
		else cout << "NO\n";
	}
}
--------------------------------------------------
Problem ID: 1877C
Editorial Content:

--------------------------------------------------
Problem ID: 1877A
Editorial Content:

--------------------------------------------------
Problem ID: 1876G
Editorial Content:

--------------------------------------------------
Problem ID: 1876F
Editorial Content:

--------------------------------------------------
Problem ID: 1876E
Editorial Content:

--------------------------------------------------
Problem ID: 1876D
Editorial Content:

--------------------------------------------------
Problem ID: 1876C
Editorial Content:

--------------------------------------------------
Problem ID: 1876B
Editorial Content:

--------------------------------------------------
Problem ID: 1876A
Editorial Content:

--------------------------------------------------
Problem ID: 1875D
Editorial Content:
1875D - Jellyfish and Mex
Tutorial
We only care about the operation before $$$\text{MEX}(a)$$$ reaches $$$0$$$, because after that, $$$m$$$ will never change.
Lemma.
Before $$$\text{MEX}(a)$$$ reaches $$$0$$$, we will choose a positive integer $$$x$$$ at a time that satisfies $$$x < \text{MEX}(a)$$$, and delete all $$$x$$$ from $$$a$$$, the $$$\text{MEX}(a)$$$ will become $$$x$$$.
Proof.
Because if $$$x > \text{MEX}(a)$$$, we can place this operation after the $$$\text{MEX}(a)$$$ becomes $$$0$$$, if we don't delete all of $$$x$$$, $$$\text{MEX}(a)$$$ won't change, we can also put this operation later.
So before $$$\text{MEX}(a)$$$ reaches $$$0$$$, the $$$x$$$ we delete is non-increasing.
It means we can solve this problem by dynamic programming. Let $$$dp_i$$$ represents when $$$\text{MEX}(a)=i$$$, and we haven't delete any $$$x$$$ satisfying $$$x < i$$$,the minimum value of $$$m$$$.
Let $$$c_i$$$ represents the number of times $$$i$$$ appears in $$$a$$$, the transition is: $$$\forall j < i, dp_j \leftarrow dp_i + i \times (c_j - 1) + j$$$.
Time complexity: $$$O(n^2)$$$ per test case.
Memory complexity: $$$O(n)$$$ per test case.
Code
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;

const ll N = 5000 + 5, Inf = 0x3f3f3f3f3f3f3f3f;
ll n = 0, m = 0, a[N] = {}, dp[N] = {};

inline void init(){
	for(ll i = 0 ; i <= n ; i ++) a[i] = 0, dp[i] = Inf;
	n = m = 0;
}

inline void solve(){
	scanf("%lld", &n);
	for(ll i = 1, x = 0 ; i <= n ; i ++){
		scanf("%lld", &x);
		if(x < n) a[x] ++;
	}
	while(a[m]) m ++;
	dp[m] = 0;
	for(ll i = m ; i >= 1 ; i --) for(ll j = 0 ; j < i ; j ++) dp[j] = min(dp[j], dp[i] + i * a[j]);
	printf("%lld\n", dp[0] - m);
}

ll T = 0;

int main(){
	memset(dp, 0x3f, sizeof(dp));
	scanf("%lld", &T);
	for(ll i = 0 ; i < T ; i ++) init(), solve();
	return 0;
}
--------------------------------------------------
Problem ID: 1875C
Editorial Content:
1875C - Jellyfish and Green Apple
Tutorial
Firstly, if $$$n \geq m$$$, we can make the problem transform $$$n < m$$$ by giving each person an apple at a time until there are not enough apples.
We can calculate the mass of apples that each person ends up with as $$$\frac n m$$$.
Since it's cut in half every time, if $$$\frac m {\gcd(n, m)}$$$ is not an integral power of $$$2$$$, there's no solution.
Since the number of apple pieces is added to exactly $$$1$$$ for each cut, So we just need to minimize the final number of apple pieces.
As the problem is transformed, $$$\frac n m$$$ is less than $$$1$$$, and $$$\frac m {\gcd(n, m)}$$$ is an integral power of $$$2$$$. So we can uniquely find a set of positive integers $$$S$$$ satisfying $$$\frac n m = \sum_{i \in S} \frac 1 {2^i}$$$. And this method can be proven to be optimal, if we find another multiset $$$T$$$ satisfying $$$S \neq T$$$, for every element $$$x$$$ that appears twice or more, We can make the answer better by removing two $$$x$$$ at a time from $$$T$$$ and adding one $$$x - 1$$$ to $$$T$$$. By repeating this process, eventually $$$T$$$ will become $$$S$$$.
We can use $$$\text{std::__builtin_popcount()}$$$ to get $$$|S|$$$, the answer is $$$m \times |S|-n$$$.
Time complexity: $$$O(\log m)$$$ per test case.
Memory complexity: $$$O(1)$$$ per test case.
Code
#include<bits/stdc++.h>

using namespace std;

int n = 0, m = 0;

inline void solve(){
	scanf("%d %d", &n, &m); n %= m;
	int a = n / __gcd(n, m), b = m / __gcd(n, m);
	if(__builtin_popcount(b) > 1) printf("-1\n");
	else printf("%lld\n", 1ll * __builtin_popcount(a) * m - n);
}

int T = 0;

int main(){
	scanf("%d", &T);
	for(int i = 0 ; i < T ; i ++) solve();
	return 0;
}
--------------------------------------------------
Problem ID: 1875A
Editorial Content:
1875A - Jellyfish and Undertale
Tutorial
We can use one tool each time the timer reaches to $$$1$$$, then the answer will be $$$\sum_{i=1}^n \min(a - 1, x_i) + b$$$. This can prove to be optimal. Because for each tool, if we use it when the timer is $$$c$$$, its contribution to the answer is $$$\min(x_i, a - c)$$$. We can't use the tool when the timer is less than or equal to $$$0$$$ because the bomb will explode before that, so $$$c=1$$$ is the optimal.
Time complexity: $$$O(n)$$$ per test case.
Memory complexity: $$$O(1)$$$ per test case.
Code
#include<bits/stdc++.h>

using namespace std;

int n = 0, a = 0, b = 0;
long long ans = 0;

inline void solve(){
	scanf("%d %d %d", &a, &b, &n);
	ans = b;
	for(int i = 0, x = 0 ; i < n ; i ++){
		scanf("%d", &x);
		ans += min(a - 1, x);
	}
	printf("%lld\n", ans);
}

int T = 0;

int main(){
	scanf("%d", &T);
	for(int i = 0 ; i < T ; i ++) solve();
	return 0;
}
--------------------------------------------------
Problem ID: 1874G
Editorial Content:
1874G - Jellyfish and Inscryption
Tutorial
For convenience, let's define $$$k = \max(a, b, x, y)$$$, use operation 1 for "You will get a card with $$$a$$$ HP, and $$$b$$$ damage", operation 2 for "If you have at least one card, choose one of your cards and increase its HP by $$$x$$$" and operation 3 for "If you have at least one card, choose one of your cards and increase its damage by $$$y$$$", operation 4 for "You will get a prop with $$$w$$$ power", operation 5 for "You can choose at most one of your cards and multiply its damage by $$$10^9$$$", "the $$$i$$$-th card" for the card we get from vertex $$$i$$$ (It must be operation 1 on vertex $$$i$$$), "do operation 2/3/5 onto card $$$i$$$" for "When we do this operation 2/3/5, we will choose the card $$$i$$$ and increase his HP or damage".
Let us consider the problem without the operation 5, what's the maximum possible answer. If you want to maximize the the sum of the power of your cards, the answer will not exceeding $$$(100 \times 200)^2 = 4 \times 10^8$$$; If you you want to maximize the the sum of the power of your props, the answer will not exceeding $$$200 \times 10^6 = 2 \times 10^8$$$. Because $$$4 \times 10^8 + 2 \times 10^8 = 6 \times 10^8 < 10^9$$$, so the operation $$$n$$$ is the most important. Let's called the card we wil do the operation 5 onto it the "flash card". Let's use meet-in-the-middle, the problem is divided into two subproblems — the game before we get the flash card and the game after we get the flash card.
1. The game after we get the flash card
It's a easy problem, we can use dynamic programming to solve this problem.
Since the most important thing is the HP and damage of the flash card, so we define the following dynamic programming state:
$$$dp_b(u, a)$$$ means we are current at vertex $$$u$$$, the current HP of the flash card is $$$a$$$, the maximum damage of the flash card.
$$$dp_c(u, a)$$$ means we are current at vertex $$$u$$$, the current HP of the flash card is $$$a$$$, the damage of the flash card is $$$dp_b(u, a)$$$, the maximum sum of the power of all the other cards and props.
Since $$$a \leq nk$$$, the time complexity of the transition is $$$O(m \times n \times k)$$$.
2. The game before we get the flash card
This is the key of the problem, and since it's much more difficult, we first consider the subproblems of this problem.
I. If the graph is a chain, and all the operation 2 and operation 3 is after the operation 1
Lemma.
We will do all the operation 2 onto one of the cards, symmetrically we will also do all the operation 3 onto one of the cards.
Proof.
We consider a sequence of operations, let's consider if we do all the operation 1 on the card with the max damage after doing all the operation 2, the answer won't be worse, we can do all the operation 1 onto this card instead, then we make a symmetrical adjustment, the answer won't be worse, and all the operation 2 is done onto one of the cards, all the operation 3 is done onto one of the cards.
II. If the graph is a chain
It's similar to the
subproblem I
. If we say
subproblem I
is like a "global max value", then
subproblem II
is like a "prefix max value".
Let's define $$$p_i$$$ means we will do the operation 2/3 on vertex $$$i$$$ onto the $$$p_i$$$-th card.
Lemma1.
If there is a operation 2 on vertex $$$i$$$ and a operation 2 on vertex $$$j$$$, if $$$p_i < j < i$$$, we will have $$$p_j = p_i$$$.
Proof.
Let's consider the final HP and damage of the cards after all the operations. Because we do the operation 2 on vertex $$$i$$$ onto the $$$p_i$$$-th card, for all $$$i' < i$$$, the damage of the $$$i'$$$-th card is not larger than the $$$p_i$$$-th card. So for $$$j$$$, if we don't do the operation 2 on vertex j onto the $$$p_i$$$-th card, we can do it onto the $$$p_i$$$-th card instead, the answer won't be worse.
Symmetrically,
Lemma1
is also correct for operation 3.
Now we can use dynamic programming to solve the problem, we define the following dynamic programming state:
$$$f(u, a, b)$$$ means we are current at vertex $$$u$$$, we will do the next several operation 3 onto a card with $$$a$$$ HP after all the operations and we will do the next several operation 2 onto a card with $$$b$$$ damage after all the operations, and this two cards are not the same.
$$$g(u, a, b)$$$ means we are current at vertex $$$u$$$, We will do the next several operation 2 and operation 3 onto a card currently having $$$a$$$ HP and $$$b$$$ damage.
The time complexity is $$$O(m \times n^2 \times k^2)$$$, but it's not enough.
Lemma2.
If a card has $$$a$$$ HP and $$$b$$$ damage after all the operations and it's not the flash card, $$$\min(a, b) \leq k$$$.
Proof.
If we use this card as the flash card instead of the last one, and do all the operations done onto the last flash card onto this card, the power of the flash card will be larger. So it won't exist in this half problem.
Now the time complexity becomes $$$O(m \times n \times k^2)$$$, it's still not enough.
Lemma3.
Let's define $$$A$$$ as the maximum HP of all the cards except the flash card after all the operations, $$$B$$$ as the maximum damage of all the cards except the flash card after all the operations, $$$\min(A, B) \leq k$$$.
Proof.
Let's assume that the $$$i$$$-th card has $$$A$$$ HP after all the operations, the $$$j$$$-th card has $$$B$$$ damage after all the operations and $$$A > k, B > k$$$. If $$$i = j$$$, it conflicts with
Lemma 2
; If $$$i < j$$$, because of the
Lemma 2
, the HP of the $$$j$$$-th card after all the operations won't exceed $$$k$$$, let's use $$$A'$$$ as the HP of the $$$j$$$-th card after all the operations, and $$$B > k$$$, so we have done some operation 3 onto the $$$j$$$-th card. But because $$$A > k \geq A'$$$, if we do these operations onto the $$$i$$$-th card, the answer will be better; If $$$i > j$$$, it's symmetric with $$$i < j$$$.
But we can make the dynamic programming state better:
$$$f(u, a, b)$$$ means we are current at vertex $$$u$$$, we will do the next several operation 3 onto a card with $$$a$$$ HP after all the operations and we will do the next several operation 2 onto a card with $$$b$$$ damage after all the operations, and this two cards are not the same.
$$$g_a(u, a, a')$$$ means we are current at vertex $$$u$$$, we will do the next several operation 3 onto a card with $$$a$$$ HP after all the operations, we will do the next several operation 2 onto a card and totally increase $$$a'$$$ HP in the next several operations to reach it's HP after all the operations.
$$$g_b(u, b, b')$$$ it's symmetric with $$$g_a$$$, just swap "HP" and "damage".
Let's define $$$A$$$ as the maximum HP of all the cards except the flash card after all the operations, $$$B$$$ as the maximum damage of all the cards except the flash card after all the operations. We will find the $$$a, a', b, b'$$$ in $$$f, g_a, g_b$$$ is $$$O(k)$$$ because if $$$A \leq k$$$, using $$$g_a$$$ we can get the right answer, if $$$B \leq k$$$, using $$$g_b$$$ we can get the right answer.
the time complexity of the transition is $$$O(m \times k^2)$$$.
The transition is very complex, you can see more details in my code : )
In my code, I use $$$g(u)$$$ to make the transition better. When $$$a'$$$ or $$$b'$$$ reaches $$$0$$$, we reaches the vertex $$$u$$$ and there is a operation 1 on vertex $$$u$$$, I don't enumerate the value of the next $$$a$$$ and $$$b$$$ while transiting. I transit it to $$$g(u)$$$ first, and enumerate the value of the next $$$a$$$ and $$$b$$$ together.
III. the problem itself
Since the path is a chain, and we use dynamic programming to solve the problem. There's no difference whether the graph is a chain.
Time complexity: $$$O(m(nk+k^2))$$$
Memory complexity: $$$O(n^2k+nk^2)$$$
Code
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;

const int N = 200 + 5;
const ll lim = 1e9;

inline void checkmax(int &x, int y){
	if(y > x) x = y;
}

inline void checkmax(ll &x, ll y){
	if(y > x) x = y;
}

inline void checkmax(pair<int, int> &x, pair<int, int> y){
	if(y > x) x = y;
}

int n = 0, m = 0, k = 0, opt[N] = {}, a[N] = {}, b[N] = {}, w[N] = {};
int f[N][N][N] = {}, g[N] = {}, g_a[N][N][N] = {}, g_b[N][N][N] = {};
pair<int, int> dp[N][N * N] = {};
vector<vector<int> > G(N);

int main(){
	scanf("%d %d", &n, &m);
	for(int u = 1 ; u <= n ; u ++){
		scanf("%d", &opt[u]);
		if(opt[u] == 1) scanf("%d %d", &a[u], &b[u]);
		else if(opt[u] == 2) scanf("%d", &a[u]);
		else if(opt[u] == 3) scanf("%d", &b[u]);
		else if(opt[u] == 4) scanf("%d", &w[u]);
		k = max(k, max(a[u], b[u]));
	}
	for(int i = 1, u = 0, v = 0 ; i <= m ; i ++){
		scanf("%d %d", &u, &v);
		G[u].push_back(v);
	}
	memset(f, -1, sizeof(f));
	memset(g, -1, sizeof(g)), memset(g_a, -1, sizeof(g_a)), memset(g_b, -1, sizeof(g_b));
	memset(dp, -1, sizeof(dp));
	f[1][0][0] = 0;
	for(int u = 1 ; u <= n ; u ++){
		if(opt[u] == 1 && g[u] != -1){
			for(int x = a[u] ; x <= k ; x ++) checkmax(g_a[u][x][x - a[u]], g[u] + x * b[u]);
			for(int x = b[u] ; x <= k ; x ++) checkmax(g_b[u][x][x - b[u]], g[u] + x * a[u]);
			checkmax(dp[u][a[u]], make_pair(b[u], g[u]));
		}
		for(int v : G[u]){
			if(opt[v] == 1){
				for(int x = 0 ; x <= k ; x ++) for(int y = 0 ; y <= k ; y ++){
					if(f[u][x][y] != -1){
						checkmax(f[v][max(x, a[v])][max(y, b[v])], f[u][x][y] + a[v] * b[v]);
						checkmax(g[v], f[u][x][y]);
					}
					if(g_a[u][x][y] != -1){
						checkmax(g_a[v][max(x, a[v])][y], g_a[u][x][y] + a[v] * b[v]);
						if(!y){
							checkmax(g[v], g_a[u][x][y]);
							checkmax(f[v][x][b[v]], g_a[u][x][y] + a[v] * b[v]);
						}
					}
					if(g_b[u][x][y] != -1){
						checkmax(g_b[v][max(x, b[v])][y], g_b[u][x][y] + a[v] * b[v]);
						if(!y){
							checkmax(g[v], g_b[u][x][y]);
							checkmax(f[v][a[v]][x], g_b[u][x][y] + a[v] * b[v]);
						}
					}
				}
				for(int x = 0 ; x <= n * k ; x ++) if(dp[u][x] != make_pair(-1, -1)){
					int y = dp[u][x].first, z = dp[u][x].second;
					checkmax(dp[v][x], make_pair(y, z + a[v] * b[v]));
				}
			}
			else if(opt[v] == 2){
				for(int x = 0 ; x <= k ; x ++) for(int y = 0 ; y <= k ; y ++){
					if(f[u][x][y] != -1) checkmax(f[v][x][y], f[u][x][y] + a[v] * y);
					if(g_a[u][x][y] != -1 && y >= a[v]) checkmax(g_a[v][x][y - a[v]], g_a[u][x][y]);
					if(g_b[u][x][y] != -1) checkmax(g_b[v][x][y], g_b[u][x][y] + a[v] * x);
				}
				for(int x = 0 ; x <= n * k ; x ++) if(dp[u][x] != make_pair(-1, -1)){
					int y = dp[u][x].first, z = dp[u][x].second;
					checkmax(dp[v][x + a[v]], make_pair(y, z));
				}
			}
			else if(opt[v] == 3){
				for(int x = 0 ; x <= k ; x ++) for(int y = 0 ; y <= k ; y ++){
					if(f[u][x][y] != -1) checkmax(f[v][x][y], f[u][x][y] + x * b[v]);
					if(g_a[u][x][y] != -1) checkmax(g_a[v][x][y], g_a[u][x][y] + x * b[v]);
					if(g_b[u][x][y] != -1 && y >= b[v]) checkmax(g_b[v][x][y - b[v]], g_b[u][x][y]);
				}
				for(int x = 0 ; x <= n * k ; x ++) if(dp[u][x] != make_pair(-1, -1)){
					int y = dp[u][x].first, z = dp[u][x].second;
					checkmax(dp[v][x], make_pair(y + b[v], z));
				}
			}
			else{
				for(int x = 0 ; x <= k ; x ++) for(int y = 0 ; y <= k ; y ++){
					if(f[u][x][y] != -1) checkmax(f[v][x][y], f[u][x][y] + w[v]);
					if(g_a[u][x][y] != -1) checkmax(g_a[v][x][y], g_a[u][x][y] + w[v]);
					if(g_b[u][x][y] != -1) checkmax(g_b[v][x][y - b[v]], g_b[u][x][y] + w[v]);
				}
				for(int x = 0 ; x <= n * k ; x ++) if(dp[u][x] != make_pair(-1, -1)){
					int y = dp[u][x].first, z = dp[u][x].second;
					checkmax(dp[v][x], make_pair(y, z + w[v]));
				}
			}
		}
	}
	ll ans = f[n][0][0];
	for(int x = 0 ; x <= n * k ; x ++) if(dp[n][x] != make_pair(-1, -1)){
		int y = dp[n][x].first, z = dp[n][x].second;
		checkmax(ans, lim * x * y + z);
	}
	printf("%lld", ans);
	return 0;
}
--------------------------------------------------
Problem ID: 1874F
Editorial Content:
1874F - Jellyfish and OEIS
Tutorial
Let's call a section $$$[l, r]$$$ bad if $$$[p_l, p_{l+1}, \dots, p_{r-1}, p_r]$$$ is a permutation of $$$[l, l + 1, \dots, r - 1, r]$$$ and $$$l \leq r \leq m_l$$$.
Let's call a section $$$[l, r]$$$ primitive if it's a bad section and there are no section $$$[l', r']$$$ satisfying $$$[l', r']$$$ is also a bad section and $$$[l, r]$$$ covers $$$[l', r']$$$.
Lemma.
For all primitive sections, none two of them intersect.
Proof.
If $$$[l_1, r_1]$$$ is a bad section, $$$[l_2, r_2]$$$ is a bad section and $$$l_1 < l_2 < r_1 < r_2$$$, the section $$$[l_2, r_1]$$$ will also be a bad section, but both $$$[l_1, r_1]$$$ and $$$[l_2, r_2]$$$ covers $$$[l_2, r_1]$$$, so $$$[l_1, r_1]$$$ and $$$[l_2, r_2]$$$ can't be primitive at the same time.
Let's use the principle of inclusion-exclusion and dynamic programming to solve the problem.
Let's define $$$f(l, r)$$$ as the number of $$$p_l, p_{l+1}, \dots, p_{r-1}, p_r$$$ which is a primitive section. By the principle of inclusion-exclusion, we count the ways to fix $$$k$$$ primitive sections in range $$$[l, r]$$$, and arrange the rest arbitrarily.
Then we can define $$$g_{1/2}(l, r, x)$$$ as the number of ways to fix $$$k$$$ ($$$k$$$ is odd/even) primitive sections in range $$$[l, r]$$$, and the number of the positions which doesn't cover by any primitive section is $$$x$$$.
Finally we define $$$g(l, r, x) = g_2(l, r, x) - g_1(l, r, x)$$$, We will have the following transition:
$$$\forall l \leq r \leq m_l, f(l, r) = \sum_{x=0}^{r-l+1} g(l, r, x) \times x! + f(l, r)$$$
$$$g(l, r, x) = g(l, r - 1, x - 1) - \sum_{mid=l}^r g(l, mid - 1, x )\times f(mid, r)$$$
Tips.
In the transition of $$$f(l, r)$$$, We add $$$f(l, r)$$$ because $$$f(l, r)$$$ contributes to $$$g(l, r, 0)$$$, but it should not contribute to $$$f(l, r)$$$, This problem can be solved by ordering the transitions.
According to the definition, $$$\sum_{x=0}^{n} g(1, n, x) \times x!$$$ is the answer.
Time complexity: $$$O(n^4)$$$
Memory complexity: $$$O(n^3)$$$
Code
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;

const ll N = 200 + 5, Mod = 1e9 + 7;
ll n = 0, m[N] = {}, fac[N] = {}, f[N][N] = {}, g[N][N][N] = {};

int main(){
	scanf("%lld", &n);
	for(ll i = 1 ; i <= n ; i ++) scanf("%lld", &m[i]);
	if(m[1] == n){
		printf("0");
		return 0;
	}
	fac[0] = 1;
	for(ll i = 1 ; i <= n ; i ++) fac[i] = fac[i - 1] * i % Mod;
	for(ll i = 1 ; i <= n ; i ++) g[i][i - 1][0] = 1;
	for(ll l = n ; l >= 1 ; l --) for(ll r = l ; r <= n ; r ++){
		for(ll x = 1 ; x <= r - l + 1 ; x ++) g[l][r][x] = g[l][r - 1][x - 1];
		for(ll mid = l ; mid < r ; mid ++) if(r <= m[mid + 1]) for(ll x = 0 ; x <= mid - l + 1 ; x ++) g[l][r][x] = (g[l][r][x] + g[l][mid][x] * (Mod - f[mid + 1][r])) % Mod;
		for(ll x = 0 ; x <= r - l + 1 ; x ++) f[l][r] = (f[l][r] + g[l][r][x] * fac[x]) % Mod;
		if(r <= m[l]) g[l][r][0] = (g[l][r][0] + (Mod - f[l][r])) % Mod;
	}
	printf("%lld", f[1][n]);
	return 0;
}
--------------------------------------------------
Problem ID: 1874E
Editorial Content:
1874E - Jellyfish and Hack
Tutorial
Firstly, if $$$lim > \frac {n(n+1)} 2$$$, the answer will be $$$0$$$. So we only need to solve the problem which satisfies $$$lim \leq \frac{n(n+1)} 2$$$.
We can use dynamic programming to solve the problem:
Let's define $$$dp_{i, a}$$$ means the number of the permutations $$$P$$$ of $$$[1, 2, \dots, i]$$$, satisfying $$$\mathrm{fun(P)} = a$$$.
Since only relative rankings are useful, we have the following transition:
$$$dp_{0, 0} = 1$$$
$$$\forall i > 0, dp_{i, a} = \sum_{j=1}^i \binom {i-1} {j-1} \sum_{b=0}^{a - i} dp_{j - 1, b} \times dp_{i - j, a - b - i}$$$
The time complexity is $$$O(n^6)$$$, because $$$a \leq \frac {i(i+1)} 2$$$, how can it becomes faster?
FFT (Fast Fourier Transform) might come to mind first. If we use FFT instead of enumerating $$$t$$$, The time complexity will become $$$O(n^4 \log n)$$$. This is not enough because $$$n$$$ is large and $$$10^9+7$$$ is not a modulus suitable for NTT (Number-theoretic Transform).
Tips.
Also, if you use divide and conquer and FFT, The time complexity will be $$$O(n^3 \text{poly}(\log n))$$$, but because FFT have a big constant factor, this still can't pass the problem.
But we can do something similar to what the FFT does. We define $$$F_i = \sum_{a=1}^{\frac {n(n + 1)} 2} dp_{i, a} \times x^a$$$, then we will have the following transition:
$$$F_0=1$$$
$$$F_i = x^i \times \sum_{j=1}^i \binom{i - 1}{j - 1} F_{j-1} \times F_{i-j}$$$
For all $$$1 \leq i \leq n$$$, The degree of $$$F_i$$$ won't exceed $$$\frac {n(n+1)} 2$$$. So if we have $$$\frac{n(n+1)} 2 + 1$$$ points on $$$F_n$$$, We can get $$$F_n$$$ by in time complexity $$$O(n^4)$$$ using Lagrange Interpolation. The only thing we need to do is the dot product of the functions, so the time complexity of the transition is also $$$O(n^4)$$$.
Time complexity: $$$O(n^4)$$$
Memory complexity: $$$O(n^3)$$$
Code
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;

const ll N = 200 + 5, Mod = 1e9 + 7;

inline ll power(ll x, ll y){
	ll ret = 1;
	while(y){
		if(y & 1) ret = ret * x % Mod;
		x = x * x % Mod, y >>= 1;
	}
	return ret;
}

ll n = 0, k = 0, lim = 0;
ll C[N][N] = {}, pw[N * N][N] = {}, iv[N * N] = {}, ifac[N * N] = {}, dp[N][N * N] = {};
ll a[N * N] = {}, b[N * N] = {}, ans = 0;

int main(){
	scanf("%lld %lld", &n, &k); lim = n * (n + 1) / 2;
	for(ll i = 0 ; i <= n ; i ++){
		C[i][0] = 1;
		for(ll j = 1 ; j <= i ; j ++) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % Mod;
	}
	ifac[0] = 1;
	for(ll x = 0 ; x <= lim ; x ++){
		pw[x][0] = 1;
		if(x) iv[x] = power(x, Mod - 2), ifac[x] = ifac[x - 1] * iv[x] % Mod;
		for(ll i = 1 ; i <= n ; i ++) pw[x][i] = pw[x][i - 1] * x % Mod;
	}
	for(ll x = 0 ; x <= lim ; x ++) dp[0][x] = 1;
	for(ll i = 1 ; i <= n ; i ++){
		for(ll j = 0 ; j < i ; j ++) for(ll x = 0 ; x <= lim ; x ++) dp[i][x] = (dp[i][x] + dp[j][x] * dp[i - 1 - j][x] % Mod * C[i - 1][j]) % Mod;
		for(ll x = 0 ; x <= lim ; x ++) dp[i][x] = dp[i][x] * pw[x][i] % Mod;
	}
	a[0] = 1;
	for(ll i = 0 ; i <= lim ; i ++){
		for(ll x = lim ; x >= 1 ; x --) a[x] = (a[x - 1] + a[x] * (Mod - i)) % Mod;
		a[0] = a[0] * (Mod - i) % Mod;
	}
	for(ll i = 1 ; i <= lim ; i ++) if(dp[n][i]){
		ll w = dp[n][i] * ifac[i] % Mod * ifac[lim - i] % Mod;
		if((lim - i) & 1) w = Mod - w;
		b[0] = a[0] * (Mod - iv[i]) % Mod;
		for(ll x = 1 ; x <= lim ; x ++) b[x] = (a[x] - b[x - 1] + Mod) * (Mod - iv[i]) % Mod;
		for(ll x = k ; x <= lim ; x ++) ans = (ans + b[x] * w) % Mod;
	}
	printf("%lld\n", ans);
	return 0;
}
--------------------------------------------------
Problem ID: 1874D
Editorial Content:
1874D - Jellyfish and Miku
Tutorial
Let's assume that $$$a$$$ is given. We can use dynamic programming to solve the problem.
Let's define $$$f_i$$$ as the expected number of days Jellyfish needs to reach city $$$i$$$ from city $$$0$$$.
We will have:
$$$f_0=0, f_1=1$$$
$$$\forall i > 1, f_i=f_{i-1}+1+\frac {a_{i-1}} {a_{i-1}+a_i} \times (f_i - f_{i-2})$$$
Let's make it better:
$$$f_i = f_{i-1} + 1 + \frac {a_{i-1}} {a_i} \times (f_{i-1}-f_{i-2}+1)$$$
What does this inspire us to do? Let's define $$$g_i=f_i-f_{i-1}$$$, then we will get:
$$$g_1=1$$$
$$$\forall i > 1, g_i = 1 + \frac {a_{i-1}} {a_i} \times (g_{i-1}+1)$$$
By induction, we will find $$$g_i = 1 + 2 \times \sum_{j=1}^{i-1} \frac {a_j} {a_i}$$$. According to the definition, $$$f_n = \sum_{i=1}^n g_n = n + 2 \times \sum_{i=1}^n\sum_{j=1}^{i-1} \frac{a_j}{a_i}$$$.
Then we can use dynamic programming to solve the problem itself.
Let's define $$$s_i = \sum_{j=1}^i a_j$$$, then $$$f_n = n + 2 \times \sum_{i=1}^n \frac{s_{i-1}}{a_i}$$$.
Let's define $$$dp_{i, x}$$$ as the minimum value of $$$\sum_{i=1}^n \frac{s_{i-1}}{a_i}$$$ when $$$s_i = x$$$.
We transit by enumerating the values of $$$a_{i+1}$$$, The transition is: $$$dp_{i+1, x+y} \leftarrow dp_{i, x} + \frac x y$$$.
But the time complexity is $$$O(n m^2)$$$, how can it becomes faster?
Let's take a closer look at $$$\sum_{i=1}^n\sum_{j=1}^{i-1} \frac{a_j}{a_i}$$$. If there exists $$$i < n$$$ satisfying $$$a_i > a_{i+1}$$$. We can swap $$$a_i$$$ and $$$a_{i+1}$$$, the answer will be better! so $$$a$$$ is a non-decreasing array, which means $$$a_i \leq \frac m {n - i + 1}$$$.
Because $$$\sum_{i=1}^n \frac n i$$$ is $$$O(n \log n)$$$, so if we only enumerate the possible values of $$$a_i$$$ the time complexity will be $$$O(m^2 \log m)$$$.
Time complexity: $$$O(m^2 \log m)$$$
Memory complexity: $$$O(nm)$$$
Code
#include<bits/stdc++.h>

using namespace std;

const int N = 3000 + 5;
const long double Inf = 1e18;
int n = 0, m = 0;
long double dp[N][N] = {};

int main(){
	scanf("%d %d", &n, &m);
	for(int i = 0 ; i <= n ; i ++) for(int x = 0 ; x <= m ; x ++) dp[i][x] = Inf;
	dp[0][0] = 0.00;
	for(int i = 1 ; i <= n ; i ++) for(int x = 0 ; x <= m ; x ++) for(int y = 1 ; x + y * (n - i + 1) <= m ; y ++) dp[i][x + y] = min(dp[i][x + y], dp[i - 1][x] + 1.00 * x / y);
	printf("%.12Lf", 2 * dp[n][m] + n);
	return 0;
}
--------------------------------------------------
Problem ID: 1874C
Editorial Content:
1874C - Jellyfish and EVA
Tutorial
Let's solve this problem by dynamic programming, Let $$$f_u$$$ represents the max probability of reaching city $$$n$$$ starting from city $$$u$$$.
The problem is how to transition. for city $$$u$$$, we assume that there are $$$d$$$ roads from city $$$u$$$, the $$$i$$$-th road from city $$$u$$$ is to city $$$v_i$$$.
Let's sort $$$v$$$ by using $$$f_v$$$ as the keyword, with $$$v$$$ with the larger $$$f_v$$$ coming first.
Let's define an array $$$a$$$ of $$$d$$$ elements equals to $$$[f_{v_1}, f_{v_2}, \dots, f_{v_d}]$$$, according to the definition, $$$a$$$ is non-increasing.
That is, next we want to find an optimal solution such that the probability of going to city $$$v_i$$$ is $$$p_i$$$, maximizing the value of $$$\sum_{i=1}^d{a_i \times p_i}$$$.
Tips:
the sum of $$$p_i$$$ may not be $$$1$$$, because it is possible to stay at city $$$u$$$ when $$$d$$$ is even.
For two choices of $$$p$$$, $$$p_1$$$ and $$$p_2$$$, Sometimes we can't which is better, for example:
$$$p_1 = [0.6, 0.2, 0.2], p_2 = [0.5, 0.5, 0]$$$
when $$$a=[1.0, 0.2, 0.2]$$$, $$$p_1$$$ is better than $$$p_2$$$. But when $$$a = [1.0, 0.8, 0]$$$, $$$p_2$$$ is better than $$$p_1$$$.
Tips.
In fact, when $$$d=3$$$, $$$p$$$ has only one choice $$$[\frac 1 3, \frac 1 3, \frac 1 3]$$$, the above is just a hypothetical to illustrate the problem.
So when can we say, $$$p_1$$$ is always not worse than $$$p_2$$$?
Lemma.
If there are two arrays $$$p_1$$$ and $$$p_2$$$, satisfying $$$\forall i \leq d, \sum_{j=1}^i{p_1}_j \geq \sum_{j=1}^i{p_2}_j$$$, $$$p_1$$$ is always not worse than $$$p_2$$$.
Proof.
Let's consider $$$a_{d+1}$$$ as $$$0$$$ and define $$$a'_i = a_i - a_{i+1}$$$, $$${p_1'}_i = \sum_{j=1}^i{p_1}_j$$$ and $$${p_2'}_i = \sum_{j=1}^i{p_2}_j$$$, then $$$\sum_{i=1}^d a_i \times {p_1}_i = \sum_{i=1}^d a'_i \times {p_1'}_i, \sum_{i=1}^d a_i \times {p_2}_i = \sum_{i=1}^d a'_i \times {p_2'}_i$$$, Because $$$a$$$ is non-increasing, so $$$a'_i \geq 0$$$, and we have $$$\forall i \leq d, {p_1}_i \geq {p_2}_i$$$, so $$$\sum_{i=1}^d a_i \times {p_1}_i \geq \sum_{i=1}^d a_i \times {p_2}_i$$$.
Now the problem is, there is whether an array $$$p$$$ not worse than any other arrays for for all $$$d$$$.
For $$$d = 1$$$, $$$p = [1.0]$$$ satisfies the condition.
For $$$d = 2$$$, $$$p = [0.5, 0]$$$ satisfies the condition.
What about $$$d>2$$$ ? After they choose the roads for the first time, The size of the problem will become $$$d - 2$$$.
For example, when $$$d = 4$$$, Let's assume Jellyfish choose $$$v_1$$$ for the first time, then there will be $$$4$$$ situations:
When Asuka chooses $$$v_1$$$ they will go to $$$v_1$$$.
When Asuka chooses $$$v_2$$$, the problem changes into the subproblem with $$$[v_3, v_4]$$$.
When Asuka chooses $$$v_3$$$, the problem changes into the subproblem with $$$[v_2, v_4]$$$.
When Asuka chooses $$$v_4$$$, the problem changes into the subproblem with $$$[v_2, v_3]$$$.
By calculating, $$$p = [0.25, 0.25, 0.125, 0]$$$, it also satisfies the condition.
Let's define $$$g_k$$$ as the best array $$$p$$$ when $$$d=k$$$, $$$g'_k$$$ as the the probabilities of going to cities except the city Jellyfish choose for the first time. By recursion, we can get $$$g'_k$$$ from $$$g_{k-2}$$$. After that, we insert $$$\frac 1 k$$$ into $$$g'_k$$$, keeping it non-increasing, we will get $$$g_k$$$.
By calculating, we will find $$$\frac 1 k$$$ is always the first element in $$$g_k$$$. So when $$$k > 2$$$, we have the following transition:
$$$g_{k, 1} = \frac 1 k$$$
$$$\forall 1 < i \leq k, g_{k, i} = g_{k-2, i - 2} \times \frac {i - 2} k + g_{k-2, i - 1} \times \frac {k - i} k$$$
In the above we consider $$$g_{k, x}$$$ as $$$0$$$ for all $$$x = 0$$$ or $$$x > k$$$.
Because $$$g_{k-2}$$$ satisfies the condition, by greedy and induction we can show that $$$g_k$$$ satisfies the condition.
Time complexity: $$$O(\max(n)^2)$$$ for preprocessing and $$$O(m \log n)$$$ per test case.
Memory complexity: $$$O(\max(n)^2)$$$ for preprocessing and $$$O(m)$$$ per test case.
Code
#include<bits/stdc++.h>

using namespace std;

const int N = 5000 + 5;
int n = 5000, m = 0;
vector<vector<int> > G(N), Gx(N);
long double f[N] = {}, g[N][N] = {};

inline bool cmp(int u, int v){
	return f[u] > f[v];
}

inline void work(int u){
	if(u == n){
		f[u] = 1.00;
		return;
	}
	sort(G[u].begin(), G[u].end(), cmp);
	int k = G[u].size();
	for(int i = 0 ; i < k ; i ++){
		int v = G[u][i];
		f[u] += f[v] * g[k][i + 1];
	}
}

inline void init(){
	for(int u = 1 ; u <= n ; u ++){
		f[u] = 0.00;
		G[u].clear(), Gx[u].clear();
	}
	n = m = 0;
}

inline void solve(){
	scanf("%d %d", &n, &m);
	for(int i = 1, u = 0, v = 0 ; i <= m ; i ++){
		scanf("%d %d", &u, &v);
		if(u != n){
			G[u].push_back(v);
			Gx[v].push_back(u);
		}
	}
	for(int u = n ; u >= 1 ; u --) work(u);
	printf("%.12Lf\n", f[1]);
}

int T = 0;

int main(){
	for(int i = 1 ; i <= n ; i += 2) for(int j = 1 ; j <= i ; j ++) g[i][j] = 1.00 / i;
	for(int i = 2 ; i <= n ; i += 2){
		g[i][1] = 1.00;
		for(int j = 1 ; j <= i ; j ++) g[i][j] /= i;
		if(i + 2 <= n) for(int j = 1 ; j <= i ; j ++) g[i + 2][j + 1] += g[i][j] * (i - j + 1), g[i + 2][j + 2] += g[i][j] * j;
	}
	scanf("%d", &T);
	for(int i = 1 ; i <= T ; i ++) init(), solve();
	return 0;
}
--------------------------------------------------
Problem ID: 1874B
Editorial Content:
1874B - Jellyfish and Math
Tutorial
First of all, since $$$\text{and}, \text{or}, \text{xor}$$$ are all bitwise operations, each bit is independent of the other.
We define $$$a_i$$$ as the $$$i$$$-th bit of $$$a$$$, $$$b_i$$$ as the $$$i$$$-th bit of $$$b$$$, $$$c_i$$$ as the $$$i$$$-th bit of $$$c$$$, $$$d_i$$$ as the $$$i$$$-th bit of $$$d$$$, $$$m_i$$$ as the $$$i$$$-th bit of $$$m$$$, $$$x_i$$$ as the $$$i$$$-th bit of $$$x$$$, $$$y_i$$$ as the $$$i$$$-th bit of $$$y$$$. (in binary)
Lemma.
For all $$$i \neq j$$$, if $$$(a_i, b_i, m_i) = (a_j, b_j, m_j)$$$ and $$$(c_i, d_i) \neq (c_j, d_j)$$$, the goal cannot be achieved.
Proof.
Because after every operation we will have $$$(x_i, y_i) = (x_j, y_j)$$$, so we can't achieve he goal.
Since $$$(a_i, b_i, m_i)$$$ has only $$$2^3=8$$$ cases, and $$$(c_i, d_i)$$$ has only $$$2^2=4$$$ cases, and there are some $$$(0/1, 0/1, 0/1)$$$ that do not appear in $$$\{(a_i, b_i, m_i)\ |\ 0 \leq i \leq \log \max(a, b, c, d, m)\}$$$, so there are only $$$(4+1)^8<4\times 10^5$$$ cases in this problem. We can use BFS(breadth-first search) for preprocessing.
Time complexity: $$$O(5^8)$$$ for preprocessing and $$$O(\log \max(a, b, c, d, m))$$$ per test case.
Memory complexity: $$$O(5^8)$$$ for preprocessing and $$$O(1)$$$ per test case.
Code
#include<bits/stdc++.h>

using namespace std;

const int S = 4e5 + 5, Inf = 0x3f3f3f3f;
int pw5[10] = {}, dp[S] = {};
queue<int> Q;

inline void checkmin(int &x, int y){
	if(y < x) x = y;
}

inline int w(int mask, int i){
	return (mask / pw5[i]) % 5;
}

inline int f(int a, int b, int m){
	return (a << 2) | (b << 1) | m;
}

inline int g(int c, int d){
	return (c << 1) | d;
}

inline int work(int mask, int opt){
	int ret = 0;
	for(int a = 0 ; a < 2 ; a ++) for(int b = 0 ; b < 2 ; b ++) for(int m = 0 ; m < 2 ; m ++){
		int x = w(mask, f(a, b, m)), c = x >> 1, d = x & 1;
		if(opt == 1) c = c & d;
		else if(opt == 2) c = c | d;
		else if(opt == 3) d = c ^ d;
		else d = m ^ d;
		ret += pw5[f(a, b, m)] * g(c, d);
	}
	return ret;
}

inline void init(){
	pw5[0] = 1;
	for(int i = 1 ; i <= 8 ; i ++) pw5[i] = pw5[i - 1] * 5;
	memset(dp, 0x3f, sizeof(dp));
	int mask = 0;
	for(int a = 0 ; a < 2 ; a ++) for(int b = 0 ; b < 2 ; b ++) for(int m = 0 ; m < 2 ; m ++) mask += pw5[f(a, b, m)] * g(a, b);
	dp[mask] = 0, Q.push(mask);
	while(Q.size()){
		int s = Q.front(); Q.pop();
		for(int opt = 0 ; opt < 4 ; opt ++){
			int t = work(s, opt);
			if(dp[t] == Inf) dp[t] = dp[s] + 1, Q.push(t);
		}
	}
	for(int mask = 0 ; mask < pw5[8] ; mask ++) for(int i = 0 ; i < 8 ; i ++) if(w(mask, i) == 4){
		for(int x = 1 ; x <= 4 ; x ++) checkmin(dp[mask], dp[mask - x * pw5[i]]);
		break;
	}
}

inline void solve(){
	int A = 0, B = 0, C = 0, D = 0, M = 0, mask = pw5[8] - 1;
	scanf("%d %d %d %d %d", &A, &B, &C, &D, &M);
	for(int i = 0 ; i < 30 ; i ++){
		int a = (A >> i) & 1, b = (B >> i) & 1, c = (C >> i) & 1, d = (D >> i) & 1, m = (M >> i) & 1;
		if(w(mask, f(a, b, m)) == 4) mask -= (4 - g(c, d)) * pw5[f(a, b, m)];
		else if(w(mask, f(a, b, m)) != g(c, d)){
			printf("-1\n");
			return;
		}
	}
	printf("%d\n", (dp[mask] < Inf) ? dp[mask] : -1);
}

int T = 0;

int main(){
	init();
	scanf("%d", &T);
	for(int i = 0 ; i < T ; i ++) solve();
	return 0;
}
--------------------------------------------------
Problem ID: 1874A
Editorial Content:
1874A - Jellyfish and Game
Tutorial
Let us define $$$\min(a)$$$ to be the minimum value of $$$a$$$ in the current round, $$$\max(a)$$$ to be the maximum value of $$$a$$$ in the current round, $$$\min(b)$$$ to be the minimum value of $$$b$$$ in the current round, $$$\max(b)$$$ to be the maximum value of $$$b$$$ in the current round, $$$\text{MIN}$$$ to be the minimum value of all the apples, $$$\text{MAX}$$$ to be the maximum value of all the apples.
By greedy and induction, we would come to the following conclusion:
If Jellyfish is the one operating this round: If $$$\min(a) < \max(b)$$$, she will swap this two apples, otherwise she will do nothing.
If Gellyfish is the one operating this round: If $$$\max(a) > \min(b)$$$, he will swap this two apples, otherwise she will do nothing.
We consider who $$$\text{MAX}$$$ and $$$\text{MIN}$$$ will belong to after the first round.
In the first round:
If $$$\max(a) < \max(b)$$$, $$$\text{MAX} = \max(b)$$$. And because $$$\min(a) < \max(b)$$$, Jellyfish will swap this two apples. So $$$\text{MAX}$$$ belongs to Jellyfish.
If $$$\max(a) > \max(b)$$$, $$$\text{MAX} = \max(a)$$$. If $$$\min(a)=\max(a)$$$, then $$$\min(a) > \max(b)$$$, Jellyfish will do nothing. Otherwise Jellyfish won't swap the apple with value $$$\text{MAX}$$$. In conclusion $$$\text{MAX}$$$ belongs to Jellyfish
We can also show that $$$\text{MIN}$$$ belongs to Gellyfish, and the proof is symmetric with the above.
So in the second round, $$$\min(b) = \text{MIN}, \max(a) = \text{MAX}$$$, We have $$$\text{MIN}<\text{MAX}$$$. So Gellyfish will swap this two apples, in the third round, $$$\min(a)=\text{MIN}, \max(b) = \text{MAX}$$$, Jellyfish will swap this two apples.
So after the first round, the game will go two rounds at a time, with two people swapping two apples with the minimum value and the maximum value back and forth.
So we only need to know the answer for $$$k = 1$$$ and $$$k = 2$$$.
Time complexity: $$$O(n + m)$$$ per test case.
Memory complexity: $$$O(n + m)$$$ per test case.
Code
#include<bits/stdc++.h>

using namespace std;

const int N = 1000 + 5;
int n = 0, m = 0, k = 0, x = 0, y = 0, a[N] = {}, b[N] = {};

inline void solve(){
	scanf("%d %d %d", &n, &m, &k); k --;
	for(int i = 0 ; i < n ; i ++) scanf("%d", &a[i]);
	for(int i = 0 ; i < m ; i ++) scanf("%d", &b[i]);
	x = y = 0;
	for(int i = 1 ; i < n ; i ++) if(a[i] < a[x]) x = i;
	for(int i = 1 ; i < m ; i ++) if(b[i] > b[y]) y = i;
	if(b[y] > a[x]) swap(a[x], b[y]);
	if(k & 1){
		x = 0, y = 0;
		for(int i = 1 ; i < n ; i ++) if(a[i] > a[x]) x = i;
		for(int i = 1 ; i < m ; i ++) if(b[i] < b[y]) y = i;
		swap(a[x], b[y]);
	}
	long long ans = 0;
	for(int i = 0 ; i < n ; i ++) ans += a[i];
	printf("%lld\n", ans);
	
}

int T = 0;

int main(){
	scanf("%d", &T);
	for(int i = 0 ; i < T ; i ++) solve();
	return 0;
}
--------------------------------------------------
Problem ID: 1873H
Editorial Content:
1873H - Mad City
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 200005;
 
vector<int> adj[N];
vector<bool> vis(N);
 
int entry_node = -1;
vector<int> path;
 
bool dfs1(int u, int p)
{
    vis[u] = true;
    for(auto v : adj[u])
    {
        if(v != p && vis[v])
        {
            entry_node = v;
            return true;
        }
        else if(v != p && !vis[v])
        {
            if(dfs1(v, u))
            {
                return true;
            }
        }
    }
    return false;
}
 
int dfs2(int u)
{
    vis[u] = true;
    int distbruh = N;
    for(auto v : adj[u])
    {
        if(v == entry_node)
        {
            return 1;
        }
        if(!vis[v])
        {
            int dist = dfs2(v)+1;
            distbruh = min(dist, distbruh);
        }
    }
    return distbruh;
}
 
void solve()
{
    int n, a, b;
    cin >> n >> a >> b;
    for(int i = 0; i < n; i++)
    {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    dfs1(b, -1);
    vis.assign(n+1, false);
    int distMarcel = N, distValeriu = 0;
    if(entry_node == a)
    {
        distMarcel = 0;
    }
    else
    {
        distMarcel = dfs2(a);
    }
    vis.assign(n+1, false);
    if(entry_node == b)
    {
        distValeriu = 0;
    }
    else
    {
        distValeriu = dfs2(b);
    }
    if(distValeriu < distMarcel)
    {
        cout << "YES" << endl;
    }
    else
    {
        cout << "NO" << endl;
    }
    for(int i = 1; i <= n; i++)
    {
        adj[i].clear();
        vis[i] = false;
    }
}
 
int32_t main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1873G
Editorial Content:
1873G - ABBC or BACB
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200'007;
const int MOD = 1'000'000'007;
 
void solve() {
	string s;
	cin >> s;
	int n = s.length(), cnt = 0;
	bool all = (s[0] == 'B' || s[n - 1] == 'B');
	for (int i = 0; i < n - 1; i++) {
		if (s[i] == s[i + 1] && s[i] == 'B') {all = true;}
	}
	vector<int> lens;
	int curr = 0;
	for (int i = 0; i < n; i++) {
		if (s[i] == 'A') {curr++;}
		else {
			if (curr != 0) {lens.push_back(curr);}
			curr = 0;
		}
	}
	if (curr != 0) {lens.push_back(curr);}
	sort(lens.begin(), lens.end());
	
	if (lens.empty()) {cout << 0 << '\n'; return;}
	
	int tot = 0;
	if (all) {tot += lens[0];}
	for (int i = 1; i < lens.size(); i++) {
		tot += lens[i];
	}
	cout << tot << '\n';
}
 
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1873F
Editorial Content:
1873F - Money Trees
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
 
const int N = 200'000;
 
int n, k;
int a[N+5], h[N+5], pref[N+5], length[N+5];
 
bool get(int dist)
{
    bool found = false;
    for(int i = 0; i < n-dist+1; i++)
    {
        if(length[i] < dist){continue;}
        int sum = pref[i+dist]-pref[i];
        if(sum <= k)
        {
            found = true;
            break;
        }
    }
    return found;
}
 
void solve()
{
    pref[0] = 0;
    cin >> n >> k;
    for(int i = 0; i < n; i++)
    {
        cin >> a[i];
        pref[i+1] = pref[i]+a[i];
    }
    for(int i = 0; i < n; i++)
    {
        cin >> h[i];
    }
    length[n-1] = 1;
    for(int i = n-2; i >= 0; i--)
    {
        if(h[i]%h[i+1] == 0)
        {
            length[i] = length[i+1]+1;
        }
        else
        {
            length[i] = 1;
        }
    }
    int l = 1, r = N;
    while(l <= r)
    {
        int mid = (l+r)/2;
        if(get(mid))
        {
            l = mid+1;
        }
        else
        {
            r = mid-1;
        }
    }
    cout << r << endl;
}
 
int main() {
    int t = 1;
    cin >> t;
    while (t--)
    {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1873E
Editorial Content:
1873E - Building an Aquarium
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200'007;
const int MOD = 1'000'000'007;
 
void solve() {
	int n;
	long long x;
	cin >> n >> x;
	long long a[n];
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	long long lo = 0, hi = 2'000'000'007;
	while (lo < hi) {
		long long mid = lo + (hi - lo + 1) / 2;
		long long tot = 0;
		for (int i = 0; i < n; i++) {
			tot += max(mid - a[i], 0LL);
		}
		if (tot <= x) {lo = mid;} 
		else {hi = mid - 1;}
	}
	cout << lo << endl;
}
 
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1873D
Editorial Content:
1873D - 1D Eraser
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200'007;
const int MOD = 1'000'000'007;
 
void solve() {
	int n, k;
	cin >> n >> k;
	string s;
	cin >> s;
	int res = 0;
	for (int i = 0; i < n; i++) {
		if (s[i] == 'B') {
			res++; i += k - 1;
		}
	}
	cout << res << '\n';
}
 
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1873C
Editorial Content:
1873C - Target Practice
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200007;
const int MOD = 1000000007;
 
int score[10][10] = {
	{1,1,1,1,1,1,1,1,1,1},
	{1,2,2,2,2,2,2,2,2,1},
	{1,2,3,3,3,3,3,3,2,1},
	{1,2,3,4,4,4,4,3,2,1},
	{1,2,3,4,5,5,4,3,2,1},
	{1,2,3,4,5,5,4,3,2,1},
	{1,2,3,4,4,4,4,3,2,1},
	{1,2,3,3,3,3,3,3,2,1},
	{1,2,2,2,2,2,2,2,2,1},
	{1,1,1,1,1,1,1,1,1,1}
};
 
void solve() {
	int ans = 0;
	for (int i = 0; i < 10; i++) {
		for (int j = 0; j < 10; j++) {
			char c;
			cin >> c;
			if (c == 'X') {ans += score[i][j];}
		}
	}
	cout << ans << '\n';
}
 
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1873B
Editorial Content:
1873B - Good Kid
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
 
void solve()
{
    int n;
    cin >> n;
    vector<int> a(n);
    int ans = 1;
    for(int i = 0; i < n; i++)
    {
        cin >> a[i];
    }
    sort(a.begin(), a.end());
    a[0]++;
    for(int i = 0; i < n; i++)
    {
        ans*=a[i];
    }
    cout << ans << endl;
}
 
int32_t main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1873A
Editorial Content:
1873A - Short Sort
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200007;
const int MOD = 1000000007;
 
string alph = "abc";
 
void solve() {
	string s;
	cin >> s;
	int cnt = 0;
	for (int i = 0; i < 3; i++) {
		cnt += (s[i] != alph[i]);
	}
	cout << (cnt <= 2 ? "YES\n" : "NO\n");
}
 
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1872G
Editorial Content:
1872G - Replace With Product
Tutorial
Tutorial is loading...
Solution
222437122
--------------------------------------------------
Problem ID: 1872F
Editorial Content:
1872F - Selling a Menagerie
Tutorial
Tutorial is loading...
Solution
222362879
--------------------------------------------------
Problem ID: 1872E
Editorial Content:
1872E - Data Structures Fan
Tutorial
Tutorial is loading...
Solution
222362852
--------------------------------------------------
Problem ID: 1872D
Editorial Content:
1872D - Plus Minus Permutation
Tutorial
Tutorial is loading...
Solution
222362817
--------------------------------------------------
Problem ID: 1872C
Editorial Content:
1872C - Non-coprime Split
Tutorial
Tutorial is loading...
Solution
222362796
--------------------------------------------------
Problem ID: 1872B
Editorial Content:
1872B - The Corridor or There and Back Again
Tutorial
Tutorial is loading...
Solution
222362772
--------------------------------------------------
Problem ID: 1872A
Editorial Content:
1872A - Two Vessels
Tutorial
Tutorial is loading...
Solution
222362736
--------------------------------------------------
Problem ID: 1870H
Editorial Content:
1870H - Standard Graph Problem
Tutorial
Let's unfold all the edges, now we need to ensure that all regular vertices are reachable from the selected vertices.
First, you should familiarize yourself with the algorithm for finding the ordered minimum spanning tree, also known as the
Edmonds' algorithm
(I will refer to his work here and without knowledge of it, the solution cannot be understood). Next, it is worth noting that the compressions in the process of this algorithm (almost) do not depend on the root, and all compressions can be performed as if there is no root (previously creating dummy edges from $$$i$$$ to $$$i+1$$$ for $$$i$$$ from $$$1$$$ to $$$n-1$$$ and from vertex $$$n$$$ to vertex $$$1$$$ with a cost of $$$n * max(a_i)+1$$$). Then, after all the compressions, only one vertex will remain. Note that the difference from Edmonds' algorithm is that if at any step of the algorithm the minimum edge from a vertex leads to the root, compression is not necessary.
So, let's maintain a tree in which each vertex corresponds to its corresponding compressed vertex or to the original vertex, and the children of vertex $$$v$$$ are all the vertices that we compressed to obtain vertex $$$v$$$. It is implied that with each compression, we create a new vertex.
Let's call the cost of vertex $$$v$$$ the minimum cost of an edge leaving vertex $$$v$$$ in the process of Edmonds' algorithm (taking into account changes in edge costs during compression in Edmonds' algorithm).
Then we need to maintain the sum of the costs of the vertices in the tree, in the subtrees of which there are no selected vertices (where the selected vertices can only be leaves). This can be easily done using a segment tree.
Problem Feedback
You can choose one best problem, or not choose if you think there is no such task.
A
The best problem
Good problem
Mid problem
Bad problem
B
The best problem
Good problem
Mid problem
Bad problem
C
The best problem
Good problem
Mid problem
Bad problem
D
The best problem
Good problem
Mid problem
Bad problem
E
The best problem
Good problem
Mid problem
Bad problem
F
The best problem
Good problem
Mid problem
Bad problem
G
The best problem
Good problem
Mid problem
Bad problem
H
The best problem
Good problem
Mid problem
Bad problem
A
The best problem
Good problem
Mid problem
Bad problem
B
The best problem
Good problem
Mid problem
Bad problem
C
The best problem
Good problem
Mid problem
Bad problem
D
The best problem
Good problem
Mid problem
Bad problem
E
The best problem
Good problem
Mid problem
Bad problem
F
The best problem
Good problem
Mid problem
Bad problem
G
The best problem
Good problem
Mid problem
Bad problem
H
The best problem
Good problem
Mid problem
Bad problem
--------------------------------------------------
Problem ID: 1870G
Editorial Content:
1870G - MEXanization
Tutorial
Let's start by introducing a more convenient way to store numbers — an array $$$cnt$$$, where $$$cnt[x]$$$ represents the number of occurrences of $$$x$$$ in the prefix for which we are finding the answer. All $$$x$$$ such that $$$x > n$$$ will be added to $$$cnt[0]$$$ because applying the operation to $$${x}$$$ in such cases is optimal.
Let's introduce a few array operations that will be sufficient to solve the problem.
Create the number $$$x$$$. Apply the operation to the set of numbers $$${0, 1, 2, \dots, x-1}$$$. In terms of the array $$$cnt$$$, this is equivalent to subtracting $$$1$$$ from the range $$$0$$$ to $$$x-1$$$ and adding $$$1$$$ to $$$cnt[x]$$$.
Turn the number $$$x$$$ into $$$0$$$. To do this, apply the operation to $$${x}$$$. In terms of the array $$$cnt$$$, this is equivalent to subtracting $$$1$$$ from $$$cnt[x]$$$ and adding $$$1$$$ to $$$cnt[0]$$$.
Create the number $$$x$$$ and clear the multiset. This is the same as creating the number $$$x$$$, but we apply the operation to all other numbers, leaving only the single number $$$x$$$ (or a larger number) in the set.
It can be proven that by using only operations of this kind, we can always obtain the optimal answer.
Now we can forget about the original condition and solve the problem for the array.
Let's learn how to check if it is possible to create the number $$$k$$$ and clear the multiset:
First, let's try to create the number $$$k$$$. If it is possible, the answer is yes. Otherwise, we look at the rightmost number that is missing (or in other words, the rightmost $$$0$$$). We try to create it, and now we need to find the rightmost element $$$\leq 1$$$ to the left of it, and so on. To implement this, we need to maintain a number $$$p$$$ such that we subtract $$$p$$$ from all elements in the prefix (initially $$$p=1$$$), iterate through the array from right to left, and if $$$cnt[i]<p$$$, assign $$$p \mathrel{{+}{=}} (p-cnt[i])$$$. When we reach zero, $$$p$$$ may be greater than $$$cnt[0]$$$, in which case we need to use the operation to turn any number into $$$0$$$. To do this, simply check that the remaining number of elements in the array is greater than or equal to $$$p$$$.
This currently works in $$$O(k)$$$ time, which is not very efficient.
Optimization techniques:
First, let's maintain the sum of elements $$$sm$$$ and as soon as it becomes negative, terminate the process. To achieve this, when subtracting $$$p-cnt[i]$$$ from $$$p$$$, let's subtract $$$(p-cnt[i])\cdot(i-1)$$$ from $$$sm$$$. Now let's use a bottom-up segment tree to find the nearest number smaller than $$$p$$$ to the left in $$$O(\log(i))$$$ time.
Now let's notice that when we update through $$$cnt[i]$$$, we subtract at least $$$i-1$$$ from $$$sm$$$, so there can't be more than $$$O(\sqrt{n})$$$ different values of $$$i$$$ through which we will update.
Now we can answer for a specific $$$k$$$ in $$$O(\sqrt{n} \cdot \log(n))$$$ time, but in reality, the complexity is $$$O(\sqrt{n})$$$ (due to the peculiarities of the bottom-up segment tree), and the authors have a proof for this, but they are afraid that you will find an error in it, so they decided not to provide it(we will add proof later).
Now let's see how to solve the full problem:
Initially, the answer is $$$0$$$, and we notice that it does not decrease. So after each addition, we will check if it is possible to increase the answer and increase it as long as possible. The answer cannot exceed $$$n$$$, so we will perform no more than $$$2 \cdot n$$$ checks.
Overall, the solution works in $$$O(n \cdot \sqrt{n})$$$ time. That's how it is.
Proof of asymptotic complexity for the query
Let's consider that in our query, the segment tree processed $$$k$$$ nodes $$$[x_1, x_2, \dots, x_k]$$$ from the bottom.
Then, the number of operations is the sum of $$$dist(x_i, x_{i+1})$$$ for $$$i$$$ from 1 to $$$k-1$$$, and $$$dist(0, x_1)$$$, where $$$dist$$$ represents the length of the path between nodes in the segment tree. Now, let's notice that for the query $$$dist(a, b)$$$, we enter the segment tree node responsible for a block of length $$$2^t$$$ only if $$$a$$$ and $$$b$$$ are in different blocks of length $$$2^{t-1}$$$, which is logical. Also, let's notice that this doesn't happen very often, specifically, the numbers $$$[x_1, x_2, \dots, x_k]$$$ can be part of a maximum of $$$\sqrt{\frac{n}{2^t}}$$$ blocks of length $$$2^t$$$ (asymptotically). Therefore, the sum of all queries is asymptotically equal to the sum of $$$\sqrt{\frac{n}{2^t}}$$$ for $$$t$$$ from 0 to 20, which is a geometric progression with a ratio of $$$\frac{1}{\sqrt{2}}$$$. Hence, the sum is asymptotically equal to $$$\sqrt{n}$$$. Proof completed.
--------------------------------------------------
Problem ID: 1870F
Editorial Content:
1870F - Lazy Numbers
Tutorial
Let's store all the number entries in a trie. Consider two traversals of this trie — depth-first search (DFS) and breadth-first search (BFS). In both traversals, we go to the children of a node in ascending order of the number on the edge (in the trie). Let the index of the node representing the number $$$x$$$ in the DFS traversal be $$$dfs(x)$$$, and in the BFS traversal be $$$bfs(x)$$$. Then notice that $$$x = bfs(x)$$$, as in BFS on the trie, we simply look at all the number entries with a certain length in order (lengths are concidered in increasing order). On the other hand, $$$dfs(x)$$$ is the index of the number entry $$$x$$$ in the sorted array. Therefore, we want to calculate the number of $$$x$$$ for which $$$dfs(x) = bfs(x)$$$.
Let's fix a layer in the trie, meaning we only consider numbers with a fixed, equal length of representation. Then let's look at $$$dfs(x) - bfs(x)$$$ for the numbers in this layer. Notice that for two numbers $$$y$$$ and $$$y + 1$$$ in this layer, it holds that $$$bfs(y + 1) - bfs(y) = 1$$$, and $$$dfs(y + 1) - dfs(y) \geq 1$$$. This means that for a fixed layer, the function $$$dfs(x) - bfs(x)$$$ is non-decreasing. Therefore, we can find the $$$0$$$ of this function using binary search on each layer.
Now let's learn how to calculate $$$dfs(x) - bfs(x)$$$. $$$bfs(x) = x$$$, which we can calculate. To find $$$dfs(x)$$$, we can traverse up from the trie node corresponding to $$$x$$$, and at each step, add the sizes of the subtrees that we have traversed in DFS before the subtree with the node $$$x$$$.
The trie has a depth of $$$O(\log(n))$$$, binary search takes the same time, so the overall asymptotic complexity of the solution is $$$O(\log^3(n))$$$.
I apologize for the issues some participants faced with the time limit, if they implemented the author's idea suboptimally.
--------------------------------------------------
Problem ID: 1870E
Editorial Content:
1870E - Another MEX Problem
Tutorial
Let's solve the problem using dynamic programming, let's store $$$dp[i][j]$$$ such that $$$dp[i][j]=1$$$ if it is possible to obtain an $$$XOR$$$ of $$$MEX$$$ values from the prefix up to $$$i$$$ (excluding $$$i$$$) equal to $$$j$$$, and $$$0$$$ otherwise. Notice that the answer cannot be greater than $$$n$$$. Therefore, the size of this two-dimensional array is $$$O(n^2)$$$.
Let's learn how to solve this in $$$O(n^3)$$$:
We iterate over $$$l$$$ from $$$1$$$ to $$$n$$$, and inside that, we iterate over $$$r$$$ from $$$l$$$ to $$$n$$$, maintaining the value $$$x=MEX([a_l, a_{l+1}, \dots, a_r])$$$. Then, for all $$$j$$$ from $$$0$$$ to $$$n$$$, we update $$$dp[r+1][j \oplus x]=1$$$ if $$$dp[l][j]=1$$$. This way, we update based on the case when the resulting set includes the set $$$[a_l, a_{l+1}, \dots, a_r]$$$.
We also need to update if $$$dp[l][x]=1$$$, we assign $$$dp[l+1][x]=1$$$. This accounts for the case when we do not include $$$a_l$$$ in the answer.
Let's define $$$MEX(l, r) = MEX([a_l, a_{l+1}, \dots, a_r])$$$, this will make the following text clearer.
Let's consider the segment $$$l, r$$$. Notice that if there exist $$$l_2$$$ and $$$r_2$$$ ($$$l \leq l_2 \leq r_2 \leq r$$$) such that $$$l_2 \ne l$$$ or $$$r_2 \ne r$$$ and $$$MEX(l, r)=MEX(l_2, r_2)$$$, then we can take the segment $$$l_2, r_2$$$ instead of the segment $$$l, r$$$ in the set of $$$MEX$$$ values, and the answer will remain the same. If, however, there is no such segment $$$l_2, r_2$$$ for the segment $$$l, r$$$, then we call this segment $$$l, r$$$ irreplaceable.
Now let's prove that there are no more than $$$n \cdot 2$$$ irreplaceable segments. For each irreplaceable segment, let's look at the larger element of the pair $$$a_l, a_r$$$, let's assume $$$a_l$$$ is larger (the other case is symmetric). Now, let's prove that there is at most one segment where $$$a_l$$$ is the left element and $$$a_l \geq a_r$$$, by contradiction:
Suppose there are at least 2 such segments, let's call their right boundaries $$$r_1, r_2$$$ ($$$r_1 < r_2$$$). Notice that $$$MEX(l, r_1) > a_l$$$, otherwise the segment $$$l, r_1$$$ would not be irreplaceable (we could remove $$$a_l$$$). Since $$$a_l \geq a_{r_2}$$$, then $$$MEX(l, r_1) > a_{r_2}$$$. It is obvious that $$$a_{r_2}$$$ appears among the elements $$$[a_l, \dots, a_{r_1}]$$$, and therefore $$$MEX(l, r_2-1) = MEX(l, r_2)$$$, which means that the segment $$$l, r_2$$$ is not irreplaceable, contradiction.
For each $$$a_i$$$, there is at most one irreplaceable segment where it is the smaller of the two extremes, and at most one where it is the larger. Therefore, the total number of irreplaceable segments is no more than $$$2 \cdot n$$$.
Let's update the DP only through the irreplaceable segments, then the solution works in $$$O(n^2+n \cdot C)$$$ time, where $$$C$$$ is the number of irreplaceable segments. However, we have already proven that $$$C\leq 2n$$$, so the overall time complexity is $$$O(n^2)$$$.
--------------------------------------------------
Problem ID: 1870D
Editorial Content:
1870D - Prefix Purchase
Tutorial
Note that if there is a prefix for which there is a longer prefix that costs less, then it is useless to buy the shorter prefix. All its purchases can be replaced with purchases of the longer prefix, and the answer will only improve. Therefore, we can replace each $$$c_i$$$ with the minimum $$$c_j$$$ among $$$i \leq j \leq n$$$ (the minimum price of a prefix of length at least $$$i$$$). After this, we will have $$$c_i \leq c_{i+1}$$$.
Now let's solve the problem greedily. We want to maximize the first element of the resulting array. It will be equal to $$$k / c_1$$$, since we cannot buy more prefixes of length $$$1$$$ ($$$c_1$$$ is the smallest price). After buying $$$k / c_1$$$ prefixes of length $$$1$$$, we will have some coins left. Now we can replace some purchases of $$$c_1$$$ with purchases of longer prefixes to improve the answer.
How much will it cost to replace $$$c_1$$$ with $$$c_i$$$? It will cost $$$c_i - c_1$$$ coins. Moreover, note that to replace $$$c_1$$$ with $$$c_i$$$, we can sequentially replace $$$c_1$$$ with $$$c_2$$$, $$$c_2$$$ with $$$c_3$$$, $$$\ldots$$$, $$$c_{i-1}$$$ with $$$c_i$$$ (since $$$c_1 \leq c_2 \leq \ldots \leq c_i$$$). This means that we can make only replacements of purchases of $$$c_{i-1}$$$ with purchases of $$$c_i$$$.
Let's say we have maximized the first $$$i-1$$$ elements of the answer, and we have $$$x$$$ coins left. Now we want to replace some purchases of $$$c_{i-1}$$$ with $$$c_i$$$. How many replacements can we make? We can afford to make no more than $$$\frac{x}{c_i - c_{i-1}}$$$ replacements (if $$$c_{i-1} = c_i$$$, then we can replace all $$$c_{i-1}$$$), and we cannot replace more purchases than we have made, so no more than $$$a_{i-1}$$$ replacements (this is the number of purchases of $$$c_{i-1}$$$). Therefore, $$$a_i = \min(a_{i-1}, \frac{x}{c_i - c_{i-1}})$$$, as we want to maximize $$$a_i$$$. Finally, subtract the cost of replacements from the number of coins and move on to $$$c_{i+1}$$$.
--------------------------------------------------
Problem ID: 1870C
Editorial Content:
1870C - Colorful Table
Tutorial
Let's fix the color $$$x$$$ for which we will calculate the answer. If there is no $$$a_i = x$$$, then there will be no cells of color $$$x$$$, and the answer is $$$0$$$. Otherwise, there is at least one cell of color $$$x$$$.
To find the minimum rectangle containing all cells of this color, we need to find the topmost, bottommost, leftmost, and rightmost cells of this color in the array $$$b$$$. Let's find the prefix in $$$a$$$ of the maximum length, where all numbers are strictly less than $$$x$$$. Let the length of this prefix be $$$L$$$. Then in the first $$$L$$$ rows and columns of the array $$$b$$$, there will be no cells of color $$$x$$$, because for all these cells, the formula $$$b_{i, j} = min(a_i, a_j)$$$ will have a number from the prefix, and all numbers on it are less than $$$x$$$. In the $$$L+1$$$-th row and $$$L+1$$$-th column, there will be cells of color $$$x$$$, because $$$a_{L+1} \geq x$$$. Thus, we have found the topmost and leftmost cells of color $$$x$$$. To find the bottom and right cells, we need to find the longest suffix where all numbers are less than $$$x$$$.
Now we need to learn how to quickly find prefixes and suffixes for all colors. Notice that the prefix for color $$$x$$$ is not shorter than the prefix for color $$$x + 1$$$, so all prefixes can be calculated in just one pass through the array, similarly for suffixes.
--------------------------------------------------
Problem ID: 1870B
Editorial Content:
1870B - Friendly Arrays
Tutorial
Note that after performing the operation on $$$b_j$$$, which has some bit set to 1, this bit will become 1 for all numbers in $$$a$$$ (and will remain so, as a bit cannot change from 1 to 0 in the result of an OR operation). If $$$n$$$ is even, then in the final XOR, this bit will become 0, as it will be equal to the XOR of an even number of ones. If $$$n$$$ is odd, then this bit will be 1 in the final XOR.
Therefore, if $$$n$$$ is even, by performing the operation on $$$b_j$$$, we set all the bits that are 1 in $$$b_j$$$ to 0 in the final XOR. If $$$n$$$ is odd, we do the opposite and set these bits to 1. So, if $$$n$$$ is even, the XOR does not increase when applying the operation, which means that to obtain the minimum possible XOR, we need to apply the operation to all the numbers in $$$b$$$, and the maximum XOR will be the original XOR. For odd $$$n$$$, it is the opposite: the minimum is the original XOR, and the maximum is obtained after applying the operation to all elements in $$$b$$$.
To apply the operation to all elements in $$$b$$$, it is sufficient to calculate their bitwise OR and apply the operation to the array $$$a$$$ with it.
--------------------------------------------------
Problem ID: 1870A
Editorial Content:
1870A - MEXanized Array
Tutorial
Note that if $$$min(n, x+1) < k$$$, then the answer is $$$-1$$$.
Otherwise, there are two cases:
If $$$k=x$$$, then the suitable array looks like $$$[0, 1, 2, \dots, k-1, \dots, k-1]$$$.
If $$$k \ne x$$$, then the suitable array looks like $$$[0, 1, 2, \dots, k-1, x, \dots, x]$$$.
In both cases, we can construct the array and calculate its sum in linear time. The overall complexity is $$$O(n \cdot t)$$$.
--------------------------------------------------
Problem ID: 1869B
Editorial Content:
1869B - 2D Traveling
Hint
What will happen if there are no major cities?
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;

const int _N = 1e5 + 5;

int T;

void solve() {
	int n, k, s, t; cin >> n >> k >> s >> t;
	vector<int> x(n + 1), y(n + 1);
	for (int i = 1; i <= n; i++) cin >> x[i] >> y[i];
	ll ans = llabs(x[s] - x[t]) + llabs(y[s] - y[t]);
	ll mins = LLONG_MAX / 2, mint = LLONG_MAX / 2;
	for (int i = 1; i <= k; i++) {
		mins = min(mins, llabs(x[s] - x[i]) + llabs(y[s] - y[i]));
		mint = min(mint, llabs(x[t] - x[i]) + llabs(y[t] - y[i]));
	}
	ans = min(ans, mins + mint);
	cout << ans << '\n';
	return;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		solve();
	}
}
Rate the problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1869A
Editorial Content:
1869A - Make It Zero
Hint 1
Indeed at most $$$\bf 4$$$ operations will be used.
Hint 2
If $$$r-l+1$$$ is even, and you do the operation on $$$[l,r]$$$ twice, then the subarray $$$a[l;r]$$$ will all become $$$0$$$.
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;

const int _N = 1e5 + 5;

int T;

void solve() {
	int n; cin >> n;
	vector<int> a(n);
	for (int i = 0; i < n; i++) cin >> a[i];
	if (n & 1) {
		cout << "4" << '\n';
		cout << "1 " << n - 1 << '\n';
		cout << "1 " << n - 1 << '\n';
		cout << n - 1 << ' ' << n << '\n';
		cout << n - 1 << ' ' << n << '\n';
	} else {
		cout << "2" << '\n';
		cout << "1 " << n << '\n';
		cout << "1 " << n << '\n';
	}
	return;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		solve();
	}
}
Rate the problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1868F
Editorial Content:
1868F - LIS?
Hint 1
Greedy.
Hint 2
This problem is somehow related to geometry.
Hint 3
What structure will the intervals you choose each time form?
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;
using point = pair<ll, ll>;

const int _N = 5e5 + 5;

int n;
ll a[_N], pre[_N], suf[_N], ans;
struct interval{
	int l, r; 
	ll d, dneed;
	int type, pos; // type0 - l, type1 - r
};
struct cmp{
	bool operator () (const interval &a, const interval &b) {
		return a.dneed - a.d > b.dneed - b.d;
	}
};

ll ceildiv(ll a, ll b) {
	// return a/b;
	if (a * b > 0) return a / b;
	else return a / b - !!(a % b);
}

namespace sg_left{ // [l, r] -> hull of point l-1 to r-1
	vector<int> hull[_N << 2];
	point pt[_N];
	void get_hull(int p, int l, int r) {
		int head = 0, tail = -1;
		for (int i = l; i <= r; i++) {
			while (head < tail && (pt[hull[p][tail]].second - pt[hull[p][tail - 1]].second) * (pt[i].first - pt[hull[p][tail]].first) <= (pt[i].second - pt[hull[p][tail]].second) * (pt[hull[p][tail]].first - pt[hull[p][tail - 1]].first)) {
				tail--;
				hull[p].pop_back();
			}
			tail++;
			hull[p].emplace_back(i);
		}
	}
	void build(int p, int l, int r) {
		get_hull(p, l - 1, r - 1);
		if (l == r) return;
		int mid = (l + r) >> 1;
		build(p * 2, l, mid);
		build(p * 2 + 1, mid + 1, r);
	}
	pair<int, int> query(int p, int l, int r, int L, int R, point o) {
		if (l >= L && r <= R) { // do ternary search
			int tl = 1, tr = hull[p].size();
			while (tl < tr) {
				int m1 = (tl + tr) / 2, m2 = (tl + tr) / 2 + 1;
				auto p1 = pt[hull[p][m1 - 1]], p2 = pt[hull[p][m2 - 1]];
				if ((o.second - p1.second) * (o.first - p2.first) >= (o.second - p2.second) * (o.first - p1.first)) {
					tl = m1 + 1;
				} else tr = m2 - 1;
			}
			return {ceildiv((o.second - pt[hull[p][tl - 1]].second), (o.first - pt[hull[p][tl - 1]].first)), hull[p][tl - 1] + 1};
		}
		int mid = (l + r) >> 1;
		pair<int, int> res = {-1, -1};
		if (L <= mid) {
			res = query(p * 2, l, mid, L, R, o);
		} 
		if (R > mid) {
			auto res2 = query(p * 2 + 1, mid + 1, r, L, R, o);
			if (res == make_pair(-1, -1)) return res2;
			else {
				if (res2.first <= res.first) {
					return res2;
				} else return res;
			}
		}
		return res;
	}
	void test() {
		auto res = query(1, 1, n, 1, n, pt[n]);
		cout << res.first << ' ' << res.second << '\n';
	}
};
namespace sg_right{ // [l, r] -> hull of point l+1 to r+1
	vector<int> hull[_N << 2];
	point pt[_N];
	void get_hull(int p, int l, int r) {
		int head = 0, tail = -1;
		for (int i = l; i <= r; i++) {
			while (head < tail && (pt[hull[p][tail]].second - pt[hull[p][tail - 1]].second) * (pt[i].first - pt[hull[p][tail]].first) < (pt[i].second - pt[hull[p][tail]].second) * (pt[hull[p][tail]].first - pt[hull[p][tail - 1]].first)) {
				tail--;
				hull[p].pop_back();
			}
			tail++;
			hull[p].emplace_back(i);
		}
	}
	void build(int p, int l, int r) {
		get_hull(p, l + 1, r + 1);
		if (l == r) return;
		int mid = (l + r) >> 1;
		build(p * 2, l, mid);
		build(p * 2 + 1, mid + 1, r);
	}
	pair<int, int> query(int p, int l, int r, int L, int R, point o) {
		if (l >= L && r <= R) { // do ternary search
			int tl = 1, tr = hull[p].size();
			while (tl < tr) {
				int m1 = (tl + tr) / 2, m2 = (tl + tr) / 2 + 1;
				auto p1 = pt[hull[p][m1 - 1]], p2 = pt[hull[p][m2 - 1]];
				if ((o.second - p1.second) * (o.first - p2.first) <= (o.second - p2.second) * (o.first - p1.first)) {
					tl = m1 + 1;
				} else tr = m2 - 1;
			}
			return {ceildiv(-(o.second - pt[hull[p][tl - 1]].second), (o.first - pt[hull[p][tl - 1]].first)), hull[p][tl - 1] - 1};
		}
		int mid = (l + r) >> 1;
		pair<int, int> res = {-1, -1};
		if (L <= mid) {
			res = query(p * 2, l, mid, L, R, o);
		} 
		if (R > mid) {
			auto res2 = query(p * 2 + 1, mid + 1, r, L, R, o);
			if (res == make_pair(-1, -1)) return res2;
			else {
				if (res.first <= res2.first) {
					return res;
				} else return res2;
			}
		}
		return res;
	}
	void test() {
		auto res = query(1, 1, n, 1, n, pt[1]);
		cout << res.first << ' ' << res.second << '\n';
	}
};


int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	if (n == 1) {
		cout << max(a[1] + 1, 0ll) << '\n';
		return 0;
	}
	sg_left::pt[0] = {0, 0}; sg_right::pt[n + 1] = {n + 1, 0};
	for (int i = 1; i <= n; i++) {
		pre[i] = pre[i - 1] + a[i];
		sg_left::pt[i] = {i, pre[i]};
	}
	for (int i = n; i >= 1; i--) {
		suf[i] = suf[i + 1] + a[i];
		sg_right::pt[i] = {i, suf[i]};
	}
	sg_left::build(1, 1, n);
	sg_right::build(1, 1, n);
	ll ans = 0;
	priority_queue<interval, vector<interval>, cmp> q;
	pair<int, int> resL = sg_left::query(1, 1, n, 1, n, sg_left::pt[n]);
	pair<int, int> resR = sg_right::query(1, 1, n, 1, n, sg_right::pt[1]);
	if (resL.second == 1) q.push({1, n, 0, resR.first + 1, 1, resR.second});
	else if (resR.second == n) q.push({1, n, 0, resL.first + 1, 0, resL.second});
	else if (resL.first <= resR.first) q.push({1, n, 0, resL.first + 1, 0, resL.second});
	else q.push({1, n, 0, resR.first + 1, 1, resR.second});
	while (!q.empty()) {
		auto x = q.top(); q.pop();
		if (x.d < x.dneed) {
			ans += x.dneed - x.d;
			x.d = x.dneed;
		}
		//split
		if (x.type == 1) x.pos++;
		int l = x.l, r = x.r;
		resL = sg_left::query(1, 1, n, l, x.pos - 1, sg_left::pt[x.pos - 1]);
		resR = sg_right::query(1, 1, n, l, x.pos - 1, sg_right::pt[l]);
		if (l == x.pos - 1) {
			ans += max(0ll, a[l] - x.d + 1);
		} else {
			if (resL.second == l) q.push({l, x.pos - 1, x.d, resR.first + 1, 1, resR.second});
			else if (resR.second == r) q.push({l, x.pos - 1, x.d, resL.first + 1, 0, resL.second});
			else if (resL.first <= resR.first) q.push({l, x.pos - 1, x.d, resL.first + 1, 0, resL.second});
			else q.push({l, x.pos - 1, x.d, resR.first + 1, 1, resR.second});
		}
		resL = sg_left::query(1, 1, n, x.pos, r, sg_left::pt[r]);
		resR = sg_right::query(1, 1, n, x.pos, r, sg_right::pt[x.pos]);
		if (x.pos == r) {
			ans += max(0ll, a[r] - x.d + 1);
		} else {
			if (resL.second == l) q.push({x.pos, r, x.d, resR.first + 1, 1, resR.second});
			else if (resR.second == r)q.push({x.pos, r, x.d, resL.first + 1, 0, resL.second});
			else if (resL.first < resR.first) q.push({x.pos, r, x.d, resL.first + 1, 0, resL.second});
			else q.push({x.pos, r, x.d, resR.first + 1, 1, resR.second});
		}
	}
	cout << ans << '\n';
}
Bonus
Can you solve this problem in $$$\mathcal{O}(n\log n+n\log V)$$$ time complexity and $$$\mathcal{O}(n)$$$ space complexity?
Hint for Bonus
The solution has nothing to do with data structures.
Implementation
/*  
  hmz is cute!
--------------------------------------------
  You've got to have faith
  Don't let them cut you down cut you down once more
*/
//#pragma GCC optimize("Ofast,no-stack-protector")
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
#include<bits/stdc++.h>
using namespace std;
#define TY long long
#define IL inline
#define umap unordered_map
#define ull unsigned long long
#define pq priority_queue
#define mp make_pair
#define pb push_back
#define mod (TY)(1e9+7)
#define MAXN 500005
#define MAXM 200005
#define MAXK 27
#define INF (TY)(1e9)
#define block 300
#define For(i,a,b) for(TY i=(a);i<=(b);++i)
#define FOR(i,a,b) for(TY i=(a);i<(b);++i)
#define Rof(i,a,b) for(TY i=(a);i>=(b);--i)
#define ROF(i,a,b) for(TY i=(a);i>(b);--i)
IL TY qr(){
	TY x=0,f=1;char op=getchar();
	for(;op<'0'||op>'9';op=getchar())if(op=='-')f=-1;
	for(;op>='0'&&op<='9';op=getchar())x=x*10+(op^48);
	return x*f;
}IL bool ischar(char op){
	if(op>='a'&&op<='z')return true;
	if(op>='A'&&op<='Z')return true;
	return false;
}IL char getc(){
	char op=getchar();
	while(!ischar(op))op=getchar();
	return op;
}IL string qs(){
	string op="";char u=getchar();
	while(!ischar(u))u=getchar();
	while(ischar(u))op+=u,u=getchar();
	return op;
}IL void qw(long long x){
	if(!x){putchar('0');return;}
	if(x<0)putchar('-'),x=-x;
	if(x>=10)qw(x/10);putchar(x%10+'0');
}IL void qw(long long x,char op){qw(x),putchar(op);}
IL void ws(string s){FOR(i,0,s.size())putchar(s[i]);}
IL TY Ceil(TY a,TY b){return a/b+(a%b!=0);}
IL TY Mod(TY a){return (a>=mod?a-mod:a);}
IL TY Abs(TY a,TY b){return a>b?a-b:b-a;}
IL TY Pow(TY a,TY b){
	TY ans=1,base=a;
	while(b){
		if(b&1)ans=ans*base%mod;
		base=base*base%mod;b>>=1;
	}return ans;
}TY n,a[MAXN],b[MAXN],sum[MAXN],lenx[MAXN],leny[MAXN],ans;
vector<signed> e1[MAXN],e2[MAXN],HH;
TY Sum[MAXN],SSum[MAXN];
bool vis[MAXN];
signed L[MAXN],R[MAXN],LL[MAXN],RR[MAXN],ok[MAXN],nxtx[MAXN],nxty[MAXN];
struct node{TY l,r,tag,op;};queue<node> q;
IL void init(TY l,TY r,TY tag){
    For(i,l,r)e1[i].clear(),e2[i].clear();
    vector<pair<TY,TY> > pre,nxt;
    For(i,l,r){
        while(!pre.empty()){
            TY ch=(pre.back().second*-1+tag)*(i-pre.back().first)+sum[i]-sum[pre.back().first];
            if(ch<0){
                nxtx[pre.back().first]=i;
                pre.pop_back();continue;
            }else{
                lenx[i]=pre.back().second+Ceil(ch+1,i-pre.back().first);
                pre.push_back({i,pre.back().second+Ceil(ch+1,i-pre.back().first)});
                break;
            }
        }if(pre.empty()){
            lenx[i]=Ceil(sum[i]-sum[l-1]+tag*(i-l+1)+1,i-l+1);
            pre.push_back({i,Ceil(sum[i]-sum[l-1]+tag*(i-l+1)+1,i-l+1)});
        }
    }while(!pre.empty())nxtx[pre.back().first]=r+1,pre.pop_back();
    Rof(i,r,l){
        while(!nxt.empty()){
            TY ch=(nxt.back().second*-1+tag)*(nxt.back().first-i)-sum[i-1]+sum[nxt.back().first-1];
            if(ch<0){
                nxty[nxt.back().first]=i;
                nxt.pop_back();continue;
            }else{
                leny[i]=nxt.back().second+Ceil(ch+1,nxt.back().first-i);
                nxt.push_back({i,nxt.back().second+Ceil(ch+1,nxt.back().first-i)});
                break;
            }
        }if(nxt.empty()){
            leny[i]=Ceil(sum[r]-sum[i-1]+tag*(r-i+1)+1,r-i+1);
            nxt.push_back({i,Ceil(sum[r]-sum[i-1]+tag*(r-i+1)+1,r-i+1)});
        }
    }while(!nxt.empty())nxty[nxt.back().first]=l-1,nxt.pop_back();
    For(i,l,r)if(nxtx[i]!=r+1)e1[nxtx[i]].pb(i);
    Rof(i,r,l)if(nxty[i]!=l-1)e2[nxty[i]].pb(i);
}int main(){
    //freopen("data.in","r",stdin);
    /* init */
    n=qr();For(i,1,n)a[i]=qr(),sum[i]=sum[i-1]+a[i];
    q.push({1,n,0,0});
    while(!q.empty()){
        TY l=q.front().l,r=q.front().r,tag=q.front().tag,op=q.front().op;
        if(l>r||l<=0||r>n)continue;
        q.pop();
        if(op==0){
            vector<pair<TY,TY> > tmp;
            TY c=0;TY lst=-1;
            For(i,l,r)b[i]=a[i]+tag;
            For(i,l,r){
                if((b[i]>=0)!=lst){
                    lst=(b[i]>=0);
                    ++c;L[c]=R[c]=i;
                    Sum[c]=b[i];
                }else R[c]=i,Sum[c]+=b[i];
            }For(i,1,c)LL[i]=i,RR[i]=i,SSum[i]=Sum[i],ok[i]=0,vis[i]=1;
            Sum[c+1]=0;RR[c+1]=INF;
            For(i,1,c)if(Sum[i]<0){
                ok[i]=(Sum[i-1]+Sum[i]>=0)+(Sum[i+1]+Sum[i]>=0);
                if(ok[i]==2)HH.pb(i),ok[i]=INF;
            }else{
                ok[i]=(Sum[i-1]+Sum[i]<0)+(Sum[i+1]+Sum[i]<0);
                if(ok[i]==2)HH.pb(i),ok[i]=INF;
            }while(!HH.empty()){
                TY now=HH.back(),nowL=LL[now],nowR=RR[now];
                TY k=SSum[nowL]+SSum[nowL-1]+SSum[nowR+1],pre=LL[LL[nowL-1]-1],nxt=RR[nowR+1]+1;
                HH.pop_back();
                if(SSum[nowL]>=0){
                    if(pre>=1&&nxt<=c){
                        ok[LL[nowL-1]]=(k+SSum[pre]>=0)+(k+SSum[nxt]>=0);
                        if(ok[LL[nowL-1]]==2)HH.pb(LL[nowL-1]),ok[LL[nowL-1]]=INF;
                    }else ok[LL[nowL-1]]=INF;
                    if(pre>=1){
                        ok[pre]+=-(SSum[nowL-1]+SSum[pre]<0)+(SSum[pre]+k<0);
                        if(ok[pre]==2&&SSum[nowL-1]+SSum[pre]>=0)HH.pb(pre),ok[pre]=INF;
                    }if(nxt<=c){
                        ok[nxt]+=-(SSum[nowR+1]+SSum[nxt]<0)+(SSum[nxt]+k<0);
                        if(ok[nxt]==2&&SSum[nowR+1]+SSum[nxt]>=0)HH.pb(nxt),ok[nxt]=INF;
                    }
                }else{
                    if(pre>=1&&nxt<=c){
                        ok[LL[nowL-1]]=(k+SSum[pre]<0)+(k+SSum[nxt]<0);
                        if(ok[LL[nowL-1]]==2)HH.pb(LL[nowL-1]),ok[LL[nowL-1]]=INF;
                    }else ok[LL[nowL-1]]=INF;
                    if(pre>=1){
                        ok[pre]+=-(SSum[nowL-1]+SSum[pre]>=0)+(SSum[pre]+k>=0);
                        if(ok[pre]==2&&SSum[nowL-1]+SSum[pre]<0)HH.pb(pre),ok[pre]=INF;
                    }if(nxt<=c){
                        ok[nxt]+=-(SSum[nowR+1]+SSum[nxt]>=0)+(SSum[nxt]+k>=0);
                        if(ok[nxt]==2&&SSum[nowR+1]+SSum[nxt]<0)HH.pb(nxt),ok[nxt]=INF;
                    }
                }SSum[LL[nowL-1]]=SSum[RR[nowR+1]]=k;
                RR[LL[nowL-1]]=RR[nowR+1];
                LL[RR[nowR+1]]=LL[nowL-1];
            }Rof(i,c,1)if(Sum[i]>=0&&vis[i]){
                Rof(j,i,LL[i])vis[j]=0;
                tmp.pb({L[LL[i]],R[RR[i]]});
            }Rof(i,tmp.size()-1,0)q.push({tmp[i].first,tmp[i].second,tag,1});
        }else{
            if(l==r){
                ans+=a[l]+tag+1;
                continue;
            }queue<TY> fir,sec;
            init(l,r,tag);
            For(i,l,r)if(nxtx[i]==r+1)fir.push(i);
            Rof(i,r,l)if(nxty[i]==l-1)sec.push(i);
            TY lstl=l,lstr=r,lstcnt=0;
            while(lstl<lstr){
                while(!fir.empty()&&(lstl>fir.front()||fir.front()>lstr))fir.pop();
                while(!sec.empty()&&(lstl>sec.front()||sec.front()>lstr))sec.pop();
                TY id1=(fir.empty()?INF:fir.front()),id2=(sec.empty()?INF:sec.front());
                TY cnt1=(id1==INF?INF:lenx[id1]-lstcnt);
                TY cnt2=(id2==INF?INF:leny[id2]-lstcnt);
                if(cnt1<=cnt2){
                    fir.pop();
                    lstcnt=lenx[id1];
                    For(j,lstl,id1){FOR(i,0,e2[j].size())sec.push(e2[j][i]);e2[j].clear();}
                    q.push({lstl,id1,-lstcnt+tag,0});
                    lstl=id1+1;
                }else{
                    sec.pop();
                    lstcnt=leny[id2];
                    Rof(j,lstr,id2){FOR(i,0,e1[j].size())fir.push(e1[j][i]);e1[j].clear();}
                    q.push({id2,lstr,-lstcnt+tag,0});
                    lstr=id2-1;
                }
            }if(lstl==lstr)q.push({lstl,lstl,-lstcnt+tag,1});
            ans+=lstcnt;
        }
    }qw(ans);
    return 0;
}
Rate the problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1868E
Editorial Content:
1868E - Min-Sum-Max
Hint 1
Consider this problem on the prefix sum array.
Hint 2
Try to make some observations about the prefix sum array. Consider dp.
Hint 3
Go for a slow solution first, for example, $$$\mathcal{O}(n^6)$$$ or $$$\mathcal{O}(n^4)$$$.
Hint 4
The last step is to optimize your dp to $$$\mathcal{O}(n^3)$$$. :)
Fun Fact
$$$\mathcal{O}(n^6)$$$ can pass $$$n\le 100$$$ easily so we have to raise the limit for $$$\sum n$$$ to $$$1~000$$$.
Solution
Tutorial is loading...
Implementation (by Artyom123)
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <set>
#include <map>
#include <math.h>
#include <iomanip>
#include <bitset>
#include <random>
#include <ctime>
#include <string_view>
#include <queue>
#include <cassert>

using namespace std;

#define fi first
#define se second
#define all(x) (x).begin(), (x).end()
#define pb emplace_back
#define ll long long
#define mp make_pair
#define pii pair<int, int>
#define ld long double

const int INF = 1e9 + 1;
const ll INFLL = 1e18;

bool contains(ll x, ll l, ll r) {
    return (x >= l) && (x <= r);
}

void solve() {
    int n;
    cin >> n;
    vector<ll> a(n + 1);
    for (int i = 1; i <= n; i++) cin >> a[i];
    if (n == 1) {
        cout << 1 << "\n";
        return;
    }
    vector<ll> pr(n + 1);
    for (int i = 0; i < n; i++) pr[i + 1] = pr[i] + a[i + 1];
    vector<vector<vector<int>>> dp_leftmin(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, -INF)));
    vector<vector<vector<int>>> dp_leftmax(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, -INF)));
    vector<vector<vector<int>>> dp_rightmin(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, -INF)));
    vector<vector<vector<int>>> dp_rightmax(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, -INF)));
    vector<pair<ll, int>> b(n + 1);
    for (int i = 0; i <= n; i++) b[i] = mp(pr[i], i);
    sort(all(b));
    vector<vector<int>> next_left(n + 1, vector<int>(n + 1, -1));
    vector<vector<int>> next_right(n + 1, vector<int>(n + 1, -1));
    for (int i = 0; i <= n; i++) {
        int prev = -1;
        for (int j = 0; j <= n; j++) {
            next_left[i][j] = prev;
            if (pr[j] == pr[i]) prev = j;
        }
        prev = n + 1;
        for (int j = n; j >= 0; j--) {
            next_right[i][j] = prev;
            if (pr[j] == pr[i]) prev = j;
        }
    }
    for (int len = 0; len <= n; len++) {
        for (int i = 0; i <= n && i + len <= n; i++) {
            int j = i + len;
            for (int k = 0; k <= n; k++) {
                if (contains(pr[i], pr[i], pr[k]) && contains(pr[j], pr[i], pr[k])) dp_leftmin[i][j][k] = min(len, 1);
                if (contains(pr[i], pr[k], pr[i]) && contains(pr[j], pr[k], pr[i])) dp_leftmax[i][j][k] = min(len, 1);
                if (contains(pr[i], pr[j], pr[k]) && contains(pr[j], pr[j], pr[k])) dp_rightmin[i][j][k] = min(len, 1);
                if (contains(pr[i], pr[k], pr[j]) && contains(pr[j], pr[k], pr[j])) dp_rightmax[i][j][k] = min(len, 1);
            }
            if (len <= 1) continue;
            for (int x = i; x <= j; x++) {
                if (next_left[i][x] >= i) {
                    int y = next_left[i][x];
                    if (pr[x] >= pr[i]) dp_leftmin[i][j][x] = max(dp_leftmin[i][j][x], dp_leftmin[i][y][x] + dp_leftmax[x][j][i] + 1);
                    if (pr[x] <= pr[i]) dp_leftmax[i][j][x] = max(dp_leftmax[i][j][x], dp_leftmax[i][y][x] + dp_leftmin[x][j][i] + 1);
                }
                if (next_left[j][x] >= i) {
                    int y = next_left[j][x];
                    if (pr[x] >= pr[j]) dp_rightmin[i][j][x] = max(dp_rightmin[i][j][x], dp_rightmin[x][j][x] + dp_rightmin[i][y][x] + 1);
                    if (pr[x] <= pr[j]) dp_rightmax[i][j][x] = max(dp_rightmax[i][j][x], dp_rightmax[x][j][x] + dp_rightmax[i][y][x] + 1);
                }
                if (next_right[i][x] <= j) {
                    int y = next_right[i][x];
                    if (pr[x] >= pr[i]) dp_leftmin[i][j][x] = max(dp_leftmin[i][j][x], dp_leftmin[i][x][x] + dp_leftmin[y][j][x] + 1);
                    if (pr[x] <= pr[i]) dp_leftmax[i][j][x] = max(dp_leftmax[i][j][x], dp_leftmax[i][x][x] + dp_leftmax[y][j][x] + 1);
                }
                if (next_right[j][x] <= j) {
                    int y = next_right[j][x];
                    if (pr[x] >= pr[j]) dp_rightmin[i][j][x] = max(dp_rightmin[i][j][x], dp_rightmin[y][j][x] + dp_rightmax[i][x][j] + 1);
                    if (pr[x] <= pr[j]) dp_rightmax[i][j][x] = max(dp_rightmax[i][j][x], dp_rightmax[y][j][x] + dp_rightmin[i][x][j] + 1);
                }
            }
            int mx_left = -INF;
            int mx_right = -INF;
            for (int k = 0; k <= n; k++) {
                int p = k;
                while (p <= n && b[p].fi == b[k].fi) {
                    mx_left = max(mx_left, dp_leftmin[i][j][b[p].se]);
                    mx_right = max(mx_right, dp_rightmin[i][j][b[p].se]);
                    p++;
                }
                for (int l = k; l < p; l++) {
                    dp_leftmin[i][j][b[l].se] = mx_left;
                    dp_rightmin[i][j][b[l].se] = mx_right;
                }
                k = p - 1;
            }
            mx_left = -INF;
            mx_right = -INF;
            for (int k = n; k >= 0; k--) {
                int p = k;
                while (p >= 0 && b[p].fi == b[k].fi) {
                    mx_left = max(mx_left, dp_leftmax[i][j][b[p].se]);
                    mx_right = max(mx_right, dp_rightmax[i][j][b[p].se]);
                    p--;
                }
                for (int l = k; l > p; l--) {
                    dp_leftmax[i][j][b[l].se] = mx_left;
                    dp_rightmax[i][j][b[l].se] = mx_right;
                }
                k = p + 1;
            }
        }
    }
    int ans = -INF;
    ans = max(ans, dp_leftmin[0][n][n]);
    ans = max(ans, dp_leftmax[0][n][n]);
    for (int x = 0; x <= n; x++) {
        for (int y = x + 1; y <= n; y++) {
            ans = max(ans, dp_rightmin[0][x][y] + dp_leftmax[y][n][x] + 1);
            ans = max(ans, dp_rightmax[0][x][y] + dp_leftmin[y][n][x] + 1);
        }
    }
    cout << ans << "\n";
}

int main() {
    #ifdef LOCAL
        freopen("input", "r", stdin);
        freopen("output", "w", stdout);
    #else 
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    #endif
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
Rate the problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1868D
Editorial Content:
1868D - Flower-like Pseudotree
Hint 1
In fact, vertices with degree $$$1$$$ are useless, let's first ignore them. It's easy to see that when $$$\sum_{i=1}^nd_i=2n$$$, we can simply hang them under the vertices which haven't reached their degree limit.
Hint 2
In most cases, we can simply put two vertices on the cycle.
Hint 3
Sort $$$d_i$$$ from the largest to the smallest. Can we construct a flower-like psuedotree when $$$d_1=2$$$? Can we construct a flower-like psuedotree when $$$d_1\neq 2$$$ and $$$d_2=2$$$?
Hint 4
Can you find an easy way to construct the flower-like psuedotree when the number of $$$d_i>1$$$ is even?
Hint 5
Try to extend the solution when the number of $$$d_i>1$$$ is even to the odd case. Note some corner cases.
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
struct node{
	int d,pos;
}a[1000005];
bool cmp(node x,node y){
	return x.d>y.d;
}
void pe(int x,int y){
	cout<<a[x].pos<<" "<<a[y].pos<<"\n";
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int t; cin>>t;
	while(t--){
		int n,tot=0; cin>>n; for(int i=1;i<=n;i++) cin>>a[i].d,a[i].pos=i,tot+=a[i].d;
		if(tot!=2*n){
			cout<<"No\n"; continue;
		}
		if(n==1){
			cout<<"No\n"; continue;
		}
		sort(a+1,a+n+1,cmp);
		if(a[1].d==2){
			cout<<"Yes\n";
			for(int i=1;i<=n;i++) pe(i,i%n+1);
			continue;
		}
		if(a[2].d==2){
			cout<<"No\n"; continue;
		}
		int cntb=0;
		for(int i=3;i<=n;i++) cntb+=(a[i].d>1);
		int num[n+1]; for(int i=1;i<=n;i++) num[i]=a[i].d;
		if(!(cntb&1)){
			cout<<"Yes\n";
			pe(1,2),pe(1,2);
			num[1]-=2,num[2]-=2;
			for(int i=3;i<=cntb+2;i++) pe(i,i-2),num[i]--,num[i-2]--;
			int it=1;
			for(int i=cntb+3;i<=n;i++){
				while(!num[it]) it++;
				num[it]--,pe(i,it);
			}
			continue;
		}
		if(a[1].d==3){
			if(a[3].d==2){
				cout<<"No\n"; continue;
			}
			if(cntb==1){
				cout<<"Yes\n";
				pe(1,2),pe(2,3),pe(3,1);
				pe(1,4),pe(2,5),pe(3,6);
				continue;
			}
			if(a[5].d==2&&cntb==3){
				cout<<"No\n"; continue;
			}
			if(cntb==3){
				cout<<"Yes\n";
				pe(1,2),pe(2,3),pe(3,4),pe(4,5),pe(5,1);
				pe(1,6),pe(2,7),pe(3,8),pe(4,9),pe(5,10);
				continue;
			}
			cout<<"Yes\n";
			pe(1,2),pe(1,2),pe(1,3),pe(2,4),pe(3,5),pe(3,6),pe(4,7);
			num[1]-=3,num[2]-=3,num[3]-=3,num[4]-=2,num[5]--,num[6]--,num[7]--;
			for(int i=8;i<=cntb+2;i++) pe(i-2,i),num[i]--,num[i-2]--;
			int it=1;
			for(int i=cntb+3;i<=n;i++){
				while(!num[it]) it++;
				num[it]--,pe(i,it);
			}
			continue;
		}
		else{
			if(a[3].d==2&&cntb==1){
				cout<<"No\n"; continue;
			}
			if(cntb==1){
				cout<<"Yes\n";
				pe(1,2),pe(2,3),pe(3,1);
				num[1]-=2,num[2]-=2,num[3]-=2;
				int it=1;
				for(int i=4;i<=n;i++){
					while(!num[it]) it++;
					num[it]--,pe(i,it);
				}
				continue;
			}
			cout<<"Yes\n";
			pe(1,2),pe(1,2),pe(1,3),pe(1,4),pe(2,5);
			num[1]-=4,num[2]-=3,num[3]-=1,num[4]-=1,num[5]-=1;
			for(int i=6;i<=cntb+2;i++) pe(i,i-2),num[i]--,num[i-2]--;
			int it=1;
			for(int i=cntb+3;i<=n;i++){
				while(!num[it]) it++;
				num[it]--,pe(i,it);
			}
			continue;
		}
	}
	return 0;
}
Rate the problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1868C
Editorial Content:
1868C - Travel Plan
Hint 1
For any simple path length $$$t$$$, what's the sum of the maximum value of cities in all assignments? For the cities out of the path, their value doesn't matter.
Hint 2
Consider an easy dp to calculate the number of paths with different lengths.
Hint 3
How many different subtrees are there in this tree?
Hint 4
What's the maximum length of the paths?
Hint 5
Try to optimize the dp with the conclusion you get in Hint 3 and Hint 4.
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;
#pragma GCC optimize("Ofast")

ll tot[505],n,m,dp[125][125],dp2[125],g[125][125],g2[125],f[125],pw[100005][125];
const ll mod=998244353;

inline ll dep( ll root) {
	if (root>n)return 0;
	return dep(root*2)+1;
}

inline ll dep2( ll root) {
	if (root>n)return 0;
	return dep2(root*2+1)+1;
}

inline bool full( ll root) {
	return dep(root)==dep2(root);
}

void dfs( ll root) {
	if (root*2>n) {
		g2[0]=dp2[0]=1;
		return;
	}
	if (root*2==n) {
		g2[0]=2,g2[1]=1;
		dp2[0]=1,dp2[1]=1;
		return;
	}
	ll d=0;
	if (full(root*2)) {

		d=dep(root*2);
		dfs(root*2+1);
	} else {
		d=dep(root*2+1);
		dfs(root*2);
	}
	ll mx=2*d+4;
	for (ll i=0; i<=mx; i++) {
		g2[i]+=g[d][i];
		for (ll j=0; j<=min(d+2,i); j++) {
			g2[i+2]+=dp2[j]*dp[d][i-j]%mod;
		}
	}
	for (ll i=mx; i>0; i--)dp2[i]=(dp2[i-1]+dp[d][i-1])%mod;
	dp2[0]=1;
	for (ll i=0; i<=mx; i++)g2[i]+=dp2[i],g2[i]%=mod;
}

inline ll qkp(ll a,ll k) {
	ll ans=1;
	while (k) {
		if (k&1)ans*=a,ans%=mod;
		a*=a,a%=mod;
		k>>=1;
	}
	return ans;
}

int main() {
	ll t;
	scanf("%lld",&t);
	for (ll i=1; i<=60; i++) {
			dp[i][0]=1;
			for (ll j=1; j<=i-1; j++) {
				dp[i][j]=2*dp[i-1][j-1]%mod;
			}
			for (ll j=0; j<=2*i-2; j++) {
				g[i][j]+=g[i-1][j]*2;
				g[i][j]+=dp[i][j];
				g[i][j]%=mod;
				for (ll k=0; k<=j; k++) {
					g[i][j+2]+=dp[i-1][k]*dp[i-1][j-k]%mod;
					g[i][j+2]%=mod;
				}
			}
		}
	while (t--) {
		scanf("%lld%lld",&n,&m);
		
		// log n^3
		dfs(1);
		ll d=dep(1),ans=0;
		for (ll j=0; j<=m; j++) {
			pw[j][0]=1;
			for (ll i=1; i<=2*d; i++) {
				pw[j][i]=pw[j][i-1]*j%mod;
			}
		}

		for (ll i=0; i<=2*d-2; i++) {
			for (ll j=1; j<=m; j++) {
				f[i]+=(pw[j][i+2]+mod-pw[j-1][i+1]*j%mod)%mod;
				f[i]%=mod;
			}
			if (n>=i+1)
				ans+=f[i]*g2[i]%mod*qkp(m,n-i-1)%mod;
			ans%=mod;
		}
		printf("%lld\n",ans);
		for (ll i=1;i<=60;i++){
			for (ll j=0;j<=2*i-2;j++){
				f[j]=g2[j]=dp2[j]=0;
			}
		}
	}

	return 0;
}
Implementation
#include <bits/stdc++.h>
#define int long long
#define double long double
#define mid ((l+r)>>1)
using namespace std;
const int mod=998244353;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans=(ans*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}
	return ans;
}
int fac[1000005],inv[1000005];
void init(){
	fac[0]=1;
	for(int i=1;i<=1000000;i++) fac[i]=fac[i-1]*i%mod;
	inv[1000000]=qp(fac[1000000],mod-2);
	for(int i=999999;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
}
int C(int i,int j){
	if(i<0||j<0||i<j) return 0;
	return fac[i]*inv[i-j]%mod*inv[j]%mod;
}
int cnt=0;
int reg[100005][131],reg2[100005][131];
unordered_map<int,int> mp;
void dfs(int now){
	if(mp[now]) return ;
	mp[now]=++cnt;
	if(now==0) return ;
	reg[cnt][0]++,reg2[cnt][0]++;
	if(now==1) return ;
	int i=0;
	for(i=1;i<=62;i++) if((1LL<<i)-1>=now) break;
	i-=2;
	int lnum=(1LL<<i)-1,rnum=(1LL<<i)-1,lft=now-(1LL<<(i+1))+1;
	if(lft<=(1LL<<i)) lnum+=lft;
	else lnum+=(1LL<<i),rnum+=(lft-(1LL<<i));
	dfs(lnum),dfs(rnum);
	int ml=mp[lnum],mr=mp[rnum],mn=mp[now];
	for(int i=0;i<=130;i++){
		for(int j=0;j<=130;j++){
			if(i+j+2>=130) break;
			(reg2[mn][i+j+2]+=(reg[ml][i]*reg[mr][j]))%=mod; 
		}
	}
	for(int i=0;i<=129;i++) (reg[mn][i+1]+=reg[ml][i]+reg[mr][i])%=mod,(reg2[mn][i+1]+=reg[ml][i]+reg[mr][i])%=mod,(reg2[mn][i]+=reg2[ml][i]+reg2[mr][i])%=mod;
}
int pw[100005][150],tot[205];
signed main(){
	init();
	int t; cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;
		dfs(n);
		int nn=mp[n];
		int ans=0;
		tot[0]=(m-1)%mod;
		for(int i=2;i<=135;i++){
			tot[i-1]=(qp((m-1)%mod+1,i)+mod-1)%mod;
			for(int l=2;l<=i;l++) (tot[i-1]+=mod-C(i,l)*tot[i-l]%mod)%=mod;
		    (tot[i-1]*=qp(i,mod-2))%=mod;
		}
		for(int i=0;i<=min(130ll,n-1);i++){
			int tmp=(qp(m%mod,i+2)+mod-tot[i+1])%mod;
			(ans+=tmp*reg2[nn][i]%mod*qp(m%mod,n-(i+1)))%=mod;
		}
		cout<<ans<<"\n";
	}
	return 0;
}
Implementation
#include <bits/stdc++.h>
#define int long long
#define double long double
#define mid ((l+r)>>1)
using namespace std;
const int mod=998244353;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans=(ans*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}
	return ans;
}
int fac[1000005],inv[1000005];
void init(){
	fac[0]=1;
	for(int i=1;i<=1000000;i++) fac[i]=fac[i-1]*i%mod;
	inv[1000000]=qp(fac[1000000],mod-2);
	for(int i=999999;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
}
int C(int i,int j){
	if(i<0||j<0||i<j) return 0;
	return fac[i]*inv[i-j]%mod*inv[j]%mod;
}
int cnt=0;
int reg[100005][131],dep[100005],depc[100005],rett[131],invi[131];
unordered_map<int,int> mp;
void dfs(int now){
	if(mp[now]) return ;
	mp[now]=++cnt;
	if(now==0) return ;
	dep[cnt]=1,depc[cnt]=1,reg[cnt][0]++;
	if(now==1) return ;
	int i=0;
	for(i=1;i<=62;i++) if((1LL<<i)-1>=now) break;
	i-=2;
	int lnum=(1LL<<i)-1,rnum=(1LL<<i)-1,lft=now-(1LL<<(i+1))+1;
	if(lft<=(1LL<<i)) lnum+=lft;
	else lnum+=(1LL<<i),rnum+=(lft-(1LL<<i));
	dfs(lnum),dfs(rnum);
	int ml=mp[lnum],mr=mp[rnum],mn=mp[now];
	if(dep[ml]>dep[mr]){
		dep[mn]=dep[ml]+1; depc[mn]=depc[ml];
		for(int i=0;i<=129;i++) reg[mn][i]=reg[ml][i];
	}
	else{
		dep[mn]=dep[ml]+1; depc[mn]=(depc[ml]+depc[mr])%mod;
		for(int i=0;i<=129;i++) reg[mn][i]=(reg[ml][i]+reg[mr][i])%mod;
		(reg[mn][dep[mn]*2-2]+=depc[ml]*depc[mr])%=mod;
	}
}
int pw[100005][150],tot[205],pw2[135];
signed main(){
	pw2[0]=1;
	for(int i=1;i<=130;i++) pw2[i]=pw2[i-1]*2%mod,invi[i]=qp(i,mod-2);
	init();
	int t; cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;
		int lg=0,lft;
		for(int i=0;i<=130;i++) rett[i]=0;
		for(lg=61;lg>=0;lg--){
			if(n>=(1LL<<(lg+1))-1){
				lft=n-((1LL<<(lg+1))-1);
				lft%=mod;
				break;
			}
		}
		for(int i=0;i<=lg;i++){
			for(int j=0;j<=lg;j++){
				int tt=max(i,j);
				(rett[i+j]+=(pw2[lg-tt+1]-1)*pw2[max(0ll,i-1)+max(0ll,j-1)]%mod)%=mod;
			}
		}
		for(int i=1;i<=lg+1;i++){
			for(int j=0;j<i;j++){
				(rett[i+j]+=lft*pw2[max(0ll,j-1)]%mod)%=mod;
			}
		}
		dfs(n);
		int nn=mp[n];
		if(n!=(1ll<<(lg+1))-1) for(int i=0;i<=130;i++) (rett[i]+=reg[nn][i])%=mod;
		int ans=0;
		tot[0]=(m-1)%mod;
		for(int i=2;i<=130;i++){
			tot[i-1]=(qp((m-1)%mod+1,i)+mod-1)%mod;
			for(int l=2;l<=i;l++) (tot[i-1]+=mod-C(i,l)*tot[i-l]%mod)%=mod;
		    (tot[i-1]*=invi[i])%=mod;
		}
		for(int i=0;i<=min(130ll,n-1);i++){
			int tmp=(qp(m%mod,i+2)+mod-tot[i+1])%mod;
			(ans+=tmp*rett[i]%mod*qp(m%mod,n-(i+1)))%=mod;
		}
		cout<<ans<<"\n";
	}
	return 0;
}
Implementation
#include <bits/stdc++.h>
#define rep(i,n) for(int i=0,_##i##__end=(n);i<_##i##__end;++i)
#define rep1(i,n) for(int i=1,_##i##__end=(n);i<=_##i##__end;++i)
#define mp make_pair
#define fi first
#define se second
typedef long long ll;
using namespace std;
const ll mod1=998244353;
int t;
ll n;
int m;
ll qkpw(ll a,ll b)
{
	ll ret=1;
	while(b)
	{
		if(b&1) ret=ret*a%mod1;
		a=a*a%mod1;
		b>>=1;
	}
	return ret;
}
ll val_full[114];
ll val_link[114];
pair<ll,ll> realget(ll P,unsigned long long c)
{
	if((c&(c+1))==0)
	return mp(val_link[bit_width(c)-1],val_full[bit_width(c)-1]);
	if(c==2)
	return mp((P*P+P)%mod1,(P*P+P+P)%mod1);
	if(c&(bit_floor(c)>>1))
	{
		pair<ll,ll> A=realget(P,bit_floor(c)-1),B=realget(P,c-bit_floor(c));
		return mp((A.fi+B.fi+1)*P%mod1,(A.se+B.se+(1+A.fi)*(1+B.fi)%mod1*P)%mod1);
	}
	pair<ll,ll> A=realget(P,c-(bit_floor(c)>>1)),B=realget(P,(bit_floor(c)>>1)-1);
	return mp((A.fi+B.fi+1)*P%mod1,(A.se+B.se+(1+A.fi)*(1+B.fi)%mod1*P)%mod1);
}
ll get_value(ll P,ll c)
{
	val_full[0]=P;val_link[0]=P;
	rep1(i,64)
	{
		val_full[i]=(val_full[i-1]*2+(1+val_link[i-1])*(1+val_link[i-1])%mod1*P)%mod1;
		val_link[i]=((val_link[i-1]*2+1)*P)%mod1;
	}
	return realget(P,c).second;
}
void Q()
{
	cin>>n>>m;
	ll cur=((n%mod1)*(n%mod1+1)/2%mod1)*qkpw(m,n+1)%mod1;
	ll INV_M=qkpw(m,mod1-2);
	rep(i,m) cur=(cur-qkpw(m,n)*get_value(i*INV_M%mod1,n)%mod1+mod1)%mod1;
	cout<<cur<<endl;
}
int main()
{
	cin>>t;while(t--)Q();
}
Rate the problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1868B2
Editorial Content:
1868B2 - Candy Party (Hard Version)
Hint 4
For whom may not give or receive candies?
Hint 5
When $$$|a_i-s|$$$ is a power of $$$2$$$, how many ways can the person gives/receives candies at most?
Hint 6
Try to determine some people's way to give/receive candies first, then others.
How to do this?
Bit-by-bit.
How to do this?
Bit-by-bit.
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;

const int _N = 1e5 + 5;

int T;

void solve() {
	int n; cin >> n;
	vector<ll> a(n); ll sum = 0;
	for (int i = 0; i < n; i++) cin >> a[i], sum += a[i];
	if (sum % n) return cout << "No" << '\n', void();
	sum /= n;
	vector<int> bit(31, 0), pow1(31, 0), pow2(31, 0);
	for (int i = 0; i < n; i++) {
		int flag = 0;
		if (a[i] == sum) continue;
		for (int j = 0; j < 31; j++) {
			if (a[i] + (1 << j) == sum) {
				pow1[j]++;
				flag = 1;
				continue;
			}
			if (a[i] - (1 << j) == sum) {
				pow2[j]++;
				flag = 1;
				continue;
			}
		}
		if (flag) continue;
		flag = 0;
		for (int j = 0; j < 31; j++) {
			for (int k = 0; k < 31; k++) {
			    if (a[i] + (1 << j) - (1 << k) == sum) {
			        flag = 1;
			        bit[j]++;
			        bit[k]--;
			    }
			}
		}
		if (!flag) {
			cout << "No" << '\n';
			return;
		}
	}
	for (int i = 30; i >= 0; i--) {
		bit[i] += (pow1[i] - pow2[i]);
		if (i == 0) break;
		if (bit[i] < 0) {
			pow1[i - 1] -= -bit[i];
			bit[i - 1] -= -bit[i];
			if (pow1[i - 1] < 0) {
				cout << "No" << '\n';
				return;
			}
		} else {
			pow2[i - 1] -= bit[i];
			bit[i - 1] += bit[i];
			if (pow2[i - 1] < 0) {
				cout << "No" << '\n';
				return;
			}
		}
	}
	if (bit[0] == 0) cout << "Yes" << '\n';
	else cout << "No" << '\n';
	return;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		solve();
	}
}
Rate the problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1868B1
Editorial Content:
1868B1 - Candy Party (Easy Version)
Hint 1
You can calculate the number of candies of each person after the swap easily. Denote the number as $$$s$$$.
Hint 2
Since a person gives candies to and receives candies from exactly one person, assume he gives away $$$2^x$$$ candies and receives $$$2^y$$$ candies, then we have $$$a_i - 2^x + 2^y = s$$$. If $$$a_i \ne s$$$, at most how many pairs $$$(x,y)$$$ can satisfy this equation?
Hint 3
Do the two restrictions in the statement,
Note that one cannot give more candies than currently he has (he might receive candies from someone else before) and he cannot give candies to himself, either.
really make any difference to the answer?
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;

const int _N = 1e5 + 5;

int T;

void solve() {
	int n; cin >> n;
	vector<ll> a(n); ll sum = 0;
	for (int i = 0; i < n; i++) cin >> a[i], sum += a[i];
	if (sum % n) return cout << "No" << '\n', void();
	sum /= n;
	vector<int> bit(31, 0);
	auto lowbit = [](int x) {
	    return x & (-x);
	};
	for (int i = 0; i < n; i++) {
		if (a[i] == sum) continue;
		int d = abs(a[i] - sum);
		int p = lowbit(d);
		int e = d + p;
		if (__builtin_popcount(e) == 1) {
		    if (a[i] > sum) bit[__lg(e)]++, bit[__lg(p)]--;
		    else bit[__lg(e)]--, bit[__lg(p)]++;
		} else {
		    cout << "No" << '\n';
		    return;
		}
	}
	for (int i = 0; i < 31; i++) {
		if (bit[i]) {
			cout << "No" << '\n';
			return;
		}
	}
	cout << "Yes" << '\n';
	return;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		solve();
	}
}
Rate the problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1868A
Editorial Content:
1868A - Fill in the Matrix
Hint 1
What is the upper bound of $$$s$$$ according to $$$n$$$ and $$$m$$$? Can you construct such a matrix that reaches the upper bound?
Hint 2
If not, can you construct a matrix which maximizes $$$\sum_{i=1}^m v_i$$$? This is of some help to get the solution.
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;

const int _N = 1e5 + 5;

int T;

void solve() {
	int n, m;
	cin >> n >> m;
	if (m == 1) cout << 0 << '\n';
	else if (n > m - 1) cout << m << '\n';
	else cout << n + 1 << '\n';
	for (int i = 0; i < min(m - 1, n); i++) {
		for (int j = 0; j < m; j++) {
			cout << (j + i) % m << ' ';
		}
		cout << '\n';
	}
	if (n > m - 1) {
		for (int i = m - 1; i < n; i++) {
			for (int j = 0; j < m; j++) {
				cout << j << ' ';
			}
			cout << '\n';
		}
	}
	return;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		solve();
	}
}
Rate the problem
Amazing problem:
Good problem:
Average problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1867F
Editorial Content:
1867F-Most Different Tree
Tutorial
Here we say that the answer for tree $$$G'$$$ is the number of subtrees in $$$P(G')$$$ that have an isomorphic subtree in $$$P(G)$$$.
Let's find a tree $$$T$$$ of minimum size that has no isomorphic tree in $$$P(G)$$$. Let the size of tree $$$T$$$ be $$$x$$$. Then take a chain of size $$$n - x$$$, and let the root of $$$T$$$ be the kid of the last vertex on the chain. We say that this is the tree $$$G'$$$ we were looking for (with the root of $$$G'$$$ being the first vertex of the chain). The number of matching subtrees will be at most $$$x - 1$$$, since all subtrees of the vertices on the chain and the subtree $$$T$$$ itself will not have isomorphic trees in $$$P(G)$$$, because $$$T$$$ lies entirely in them, and $$$T$$$ has no isomorphic tree in $$$P(G)$$$. Therefore, the answer is not greater than $$$n - (n - x) - 1 = x - 1$$$.
Let's prove why the answer cannot be less than $$$x - 1$$$: suppose there exists a tree $$$G*$$$ for which the answer is less than $$$x - 1$$$. Let's find a subtree of minimum size whose size is at least $$$x$$$ (it always exists, since we can take the entire tree for example). In this subtree, there are at least $$$x - 1$$$ other subtrees, whose sizes are less than $$$x$$$ (because in the previous step we chose a subtree of minimum size not less than $$$x$$$). And since all trees of size less than $$$x$$$ have isomorphic trees in $$$P(G)$$$ (by definition $$$T$$$ is the tree of minimum size that has no isomorphic tree in $$$P(G)$$$ and its size is $$$x$$$), the number of matching subtrees in tree $$$G*$$$ is at least $$$x - 1$$$, which is a contradiction.
Therefore in our case the answer is $$$x - 1$$$.
Now let's solve the second part of the problem — finding $$$T$$$. To do this, let's first find all trees of size 1, then of size 2, then 3, 4 and so on until we find a tree that has no isomorphic subtree in $$$P(G)$$$. One can see that if we generate all trees of size up to 15 we will definitely find $$$T$$$ there. Within each size, let's number the trees in the order in which we've generated them. To find all trees of size $$$x$$$ if we are given all trees of size $$$x - 1$$$ and smaller, let's say that the sizes of the children of the root of the tree we generate must not decrease, and if the sizes are the same, their positions in the order must not decrease. Then, we can iterate over the first child, then among the smaller and suitable ones, the second child, then the third, and so on until the total size of the tree becomes exactly $$$x$$$. This way, we will enumerate all trees of size $$$x$$$ in complexity of their total number (since we will not consider any tree twice and will not consider any extra trees). Let's do this until we find a tree that is not in $$$P(G)$$$.
Hashes can be used to compare trees for isomorphism. For more details, read the
blog post
Time Complexity: $$$O(n \log n)$$$.
Solution
#include <bits/stdc++.h>

using namespace std;

const int MAXSZ = 15;

void rec(int ns, int last, vector<int>& now, vector<vector<int>>& aint, vector<int>& col, vector<int>& sz, int& ss, int sns) {
    if (ss < 0) {
        return;
    }
	if (ns == 0) {
		col.back()++;
		aint.push_back(now);
		ss -= sns;
		return;
	}
	for (int i = min(last, col[ns] - 1); i >= 0; i--) {
		now.push_back(i);
		rec(ns - sz[i], i, now, aint, col, sz, ss, sns);
		now.pop_back();
	}
}

void dfs(int v, int p, vector<vector<int>>& arr, vector<int>& num, map<vector<int>, int>& m, vector<int>& sz) {
	vector<int> now;
	sz[v] = 1;
	for (auto i : arr[v]) {
		if (i != p) {
			dfs(i, v, arr, num, m, sz);
			sz[v] += sz[i];
			if (sz[v] <= MAXSZ) {
			    now.push_back(num[i]);
			}
		}
	}
	if (sz[v] > MAXSZ) {
		num[v] = -1;
		return;
	}
	stable_sort(now.begin(), now.end());
	reverse(now.begin(), now.end());
	num[v] = m[now] - 1;
}

void dfs2(int x, int p, vector<vector<int>>& aint, vector<int>& ans) {
	if (p >= 0) {
		ans.push_back(p);
	}
	int now = ans.size();
	for (auto i : aint[x]) {
		dfs2(i, now, aint, ans);
	}
}

void solve() {
	int n;
	cin >> n;
	vector<vector<int>> aint(1);
	vector<vector<int>> arr(n);
	for (int i = 1; i < n; i++) {
		int a, b;
		cin >> a >> b;
		a--;
		b--;
		arr[a].push_back(b);
		arr[b].push_back(a);
	}
	map<vector<int>, int> m;
	vector<int> col(1, 0), sz(1, 1);
	col.push_back(1);
	for (int i = 2; i <= MAXSZ; i++) {
		vector<int> now;
		col.push_back(col.back());
		int ss = n;
		rec(i - 1, aint.size() - 1, now, aint, col, sz, ss, i);
		while (sz.size() < col.back()) {
			sz.push_back(i);
		}
		if (ss < 0) {
		    break;
		}
	}
	for (int i = 0; i < col.back(); i++) {
		m[aint[i]] = i + 1;
	}
	vector<int> num(n), szi(n, 1);
	dfs(0, 0, arr, num, m, szi);
	set<int> s;
	for (int i = 0; i < col.back(); i++) {
		s.insert(i);
	}
	for (auto i : num) {
		s.erase(i);
	}
	int x = *s.begin();
	vector<int> ans;
	if (sz[x] > n) {
		for (int i = 0; i < n; i++) {
			for (auto j : arr[i]) {
				if (i < j) {
					cout << i + 1 << ' ' << j + 1 << '\n';
				}
			}
		}
		return;
	}
	for (int i = 0; i < n - sz[x] - 1; i++) {
		ans.push_back(i);
	}
	dfs2(x, n - sz[x] - 1, aint, ans);
	for (int i = 0; i < ans.size(); i++) {
		cout << ans[i] + 1 << ' ' << i + 2 << '\n';
	}
}

int main() {
    	ios_base::sync_with_stdio(false);
    	cin.tie(0);
    	cout.tie(0);
	int t = 1;
	//cin >> t;
	for (int i = 0; i < t; i++) {
		solve();
	}
}
--------------------------------------------------
Problem ID: 1867E2
Editorial Content:
1867E2-Salyg1n and Array (hard version)
Tutorial
Let's make queries to subarrays starting at positions $$$1$$$, $$$k + 1$$$, $$$2k + 1$$$, $$$\ldots$$$ $$$m \cdot k + 1$$$, such that the size of the uncovered part is greater than $$$2 \cdot k$$$ and not greater than $$$3 \cdot k$$$. In other words, $$$2 \cdot k < n - (m + 1) \cdot k \le 3 \cdot k$$$. Let's keep the $$$\operatorname{XOR}$$$ of all the answers to these queries. We will call these queries primary.
Let the size of the remaining (uncovered) part be $$$x$$$ ($$$2 \cdot k < x \le 3 \cdot k$$$). Let's learn how to solve the problem for an array of size $$$x$$$ in three queries.
If $$$x = 3 \cdot k$$$, simply make queries to positions $$$1$$$, $$$k + 1$$$, $$$2 \cdot k + 1$$$.
Otherwise, let $$$y = x - k$$$. Note that $$$y$$$ is even, since $$$x$$$ and $$$k$$$ are even.
Make queries at positions $$$1$$$, $$$1 + \frac{y}{2}$$$, $$$1 + y$$$.
Note that after this query, the subarray [$1$; $$$k - \frac{y}{2}$$$] will turn into the subarray [$$$y/2 + 1$$$; $$$k$$$] and reverse. After the next query, the same thing will happen, the subarray will shift one unit to the right and reverse. Therefore, the prefixes of length $$$k - \frac{y}{2}$$$ for each query are the same, up to the reversal, which does not affect the $$$\operatorname{XOR}$$$. Since the number of queries in the second group is $$$3$$$, which is an odd number, the $$$\operatorname{XOR}$$$ of these prefixes will be taken into account exactly once in the $$$\operatorname{XOR}$$$ of all the queries, which will therefore be equal to the $$$\operatorname{XOR}$$$ of the elements.
The number of primary queries does not exceed $$$\lfloor \frac{n}{k} \rfloor \leq k \leq 50$$$, since $$$n \leq k^2 \leq 2500$$$.
The total number of queries does not exceed $$$53$$$.
Solution
#include <iostream>

using namespace std;

int ask(int i) {
	cout << "? " << i << endl;
	int x;
	cin >> x;
	return x;
}

void solve() {
	int n, k;
	cin >> n >> k;
	int res = 0;
	int i;
	for (i = 1; n - i + 1 >= 2 * k; i += k)
		res ^= ask(i);
	if (n - i + 1 == k) {
		res ^= ask(i);
		cout << "! " << res << endl;
		return;
	}
	int y = (n - i + 1 - k) / 2;
	res ^= ask(i);
	res ^= ask(i + y);
	res ^= ask(i + 2 * y);
	cout << "! " << res << endl;
}

int main() {
	int t;
	cin >> t;
	while (t--)
		solve();
	return 0;
}
--------------------------------------------------
Problem ID: 1867E1
Editorial Content:
1867E1-Salyg1n and Array (simple version)
Tutorial
Let's make queries to subarrays starting at positions $$$1$$$, $$$k + 1$$$, $$$2k + 1$$$, $$$\ldots$$$ $$$m \cdot k + 1$$$, as long as these queries are valid, meaning their right boundary does not exceed $$$n$$$. Let's save the $$$\operatorname{XOR}$$$ of all the answers to these queries. We will call these queries primary.
Now, we will shift the last subarray of the query one unit to the right and make a new query, as long as the right boundary does not exceed $$$n$$$. We will call these queries secondary. It is claimed that the $$$\operatorname{XOR}$$$ of the entire array will be equal to the $$$\operatorname{XOR}$$$ of all the queries. Let's prove this.
Let $$$i$$$ be the position at which the first secondary query starts. Notice that after this query, the subarray [$i$; $$$i + k - 2$$$] will turn into the subarray [$$$i + 1$$$; $$$i + k - 1$$$] and reverse. After the next query, the same thing will happen, the subarray will shift one unit to the right and reverse. Therefore, the prefixes of length $$$k-1$$$ of each secondary query will be the same, up to the reversal, which does not affect the $$$\operatorname{XOR}$$$. Since the number of secondary queries is equal to $$$n \operatorname{mod} k$$$, which is an even number, the $$$\operatorname{XOR}$$$ of these prefixes will not affect the $$$\operatorname{XOR}$$$ of all the secondary queries, which will therefore be equal to the $$$\operatorname{XOR}$$$ of the elements [$a_{i + k — 1}$; $a_n$], that is, all the elements that we did not consider in the primary queries.
The number of primary queries is equal to $$$\lfloor \frac{n}{k} \rfloor \leq k \leq 50$$$, since $$$n \leq k^2 \leq 2500$$$.
The number of secondary queries is equal to $$$n \operatorname{mod} k < k <= 50$$$, since $$$k^2 \leq 2500$$$.
The total number of queries does not exceed $$$100$$$.
Solution
#include <iostream>

using namespace std;

int ask(int i) {
	cout << "? " << i << endl;
	int x;
	cin >> x;
	return x;
}

void solve() {
	int n, k;
	cin >> n >> k;
	int res = 0;
	int i;
	for (i = 1; i + k - 1 <= n; i += k)
	    res ^= ask(i);
	for (; i <= n; ++i)
	    res ^= ask(i - k + 1);
	cout << "! " << res << endl;
}

int main() {
	int t;
	cin >> t;
	while (t--)
		solve();
	return 0;
}
--------------------------------------------------
Problem ID: 1867D
Editorial Content:
1867D-Cyclic Operations
Tutorial
If $$$k = 1$$$, then we can change $$$b_i$$$ to $$$i$$$, so the answer is YES only if $$$b_i = i$$$, otherwise the answer is NO.
Otherwise, let's build an undirected graph with $$$n$$$ vertices and edges ($$$i, b_i$$$). Any component of this graph will look like a cycle (possibly of size $$$1$$$) to each vertex of which a tree is attached (possibly empty).
Proof
Let's assume that there are $$$x$$$ vertices in a component, then there are also $$$x$$$ edges in it (since each vertex has exactly one outgoing edge). We can construct a depth-first search (DFS) tree for this component, which will have $$$x - 1$$$ edges. Now, when we add the remaining edge ($$$u, v$$$), a cycle is formed in the component (formed by the edge ($$$u, v$$$) and the path between $$$u$$$ and $$$v$$$ in the DFS tree). Each vertex will have a tree attached to it, because before adding the edge, we had a tree.
Now it is claimed that if the cycle in each component has a size exactly $$$k$$$, then the answer is YES, otherwise NO.
Proof
Let's first consider the situation where the size of the cycle in some component is not $$$k$$$. Let the cycle contain vertices $$$v_1, v_2, \cdots, v_x$$$ in that order. Now let's look at the last operation in which one of the $$$l_i$$$ was equal to some element from the cycle. If the size of the cycle is less than $$$k$$$, then in the last operation there will be at least one vertex not from the cycle, which means that at least one vertex from the cycle will be replaced by a number that is not the next vertex in the cycle, which is incorrect because each vertex from the cycle should be replaced by the next vertex after it. If the size of the cycle is greater than $$$k$$$, then we will have a vertex from the cycle that will be replaced by a vertex that is not the next vertex in the cycle (otherwise we would have used all the vertices of the cycle, and there are more than $$$k$$$ of them). Therefore, in any case, there is no valid last operation with vertices from the cycle, so the answer is NO.
If the size of the cycle in a component is equal to $$$k$$$, then we can apply the following algorithm:
While there is at least one vertex $$$v$$$ in the component that is a leaf, we will perform the operation with $$$l = [v, b_v, b_{b_v}, \cdots]$$$ (all elements are distinct because we will enter the cycle and it has a size of $$$k$$$). After this operation, we will have $$$a_v = b_v$$$, and we can remove vertex $$$v$$$ (it had only $$$1$$$ outgoing edge).
When only the cycle remains, we can apply the operation for the vertices in the cycle, preserving the order, and then for all vertices in the component, we will have $$$a_v = b_v$$$. By doing this for all components, we will get $$$a = b$$$, which is what we wanted, so the answer is YES.
Time Complexity: $$$O(n)$$$ per test case.
Proof
Let's assume that there are $$$x$$$ vertices in a component, then there are also $$$x$$$ edges in it (since each vertex has exactly one outgoing edge). We can construct a depth-first search (DFS) tree for this component, which will have $$$x - 1$$$ edges. Now, when we add the remaining edge ($$$u, v$$$), a cycle is formed in the component (formed by the edge ($$$u, v$$$) and the path between $$$u$$$ and $$$v$$$ in the DFS tree). Each vertex will have a tree attached to it, because before adding the edge, we had a tree.
Proof
Let's first consider the situation where the size of the cycle in some component is not $$$k$$$. Let the cycle contain vertices $$$v_1, v_2, \cdots, v_x$$$ in that order. Now let's look at the last operation in which one of the $$$l_i$$$ was equal to some element from the cycle. If the size of the cycle is less than $$$k$$$, then in the last operation there will be at least one vertex not from the cycle, which means that at least one vertex from the cycle will be replaced by a number that is not the next vertex in the cycle, which is incorrect because each vertex from the cycle should be replaced by the next vertex after it. If the size of the cycle is greater than $$$k$$$, then we will have a vertex from the cycle that will be replaced by a vertex that is not the next vertex in the cycle (otherwise we would have used all the vertices of the cycle, and there are more than $$$k$$$ of them). Therefore, in any case, there is no valid last operation with vertices from the cycle, so the answer is NO.
If the size of the cycle in a component is equal to $$$k$$$, then we can apply the following algorithm:
While there is at least one vertex $$$v$$$ in the component that is a leaf, we will perform the operation with $$$l = [v, b_v, b_{b_v}, \cdots]$$$ (all elements are distinct because we will enter the cycle and it has a size of $$$k$$$). After this operation, we will have $$$a_v = b_v$$$, and we can remove vertex $$$v$$$ (it had only $$$1$$$ outgoing edge).
When only the cycle remains, we can apply the operation for the vertices in the cycle, preserving the order, and then for all vertices in the component, we will have $$$a_v = b_v$$$. By doing this for all components, we will get $$$a = b$$$, which is what we wanted, so the answer is YES.
Solution
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while(t--)
    {
        int n,k;
        cin >> n >> k;
        int b[n];
        int vis[n];
        for(int j = 0;j < n;++j)
        {
            cin >> b[j];
            vis[j] = 0;
        }
        if(k == 1)
        {
            int no = 0;
            for(int j = 0;j < n;++j)
            {
                if(b[j] != j+1)
                {
                    no = 1;
                }
            }
            cout << (no ? "NO\n" : "YES\n");
            continue;
        }
        int num[n];
        int no = 0;
        int tgr = 1;
        for(int j = 0;j < n;++j)
        {
            if(!vis[j])
            {
                int ind = j;
                int cnum = 0;
                while(!vis[ind])
                {
                    vis[ind] = tgr;
                    num[ind] = cnum++;
                    ind = b[ind]-1;
                }
                if(vis[ind] != tgr)
                {
                    tgr++;
                    continue;
                }
                if(cnum-num[ind] != k)
                {
                    no = 1;
                    break;
                }
                tgr++;
            }
        }
        cout << (no ? "NO\n" : "YES\n");
    }
}
--------------------------------------------------
Problem ID: 1867C
Editorial Content:
1867C-Salyg1n and the MEX Game
Tutorial
The correct strategy for Alice is to add the number $$$\operatorname{MEX}(S)$$$ to the set $$$S$$$ on the first move, and add the last removed number on the remaining moves.
Let m = $$$\operatorname{MEX}(S \cup {\operatorname{MEX}(S)})$$$, at the start of the game. In other words, m is equal to the second $$$\operatorname{MEX}$$$ of the set $$$S$$$. $$$m \geq 1$$$.
Notice that after the first move, $$$\operatorname{MEX}(S) = m$$$, and no matter what Bob removes, we will return that number to the set, so the result of the game will always be equal to $$$m$$$.
Let's prove that with Bob's optimal play, we cannot achieve a result greater than m.
Notice that the $$$\operatorname{MEX}$$$ of a set is the largest number k such that all numbers from $$$0$$$ to $$$k-1$$$ inclusive are present in the set.
Let $$$p_i$$$ be the number of numbers from $$$0$$$ to $$$i-1$$$ inclusive that appear in the set $$$S$$$. Then $$$\operatorname{MEX}(S)$$$ is equal to the maximum $$$i$$$ such that $$$p_i = i$$$.
If Bob removes the number $$$y$$$ during his turn, he decreases all values $$$p_i$$$ where $$$i > y$$$ by $$$1$$$. So, if $$$y = \operatorname{min}(S)$$$, Bob decreases all non-zero values $$$p_i$$$ by $$$1$$$.
Alice can increase some values $$$p_i$$$ by $$$1$$$ during her turn. Therefore, after Alice's first move, $$$\operatorname{MEX}(S)$$$ will no longer increase if Bob keeps removing the minimum, because no non-zero values of $$$p_i$$$ will increase (Bob decreases them by $$$1$$$, and Alice increases them by at most $$$1$$$).
It is obvious that in order to maximize $$$\operatorname{MEX}(S)$$$ after the first move, Alice needs to add the number $$$\operatorname{MEX}(S)$$$ to the set $$$S$$$.
We have proven that $$$R \leq m$$$ and provided a strategy that achieves a result of $$$m$$$.
Time Complexity: $$$O(n)$$$ per test case.
Solution
#include <iostream>
#include <vector>

using namespace std;

void solve() {
	int n;
	cin >> n;
	vector<int> s(n);
	for (int i = 0; i < n; ++i)
		cin >> s[i];
	int mex = -1;
	for (int i = 0; i < n; ++i) {
		if (i == 0 && s[i] != 0) {
			mex = 0;
			break;
		}
		if (i > 0 && s[i] != s[i - 1] + 1) {
			mex = s[i - 1] + 1;
			break;
		}
	}
	if (mex == -1)
		mex = s[n - 1] + 1;
	cout << mex << endl;
	int y;
	cin >> y;
	while (y != -1) {
		cout << y << endl;
		cin >> y;
	}
}

int main() {
	int t;
	cin >> t;
	while (t--)
		solve();

	return 0;
}
--------------------------------------------------
Problem ID: 1867B
Editorial Content:
1867B — XOR Palindromes
Tutorial
Firstly, a string is a palindrome if and only if for any $$$i$$$ ($$$1 \leq i \leq n$$$) $$$s_i = s_{n-i+1}$$$ (because when reversed, $$$s_i$$$ becomes $$$s_{n-i+1}$$$).
We can divide the characters into pairs, where each pair consists of $$$s_i$$$ and $$$s_{n-i+1}$$$. If $$$s_i = s_{n-i+1}$$$, then we need to have $$$l_i = l_{n-i+1}$$$ in order to obtain equal elements after XOR. Therefore, either $$$l_i = l_{n-i+1} = 0$$$ (with $$$0$$$ ones) or $$$l_i = l_{n-i+1} = 1$$$ (with $$$2$$$ ones). If $$$s_i \neq s_{n-i+1}$$$, then $$$l_i \neq l_{n-i+1}$$$ must hold ($$$1$$$ one in any case). Additionally, if $$$n$$$ is odd, then $$$l_{n/2+1}$$$ can be either $$$0$$$ or $$$1$$$ (with $$$0$$$ or $$$1$$$ ones).
We can iterate over the number of pairs where $$$l_i = l_{n-i+1}$$$ will have two ones, as well as whether there will be a one in the center or not. This way, we can obtain all possible numbers of ones in $$$l$$$, i.e., all good $$$i$$$.
Time Complexity: $$$O(n)$$$ per test case.
Solution
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        string s;
        cin >> s;
        string t(n+1,'0');
        int ans = 0;
        int max_1 = 0;
        int max_2 = 0;
        for(int i = 0;i <= n/2-1;++i)
        {
            if(s[i] == s[n-i-1])
                max_2++;
            else
                ans++;
        }
        if(n%2 == 1)
            max_1++;
        for(int j = 0;j <= max_2;++j)
        {
            for(int k = 0;k <= max_1;++k)
            {
                t[ans + j*2 + k] = '1';
            }
        }
        cout << t << "\n";
    }
}
--------------------------------------------------
Problem ID: 1867A
Editorial Content:
1867A — green_gold_dog, array and permutation
Tutorial
Let's subtract $$$n$$$ from the minimum number, subtract $$$n - 1$$$ from the second minimum, $$$n - 2$$$ from the third $$$\ldots$$$, and subtract $$$1$$$ from the maximum. Then the number of distinct elements will be $$$n$$$. Obviously, it is impossible to achieve a better result.
Let's prove that the number of distinct elements will be equal to $$$n$$$. Suppose $$$c_i = c_j$$$, then without loss of generality, let's say that $$$b_i > b_j$$$, then $$$a_i \leq a_j$$$, which means $$$c_i = a_i - b_i$$$ < $$$a_j - b_j = c_j$$$. Contradiction.
Time Complexity: $$$O(n \log n)$$$ per test case.
Solution
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

void solve() {
	ll n;
	cin >> n;
	vector<pair<ll, ll>> arr(n);
	for (ll i = 0; i < n; i++) {
		ll x;
		cin >> x;
		arr[i].first = x;
		arr[i].second = i;
	}
	vector<ll> ans(n);
	sort(arr.begin(), arr.end());
	reverse(arr.begin(),arr.end());
	for (ll i = 0; i < n; i++) {
		ans[arr[i].second] = i + 1;
	}
	for (auto i : ans) {
		cout << i << ' ';
	}
	cout << '\n';
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
	ll t = 1;
	cin >> t;
	for (ll i = 0; i < t; i++) {
		solve();
	}
}
--------------------------------------------------
Problem ID: 1866M
Editorial Content:
1866M. Mighty Rock Tower
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1866L
Editorial Content:
1866L. Lihmuf Balling
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1866K
Editorial Content:
1866K. Keen Tree Calculation
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1866J
Editorial Content:
1866J. Jackets and Packets
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1866I
Editorial Content:
1866I. Imagination Castle
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1866H
Editorial Content:
1866H. Happy Sets
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1866G
Editorial Content:
1866G. Grouped Carriages
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1866F
Editorial Content:
1866F. Freak Joker Process
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1866E
Editorial Content:
1866E. Elevators of Tamem
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1866D
Editorial Content:
1866D. Digital Wallet
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1866C
Editorial Content:
1866C. Completely Searching for Inversions
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1866B
Editorial Content:
1866B. Battling with Numbers
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1866A
Editorial Content:
1866A. Ambitious Kid
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1864I
Editorial Content:
1864I-Future Dominators
Tutorial
This problem is based on a method of online edge deletion and querying connectivity of a planar graph.
Firstly, if this vertex is not an articulation point, it will not cause any change in connectivity. Therefore, the algorithm needs to determine whether a certain vertex is an articulation point.
Thinking about using a data structure called union-find to keep track of the deleted points, we can identify a clear condition: if a vertex has two neighbors with the same union-find value among its $$$8$$$-connected neighbors, then it becomes an articulation point. This is easy to understand:
When the values in the union-find are the same, it means there's a loop forming, and this messes up how things are connected inside and outside the loop. But if all the values in the union-find are different, no loops will form, and we can find a way to connect these points to each other.
For points which are not articulation points, the greedy way to do it is to put the biggest number in the component of points that are already connected. This helps keep things organized and efficient.
Now, let's think about the case of articulation points. If we've already decided to put a $$$1$$$ in the connected group before the articulation point, it's pretty clear that, in order to get the largest overall value, we should put the $$$1$$$ in the smallest connected component. And the remaining connected components will then share the largest value. In other words, when we pick the largest number for one component, the largest numbers for the other components will decrease at the same time.
If we're sure that a particular component won't have the number $$$1$$$ placed in it, then the point we're looking at can only hold the value which is one more than the maximum value in the connected component formed by removing this point. It might sound a bit complicated, but I'll show you a picture to make it clearer.
In simpler words, the value we put in that point is fixed. It's just the right amount to make sure it matches the sum of all the values in the connected group above it, instead of picking the smallest group. To make this work, we have to keep track of where the smallest value is located inside that connected component.
The method we discussed is quite slow, around $$$O(n^3)$$$. Now, let's talk about how to make it much faster, around $$$O(n^2 log n)$$$.
Firstly, for every cell, we keep a pointer that points to the information about its connected component. So, whenever we update any cell, the entire connected component gets updated automatically.
When dealing with articulation points, it's important to quickly update the pointer information. One effective way is to use a clever merging technique. This involves simultaneously performing a breadth-first search on multiple connected components. If only one connected component remains incomplete in the search, we immediately stop all calculations.
One of the things we need to do is to launch the BFS from the new connected components which arise after fixing a certain cell. In particular, we don't want to launch two parallel BFS which start in different cells but sooner or later are merged into one component. So among the $$$4$$$ side-neighbors of the cell being fixed, we need to segregate them based on the remaining connectivity, considering the removal of the current cell. To facilitate this segregation, we examine the 8 corner- or side-neighbors and analyze their DSU values. For instance, if all these DSU values are distinct from each other, it implies that the empty neighboring cells belong to a unified component.
Conversely, if certain DSU values occur multiple times, it signifies the existence of a planar cycle that becomes linked through the cell being fixed. Consequently, cells within and outside this cycle must be assigned to separate connected components. To manage this, we iterate through pairs of $8-$neighbors sharing the same DSU value and classify the $4-$neighbors into those situated within the cycle and those outside it.
During the pointer update process, we handle smaller connected components by updating their pointers in a straightforward manner. For larger connected components, we retain their original pointers and make necessary adjustments. It's easy to show that this approach updates pointers efficiently (each time a connected group is encountered in the search, its size at least doubles). This helps us achieve a time complexity of $$$O(n^2 log n)$$$.
Next, we also need to determine whether two cells are part of the same connected component. This is necessary for calculating the situation represented in the previous image. This step is quite simple because we ensured earlier that pointers of different connected components are always different. So, all we need to do is compare the pointer values to check if two cells belong to the same connected component.
For the connected components that share the largest value, there are several ways to handle them. One approach is to use the
*int
data type for the maximum value, so changing one value directly changes the shared value. Another method is to use a
vector
to store the pointers that share the value, and when updating, you iterate through this vector to update them.
It's easy to prove that the maximum shared values can only exist in a maximum of $$$O(1)$$$ components simultaneously. This is because they only arise when cutting an articulation point in a connected component where the value is not $$$1$$$, and these components cannot merge together.
So, the total time complexity will be $$$O(n^2logn)$$$.
solution
#include<bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast","inline","-ffast-math")
#pragma GCC target("avx,sse2,sse3,sse4,mmx")
struct node {
   int mx,sz;bool bg;
   pair<int,int> mn;
   vector<node*> cp;
   void cln(){for(node* i:cp)i->cp.erase(find(i->cp.begin(),i->cp.end(),this));cp.clear();}
   void fresh() {
      if(!bg) return;
      bg=false;int sum=0;node* lt=nullptr;
      for(node* i:cp)if(i->bg){lt=i;sum++;}
      if(sum==1){lt->mx=lt->sz;lt->bg=false;lt->cln();}
   }
   ~node(){cln();}
};
int prevAns;
pair<int,int> fa[1002][1002];
pair<int,int> getfa(pair<int,int> x) {
   if(fa[x.first][x.second]==x) return x;
   return fa[x.first][x.second]=getfa(fa[x.first][x.second]);
}
void merge(pair<int,int> x,pair<int,int> y) {
   pair<int,int> t=getfa(x);
   fa[t.first][t.second]=getfa(y);
}

int n,q;
node* bk[1002][1002];
bool vis[1002][1002];
vector<pair<int,int>> dxy={{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1}},xy={{-1,0},{0,1},{1,0},{0,-1}};
void Delta() {
   cin >> n >> q;
   bk[1][1]=new node{n*n,n*n,false,{0,0},{}};
   for(int i=0;i<=n+1;++i)
      for(int j=0;j<=n+1;++j) {
         fa[i][j]={i,j};
         if(i==0||j==0||i==n+1||j==n+1) {
            fa[i][j]={0,0};
            vis[i][j]=true;
            bk[i][j]=nullptr;
         } else {
            bk[i][j]=bk[1][1];
            vis[i][j]=false;
         }
      }
   prevAns=0;
   while(q--) {
      int x,y,cnt=1;cin >> x >> y;
      x^=prevAns;
      y^=prevAns;
      pair<int,int> Q[8];
      int P[4]={0,0,0,0};
      for(int i=0;i<8;++i)
         Q[i]=getfa({x+dxy[i].first,y+dxy[i].second});
      for(int i=0;i<8;++i)
         for(int j=1;j<8;++j)
            if(Q[i]==Q[(i+j)%8]) {
               cnt++;
               for(int k=(i+1)%8;k!=(i+j)%8;k=(k+1)%8)
                  if(k%2==1)
                     P[k/2]+=1ll<<cnt;
               break;
            }
      vis[x][y]=true;
      for(pair<int,int> i:dxy)
         if(vis[x+i.first][y+i.second])
            merge({x,y},{x+i.first,y+i.second});
      bk[x][y]->fresh();
      if((P[0]&P[1]&P[2]&P[3])==max({P[0],P[1],P[2],P[3]})) {
         prevAns=bk[x][y]->mx;
         cout << prevAns << ' ';
         bk[x][y]->mx--;bk[x][y]->sz--;
         for(node* i:bk[x][y]->cp) i->mx--;
         if(bk[x][y]->sz==0) delete bk[x][y];
      } else {
         vector<pair<int,int>> s[4];
         queue<pair<int,int>> q[4];
         pair<int,int> id[4];
         int cnt,dc=0;
         {
            vector<int> R;
            for(int i=0;i<4;++i) R.push_back(P[i]);
            sort(R.begin(),R.end());
            R.resize(unique(R.begin(),R.end())-R.begin());
            cnt=R.size();
            for(int i=0;i<4;++i)
               P[i]=lower_bound(R.begin(),R.end(),P[i])-R.begin();
         }
         for(int i=0;i<cnt;++i) {
            for(int j=0;j<4;++j)
               if(P[j]==i&&!vis[x+xy[j].first][y+xy[j].second]) {
                  id[i]={x+xy[j].first,y+xy[j].second};
                  if(!vis[id[i].first][id[i].second]) {
                     q[i].push(id[i]);
                     s[i].push_back(id[i]);
                     vis[id[i].first][id[i].second]=true;
                     dc++;
                  }
                  break;
               }
         }
         while(dc>1)
            for(int i=0;i<4;++i)
               if(q[i].size()!=0) {
                  pair<int,int> t=q[i].front();q[i].pop();
                  for(int j=0;j<4;++j) {
                     pair<int,int> p={t.first+xy[j].first,t.second+xy[j].second};
                     if(!vis[p.first][p.second]) {
                        q[i].push(p);s[i].push_back(p);
                        vis[p.first][p.second]=true;
                     }
                  }
                  if(q[i].empty()) --dc;
               }
         vector<int> sm,bg;node* tp[4];
         if(bk[x][y]->mx==bk[x][y]->sz) {
            if(dc==1) {
               for(int i=0;i<4;++i)
                  if(!q[i].empty()) bg.push_back(i);
                  else if(!s[i].empty()) sm.push_back(i);
               for(int i:sm) {
                  tp[i]=new node{bk[x][y]->mx,(int)s[i].size(),false,{x,y},{}};
                  for(pair<int,int> j:s[i])
                     bk[j.first][j.second]=tp[i];
               }
               for(int i:sm) {
                  for(int j:sm)
                     if(i!=j) tp[i]->cp.push_back(tp[j]);
                  bk[x][y]->sz-=s[i].size();
               }
               prevAns=bk[x][y]->sz;
               cout<< prevAns << ' ';
               bk[x][y]->sz--;bk[x][y]->mx=bk[x][y]->sz;
            } else {
               int mxz=0;
               for(int i=0;i<4;++i)
                  if(!s[i].empty()) {
                     sm.push_back(i);
                     mxz=max(mxz,(int)s[i].size());
                  }
               prevAns=mxz+1;
               cout << prevAns << ' ';
               for(int i:sm) {
                  tp[i]=new node{bk[x][y]->mx,(int)s[i].size(),(int)s[i].size()==mxz,{x,y},{}};
                  for(pair<int,int> j:s[i])
                     bk[j.first][j.second]=tp[i];
               }
               for(int i:sm)
                  for(int j:sm)
                     if(i!=j) tp[i]->cp.push_back(tp[j]);
               delete bk[x][y];
            }
         } else {
            vector<node*> ar;vector<int> lt,ult;
            if(dc==1) {
               int sult=1,ty=bk[x][y]->mx;
               pair<int,int> pmn=bk[x][y]->mn;
               bk[x][y]->mn={x,y};bk[x][y]->sz--;
               for(int i=0;i<4;++i)
                  if(!s[i].empty()) {
                     if(!q[i].empty()) {
                        bg.push_back(i);
                        tp[i]=bk[x][y];
                     }
                     else {
                        tp[i]=new node{bk[x][y]->mx,(int)s[i].size(),false,{x,y},{}};
                        sm.push_back(i);
                        bk[x][y]->sz-=(int)s[i].size();
                        for(pair<int,int> j:s[i])
                           bk[j.first][j.second]=tp[i];
                     }
                  }
               pair<int,int> tmp=pmn;
               for(pair<int,int> i:xy) {
                  node* t=bk[i.first+tmp.first][i.second+tmp.second];
                  if(t!=nullptr&&pair<int,int>{i.first+tmp.first,i.second+tmp.second}!=pair<int,int>{x,y}) {
                     ar.push_back(t);
                  }
               }
               vector<node*> cp=bk[x][y]->cp;
               for(node* i:cp) i->cp.erase(find(i->cp.begin(),i->cp.end(),bk[x][y]));
               bk[x][y]->cp.clear();
               for(int i=0;i<4;++i) {
                  if(!s[i].empty()) {
                     if(id[i]==tmp||find(ar.begin(),ar.end(),bk[id[i].first][id[i].second])!=ar.end()) {
                        tp[i]->mn=pmn;
                        lt.push_back(i);
                     } else {
                        ult.push_back(i);
                        sult+=tp[i]->sz;
                     }
                  }
               }
               for(int i:ult)
                  for(int j:ult)
                     if(i!=j) tp[i]->cp.push_back(tp[j]);
               for(node* i:cp) {
                  for(int j:lt) {
                     i->cp.push_back(tp[j]);
                     tp[j]->cp.push_back(i);
                  }
                  i->mx-=sult;
               }
               prevAns=ty-sult+1;
               cout << prevAns << ' ';
               for(int i:lt) {
                  for(int j:lt)
                     if(i!=j) tp[i]->cp.push_back(tp[j]);
                  tp[i]->mx-=sult;
               }
            } else {
               pair<int,int> pmn=bk[x][y]->mn;
               int sult=1;
               for(int i=0;i<4;++i)
                  if(!s[i].empty()) {
                     tp[i]=new node{bk[x][y]->mx,(int)s[i].size(),false,{x,y},{}};
                     for(pair<int,int> j:s[i])
                        bk[j.first][j.second]=tp[i];
                  }
               pair<int,int> tmp=bk[x][y]->mn;
               for(pair<int,int> i:xy) {
                  node* t=bk[i.first+tmp.first][i.second+tmp.second];
                  if(t!=nullptr&&pair<int,int>{i.first+tmp.first,i.second+tmp.second}!=pair<int,int>{x,y})
                     ar.push_back(t);
               }
               for(int i=0;i<4;++i)
                  if(!s[i].empty()) {
                     if(id[i]==tmp||find(ar.begin(),ar.end(),bk[id[i].first][id[i].second])!=ar.end()) {
                        tp[i]->mn=pmn;
                        lt.push_back(i);
                     } else {
                        ult.push_back(i);
                        sult+=(int)s[i].size();
                     }
                  }
               for(int i:ult)
                  for(int j:ult)
                     if(i!=j) tp[i]->cp.push_back(tp[j]);
               for(node* i:bk[x][y]->cp) {
                  for(int j:lt) {
                     i->cp.push_back(tp[j]);
                     tp[j]->cp.push_back(i);
                  }
                  i->mx-=sult;
               }
               for(int i:lt) {
                  for(int j:lt)
                     if(i!=j) tp[i]->cp.push_back(tp[j]);
                  tp[i]->mx-=sult;
               }
               prevAns=bk[x][y]->mx-sult+1;
               cout << prevAns << ' ';
               delete bk[x][y];
            }
         }
         for(int i=0;i<4;++i)
            for(pair<int,int> j:s[i])
               vis[j.first][j.second]=false;
      }
      bk[x][y]=nullptr;
   }
   set<node*> _;
   for(int i=1;i<=n;++i)
      for(int j=1;j<=n;++j)
         _.insert(bk[i][j]);
   for(node* i:_)
      if(i!=nullptr) delete i;
   cout << endl;
}
signed main() {
   ios_base::sync_with_stdio(0);
   cin.tie(0);cout.tie(0);
   int T;cin >> T;
   while(T--) Delta();
}
--------------------------------------------------
Problem ID: 1864H
Editorial Content:
1864H-Asterism Stream
Tutorial
Here is a basic $$$\Theta(n)$$$ dp solution.
Before that let $$$k = \frac{1}{2}$$$. At the same time, because a special geometric sequence $$$f(x)=ak^{bx}$$$ will be frequently used next, it is defined as $$$\{a,b\}$$$.
Let $$$f(x)$$$ be the expected number of moves needed if we start with $$$x$$$. Obviously, there is the following formula:
$$$f(x)=\begin{cases}0&n\leqslant x\\k(f(x+1)+f(2x))+1&x<n\end{cases}$$$
It's easy to see that for the interval $$$[n, 2n]$$$ value of $$$f(x)$$$ is $$$0$$$.
If for an interval $$$[2l,2r]$$$, it can already be represented by the sum of several $$${a,b}$$$, then it can be represented by a small number of new $$$\{a,b\}$$$ for all $$$f(x)$$$, where $$$x\in[l,r]$$$
First there is $$$f(r)=kf(r+1)+kf(2r)+1$$$. So, $$$r-1$$$ can be represented as $$$f(r-1)=k^2f(r+1)+ kf(2r-2)+k^2f(2r)+k+1$$$.
By analogy, one can get
$$$f(r-x)=k^{x+1}f(r+1)+\sum\limits_{i=0}^xk^{i+1}f(2r-2x+2i)+\sum\limits_{i=0}^xk^i$$$
by substitution, it can be shown as
$$$f(x)=k^{r-x+1}f(r+1)+\sum\limits_{i=0}^{r-x}k^{i+1}f(2x+2i)+\sum\limits_{i=0}^{r-x}k^i$$$
Because $$$\{a,b\}$$$ of the interval where $$$f(r+1)$$$ is already known, the value of $$$f(r+1)$$$ can be calculated quickly. So, the first term of $$$f(x)$$$ can be represented as below:
$$$k^{r-x+1}f(r+1)=k^{r+1}f(r+1)·k^{-x}=\{k^{r+1}f(r+1),-1\}$$$
Then the last term of $$$f(x)$$$, $$$\sum\limits_{i=0}^{r-x}k^i$$$ is sum of an ordinary geometric sequence. So, after applying the formula it can represented as $$$\{2,0\}+\{-k^r,-1\}$$$.
For the second term $$$\sum\limits_{i=0}^{r-x}k^{i+1}f(2x+2i)$$$, it has been assumed that $$$f(2x+2i)$$$ is $$$\sum\{a,b\}$$$, so split it into the following form (the derivation process depends on $$$k^{2b+1}\neq1$$$):
$$$ \!\begin{aligned} \sum\limits_{i=0}^{r-x}k^{i+1}f(2x+2i)&=\sum\limits_{i=0}^{r-x}k^{i+1}\sum\limits_f\{a,b\}\\ &=\sum\limits_{i=0}^{r-x}k^{i+1}\sum\limits_fak^{b(2x+2i)}\\ &=\sum\limits_f\sum\limits_{i=0}^{r-x}k^{i+1}ak^{b(2x+2i)}\\ &=\sum\limits_f\sum\limits_{i=0}^{r-x}ak^{2bx+1}·k^{i+2bi}\\ &=\sum\limits_fak^{2bx+1}\sum\limits_{i=0}^{r-x}(k^{2b+1})^i\\ &=\sum\limits_fak^{2bx+1}\cdot\frac{k^{(2b+1)(r-x+1)}-1}{k^{2b+1}-1}\\ &=\sum\limits_f\frac{ak^{(2b+1)(n+1)+1}}{k^{2b+1}-1}\cdot k^{-x}+\frac{-ak}{k^{2b+1}-1}\cdot k^{2bx}\\ &=\sum\limits_f\{\frac{ak^{(2b+1)(n+1)+1}}{k^{2b+1}-1},-1\}+\{\frac{-ak}{k^{2b+1}-1},2b\} \end{aligned} $$$
Because of the obvious combination law $$$\{a,b\}+\{c,b\}=\{a+c,b\}$$$, the number of its geometric series is linear with the number of recursions.
For $$$x\in[n,2n], f(x)=0$$$, which can be represented as $$$f(x)=\{0,0\}$$$, so this recursive rule can always be used, Until the $$$x\in[1,1]$$$ is obtained, to get the result.
The complexity varies depending on the implementation $$$\Theta(T\log^3n)$$$ or $$$\Theta(T\log^2n)$$$.
solution
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast", "inline", "-ffast-math")
#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#define int long long
const int MOD = 998244353;
int n, k;
long long power(int x, int p)
{
    if (p < 0)
        return power(power(x, MOD - 2), -p);
    int answer = 1;
    x %= MOD;
    while (p)
    {
        if (p & 1)
            answer = answer * x % MOD;
        x = x * x % MOD;
        p >>= 1;
    }
    return answer;
}
void Delta()
{
    cin >> n;
    k = power(2, MOD - 2);
    int l = n, r = max(1ll, (n - 1) * 2), n0 = 0, s;
    vector<int> Q;
    while (l > 1)
    {
        vector<int> P;
        l = (l + 1) / 2;
        r /= 2;
        s = n0;
        for (int i = 0, t = k - 1; i < (int)Q.size(); ++i)
        {
            s = (s + Q[i] * power(power(k, -(1ll << i)), r + 1)) % MOD;
            t = t * t % MOD;
        }
        P.push_back(((power(k, r + 1) * s - power(k, r)) % MOD + MOD) % MOD);
        for (int i = 0; i < (int)Q.size(); ++i)
        {
            P[0] += power(power(k, 1 - (1ll << (i + 1))) - 1, MOD - 2) * Q[i] % MOD * power(power(k, 1 - (1ll << (i + 1))), r + 1) % MOD * k % MOD;
            P.push_back(((MOD - Q[i] * k % MOD * power(power(k, 1 - (1ll << (i + 1))) - 1, MOD - 2) % MOD) % MOD + MOD) % MOD);
        }
        P[0] += (MOD - n0) * power(k, r + 1) % MOD;
        for (int &i : P)
            i %= MOD;
        Q = P;
        n0 += 2;
    }
    s = n0;
    for (int i = 0, t = k - 1; i < (int)Q.size(); ++i)
    {
        s = (s + Q[i] * power(power(k, -(1ll << i)), 1)) % MOD;
        t = t * t % MOD;
    }
    cout << s << endl;
}
signed main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--)
        Delta();
}
--------------------------------------------------
Problem ID: 1864G
Editorial Content:
1864G-Magic Square
Hint1
Theorem 1: After a row shift, all numbers moved are in the correct column.
Proof 1: Suppose a number moved after a row shift is not in the correct column, if it is not in the correct row, it needs at least two more moves to its target position, otherwise it needs at least three more moves because the row cannot be shifted again.
Also, after a column shift, all numbers moved are in the correct row.
Hint2
Theorem 2: If both row shift and column shift are performed, two rows cannot have equal shift distance.
Proof 2: If row $$$i$$$ is shifted by $$$x$$$ and column $$$j$$$ is shifted by $$$y$$$, regardless of their order, then there is a number with offset $$$(y, x)$$$. If row $$$i_1$$$ and row $$$i_2$$$ are shifted by $$$x$$$ and column $$$j$$$ is shifted by $$$y$$$, regardless of their order, then there are two numbers with the same offset $$$(y, x)$$$ (if two number coincide, it was moved at least three times).
In the same way, if both row shift and column shift are performed, two columns cannot have equal shift distance.
If after a row shift, all numbers moved are in the correct column, we call such rows available. Similarly, if after a column shift, all numbers moved are in the correct row, we call such columns available.
Hint3
Theorem 3: If there is an available row and an available column at the same time, then there is no solution.
Proof 3: If row $$$i$$$ can be shifted by $$$x$$$ and column $$$j$$$ can be shifted by $$$y$$$, the number in $$$(i, j)$$$ has offset $$$(y, x)$$$. Assume that the number in $$$(i, j)$$$ is moved to $$$(i+y, j)$$$ and then to $$$(i+y, j+x)$$$. Row $$$i+y$$$ is shifted by $$$x$$$, no other row can be shifted by $$$x$$$. Consider the number in $$$(i,j+1)$$$, it needs to be shifted by $$$x$$$ in some row, so it must be moved to row $$$i+y$$$ before row $$$i+y$$$ shifts. Then the numbers in $$$(i, j)$$$ and $$$(i+1, j)$$$ have the same offset $$$(y, x)$$$. Similarly, if the number in $$$(i, j)$$$ is moved to $$$(i, j+x)$$$ and then to $$$(i+y, j+x)$$$, there is no solution.
Tutorial
We can use the following method to solve this problem:
For each row and each column, check if it is available.
If there are both available rows and available columns, there is no solution.
If no rows or columns are available, the matrix is already equal to the target one, or there is no solution.
If there are only available rows or available columns, their order doesn't matter, so if there $$$s$$$ choices, the answer should be multiplied by $$$s!$$$. Apply all available operations and check again.
Total complexity: $$$O(n^3)$$$ or $$$O(n^2)$$$ if maintaining row/column offsets in each row/column.
solution
#include <bits/stdc++.h>

#define all(a) (a).begin(), (a).end()
#define sz(a) (int)(a).size()
#define pb push_back
#define mp make_pair

using namespace std;

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

const int mod = 998244353;
const int nmax = 600;

int fact[nmax];

int main() {

    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    fact[0] = 1;
    for (int i = 1; i < nmax; ++i) {
        fact[i] = ll(fact[i - 1]) * i % mod;
    }
    
    int tt;
    cin >> tt;
    
    while (tt--) {
        int n;
        cin >> n;
        vector<vector<int> > a(n, vector<int>(n));
        set<int> seta;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                cin >> a[i][j];
                seta.insert(a[i][j]);
            }
        }
        assert(sz(seta) == n * n);
    
        vector<vector<int> > b(n, vector<int>(n));
        set<int> setb;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                cin >> b[i][j];
                setb.insert(b[i][j]);
            }
        }
        assert(sz(setb) == n * n);
        assert(seta == setb);
        vector<int> vct;
        for (int x : seta) {
            vct.pb(x);
        }
    
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                a[i][j] = lower_bound(all(vct), a[i][j]) - vct.begin();
                b[i][j] = lower_bound(all(vct), b[i][j]) - vct.begin();
            }
        }
    
        vector<pii> posa(n * n);
        vector<pii> posb(n * n);
    
        set<pii> off;
    
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                posa[a[i][j]] = {i, j};
                posb[b[i][j]] = {i, j};
            }
        }
        bool valid = true;
        for (int x = 0; x < n * n; ++x) {
            pii p = posa[x], q = posb[x];
            if (p.first != q.first && p.second != q.second) {
                pii s = {(q.first - p.first + n) % n, (q.second - p.second + n) % n};
                if (off.count(s)) {
                    valid = false;
                } else {
                    off.insert(s);
                }
            }
        }
        if (!valid) {
            cout << "0\n";
            continue;
        }
    
        int cnt = 0;
        ll ans = 1;
    
        while (a != b) {
            vector<pii> rows;
            for (int i = 0; i < n; ++i) {
                int shift = posb[a[i][0]].second;
                bool ok = true;
                for (int j = 0; j < n; ++j) {
                    int x = a[i][j];
                    if (posb[x].second != (j + shift) % n) {
                        ok = false;
                        break;
                    }
                }
                if (ok && shift) {
                    rows.pb({i, shift});
                }
            }
            vector<pii> cols;
            for (int j = 0; j < n; ++j) {
                int shift = posb[a[0][j]].first;
                bool ok = true;
                for (int i = 0; i < n; ++i) {
                    int x = a[i][j];
                    if (posb[x].first != (i + shift) % n) {
                        ok = false;
                        break;
                    }
                }
                if (ok && shift) {
                    cols.pb({j, shift});
                }
            }
            if (cols.empty() && rows.empty()) {
                valid = false;
                break;
            }
            if (!(cols.empty() ^ rows.empty())) {
                valid = false;
                break;
            }
            if (!rows.empty()) {
                cnt += sz(rows);
                ans *= fact[sz(rows)];
                ans %= mod;
                for (pii p : rows) {
                    int i = p.first;
                    int shift = p.second;
                    vector<int> v = a[i];
                    for (int j = 0; j < n; ++j) {
                        int x = v[j];
                        a[i][(j + shift) % n] = x;
                        posa[x] = {i, (j + shift) % n};
                    }
                }
            } else {
                cnt += sz(cols);
                ans *= fact[sz(cols)];
                ans %= mod;
                for (pii p : cols) {
                    int j = p.first;
                    int shift = p.second;
                    vector<int> v;
                    for (int i = 0; i < n; ++i) {
                        v.pb(a[i][j]);
                    }
                    for (int i = 0; i < n; ++i) {
                        int x = v[i];
                        a[(i + shift) % n][j] = x;
                        posa[x] = {(i + shift) % n, j};
                    }
                }
            }
        }
        if (!valid) {
            cout << "0\n";
            continue;
        }
        cout << ans << '\n';
        // cout << cnt << " " << ans << "\n";
    }

}
--------------------------------------------------
Problem ID: 1864F
Editorial Content:
1864F-Exotic Queries
Hint
The final solution is irrelevant to Cartesian trees.
Tutorial
First, we consider only the sequence of elements to be manipulated. We claim that it is optimal to operate on the whole sequence so that the minimum elements are all decreased to $$$0$$$, and then solve the problem on the segments separated by the $0$s recursively.
A straightforward corollary of the claim is that two equal elements between which there are no smaller elements are handled in a single operation, so the final answer is $$$\ell$$$ (the number of elements to be manipulated) minus the number of such adjacent pairs.
Proof: Define $$$S(l, r)$$$ to be the answer for the segment $$$[l, r]$$$. Do induction on the length of the segment. If the first operation does not manipulate the whole segment, the segment will be separated into several independent parts by the first operation, for the non-inclusive operations cannot intersect, and the final answer, which is the sum of $$$S$$$ of the parts, will not be less than the initial answer according to the corollary, for some of the equal pairs are separated.
Now the original problem is converted into a data structure task. Consider all adjacent equal pairs $$$(l, r)$$$, and $$$m$$$ is the maximum element between $$$(l, r)$$$, $m < a_l$. $$$(l, r)$$$ decrease the answer if and only if $$$m < L \le a_l = a_r \le R$$$, which can be easily calculated with a segment tree and sweeping lines.
solution
#include <bits/stdc++.h>

#define all(a) (a).begin(), (a).end()
#define sz(a) (int)(a).size()
#define pb push_back
#define mp make_pair

using namespace std;

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

vector<int> sum;
int N;

void updSumTree(int pos) {
    for (pos += N; pos; pos >>= 1) {
        ++sum[pos];
    }
}

int getSumTree(int l, int r) {
    int ans = 0;
    for (l += N, r += N; l <= r; l = (l + 1) >> 1, r = (r &mdash; 1) >> 1) {
        if (l & 1) {
            ans += sum[l];
        }
        if (!(r & 1)) {
            ans += sum[r];
        }
    }
    return ans;
}

vector<int> t;
int n;

void updTree(int pos, int val) {
    for (pos += n; pos; pos >>= 1) {
        t[pos] = max(t[pos], val);
    }
}

int getTree(int l, int r) {
    int ans = 0;
    for (l += n, r += n; l <= r; l = (l + 1) >> 1, r = (r &mdash; 1) >> 1) {
        if (l & 1) {
            ans = max(ans, t[l]);
        }
        if (!(r & 1)) {
            ans = max(ans, t[r]);
        }
    }
    return ans;
}

const int nmax = 1e6 + 100;

vector<int> pos[nmax];
int cnt[nmax];
int distinct[nmax];

struct query {
    int l, r, id;
    bool operator<(const query& other) const {
        return l < other.l;
    }
};

int main() {

    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    int q;
    cin >> n >> q;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    
    t.assign(4 * n, 0);
    
    for (int i = 0; i < n; ++i) {
        pos[a[i]].pb(i);
    }
    
    vector<pii> pts;
    for (int x = 1; x <= n; ++x) {
        for (int i = 0; i + 1 < sz(pos[x]); ++i) {
            int lf = pos[x][i], rg = pos[x][i + 1];
            ++lf, --rg;
            if (lf > rg) {
                continue;
            }
            int y = getTree(lf, rg);
            //cout << x << " " << y << endl;
            if (y == 0) {
                continue;
            }
            pts.pb({n - y, x});
        }
        for (int p : pos[x]) {
            updTree(p, x);
        }
    }
    
    cnt[0] = 0;
    distinct[0] = 0;
    for (int x = 1; x <= n; ++x) {
        cnt[x] = cnt[x - 1] + sz(pos[x]);
        distinct[x] = distinct[x - 1] + (!pos[x].empty());
    }
    
    sort(all(pts));
    int ptr = 0;
    
    vector<query> queries(q);
    vector<int> ans(q);
    for (int i = 0; i < q; ++i) {
        int l, r;
        cin >> l >> r;
        queries[i] = {n - l, r, i};
        ans[i] = distinct[r] - distinct[l - 1];
    }
    
    sort(all(queries));
    
    N = n + 1;
    sum.assign(2 * N, 0);


    for (int i = 0; i < q; ++i) {
        while (ptr < sz(pts) && pts[ptr].first <= queries[i].l) {
            updSumTree(pts[ptr].second);
            ++ptr;
        }
        ans[queries[i].id] += getSumTree(0, queries[i].r);
    }
    
    for (int i = 0; i < q; ++i) {
        cout << ans[i] << "\n";
    }

}
--------------------------------------------------
Problem ID: 1864E
Editorial Content:
1864E-Guess Game
Tutorial
First, let's analize a single game for fixed $$$a$$$, $$$b$$$, and how many turns it takes.
Consider the binary representation of $$$a \mid b$$$. We consider bits from highest to lowest. For bits with a value of $$$0$$$, we can ignore it because it firmly tells us that both bits of $$$a$$$ and $$$b$$$ are $$$0$$$. For convenience, we assume that all bits of $$$a \mid b$$$ are $$$1$$$.
In the first round, if the highest bit of $$$a$$$ is $$$0$$$, then Alice can immediately say that $$$a<b$$$. Otherwise, in the second round of the game, Bob knows that the highest bit of $$$a$$$ is not $$$0$$$. If the highest or the second highest bit of b is $$$0$$$, then Bob can immediately say that $$$a>b$$$. Otherwise, in the third round of the game, Alice knows that the highest and the second highest bits of $$$b$$$ are not $$$0$$$, and so on.
Consider only set bits in $$$a \mid b$$$. Let's enumerate these bits from highest to lowest. After some observation, we can conclude that:
If $$$a<b$$$ and the $$$i$$$-th bit in $$$a$$$ is zero, then the answer is $$$i+1−(i\%2 == 1)$$$;
If $$$a=b$$$, then the answer is $$$k+1$$$, where $$$k$$$ is the number of set bits in $$$a \mid b$$$;
If $$$a>b$$$ and the $$$i$$$-th bit in $$$b$$$ is zero, then the answer is $$$i+(i\%2 == 1)$$$.
Now that we have a brute force algorithm for $$$O (n^2 \log A)$$$, how can we optimize it?
We can build a bit trie and traverse all nodes. We can easily calculate the number of $$$1$$$s that pass from a node to the root node, as well as the number of numbers prefixed with it and followed by $$$0$$$ (or $$$1$$$). Use this information to calculate the answer.
solution
#include <bits/stdc++.h>

#define all(a) (a).begin(), (a).end()
#define sz(a) (int)(a).size()
#define pb push_back
#define mp make_pair

using namespace std;

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

struct node {
    int to[2];
    int cnt;
    node() {
        to[0] = to[1] = -1;
        cnt = 0;
    }
};

bool bit(int mask, int pos) {
    return (mask >> pos) & 1;
}

vector<node> t;

void add(int x) {
    int v = 0;
    for (int i = 29; i >= 0; --i) {
        int b = bit(x, i);
        if (t[v].to[b] == -1) {
            t[v].to[b] = sz(t);
            t.pb(node());
        }
        ++t[v].cnt;
        v = t[v].to[b];
    }
    ++t[v].cnt;
}

const int mod = 998244353;

void mul(int& a, int b) {
    ll c = ll(a) * b;
    if (c >= mod) {
        c %= mod;
    }
    a = c;
}

int binpow(int a, int n) {
    int ans = 1;
    while (n) {
        if (n & 1) {
            mul(ans, a);
        }
        mul(a, a);
        n >>= 1;
    }
    return ans;
}

void solve(int v, int k, ll& ans) {
    if (t[v].to[0] != -1 && t[v].to[1] != -1) {
        ll i = k + 1;
        ans += (2 * (i / 2) + 1) * t[t[v].to[0]].cnt * t[t[v].to[1]].cnt;
        ans += 2 * ((i + 1) / 2) * t[t[v].to[0]].cnt * t[t[v].to[1]].cnt;
    }
    if (t[v].to[0] == -1 && t[v].to[1] == -1) {
        ll i = k + 1;
        ans += i * t[v].cnt * t[v].cnt;
    }
    if (t[v].to[0] != -1) {
        solve(t[v].to[0], k, ans);
    }
    if (t[v].to[1] != -1) {
        solve(t[v].to[1], k + 1, ans);
    }
}

int main() {

    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    int tt;
    cin >> tt;
    while (tt--) {
        t.clear();
        t.pb(node());
        int n;
        cin >> n;
        for (int i = 0; i < n; ++i) {
            int a;
            cin >> a;
            add(a);
        }
        ll x = 0;
        solve(0, 0, x);
        int ans = x % mod;
        mul(ans, binpow(n, mod - 2));
        mul(ans, binpow(n, mod - 2));
        cout << ans << "\n";
    }

}
--------------------------------------------------
Problem ID: 1864D
Editorial Content:
1864D-Matrix Cascade
Tutorial
Firstly, the first row has some elements that are $$$\text{1}$$$ s and some elements that are $$$\text{0}$$$ s. The elements that are $$$\text{1}$$$ can only be turned into $$$\text{0}$$$ by operating on the corresponding cell an odd number of times, and the elements that are $$$\text{0}$$$ can only be turned into $$$\text{0}$$$ by operating on the corresponding cell an even number of times. Two operations on the same cell are equivalent to no operation, so only one operation is performed on the corresponding cell of the element that is $$$\text{1}$$$ in the first row. Thus, the operation on the first row is deterministic. Subsequent rows are affected by the operations in the first row, so it is sufficient to proceed to consider rows $$$2$$$ to $$$n$$$ in the same way.
Now consider how to quickly deal with the effect of the preceding rows on the following rows. An operation on position $$$(x,y)$$$ will simultaneously invert all the elements from column $$$y-1$$$ to column $$$y+1$$$ in row $$$x+1$$$, and from column $$$y-2$$$ to column $$$y+2$$$ in row $$$x+2$$$, and son on. Thus, the elements being inverted are exactly the portion of the matrix sandwiched between lines passing through $$$(x,y)$$$ with slopes $$$1$$$ and $$$-1$$$. Let $$$b$$$ denote the effect of the line with slope $$$1$$$ from all predecing rows, and let $$$c$$$ denote the effect of the line with slope $$$-1$$$ from all preceding rows. % To optimize complexity, $$$b$$$, $$$c$$$ are both obtained using difference arrays to the current line using prefix sums to obtain the $$$b,c$$$ values at that time.
After an operation on $$$(i,j)$$$, $$$b[i+1][j-1]$$$ is marked, and $$$c[i+1][j+2]$$$ is marked. Next, $$$b[i][j]$$$ inherits $$$b[i-1][j+1]$$$, and $$$c[i][j]$$$ inherits $$$c[i-1][j-1]$$$. For the current row, the effect of the previous rows is obtained by maintaining the prefix sums on $$$b$$$ and $$$c$$$. The total complexity is $$$O(n^2)$$$.
solution
#include <bits/stdc++.h>

#define all(a) (a).begin(), (a).end()
#define sz(a) (int)(a).size()
#define pb push_back
#define mp make_pair

using namespace std;

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

int main() {

    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    int tt;
    cin >> tt;
    
    while (tt--) {
        int n;
        cin >> n;
        vector<string> a(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }
        int ans = 0;
        vector<vector<int> > val(n, vector<int>(n, 0));
        vector<vector<int> > sum(n, vector<int>(n, 0));
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i == 0) {
    
                } else if (i == 1) {
                    for (int k = max(0, j - 1); k <= min(j + 1, n - 1); ++k) {
                        sum[i][j] ^= sum[i - 1][k];
                    }
                } else {
                    if (j == 0) {
                        sum[i][j] ^= sum[i - 2][j];
                    } else {
                        sum[i][j] ^= sum[i - 1][j - 1];
                    }
                    if (j == n - 1) {
                        sum[i][j] ^= sum[i - 2][j];
                    } else {
                        sum[i][j] ^= sum[i - 1][j + 1];
                    }
                    sum[i][j] ^= sum[i - 2][j];
                    sum[i][j] ^= val[i - 1][j];
                }
                if (sum[i][j] ^ (a[i][j] - '0')) {
                    ++ans;
                    sum[i][j] ^= 1;
                    val[i][j] = 1;
                }
            }
        }
        cout << ans << "\n";
    }

}
--------------------------------------------------
Problem ID: 1864C
Editorial Content:
1864C-Divisor Chain
Tutorial
Let us divide the task into two steps, on each step we will use each divisor at most once. For convenience, let us denote $$$L$$$ as the largest value, such that $$$2^L \le x$$$ holds. The two steps are as follows.
Reduce $$$x$$$ to $$$2^L$$$.
Given any integer $$$x$$$, we can see that its lowest significant bit is a divisor of $$$x$$$. If $$$x$$$ has more than one bit, we can repeatedly subtract the value corresponding to the lowest significant bit of $$$x$$$. When $$$x$$$ finally has only one bit, finish the first step. In this step, we have only used each significant bit of $$$x$$$ at most once.
Reduce $$$2^L$$$ to $$$1$$$.
We can find a way to reduce $$$2^L$$$ to $$$1$$$ by using each bit exactly once. Formally, if $$$k \ge 0$$$, then $$$2^{k+1}-2^k=2^k$$$, and $$$2^k$$$ is a divisor of $$$2^{k+1}$$$. Thus, by subtracting $$$2^{L-1},2^{L-2},\ldots,1$$$ in order, we reach $$$1$$$ from $$$2^L$$$ by using each bit from the $$$0$$$-th bit to the $$$(L-1)$$$-st bit exactly once.
As a result, we can reduce $$$x$$$ to $$$1$$$ by using each power of $$$2$$$ at most twice (once from the first step, once from the second step). Since we used each bit at most twice, the time complexity for solving one test case is $$$O(\log x)$$$.
Due to the lenient constraints, some solutions with $$$O(\sqrt x)$$$ time complexity should pass as well (as long as they fit into the $$$1000$$$ operations limit).
solution
#include <bits/stdc++.h>

#define all(a) (a).begin(), (a).end()
#define sz(a) (int)(a).size()
#define pb push_back
#define mp make_pair

using namespace std;

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

bool bit(int mask, int pos) {
    return (mask >> pos) & 1;
}

int main() {

    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    int tt;
    cin >> tt;
    while (tt--) {
        int x;
        cin >> x;
        int p;
        vector<int> ans;
        ans.pb(x);
        for (int i = 0; ; ++i) {
            if (bit(x, i)) {
                if (x == (1 << i)) {
                    p = i;
                    break;
                }
                x -= (1 << i);
                ans.pb(x);
            }
        }
        while (p > 0) {
            x -= (1 << (p - 1));
            ans.pb(x);
            --p;
        }
        cout << sz(ans) << "\n";
        for (int y : ans) {
            cout << y << " ";
        }
        cout << "\n";
    }

}
--------------------------------------------------
Problem ID: 1864B
Editorial Content:
1864B-Swap and Reverse
Tutorial
By the first kind of operation, we already know that every odd index (same for the even ones) can be swapped with each other freely. Therefore, let us write down the values of the indices modulo $$$2$$$. For example, if $$$n$$$ is $$$10$$$, the indices modulo $$$2$$$ are $$$[1,0,1,0,1,0,1,0,1,0]$$$. Now, we consider the two cases.
When $$$k$$$ is odd.
We can find out that after reversing any subarray of length $$$k$$$, the indices modulo $$$2$$$ do not change. So in this case, any series of the second operation is identical to some series of the first operation. Therefore, you should sort the odd indices and the even indices separately, and output the result of merging them into one string.
When $$$k$$$ is even.
Let us observe how we can swap two adjacent indices in this case. First, reverse $$$[i,i+k-1]$$$, and then reverse $$$[i+1,i+k]$$$. If we do this on $$$[1,0,1,0,1,0,1,0,1,0]$$$, assuming $$$i=1$$$ and $$$k=6$$$, the indices modulo $$$2$$$ turn into $$$[0,1,0,1,0,1,1,0,1,0]$$$, and then $$$[0,1,1,0,1,0,1,0,1,0]$$$. Using these two steps and some series of the first operation, we can see that we can swap any two adjacent indices as a result. And such a series of operation is always possible, as $$$k<n$$$. Therefore, we can sort the entire string, and output the result.
solution
#include <bits/stdc++.h>

#define all(a) (a).begin(), (a).end()
#define sz(a) (int)(a).size()
#define pb push_back
#define mp make_pair

using namespace std;

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

int main() {

    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    int tt;
    cin >> tt;
    while (tt--) {
        int n, k;
        cin >> n >> k;
        string s;
        cin >> s;
        vector<char> odd, even;
        for (int i = 0; i < n; ++i) {
            if (i % 2 == 0) {
                even.pb(s[i]);
            } else {
                odd.pb(s[i]);
            }
        }
        sort(all(even));
        sort(all(odd));
        string ans1 = "";
        for (int i = 0, j = 0; i < sz(even) || j < sz(odd); ++i, ++j) {
            if (i < sz(even)) {
                ans1 += even[i];
            }
            if (j < sz(odd)) {
                ans1 += odd[i];
            }
        }
        if (k % 2 == 0) {
            sort(all(s));
            cout << s << "\n";
            continue;
        }
        cout << ans1 << "\n";
    }

}
bonus
Try to solve the problem if $$$n = k$$$ was allowed.
--------------------------------------------------
Problem ID: 1864A
Editorial Content:
1864A-Increasing and Decreasing
Tutorial
We use the following greedy construction:
For all $$$i$$$ ($$$1<i<n$$$), set $$$a_i=a_{i+1}-(n-i)$$$. If $$$a_2-a_1 \geq n-1$$$, we've found a solution, otherwise there is no solution.
Proof. Assume there's a solution which includes an index $$$i$$$ ($$$1<i<n$$$) such that $$$a_{i+1}-a_i>n-i$$$. We can make $$$a_j:=a_j+\Delta$$$ for all $$$j$$$ ($$$2 \le j \le i$$$), where $$$\Delta=a_{i+1}-a_i-(n-i)$$$. After several processes like this, we get a solution the same as greedy construction gives. This leads to a contradiction.
solution
#include <bits/stdc++.h>

#define all(a) (a).begin(), (a).end()
#define sz(a) (int)(a).size()
#define pb push_back
#define mp make_pair

using namespace std;

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

int main() {

    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    int tt;
    cin >> tt;
    while (tt--) {
        int x, y, n;
        cin >> x >> y >> n;
        vector<int> a(n);
        a[0] = x, a[n - 1] = y;
        int d = 1;
        for (int i = n - 2; i >= 1; --i) {
            a[i] = a[i + 1] - d;
            ++d;
        }
        bool ok = true;
        for (int i = 0; i + 1 < n; ++i) {
            if (a[i + 1] <= a[i]) {
                ok = false;
            }
        }
        for (int i = 0; i + 2 < n; ++i) {
            int p = a[i + 1] - a[i];
            int q = a[i + 2] - a[i + 1];
            if (p <= q) {
                ok = false;
            }
        }
        if (!ok) {
            cout << "-1\n";
            continue;
        }
        for (int i = 0; i < n; ++i) {
            cout << a[i] << " ";
        }
        cout << "\n";
    }

}
--------------------------------------------------
Problem ID: 1863I
Editorial Content:
1863I - Redundant Routes
1863I - Redundant Routes
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1863H
Editorial Content:
1863H - Goldberg Machine 3
1863H - Goldberg Machine 3
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1863G
Editorial Content:
1863G - Swaps
1863G - Swaps
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1863F
Editorial Content:
1863F - Divide, XOR, and Conquer
1863F - Divide, XOR, and Conquer
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1863E
Editorial Content:
1863E - Speedrun
1863E - Speedrun
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1863D
Editorial Content:
1863D - Two-Colored Dominoes
1863D - Two-Colored Dominoes
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1863C
Editorial Content:
1863C - MEX Repetition
1863C - MEX Repetition
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1863B
Editorial Content:
1863B - Split Sort
1863B - Split Sort
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1863A
Editorial Content:
1863A - Channel
1863A - Channel
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1862G
Editorial Content:
1862G - The Great Equalizer
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        scanf("%d", &n);
        vector<int> a(n);
        for (int i = 0; i < n; ++i) {
            scanf("%d", &a[i]);
        }
        if (n == 1) {
            int q;
            scanf("%d", &q);
            while (q--) {
                int pos, val;
                scanf("%d %d", &pos, &val);
                cout << val << " ";
            }
            cout << "\n";
            continue;
        }
        multiset<int> aset;
        for (int i = 0; i < n; ++i) {
            aset.insert(a[i]);
        }
        multiset<int> deltas;
        for (auto it = ++aset.begin(); it != aset.end(); ++it) {
            auto prev = it;
            --prev;
            deltas.insert(*it - *prev);
        }
        int q;
        scanf("%d", &q);
        while (q--) {
            int pos, val;
            scanf("%d %d", &pos, &val);
            auto it = aset.find(a[pos - 1]);
            auto nxt = it, prev = it;
            ++nxt; --prev;
            if (it == aset.begin()) {
                deltas.erase(deltas.find(*nxt - *it));
            } else if (it == --aset.end()) {
                deltas.erase(deltas.find(*it - *prev));
            } else {
                deltas.erase(deltas.find(*nxt - *it));
                deltas.erase(deltas.find(*it - *prev));
                deltas.insert(*nxt - *prev);
            }
            aset.erase(it);
            aset.insert(val);
            it = aset.find(val);
            nxt = it, prev = it;
            ++nxt; --prev;
            if (it == aset.begin()) {
                deltas.insert(*nxt - *it);
            } else if (it == --aset.end()) {
                deltas.insert(*it - *prev);
            } else {
                deltas.insert(*nxt - *it);
                deltas.insert(*it - *prev);
                deltas.erase(deltas.find(*nxt - *prev));
            }
            a[pos - 1] = val;
            cout << *--aset.end() + *--deltas.end() << " ";
        }
        cout << "\n";
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1862F
Editorial Content:
1862F - Magic Will Save the World
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define int long long
 
int32_t main() {
    int q;
    cin >> q;
    while (q--) {
        int w, f, n;
        cin >> w >> f >> n;
        vector<int> s(n);
        int sum_s = 0;
        for (int i = 0; i < n; ++i) {
            cin >> s[i];
            sum_s += s[i];
        }
        vector<bool> dp(sum_s + 1);
        dp[0] = true;
        for (int i = 0; i < n; ++i) {
            for (int w = sum_s; w - s[i] >= 0; --w) {
                dp[w] = dp[w] || dp[w - s[i]];
            }
        }
        int ans = 2e9;
        for (int i = 0; i <= sum_s; ++i) {
            if (dp[i]) {
                ans = min(ans, max((i + w - 1) / w, (sum_s - i + f - 1) / f));
            }
        }
        cout << ans << "\n";
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1862E
Editorial Content:
1862E - Kolya and Movie Theatre
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define int long long
 
int32_t main() {
    int t;
    cin >> t;
    for (int _ = 0; _ < t; ++_) {
        int n, m, d;
        cin >> n >> m >> d;
        vector<int> a(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }
        int ans = 0;
        set<pair<int, int>> s;
        int sum = 0;
        for (int i = 0; i < n; ++i) {
            int cur = sum + a[i] - d * (i + 1);
            ans = max(ans, cur);
            if (a[i] > 0) {
                s.insert({a[i], i});
                sum += a[i];
                if (s.size() >= m) {
                    sum -= (s.begin()->first);
                    s.erase(s.begin());
                }
            }
        }
        cout << ans << endl;
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1862D
Editorial Content:
1862D - Ice Cream Balls
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define int long long
 
int32_t main() {
    int q;
    cin >> q;
    while (q--) {
        int n;
        cin >> n;
        int l = 0, r = min<int>(2e9, 2 * n);
        while (r - l > 1) {
            int m = (l + r) >> 1;
            // m = x + y, answer = x + 2 * y
            if (m * (m - 1) / 2 + m < n) {
                l = m;
            } else {
                r = m;
            }
        }
        int y = n - r * (r - 1) / 2;
        if ((r + 1) * r / 2 <= n) {
            cout << min(r + y, r + 1 + n - (r + 1) * r / 2) << "\n";
        } else {
            cout << r + y << "\n";
        }
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1862C
Editorial Content:
1862C - Flower City Fence
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
 
using namespace std;
 
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n + 1);
        for (int i = 1; i <= n; i++) {
            cin >> a[i];
        }
        if (a[1] != n) {
            cout << "NO" << '\n';
            continue;
        }
        vector<int> b;
        for (int i = n; i >= 1; i--) {
            while (b.size() < a[i]) {
                b.push_back(i);
            }
        }
        bool meow = true;
        for (int i = 1; i <= n; i++) {
            if (a[i] != b[i - 1]) {
                cout << "NO" << '\n';
                meow = false;
                break;
            }
        }
        if (meow) {
            cout << "YES" << '\n';
        }
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1862B
Editorial Content:
1862B - Sequence Game
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define int long long
 
int32_t main() {
    int q;
    cin >> q;
    while (q--) {
        int n;
        cin >> n;
        vector<int> a;
        for (int i = 0; i < n; ++i) {
            int x;
            cin >> x;
            if (i && a.back() > x) {
                a.push_back(1);
            }
            a.push_back(x);
        }
        cout << a.size() << "\n";
        for (int el : a)
            cout << el << " ";
        cout << "\n";
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1862A
Editorial Content:
1862A - Gift Carpet
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define int long long
 
int32_t main() {
    int q;
    cin >> q;
    while (q--) {
        int n, m;
        cin >> n >> m;
        vector<string> carpet(n);
        for (int i = 0; i < n; ++i) {
            cin >> carpet[i];
        }
        string vika = "vika";
        int fnd = 0;
        for (int i = 0; i < m; ++i) {
            bool check = false;
            for (int j = 0; j < n; ++j) {
                if (carpet[j][i] == vika[fnd]) {
                    check = true;
                }
            }
            if (check) {
                ++fnd;
                if (fnd == 4) {
                    break;
                }
            }
        }
        if (fnd == 4) {
            cout << "YES\n";
        } else {
            cout << "NO\n";
        }
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1861F
Editorial Content:
1861F - Four Suits
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
const int K = 4;
const int N = 2 * int(1e6) + 43;
 
pair<long long, long long> operator+(const pair<long long, long long>& a, const pair<long long, long long>& b)
{
	return make_pair(a.first + b.first, a.second + b.second);
}
 
pair<long long, long long> operator-(const pair<long long, long long>& a, const pair<long long, long long>& b)
{
	return make_pair(a.first - b.first, a.second - b.second);
}
 
// prefix sums for an array of pairs
vector<pair<long long, long long>> pref_sums(const vector<pair<long long, long long>>& a)
{
	int n = a.size();
	vector<pair<long long, long long>> ans(n);
	ans[0] = a[0];
	for(int i = 1; i < n; i++)
		ans[i] = ans[i - 1] + a[i];
	return ans;
}
 
// for an array of pairs denoting linear functions, evaluate
// them in the corresponding points
vector<long long> eval(const vector<pair<long long, long long>>& a)
{
	int n = a.size();
	vector<long long> ans(n);
	for(int i = 0; i < n; i++)
		ans[i] = a[i].first * i + a[i].second;
	return ans;
}
 
void solve()
{
	int n;
	scanf("%d", &n);
	vector<vector<int>> a(n, vector<int>(K));
	for(int i = 0; i < n; i++)
		for(int j = 0; j < K; j++)
			scanf("%d", &a[i][j]);
	vector<int> b(K);
	for(int i = 0; i < K; i++)
		scanf("%d", &b[i]);
	
	int deck_size = 0;
	for(int i = 0; i < K; i++)
		deck_size += b[i];
	
	// calculate the remaining number of cards for each player
	long long full = deck_size;
	for(int i = 0; i < n; i++)
		for(int j = 0; j < K; j++)
			full += a[i][j];
	vector<int> remain(n, full / n);
	for(int i = 0; i < n; i++)
		for(int j = 0; j < K; j++)
			remain[i] -= a[i][j];
	
	// for every player, calculate the maximum number of cards
	// they already have among all suits
	// and store it in a multiset
	vector<int> min_val(n);
	for(int i = 0; i < n; i++)
		min_val[i] = *max_element(a[i].begin(), a[i].end());
	multiset<int> min_vals;
	for(int i = 0; i < n; i++)
		min_vals.insert(min_val[i]);
	
	// for every mask of suits and every player, calculate
	// the number of cards in those suits they already have
	vector<vector<int>> already_has(1 << K, vector<int>(n));
	for(int mask = 0; mask < (1 << K); mask++)
		for(int i = 0; i < n; i++)
			for(int j = 0; j < K; j++)
				if(mask & (1 << j))
					already_has[mask][i] += a[i][j];
	// for every mask of suits and every player, calculate the
	// maximum value of x such that if that player can receive 
	// no more than x cards in each suit, the vertex of that
	// player should belong to T in the cut
	vector<vector<int>> max_x(1 << K, vector<int>(n));
	for(int mask = 0; mask < (1 << K); mask++)
		for(int i = 0; i < n; i++)
		{
			int suits = __builtin_popcount(mask);
			if (suits == 0) max_x[mask][i] = N - 2;
			else
			{
				// incoming edges have capacity of
				// x - a[i][j]
				int incoming = -already_has[mask][i];
				// outgoing edge has capacity of remain[i]
				// find the maximum x such that
				// suits * x + incoming < remains[i]
				int x = (remain[i] - incoming) / suits;
				x = min(x, N - 2);
				max_x[mask][i] = x;
			}
		}
	
	// for every mask and for all players, calculate the sum of 
	// values they add to the cut if they can have no more than
	// x cards of each suit in the mask
	vector<vector<long long>> add_to_cut(1 << K, vector<long long>(N));
	for(int mask = 0; mask < (1 << K); mask++)
	{
		int suits = __builtin_popcount(mask);
		vector<pair<long long, long long>> aux(N);
		for(int i = 0; i < n; i++)
		{
			// for the i-th player, they add remains[i] to
			// the minimum cut if x > max_x[mask][i]
			// otherwise, they add
			// suits * x - already_has[mask][i]
			int incoming = -already_has[mask][i];
			// add [suits * x - incoming] on segment [0, max_x]
			int x = max_x[mask][i];
			pair<long long, long long> f1 = {suits, incoming};
			aux[0] = aux[0] + f1;
			aux[x + 1] = aux[x + 1] - f1;
			// add remain[i] on [max_x + 1, N)
			pair<long long, long long> f2 = {0, remain[i]};
			aux[x + 1] = aux[x + 1] + f2;
			aux[N - 1] = aux[N - 1] - f2;
		}
		// sum up those functions and evaluate them
		add_to_cut[mask] = eval(pref_sums(aux));
	}
	
	// now we're ready to solve the problem!
	vector<int> ans(n);
	// iterate on the player we want to maximize
	for(int i = 0; i < n; i++)
	{
		// iterate on the suits they will maximize
		for(int j = 0; j < K; j++)
		{
			int d = min(remain[i], b[j]);
			int max_cards = a[i][j] + d;
			b[j] -= d;
			// find the maximum current score over all others
			min_vals.erase(min_vals.find(min_val[i]));
			int max_rival = *min_vals.rbegin();
			min_vals.insert(min_val[i]);
			if(max_rival >= max_cards)
				ans[i] = max(ans[i], 0);
			else
			{
				// binary search on the maximum cards over all
				// opponents
				int L = max_rival - 1;
				int R = max_cards;
				while(R - L > 1)
				{
					int mid = (L + R) / 2;
					long long min_cut = 1e18;
					long long req_flow = deck_size - remain[i];
					// iterate on the mask of suit vertices
					// which belong to S
					for(int mask = 0; mask < (1 << K); mask++)
					{
						int suits = __builtin_popcount(mask);
						long long cur_cut = 0;
						for(int z = 0; z < K; z++)
							if(!(mask & (1 << z)))
								cur_cut += b[z];
						cur_cut += add_to_cut[mask][mid];
						// don't forget to discard our player
						// from the flow network!
						if(mid > max_x[mask][i])
							cur_cut -= remain[i];
						else
						{
							long long add = mid * suits - already_has[mask][i];
							cur_cut -= add;
						}
						min_cut = min(min_cut, cur_cut);
					}
					if(min_cut < req_flow)
						L = mid;
					else
						R = mid;
				}
				ans[i] = max(ans[i], max_cards - R);
			}
			b[j] += d;
		}
	}
	
	for(int i = 0; i < n; i++)
		printf("%d ", ans[i]);
	puts("");
}
 
int main()
{
	int t = 1;
	for(int i = 0; i < t; i++) solve();
}
--------------------------------------------------
Problem ID: 1861E
Editorial Content:
1861E - Non-Intersecting Subpermutations
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
const int MOD = 998244353;
 
int add(int x, int y)
{
	x += y;
	while(x >= MOD) x -= MOD;
	while(x < 0) x += MOD;
	return x;
}
 
int sub(int x, int y)
{
	return add(x, -y);
}
 
int mul(int x, int y)
{
	return (x * 1ll * y) % MOD;
}
 
int binpow(int x, int y)
{
	int z = 1;
	while(y > 0)
	{
		if(y & 1) z = mul(z, x);
		x = mul(x, x);
		y /= 2;
	}
	return z;
}
 
int main()
{
	int n, k;
	cin >> n >> k;
	int ans = 0;
	vector<vector<int>> dp(n + 1, vector<int>(k, 0));
	dp[0][0] = 1;
	for(int i = 0; i < n; i++)
	{
		int cur = 0;
		for(int j = k - 1; j >= 1; j--)
		{
			cur = add(cur, dp[i][j]);
			dp[i + 1][j] = cur;
		}
		for(int j = k - 1; j >= 0; j--)
		{
			int nxt = (j + 1) % k;
			dp[i + 1][nxt] = add(dp[i + 1][nxt], mul(dp[i][j], k - j));
		}
		ans = add(ans, mul(dp[i + 1][0], binpow(k, n - (i + 1))));
	}
	cout << ans << endl;
}
--------------------------------------------------
Problem ID: 1861D
Editorial Content:
1861D - Sorting By Multiplication
Tutorial
Tutorial is loading...
Solution (Roms)
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 200 * 1000 + 5;
 
int t;
int n;
int a[N];
 
int main() {
    cin >> t;
    for (int tc = 0; tc < t; ++tc){
    	cin >> n;
    	for (int i = 0; i < n; ++i)
    	    cin >> a[i];
    	
    	int cnt = 0;
    	for (int i = 1; i < n; ++i)
    	    cnt += (a[i - 1] >= a[i]);
    	    
    	int res = n, cnt2 = 0;
        for (int i = 0; i <= n; ++i) {
            bool isMultipliedByNegative = (i > 0);
            res = min(res, isMultipliedByNegative + cnt + cnt2);
            
            if (i + 1 < n)
                cnt -= (a[i] >= a[i + 1]);
            if (i > 0)
                cnt2 += (a[i - 1] <= a[i]);
        }
        
        cout << res << endl;
    }
}
--------------------------------------------------
Problem ID: 1861C
Editorial Content:
1861C - Queries for the Array
Tutorial
Tutorial is loading...
Solution 1 (Roms)
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 200000;
 
int main() {
    int t;
    cin >> t;
    for (int tc = 0; tc < t; ++tc) {
        string s;
        cin >> s;
        int maxSortedPref = 0;
        int minNotSortedPref = 0;
        int bal = 0;
        bool good = true;
        
        for (auto c : s) {
            if (c == '+') {
                ++bal;
            } else if (c == '-') {
                --bal;
                maxSortedPref = min(maxSortedPref, bal);
                if (bal < minNotSortedPref)
                    minNotSortedPref = 0;
            } else if (c == '1') {
                maxSortedPref = max(maxSortedPref, bal);
            } else {
                if (bal <= 1) {
                    good = false;
                    break;
                }
                if (minNotSortedPref == 0 || minNotSortedPref > bal)
                    minNotSortedPref = bal;
            }
            if(minNotSortedPref <= maxSortedPref && minNotSortedPref != 0) {
                good = false;
                break;
            }
        }
        
        if (good)
            puts("YES");
        else
            puts("NO");
    }
    return 0;
}
Solution 2 (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
vector<int> has0, has1;
vector<vector<int>> g;
 
bool ans;
 
bool dfs(int x, int d)
{
	if(has0[x] && (has1[x] || d <= 1))
		ans = false;
	bool res = false;
	for(auto y : g[x])
		res |= dfs(y, d + 1);
	if(has0[x] && res)
		ans = false;
	return res || has1[x];
}
 
void solve()
{
	ans = true;
	has0.push_back(0);
	has1.push_back(0);
	g.push_back(vector<int>());
	int ts = 1;
	
	string s;
	cin >> s;
	vector<int> st = {0};
	for(auto x : s)
	{
		int cur = st.back();
		if(x == '0')
			has0[cur] = 1;
		if(x == '1')
			has1[cur] = 1;
		if(x == '+')
		{
			g[cur].push_back(ts);
			st.push_back(ts);
			ts++;
			has0.push_back(0);
			has1.push_back(0);
			g.push_back(vector<int>());
		}
		if(x == '-')
			st.pop_back();
	}
	
	dfs(0, 0);
	cout << (ans ? "YES\n" : "NO\n");
	
	has0.clear();
	has1.clear();
	g.clear();
}
 
int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	int t;
	cin >> t;
	for(int i = 0; i < t; i++)
		solve();
}
--------------------------------------------------
Problem ID: 1861B
Editorial Content:
1861B - Two Binary Strings
Tutorial
Tutorial is loading...
Solution (Roms)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int t;
    cin >> t;
    for (int tc = 0; tc < t; ++tc) {
        string a, b;
        cin >> a >> b;
        bool ok = false;
        for (int i = 0; i + 1 < a.size(); ++i) {
            if (a[i] == b[i] && a[i] == '0' && a[i + 1] == b[i + 1] && a[i + 1] == '1') {
                ok = true;
            }
        }
        
        if (ok) 
            puts("YES");
        else
            puts("NO");
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1861A
Editorial Content:
1861A - Prime Deletion
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
int main()
{
	int t;
	cin >> t;
	for(int i = 0; i < t; i++)
	{
		string s;
		cin >> s;
		if(s.find("1") < s.find("3"))
			cout << 13;
		else
			cout << 31;
		cout << endl;
	}
}
--------------------------------------------------
Problem ID: 1860F
Editorial Content:
1860F - Evaluate RBS
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
using namespace std;
 
const int INF = 1e9;
 
struct bracket{
	int a, b, c;
};
 
struct point{
	int x, y;
};
 
long long cross(const point &a, const point &b){
	return a.x * 1ll * b.y - a.y * 1ll * b.x;
}
 
long long dot(const point &a, const bracket &b){
	return a.x * 1ll * b.a + a.y * 1ll * b.b;
}
 
bool operator <(const point &a, const point &b){
	return cross(a, b) > 0;
}
 
int main() {
	int t;
	cin >> t;
	while (t--){
		int n;
		cin >> n;
		vector<bracket> val;
		forn(i, 2 * n){
			int a, b;
			string c;
			cin >> a >> b >> c;
			val.push_back({a, b, c[0] == '(' ? 1 : -1});
		}
		map<point, vector<int>> opts;
		forn(i, 2 * n) forn(j, 2 * n){
			int dx = val[i].b - val[j].b;
			int dy = val[j].a - val[i].a;
			if (dx <= 0 || dy <= 0) continue;
			opts[{dx, dy}].push_back(i);
			opts[{dx, dy}].push_back(j);
		}
		opts[{1, INF}];
		vector<int> ord(2 * n), rord(2 * n);
		iota(ord.begin(), ord.end(), 0);
		sort(ord.begin(), ord.end(), [&](int i, int j){
			long long di = dot({INF, 1}, val[i]);
			long long dj = dot({INF, 1}, val[j]);
			if (di != dj) return di < dj;
			return val[i].c > val[j].c;
		});
		forn(i, 2 * n) rord[ord[i]] = i;
		int neg = 0, cur = 0;
		vector<int> bal(1, 0);
		for (int i : ord){
			cur += val[i].c;
			bal.push_back(cur);
			neg += cur < 0;
		}
		bool ans = neg == 0;
		vector<int> prv;
		for (auto it : opts){
			vector<int> tot = prv;
			for (int x : it.second) tot.push_back(x);
			sort(tot.begin(), tot.end(), [&](int i, int j){
				return rord[i] < rord[j];
			});
			tot.resize(unique(tot.begin(), tot.end()) - tot.begin());
			for (int x : tot) neg -= bal[rord[x] + 1] < 0;
			vector<int> tmp = tot;
			sort(tot.begin(), tot.end(), [&](int i, int j){
				long long di = dot(it.first, val[i]);
				long long dj = dot(it.first, val[j]);
				if (di != dj) return di < dj;
				return val[i].c > val[j].c;
			});
			vector<int> nrord(tot.size());
			forn(i, tot.size()) nrord[i] = rord[tmp[i]];
			forn(i, tot.size()) rord[tot[i]] = nrord[i];
			for (int x : tot){
				bal[rord[x] + 1] = bal[rord[x]] + val[x].c;
				neg += bal[rord[x] + 1] < 0;
			}
			if (neg == 0){
				ans = true;
				break;
			}
			prv = it.second;
		}
		puts(ans ? "YES" : "NO");
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1860E
Editorial Content:
1860E - Fast Travel Text Editor
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
 
using namespace std;
 
const int INF = 1e9;
const int AL = 26;
 
struct query{
	int f, t, ans;
};
 
struct edge{
	int u, w;
};
 
int main() {
	cin.tie(0);
	iostream::sync_with_stdio(false);
	string s;
	cin >> s;
	int n = s.size();
	
	int m;
	cin >> m;
	vector<query> a(m);
	forn(i, m){
		cin >> a[i].f >> a[i].t;
		--a[i].f, --a[i].t;
		a[i].ans = abs(a[i].f - a[i].t);
	}
	
	int k = n - 1 + AL * AL;
	vector<vector<edge>> g(k);
	forn(i, n - 1){
		int j = n - 1 + (s[i] - 'a') * AL + (s[i + 1] - 'a');
		g[i].push_back({j, 0});
		g[j].push_back({i, 1});
		if (i > 0){
			g[i].push_back({i - 1, 1});
			g[i - 1].push_back({i, 1});
		}
	}
	
	for (int st = n - 1; st < k; ++st){
		vector<int> d(k, INF);
		d[st] = 0;
		deque<int> q;
		q.push_back(st);
		while (!q.empty()){
			int v = q.front();
			q.pop_front();
			for (auto it : g[v]){
				if (d[it.u] <= d[v] + it.w) continue;
				d[it.u] = d[v] + it.w;
				if (it.w == 0) q.push_front(it.u);
				else q.push_back(it.u);
			}
		}
		forn(i, m){
			a[i].ans = min(a[i].ans, d[a[i].f] + d[a[i].t] - 1);
		}
	}
	
	forn(i, m) cout << a[i].ans << '\n';
	return 0;
}
--------------------------------------------------
Problem ID: 1860D
Editorial Content:
1860D - Balanced String
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
using li = long long;
 
const int N = 111;
 
int n;
string s;
int dp[2][N][N * N];
 
int main() {
  cin >> s;
  n = s.size();
  dp[0][0][0] = 0;
  for (int i = 0; i < n; ++i) {
    for (int j = 0; j <= i + 1; ++j) {
      for (int cnt = 0; cnt <= j * (i + 1 - j); ++cnt) {
        dp[1][j][cnt] = n;   
      }
    }
    for (int j = 0; j <= i; ++j) {
      for (int cnt = 0; cnt <= j * (i - j); ++cnt) {
        dp[1][j + 1][cnt] = min(dp[1][j + 1][cnt], dp[0][j][cnt] + (s[i] != '0'));
        dp[1][j][cnt + j] = min(dp[1][j][cnt + j], dp[0][j][cnt] + (s[i] != '1'));
      }
    } 
    swap(dp[0], dp[1]);
  }
  int cnt0 = count(s.begin(), s.end(), '0');
  cout << dp[0][cnt0][cnt0 * (n - cnt0) / 2] / 2 << '\n';
}
--------------------------------------------------
Problem ID: 1860C
Editorial Content:
1860C - Game on Permutation
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    int ans = 0;
    int mn = n + 1, mnWin = n + 1;
    while (n--) {
      int x;
      cin >> x;
      if (mn < x && x < mnWin) {
      	ans += 1;
      	mnWin = x;
      }
      mn = min(mn, x);
    }
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1860B
Editorial Content:
1860B - Fancy Coins
Tutorial
Tutorial is loading...
Solution 1 (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
int main()
{
	int t;
	cin >> t;
	for(int i = 0; i < t; i++)
	{
		int m, k, a1, ak;
		cin >> m >> k >> a1 >> ak;
		int taken_k = m / k;
		int taken_1 = m % k;
		int taken_fancy_1 = max(0, taken_1 - a1);
		int left_regular_1 = max(0, a1 - taken_1);
		int taken_fancy_k = max(0, taken_k - ak);
		int to_replace = min(left_regular_1 / k, taken_fancy_k);
		int ans = taken_fancy_1 + taken_fancy_k - to_replace;
		cout << ans << endl;
	}
}
Solution 2 (BledDest)
#include<bits/stdc++.h>
 
using namespace std;
 
int main()
{
	int t;
	cin >> t;
	for(int i = 0; i < t; i++)
	{
		int m, k, a1, ak;
		cin >> m >> k >> a1 >> ak;
		// function which calculates the number of fancy coins taken
		// if we take exactly x coins of value k
		auto f = [m, k, a1, ak](int x)
		{
			int taken_1 = m - k * x;
			return max(0, taken_1 - a1) + max(0, x - ak);
		};
		
		int lf = 0;
		int rg = m / k;
		while(rg - lf > 2)
		{
			int mid = (lf + rg) / 2;
			if(f(mid) < f(mid + 1))
				rg = mid + 1;
			else
				lf = mid;
		}
		int ans = 1e9;
		for(int i = lf; i <= rg; i++) ans = min(ans, f(i));
		cout << ans << endl;
	}
}
--------------------------------------------------
Problem ID: 1860A
Editorial Content:
1860A - Not a Substring
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
	string s;
	cin >> s;
	int n = s.size();
	string a, b;
	for (int i = 0; i < 2 * n; ++i) {
	  a += "()"[i & 1];
	  b += ")("[i < n];
	}
	if (a.find(s) == string::npos) {
	  cout << "YES\n" << a << '\n';
	} else if (b.find(s) == string::npos) {
	  cout << "YES\n" << b << '\n';
	} else {
	  cout << "NO\n";
	}
  }
}
--------------------------------------------------
Problem ID: 1859F
Editorial Content:
1859F - Teleportation in Byteland
Hints
Hint 1
How many times do we really need to take driving courses?
Hint 2
Can you think how would an optimal answer path look like?
Hint 3
Can you recalculate the distances required to get to a city from every vertex?
Hint 1
How many times do we really need to take driving courses?
Hint 2
Can you think how would an optimal answer path look like?
Hint 3
Can you recalculate the distances required to get to a city from every vertex?
Tutorial
Root the tree arbitrarily.
First, we can notice that there is no need to take driving courses more than $$$log{maxW}$$$ times.
Now, let's iterate for the number of driving courses we take from $$$0$$$ to $$$20$$$ ($$$2^{20} > 1000000$$$). For each number we solve separately.
Let us fix the number of taken as $$$q$$$. Now the path looks like the following: we go over the simple path, then we veer off to take courses in some town, then we come back to the path and finish it. Let's call $$$d[x]$$$ the minimum distance required to get from $$$x$$$ to a town which offers driving courses and then come back to the same town. We can recalculate $$$d[x]$$$ with multi-source BFS.
Now, let's look at the vertex $$$v1$$$ on the path, from which we will start going off the path. Then, the cost of the path is $$$d[v1]$$$ + distance from $$$a$$$ to $$$v1$$$ on the original edges (with $$$c = 1$$$) + distance from $$$v1$$$ to $$$b$$$ on the modified edges(with $$$c = 2^{q}$$$).
Now let's look at some cases, let $$$LCA$$$ be the LCA of $$$a$$$ and $$$b$$$, $$$h1[x]$$$ — the sum of all original edges from the root downwards to $$$x$$$, $$$h2[x]$$$ — the sum of all modified edges from the root downwards to $$$x$$$.
If $$$v1$$$ is between $$$LCA$$$ and $$$a$$$, the cost is $$$h1[a] - h1[v1] + d1[v1] - h2[LCA] + h2[v1] + h2[b] - h2[LCA]$$$. If $$$v1$$$ is between $$$LCA$$$ and $$$a$$$, the cost is $$$h1[a] - h1[LCA] + h1[v1] - h1[LCA] + d1[v1] + h2[b] - h2[v1]$$$. Now we simply need to consider the terms which depend only on $$$v1$$$, and then we need to take the maximum value on a path. For that we can use binary lifting, and for LCA as well.
Author's code
#include <iostream>
#include <iomanip>
#include <fstream>
#include <vector>
#include <numeric>
#include <algorithm>
#include <set>
#include <map>
#include <cmath>
#include <stack>
#include <deque>
#include <string>
#include <ctime>
#include <bitset>
#include <queue>
#include <cassert>
#include<unordered_set>
#include<unordered_map>
#include<string.h>
#include <random>
#include <chrono>
#include <math.h>
using namespace std;
#define pi pair<int, int>
#define ll long long
#define pll pair<ll, ll>
const ll INF = 1e18;
vector<vector<pi>> g;
vector<int> is_special;
vector<vector<int>> bin_lift;
vector<vector<pi>> new_g;
vector<int> tin;
vector<int> tout;
vector<ll> ans;
vector<pi> req;
vector<ll> h_orig;
vector<ll> h_new;
vector<ll> d;
vector<bool> used_bfs;
vector<vector<pll>> bin_lift_2;
vector<int> lc;
vector<int> top_order;
vector<pair<int, int>> pr;
int TIMER = 0;
void DFS(int v, int p) {
    top_order.push_back(v);
    tin[v] = TIMER++;
    bin_lift[v][0] = p;
    for (int i = 1; i < 17; ++i) {
        if (bin_lift[v][i - 1] == -1) break;
        bin_lift[v][i] = bin_lift[bin_lift[v][i - 1]][i - 1];
    }
    for (auto& x : g[v]) {
        if (x.first == p) {
            pr.push_back(x);
            continue;
        }
    }
    for (auto& x : g[v]) {
        if (x.first == p) continue;
        h_orig[x.first] = h_orig[v] + x.second;
        DFS(x.first, v);
    }
    tout[v] = TIMER;
}
void BFS(int N) {
    priority_queue<pll> q;
    for (int i = 0; i < N; ++i) {
        if (is_special[i]) {
            q.push({ -0, i });
            d[i] = 0;
        }
    }
    while (!q.empty()) {
        int v = q.top().second; q.pop();
        if (used_bfs[v]) continue;
        used_bfs[v] = true;
        for (auto& x : new_g[v]) {
            if (d[x.first] > d[v] + x.second) {
                d[x.first] = d[v] + x.second;
                q.push({ -d[x.first], x.first });
            }
        }
    }
}
inline bool isIn(int a, int b) {
    return tin[a] <= tin[b] && tout[a] >= tout[b];
}
int gLCA(int a, int b) {
    if (isIn(a, b)) return a;
    if (isIn(b, a)) return b;
    int cB = b;
    for (int i = 16; i >= 0; --i) {
        if (bin_lift[cB][i] == -1) continue;
        if (!isIn(bin_lift[cB][i], a)) cB = bin_lift[cB][i];
    }
    return bin_lift[cB][0];
}
ll g1(int a, int LCA) {
    ll mn = d[a] + h_new[a] - h_orig[a];
    int cK = a;
    for (int i = 16; i >= 0; --i) {
        if (bin_lift[cK][i] == -1) continue;
        if (!isIn(LCA, bin_lift[cK][i])) continue;
        mn = min(mn, bin_lift_2[cK][i].first);
        cK = bin_lift[cK][i];
    }
    return mn;
}
ll g2(int a, int LCA) {
    ll mn = d[a] + h_orig[a] - h_new[a];
    int cK = a;
    for (int i = 16; i >= 0; --i) {
        if (bin_lift[cK][i] == -1) continue;
        if (!isIn(LCA, bin_lift[cK][i])) continue;
        mn = min(mn, bin_lift_2[cK][i].second);
        cK = bin_lift[cK][i];
    }
    return mn;
}
void solve() {
    top_order.clear();
    pr.clear();
    int N = 0, T = 0; cin >> N >> T;
    g.assign(N, vector<pi>());
    for (int j = 0; j < N - 1; ++j) {
        int u = 0, v = 0, w = 0; cin >> u >> v >> w;
        u--; v--;
        g[u].push_back({ v, w }); g[v].push_back({ u, w });
    }
    is_special.assign(N, 0);
    string s = ""; cin >> s;
    for (int i = 0; i < N; ++i) is_special[i] = s[i] - '0';
    tin.assign(N, 0); tout.assign(N, 0);
    bin_lift.assign(N, vector<int>(17, -1));
    TIMER = 0;
    h_orig.assign(N, 0);
    DFS(0, -1);
    int Q = 0; cin >> Q;
    ans.assign(Q, INF);
    req.clear();
    lc.clear();
    for (int j = 0; j < Q; ++j) {
        int u = 0, v = 0; cin >> u >> v;
        u--; v--;
        req.push_back({ u, v });
        lc.push_back(gLCA(u, v));
    }
    bin_lift_2.assign(N, vector<pll>(17, pll(INF, INF)));
    h_new.assign(N, 0);
    for (ll level = 1; level <= 20; ++level) {
        const int w = (1ll << level);
        new_g.assign(N, vector<pi>());
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < g[i].size(); ++j) {
                new_g[i].push_back({ g[i][j].first, g[i][j].second + ((g[i][j].second + w - 1) / w) });
            }
        }
        d.assign(N, INF);
        used_bfs.assign(N, false);
        BFS(N);
        h_new[0] = 0;
        for (int n = 1; n < N; ++n) {
            h_new[top_order[n]] = h_new[pr[n - 1].first] + (pr[n - 1].second + w - 1) / w;
            int p = pr[n - 1].first;
            int v = top_order[n];
            bin_lift_2[v][0] = { d[p] + h_new[p] - h_orig[p], d[p] + h_orig[p] - h_new[p] };
            for (int i = 1; i < 17; ++i) {
                if (bin_lift[v][i] == -1) break;
                bin_lift_2[v][i].first = min(bin_lift_2[v][i - 1].first, bin_lift_2[bin_lift[v][i - 1]][i - 1].first);
                bin_lift_2[v][i].second = min(bin_lift_2[v][i - 1].second, bin_lift_2[bin_lift[v][i - 1]][i - 1].second);
            }
        }
        for (int j = 0; j < Q; ++j) {
            int a1 = req[j].first; int b1 = req[j].second;
            int LCA = lc[j];
            ans[j] = min(ans[j], g1(a1, LCA) + h_orig[a1] - h_new[LCA] + h_new[b1] - h_new[LCA] + level * T);
            ans[j] = min(ans[j], g2(b1, LCA) + h_orig[a1] - h_orig[LCA] - h_orig[LCA] + h_new[b1] + level * T);
        }
    }
    for (int i = 0; i < Q; ++i) {
        ans[i] = min(ans[i], h_orig[req[i].first] + h_orig[req[i].second] - 2 * h_orig[lc[i]]);
        cout << ans[i] << "\n";
    }
}
 
signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cout << setprecision(12);
    int T = 1;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1859E
Editorial Content:
1859E - Maximum Monogonosity
Hints
Hint 1
Maybe we can relax some conditions?
Hint 2
Do we really need to always correctly calculate all sums?
Hint 3
Optimize the obvious dp.
Hint 1
Maybe we can relax some conditions?
Hint 2
Do we really need to always correctly calculate all sums?
Hint 3
Optimize the obvious dp.
Tutorial
Let's call the value of a segment $$$[l; r]$$$ $$$f(l, r) = abs(a_l - b_r) + abs(a_r - b_l)$$$.
Let's write $$$dp[n1][k1]$$$ — maximum value of segments of total length $$$k1$$$ that end before $$$n1$$$.
The obvious way to recalc is the following:
$$$dp[n1][k1] = max(dp[n1 - 1][k1], dp[n1 - l][k1 - l] + f(n1 - l + 1, n1), 1 \le l \le k1)$$$.
This works in $$$O(NK^2)$$$ and is too slow.
Now let's consider the following: instead of getting the absolute value of segment $$$[l; r]$$$, we consider the maximum of the following four combinations: $$$b_l - a_r + b_r - a_l$$$, $$$b_l - a_r - b_r + a_l$$$, $$$-b_l + a_r + b_r - a_l$$$, $$$-b_l + a_r - b_r + a_l$$$. We can see that this always gives us the correct answer to the absolute value, since we check all of the possibilities.
Now we can look at out dp states as a table, and notice that we recalc over the diagonal (we recalc over all states that have the same value of n1 — k1).
Now, for each "diagonal", we maintain four maximum combinations: $$$dp[n1][k1] + b_{k1} + a_{k1}, dp[n1][k1] - b_{k1} + a_{k1}, dp[n1][k1] + b_{k1} - a_{k1}, dp[n1][k1] - b_{k1} - a_{k1}$$$, and when we want to recalc state $$$dp[n2][k2]$$$, we just consider all of the four possibilities.
Author's code
#include <iostream>
#include <vector>
using namespace std;
const long long INF = 1e18;
#define int long long
 
void solve() {
	int N = 0, K = 0; cin >> N >> K;
	vector<int> a;
	vector<int> b;
	a.assign(N, 0);
	b.assign(N, 0);
	for (int i = 0; i < N; ++i) {
		cin >> a[i];
	}
	for (int i = 0; i < N; ++i) {
		cin >> b[i];
	}
	vector<long long> mx1; // max of (b_l + a_l) + corresponding dp
	vector<long long> mx2; // max of (b_l - a_l) + corresponding dp
	vector<long long> mn1; // min of (b_l + a_l) + corresponding dp
	vector<long long> mn2; // min of (b_l - a_l) + corresponding dp
	vector<vector<long long>> dp;
	mx1.assign(N + 1, -INF); mx2.assign(N + 1, -INF);
	mn1.assign(N + 1, INF); mn2.assign(N + 1, INF);
	dp.assign(N + 1, vector<long long>(K + 1, 0));
	for (int i = 0; i <= N; ++i) {
		for (int j = 0; j <= min(i, K); ++j) {
			if (i != 0) dp[i][j] = dp[i - 1][j];
			int diag_val = i - j;
			if (i != 0) {
				dp[i][j] = max(dp[i][j], b[i - 1] + a[i - 1] - mn1[diag_val]);
				dp[i][j] = max(dp[i][j], -b[i - 1] - a[i - 1] + mx1[diag_val]);
				dp[i][j] = max(dp[i][j], a[i - 1] - b[i - 1] - mn2[diag_val]);
				dp[i][j] = max(dp[i][j], b[i - 1] - a[i - 1] + mx2[diag_val]);
			}
			if (i != N) {
				mn1[diag_val] = min(mn1[diag_val], b[i] + a[i] - dp[i][j]);
				mx1[diag_val] = max(mx1[diag_val], b[i] + a[i] + dp[i][j]);
				mn2[diag_val] = min(mn2[diag_val], b[i] - a[i] - dp[i][j]);
				mx2[diag_val] = max(mx2[diag_val], b[i] - a[i] + dp[i][j]);
			}
		}
	}
	cout << dp[N][K] << "\n";
}
 
 
signed main() {
	int T = 1;
	cin >> T;
	while (T--) {
		solve();
	}
}
--------------------------------------------------
Problem ID: 1859D
Editorial Content:
1859D - Andrey and Escape from Capygrad
Hints
Hint 1
What if we use greedy a bit?
Hint 2
Where it is always beneficial to teleport?
Hint 3
Use scanline
Hint 1
What if we use greedy a bit?
Hint 2
Where it is always beneficial to teleport?
Hint 3
Use scanline
Tutorial
Statement: It is always beneficial to teleport to point $$$b_i$$$.
Proof: Let's assume that we were able to teleport from point $$$X$$$ to the right of $$$b_i$$$, but not from $$$b_i$$$. Then we used some segment $$$A$$$ that covers point $$$X$$$, but does not cover point $$$b$$$, and ends to the right of $$$b$$$. This is a contradiction.
Let $$$ans_i$$$ be the maximum coordinate we can reach while being on segment $$$i$$$, and let $$$p_j$$$ be the answer to the $$$j$$$-th query. Then we notice that the answer to query $$$p_j = \max(x_j, \max_{i = 1}^n {ans_i \vert l_i \le x_j \le r_i})$$$.
We will use the scanline method from the end. Events: $$$l_i$$$, $$$b_i$$$, $$$r_i$$$, $$$x_j$$$.
We notice that events of type $$$r_i$$$ are not important to us when scanning from the end (according to statement number 1). It is important for us that we process events of type $$$b_i$$$ first, then events of type $$$x_j$$$, and then events of type $$$l_i$$$ (closing the segment in the scanline).
We will go through the events of the scanline, processing them in the order of $$$b_i$$$, then events of type $$$x_j$$$, and then events of type $$$l_i$$$.
We assume that there is a data structure that allows us to add elements, remove elements, and quickly output the maximum.
For each event of type $$$b_i$$$, update the value of $$$ans_i$$$ — take the maximum value of $$$ans$$$ of all open segments from the structure.
For each event of type $$$x_j$$$, update the value of $$$p_j$$$ — take the maximum value of $$$ans$$$ of all open segments from the structure, as well as $$$x_j$$$.
For each event of type $$$l_i$$$, remove $$$ans_i$$$ from the structure.
We notice that to solve this problem, we can use the std::multiset} container, which automatically sorts elements in ascending order. We can store in $$$multiset$$$ $$$ans_i$$$ of all open segments. And then, when processing events, extract the maximum from $$$multiset$$$, all operations are performed in $$$O(\log n)$$$. This allows us to solve the problem in $$$O((n + q) \log n)$$$ time and $$$O(n)$$$ memory.
Author's code
#include <iostream>
#include <vector>
#include <set>
#include <iomanip>
#include <cmath>
#include <algorithm>
#include <map>
#include <stack>
#include <cassert>
#include <unordered_map>
#include <bitset>
#include <random>
#include <unordered_set>
#include <chrono>
 
using namespace std;
 
#define all(a) a.begin(), a.end()
 
void solve() {
    int n;
    cin >> n;
 
    vector<int> ans(n);
    vector<tuple<int, int, int>> events;
    for (int i = 0 ; i < n ; i++) {
        int l, r, a, b;
        cin >> l >> r >> a >> b;
        ans[i] = b;
        events.emplace_back(b, 1, i);
        events.emplace_back(l, -1, i);
    }
    int q;
    cin >> q;
    vector<int> queries(q);
    for (int i = 0 ; i < q ; i++) {
        int x;
        cin >> x;
        queries[i] = x;
        events.emplace_back(x, 0, i);
    }
 
    sort(all(events));
    reverse(all(events));
    multiset<int> s;
    for (auto [x, type, ind] : events) {
        if (type == 1) {
            if (!s.empty()) {
                ans[ind] = *s.rbegin();
            }
            s.insert(ans[ind]);
        } else if (type == 0) {
            if (!s.empty()) {
                queries[ind] = max(queries[ind], *s.rbegin());
            }
        } else {
            s.extract(ans[ind]);
        }
    }
 
    for (auto el : queries)
        cout << el << " ";
    cout << "\n";
}
 
signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
 
    int t = 1;
    cin >> t;
    while (t--)
        solve();
 
    return 0;
}
--------------------------------------------------
Problem ID: 1859C
Editorial Content:
1859C - Another Permutation Problem
Hints
Hint 1
What if we fix the maximum element in the resulting array?
Hint 2
Try using greedy.
Hint 3
Optimize the log factor away by noticing a certain fact.
Hint 1
What if we fix the maximum element in the resulting array?
Hint 2
Try using greedy.
Hint 3
Optimize the log factor away by noticing a certain fact.
Tutorial
Let's fix the maximum element in an array — let it be $$$M$$$. Now, let's iterate from $$$n$$$ to $$$1$$$. Let the current chosen number be $$$i$$$. I claim that if we maintain the remaining available numbers to multiply by, then it is optimal to take the maximum such number $$$x$$$ that $$$x * i \le M$$$.
Proof: let's say that this is not correct. Then, let's say that we pair $$$i$$$ with another number $$$x1$$$, and $$$x$$$ gets paired with some other number $$$i1$$$. Then, $$$i1 < i$$$, because it was chosen later, and $$$x1 < x$$$ (otherwise $$$i * x1 > M$$$). Now let's swap $$$x$$$ with $$$x1$$$. The sum is increased by $$$i * x - i * x1 - i1 * x + i1 * x1 = (i - i1)(x - x1) > 0$$$, and all of the numbers are less or equal to $$$M$$$.
Now the task can be solved in $$$O(N^3logN)$$$ by simply iterating on the maximum from $$$N^2$$$ to $$$1$$$, while maintaining the remaining numbers with a set. In order to squeeze it in the TL, you can only consider such maximums that they can be represented as $$$i * j, 1 \le i, j \le n$$$.
In order to optimize it to $$$O(N^3)$$$, let's notice that for each number $$$x$$$, it can be paired with any number from $$$1$$$ to $$$\frac{M} {x}$$$. Now just maintain a stack of all available elements at the current moment, add all numbers that possible, and pop the maximum number for all $$$i$$$ from $$$1$$$ to $$$N$$$.
Author's code
#include <iostream>
#include <algorithm>
#include <set>
#include <stack>
#include <vector>
using namespace std;
void solve() {
	int N = 0; cin >> N;
	int ans = 0;
	vector<int> pr;
	pr.assign(N * N, -1);
	for (int i = 1; i <= N; ++i) {
		for (int j = 1; j <= N; ++j) {
			pr[i * j - 1] = 1;
		}
	}
	for (int mx = N * N; mx >= 1; --mx) {
		if (pr[mx - 1] == -1) continue;
		vector<vector<int>> a;
		int curans = -mx;
		bool br = false;
		a.assign(N, vector<int>());
		for (int j = N; j >= 1; --j) {
			int num = min(mx / j, N);
			if (num < 1) {
				br = true;
				break;
			}
			a[num - 1].push_back(j);
		}
		if (br) break;
		stack<int> s;
		for (int i = 0; i < N; ++i) {
			s.push(i + 1);
			bool brk = false;
			for (auto x : a[i]) {
				if (s.empty()) {
					brk = true; break;
				}
				curans += s.top() * x;
				s.pop();
			}
			if (brk) break;
		}
		ans = max(ans, curans);
	}
	cout << ans << "\n";
}
 
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	int t = 0; cin >> t;
	while (t--) solve();
	return 0;
}
--------------------------------------------------
Problem ID: 1859B
Editorial Content:
1859B - Olya and Game with Arrays
Hints
Hint 1
Do all numbers in a single array really matter?
Hint 2
If only the first minimum and the second minimum matter, what is the only way to increase a single array's beauty?
Hint 3
What can we say about the array which will have the smallest number in the end?
Hint 1
Do all numbers in a single array really matter?
Hint 2
If only the first minimum and the second minimum matter, what is the only way to increase a single array's beauty?
Hint 3
What can we say about the array which will have the smallest number in the end?
Tutorial
To increase the answer for each array separately, it is necessary to move the minimum to another array. Then, notice that it is optimal to move all the minimums to one array. Let's figure out which array. After moving the minimum from an array, the second minimum in the original array becomes the new minimum. Then, it is easy to notice that it is optimal to move all the minimums to the array with the smallest second minimum. After all the movements, we will have one array where the minimum element is the smallest number among all the arrays, and $$$n-1$$$ arrays where the minimum element is the second minimum in the original array.
Therefore, the answer to the problem will be $$$M + K - S$$$, where $$$M$$$ is the minimum element among all the arrays, $$$K$$$ is the sum of all the second minimums, and $$$S$$$ is the smallest second minimum.
Author's code
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
 
using namespace std;
 
#define all(v) v.begin(), v.end()
 
typedef long long ll;
 
const int INF = 1e9 + 7;
 
void solve() {
    int n;
    cin >> n;
 
    int minn = INF;
    vector<int> min2;
    for (int i = 0 ; i < n ; i++) {
        int m;
        cin >> m;
        vector<int> v(m);
        for (auto &el : v) cin >> el;
 
        int minel = *min_element(all(v));
        minn = min(minn, minel);
        v.erase(find(all(v), minel));
        min2.push_back(*min_element(all(v)));
    }
    cout << minn + (ll) accumulate(all(min2), 0ll) - *min_element(all(min2)) << "\n";
}
 
signed main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
 
#ifdef LOCAL
    freopen("a.in", "r", stdin);
#endif
 
    int t = 1;
    cin >> t;
    while (t--)
        solve();
 
    return 0;
}
--------------------------------------------------
Problem ID: 1859A
Editorial Content:
1859A - United We Stand
Hints
Hint 1
What does it mean that $$$A$$$ divides $$$B$$$?
Hint 1
What does it mean that $$$A$$$ divides $$$B$$$?
Tutorial
First, if all numbers are equal, then there is no answer (since $$$a$$$ is divisible by $$$a$$$, if both arrays are non-empty, then $$$c_1$$$ is a divisor of $$$b_1$$$).
Second, if $$$a$$$ is divisible by $$$b$$$ and they are both natural numbers, then the following equality holds: $$$b \le a$$$ (by definition, if $$$a$$$ is divisible by $$$b$$$, then $$$a$$$ can be represented as $$$k \dot b$$$, where $$$k$$$ is a natural number).
Now we can place all instances of the smallest number into $$$b$$$, and all other numbers into $$$c$$$. It can be seen that such a construction always gives a valid answer.
Author's code
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
 
void solve() {
	int n = 0; cin >> n; 
	vector<int> inp; inp.assign(n, 0);
	for (auto& x : inp) cin >> x;
	sort(inp.begin(), inp.end());
	if (inp.back() == inp[0]) {
		cout << "-1\n";
		return;
	}
	else {
		int it = 0;
		while (inp[it] == inp[0]) it++;
		cout << it << " " << n - it << "\n";
		for (int j = 0; j < it; ++j) cout << inp[j] << " ";
		for (int j = it; j < n; ++j) cout << inp[j] << " ";
	}
}
 
int main() {
	int t = 0; cin >> t;
	while (t--) solve();
	return 0;
}
--------------------------------------------------
Problem ID: 1858E2
Editorial Content:
1858E2 - Rollbacks (Hard Version)
Tutorial
Tutorial is loading...
Code
#include <iostream>
#include <vector>
#include <numeric>
#include <set>

using namespace std;

const int maxn = 1e6 + 1;

int f[maxn];

int get(int i) {
    int ans = 0;
    while (i >= 0) {
        ans += f[i];
        i = (i & (i + 1)) - 1;
    }
    return ans;
}

void upd(int i, int x) {
    while (i < maxn) {
        f[i] += x;
        i = i | (i + 1);
    }
}

int a[maxn];
int rev[maxn];
set<int> ids[maxn];

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    fill(rev, rev + maxn, -1);
    fill(a, a + maxn, -1);
    int q;
    cin >> q;
    int ptr = -1;
    vector<pair<pair<int, int>, int>> changes;
    while (q--) {
        char t;
        cin >> t;
        if (t == '?') {
            cout << get(ptr) << endl;
        } else if (t == '+') {
            int x;
            cin >> x;
            int mem = a[ptr + 1];
            if (a[ptr + 1] != -1) {
                if (ids[a[ptr + 1]].size()) {
                    upd(*ids[a[ptr + 1]].begin(), -1);
                    ids[a[ptr + 1]].erase(ptr + 1);
                }
                if (ids[a[ptr + 1]].size()) {
                    upd(*ids[a[ptr + 1]].begin(), 1);
                }
            }
            a[ptr + 1] = x;
            if (a[ptr + 1] != -1) {
                if (ids[a[ptr + 1]].size()) {
                    upd(*ids[a[ptr + 1]].begin(), -1);
                }
                ids[x].insert(ptr + 1);
                if (ids[a[ptr + 1]].size()) {
                    upd(*ids[a[ptr + 1]].begin(), 1);
                }
            }
            ++ptr;
            changes.push_back({ { 1, mem }, -1 });
        } else if (t == '-') {
            int k;
            cin >> k;
            ptr -= k;
            changes.push_back({ { -1, k }, -1 });
        } else {
            if (changes.back().first.first == 1) {
                if (a[ptr] != -1) {
                    if (ids[a[ptr]].size()) {
                        upd(*ids[a[ptr]].begin(), -1);
                        ids[a[ptr]].erase(ptr);
                    }
                    if (ids[a[ptr]].size()) {
                        upd(*ids[a[ptr]].begin(), 1);
                    }
                }
                a[ptr] = changes.back().first.second;
                --ptr;
                if (a[ptr + 1] != -1) {
                    if (ids[a[ptr + 1]].size()) {
                        upd(*ids[a[ptr + 1]].begin(), -1);
                    }
                    ids[a[ptr + 1]].insert(ptr + 1);
                    if (ids[a[ptr + 1]].size()) {
                        upd(*ids[a[ptr + 1]].begin(), 1);
                    }
                }
            } else {
                ptr += changes.back().first.second;
            }
            changes.pop_back();
        }
    }
}
--------------------------------------------------
Problem ID: 1858E1
Editorial Content:

--------------------------------------------------
Problem ID: 1858D
Editorial Content:
1858D - Trees and Segments
Tutorial
Tutorial is loading...
Code
#include <bits/stdc++.h>

#define int long long

using namespace std;
using ll = long long;

void solve();

template<typename ...Args>
void println(Args... args) {
    apply([](auto &&... args) { ((cout << args << ' '), ...); }, tuple(args...));
    cout << '\n';
}

int32_t main() {
    cin.tie(nullptr);
    ios_base::sync_with_stdio(false);
    int t = 1;
    cin >> t;
    for (int tc = 0; tc < t; ++tc) {
        solve();
    }
    return 0;
}

void solve() {
    int n, k;
    cin >> n >> k;
    string s;
    cin >> s;
    vector<int> max0by1(n + 1, -1e9);
    vector<vector<int>> max0pref(n + 1, vector<int>(n + 1));
    vector<vector<int>> max0suf(n + 1, vector<int>(n + 1));
    for (int l = 0; l < n; ++l) {
        int cnt1 = 0;
        for (int r = l + 1; r <= n; ++r) {
            cnt1 += s[r - 1] == '1';
            max0pref[r][cnt1] = max(max0pref[r][cnt1], r - l);
            max0suf[l][cnt1] = max(max0suf[l][cnt1], r - l);
        }
    }
    for (int r = 0; r <= n; ++r) {
        for (int cnt = 0; cnt <= n; ++cnt) {
            if (r) max0pref[r][cnt] = max(max0pref[r][cnt], max0pref[r - 1][cnt]);
            if (cnt) max0pref[r][cnt] = max(max0pref[r][cnt], max0pref[r][cnt - 1]);
        }
    }
    for (int l = n; l >= 0; --l) {
        for (int cnt = 0; cnt <= n; ++cnt) {
            if (l + 1 <= n) max0suf[l][cnt] = max(max0suf[l][cnt], max0suf[l + 1][cnt]);
            if (cnt) max0suf[l][cnt] = max(max0suf[l][cnt], max0suf[l][cnt - 1]);
        }
    }
    vector<int> ans(n + 1, -1e9);
    for (int l = 0; l < n; ++l) {
        int cnt0 = 0;
        for (int r = l; r <= n; ++r) {
            if (r > l) cnt0 += s[r - 1] == '0';
            if (cnt0 > k) break;
            max0by1[r - l] = max(max0by1[r - l], max0pref[l][k - cnt0]);
            max0by1[r - l] = max(max0by1[r - l], max0suf[r][k - cnt0]);
        }
    }
    for (int i = 0; i <= n; ++i) {
        for (int a = 1; a <= n; ++a) ans[a] = max(ans[a], i + max0by1[i] * a);
    }
    for (int i = 1; i <= n; ++i) cout << ans[i] << ' ';
    cout << '\n';
}
--------------------------------------------------
Problem ID: 1858C
Editorial Content:
1858C - Yet Another Permutation Problem
Tutorial
Tutorial is loading...
Code
#include<iostream>
#include<vector>

using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n);
        int cur = 0;
        for (int i = 1; i <= n; i += 2) {
            for (int j = i; j <= n; j *= 2) {
                a[cur++] = j;
            }
        }
        for (int i = 0; i<n; ++i) {
            cout << a[i] << " ";
        }
        cout << '\n';
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1858B
Editorial Content:
1858B - The Walkway
Tutorial
Tutorial is loading...
Code
#include <bits/stdc++.h>

using namespace std;

int solve(int d, vector<int> x)
{
    int ans = 0;
    for (int i = 1; i < x.size(); i++)
    {
        ans += (x[i] - x[i - 1] - 1) / d;
    }
    ans += int(x.size()) - 2;
    return ans;
}

void solve()
{
    #define tests

    int n, m, d;
    cin >> n >> m >> d;
    vector<int> r(m);
    for (int i = 0; i < m; i++) cin >> r[i];
    r.insert(r.begin(), 1 - d);
    r.push_back(n + 1);

    int ans = 2e9;
    vector<int> res;
    for (int i = 1; i <= m; i++)
    {
        int A = r[i] - r[i - 1] - 1;
        int B = r[i + 1] - r[i] - 1;
        int C = r[i + 1] - r[i - 1] - 1;
        int D = C / d - (A / d + B / d);
        if (D < ans)
        {
            ans = D;
            res.clear();
        }
        if (D == ans)
        {
            res.push_back(r[i]);
        }
    }
    cout << ans + solve(d, r) - 1 << ' ' << res.size() << endl;
}

int main()
{
    int t = 1;
    #ifdef tests
    cin >> t;
    #endif
    while (t--)
    {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1858A
Editorial Content:
1858A - Buttons
Tutorial
Tutorial is loading...
Code
t = int(input())
for i in range(t):
    a, b, c = map(int, input().split())
    if c % 2 == 0:
        if a > b:
            print("First")
        else:
            print("Second")
    else:
        if b > a:
            print("Second")
        else:
            print("First")
--------------------------------------------------
Problem ID: 1857G
Editorial Content:
1857G - Counting Graphs
Tutorial
Tutorial is loading...
Code C++
#include<bits/stdc++.h>
using namespace std;
const int N=200000,mod=998244353;
int p[N+1],sz[N+1];
struct edge
{
    int u,v,w;
    void read(){cin>>u>>v>>w;}
    bool operator<(edge x){return w<x.w;}
}a[N+1];
int leader(int v)
{
    if(p[v]==v)return v;
    else return p[v]=leader(p[v]);
}
void unite(int u,int v)
{
    u=leader(u);
    v=leader(v);
    p[u]=v;
    sz[v]+=sz[u];
}
long long binpow(long long a,long long n)
{
    if(n==0)return 1;
    if(n%2==0)return binpow(a*a%mod,n/2);
    else return a*binpow(a,n-1)%mod;
}
int main()
{
    int t;cin>>t;
    while(t--)
    {
        int n,S;cin>>n>>S;
        for(int i=1;i<=n;i++)p[i]=i,sz[i]=1;
        for(int i=0;i<n-1;i++)a[i].read();
        sort(a,a+n-1);
        long long ans=1;
        for(int i=0;i<n-1;i++)
        {
            int sub_u=sz[leader(a[i].u)];
            int sub_v=sz[leader(a[i].v)];
            ans=ans*binpow(S-a[i].w+1,1ll*sub_u*sub_v-1)%mod;
            unite(a[i].u,a[i].v);
        }
        cout<<ans<<"\n";
    }
}
Code Python
mod=998244353
def find_(v):
    stack=[v]
    while dsu[v]!=v:
        stack.append(dsu[v])
        v=stack[-1]
    while stack:
        dsu[stack[-1]]=dsu[v]
        v=stack.pop()
    return dsu[v]
 
for i in range(int(input())):
    n,S=map(int,input().split())
    l=[tuple(map(int,input().split()))for i in range(n-1)]
    l.sort(key=lambda x:x[2])
    ans=1
    dsu=[i for i in range(n)]
    coun=[1]*n
    for a,b,c in l:
        a-=1;b-=1
        if find_(a)!=find_(b):
            ans=ans*pow(S-c+1,coun[dsu[a]]*coun[dsu[b]]-1,mod)
            ans%=mod
            coun[dsu[a]]+=coun[dsu[b]]
            coun[dsu[b]]=0
            dsu[b]=dsu[a]
    print(ans)
Rate the problem
Good task
Average task
Bad task
Didn't solve
--------------------------------------------------
Problem ID: 1857F
Editorial Content:
1857F - Sum and Product
Tutorial
Tutorial is loading...
Code C++
#include<bits/stdc++.h>
using namespace std;
map<long long,int>cnt;
long long my_sqrt(long long a)
{
    long long l=0,r=5000000001;
    while(r-l>1)
    {
        long long mid=(l+r)/2;
        if(1ll*mid*mid<=a)l=mid;
        else r=mid;
    }
    return l;
}
long long get(int b,long long c)
{
    long long D=1ll*b*b-4ll*c;
    if(D<0)return 0;
    long long x1=(b-my_sqrt(D))/2;
    long long x2=(b+my_sqrt(D))/2;
    if(x1+x2!=b||x1*x2!=c)return 0;
    if(x1==x2)return 1ll*cnt[x1]*(cnt[x1]-1)/2ll;
    else return 1ll*cnt[x1]*cnt[x2];
}
int main()
{
    int t;cin>>t;
    while(t--)
    {
        int n;cin>>n;
        cnt.clear();
        for(int i=1;i<=n;i++)
        {
            int x;cin>>x;
            cnt[x]++;
        }
        int q;cin>>q;
        for(int i=0;i<q;i++)
        {
            int b;long long c;
            cin>>b>>c;
            cout<<get(b,c)<<" \n"[i==q-1];
        }
    }
}
Code Python
from collections import Counter
from math import sqrt
 
for _ in range(int(input())):
    n=int(input())
    a=[*map(int,input().split())]
    d=Counter(map(str,a))
    for i in range(int(input())):
        x,y=map(int,input().split())
        if x*x-4*y<0:print(0);continue
        D=int(sqrt(x*x-4*y))
        x1=(x+D)//2
        x2=(x-D)//2
        if x1+x2!=x or x1*x2!=y:print(0);continue
        if x1!=x2:print(d[str(x1)]*d[str(x2)])
        else:print(d[str(x1)]*(d[str(x1)]-1)//2)
Rate the problem
Good task
Average task
Bad task
Didn't solve
--------------------------------------------------
Problem ID: 1857E
Editorial Content:
1857E - Power of Points
Tutorial
Tutorial is loading...
Code C++
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
pair<int,int>x[N];
long long a[N];
int main()
{
    int t;cin>>t;
    while(t--)
    {
        int n;cin>>n;
        long long s1=0,s2=0;
        for(int i=1;i<=n;i++)
        {
            cin>>x[i].first;
            x[i].second=i;
            s2+=x[i].first;
        }
        sort(x+1,x+n+1);
        for(int i=1;i<=n;i++)
        {
            s2-=x[i].first;
            s1+=x[i].first;
            a[x[i].second]=n+1ll*x[i].first*(2*i-n)-s1+s2;
        }
        for(int i=1;i<=n;i++)cout<<a[i]<<" \n"[i==n];
    }
}
Code Python
for i in range(int(input())):
    n=int(input())
    a=sorted([(b,i)for i,b in enumerate(map(int,input().split()))])
    ans=[0]*n
    s1=0
    s2=sum(a[i][0] for i in range(n))
    for i in range(n):
        ans[a[i][1]]=s2-a[i][0]*(n-i)+n-i+a[i][0]*i-s1+i
        s1+=a[i][0]
        s2-=a[i][0]
    print(*ans)
Rate the problem
Good task
Average task
Bad task
Didn't solve
--------------------------------------------------
Problem ID: 1857D
Editorial Content:
1857D - Strong Vertices
Tutorial
Tutorial is loading...
Code C++
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
int a[N],b[N];
int main()
{
    int t;cin>>t;
    while(t--)
    {
        int n;cin>>n;
        for(int i=1;i<=n;i++)cin>>a[i];
        for(int i=1;i<=n;i++)cin>>b[i];
        int mx=INT_MIN;
        for(int i=1;i<=n;i++)mx=max(mx,a[i]-b[i]);
        int c=0;
        for(int i=1;i<=n;i++)c+=(a[i]-b[i]==mx);
        cout<<c<<"\n";
        for(int i=1;i<=n;i++)if(a[i]-b[i]==mx)cout<<i<<' ';
        cout<<"\n";
    }
}
Code Python
for _ in range(int(input())):
    n=int(input())
    a=[*map(int,input().split())]
    b=[*map(int,input().split())]
    c=[a[i]-b[i] for i in range(n)]
    mx=max(c)
    ans=[]
    for i in range(n):
        if c[i]==mx:ans.append(i+1)
    print(len(ans))
    print(*ans)
Rate the problem
Good task
Average task
Bad task
Didn't solve
--------------------------------------------------
Problem ID: 1857C
Editorial Content:
1857C - Assembly via Minimums
Tutorial
Tutorial is loading...
Code C++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;cin>>t;
    while(t--)
    {
        int n;cin>>n;
        int m=n*(n-1)/2,b[m];
        for(int i=0;i<m;i++)cin>>b[i];
        sort(b,b+m);
        for(int i=0;i<m;i+=--n)cout<<b[i]<<' ';
        cout<<"1000000000\n";
    }
}
Code Python
for _ in range(int(input())):
    n=int(input())
    l=sorted(map(int,input().split()))
    j=0
    for i in range(n-1,0,-1):
        print(l[j],end=' ')
        j+=i
    print(l[-1])
Rate the problem
Good task
Average task
Bad task
Didn't solve
--------------------------------------------------
Problem ID: 1857B
Editorial Content:
1857B - Maximum Rounding
Tutorial
Tutorial is loading...
Code C++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;cin>>t;
    while(t--)
    {
        string s;cin>>s;
        s='0'+s;
        int p=s.size();
        for(int i=s.size()-1;i>=0;i--)
        {
            if(s[i]>='5')s[i-1]++,p=i;
        }
        for(int i=(s[0]=='0');i<s.size();i++)
        {
            cout<<(i>=p?'0':s[i]);
        }
        cout<<"\n";
    }
}
Code Python
for i in range(int(input())):
    s=[0]+[*map(int,list(input()))]
    k=len(s)
    for i in range(len(s)-1,0,-1):
        if s[i]>4:s[i-1]+=1;k=i
    if s[0]!=0:print(s[0],end='')
    s=[*map(str,s)]
    print(''.join(s[1:k]+['0']*(len(s)-k)))
Rate the problem
Good task
Average task
Bad task
Didn't solve
--------------------------------------------------
Problem ID: 1857A
Editorial Content:
1857A - Array Coloring
Tutorial
Tutorial is loading...
Code C++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;cin>>t;
    while(t--)
    {
        int n;cin>>n;
        int cnt=0;
        for(int i=0;i<n;i++)
        {
            int x;cin>>x;
            if(x%2!=0)cnt++;
        }
        if(cnt%2==0)cout<<"YES\n";
        else cout<<"NO\n";
    }
}
Code Python
for i in range(int(input())):
    n=int(input())
    a=[*map(int,input().split())]
    cnt=0
    for i in range(n):
        if a[i]%2!=0:cnt+=1
    if cnt%2==0:print('YES')
    else:print('NO')
Rate the problem
Good task
Average task
Bad task
Didn't solve
--------------------------------------------------
Problem ID: 1856E2
Editorial Content:
1856E2 - PermuTree (hard version)
Hints
Hint 0
Read hints for the easy version.
Hint 1
For each $$$\operatorname{lca}(u, v)$$$, we actually need to do subset sum on the subtree sizes.
Hint 2
If there is a very subtree that is bigger than the sum of the sizes of the other subtrees, you don't have to do subset sum.
Hint 3
Optimize subset sum to $$$\mathcal{O}(s \sqrt s)$$$, where s is the sum of the sizes of the subtrees for some fixed $$$\operatorname{lca}(u, v)$$$.
Hint 4
Use bitset to optimize subset sum even more.
Hint 0
Read hints for the easy version.
Hint 1
For each $$$\operatorname{lca}(u, v)$$$, we actually need to do subset sum on the subtree sizes.
Hint 2
If there is a very subtree that is bigger than the sum of the sizes of the other subtrees, you don't have to do subset sum.
Hint 3
Optimize subset sum to $$$\mathcal{O}(s \sqrt s)$$$, where s is the sum of the sizes of the subtrees for some fixed $$$\operatorname{lca}(u, v)$$$.
Hint 4
Use bitset to optimize subset sum even more.
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define all(x) (x).begin(), (x).end()
#define allr(x) (x).rbegin(), (x).rend()
#define gsize(x) (int)((x).size())

const char nl = '\n';
typedef long long ll;
typedef long double ld;

using namespace std;

const int maxn = 1000000;

vector<int> g[maxn];
int s[maxn];
ll ans = 0;
vector<ll> b;
ll closest;

template <int len = 1>
void subset_sum(int n) {
    if (n >= len) {
        subset_sum<std::min(len*2, maxn)>(n);
        return;
    }
    
    bitset<len> dp;
    
    dp[0] = 1;
    for (ll x: b) {
        dp = dp | (dp << x);
    }
    
    ll cv = n;
    closest = 0;
    for (int i = 0; i <= n; i++) {
        if (dp[i] && abs(i - (n - i)) < cv) {
            closest = i;
            cv = abs(i - (n - i));
        }
    }
}

ll solve(vector<ll> &a) {
    if (a.empty()) return 0;
    
    sort(allr(a));
    ll cs = 0;
    for (ll x: a) cs += x;
    
    if (a[0] * 2 >= cs) {
        return a[0];
    }
    
    int n = gsize(a);
    a.push_back(0);
    
    b.clear();
    int pi = 0;
    for (int i = 1; i <= n; i++) {
        if (a[i] != a[i - 1]) {
            ll cnt = i - pi;
            ll x = a[i - 1];
            
            ll j = 1;
            while (j < cnt) {
                b.push_back(x * j);
                cnt -= j;
                j *= 2;
            }            
            b.push_back(x * cnt);

            pi = i;
        }
    }
    
    subset_sum(cs);
    return closest;
}

void dfs(int v, int p = -1) {
    vector<ll> a;
    s[v] = 1;
    
    for (int u: g[v]) {
        if (u == p) continue;
        dfs(u, v);
        s[v] += s[u];
        
        a.push_back(s[u]);
    }
    
    ll x = solve(a);
    ans += x * (s[v] - 1 - x);
    a.clear();
}

int main() {
	ios::sync_with_stdio(0); cin.tie(0);
    
    int n;
    cin >> n;
    for (int i = 1; i < n; i++) {
        int x;
        cin >> x;
        g[x - 1].push_back(i);
    }
    
    dfs(0);
    
    cout << ans << nl;
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1856E1
Editorial Content:
1856E1 - PermuTree (easy version)
Hints
Hint 1
Fix the value of $$$\operatorname{lca}(u, v)$$$.
Hint 2
You can solve the problem independently for each value of $$$\operatorname{lca}(u, v)$$$.
Hint 3
Do dynamic programming.
Hint 4
For each subtree of $$$\operatorname{lca}(u, v)$$$, we only care about how many vertices are $$$>$$$ or $$$<$$$ less than $$$a_{\operatorname{lca}(u, v)}$$$.
Hint 5
This dynamic programming solution can actually be made to work in $$$\mathcal{O}(n^2)$$$.
Hint 1
Fix the value of $$$\operatorname{lca}(u, v)$$$.
Hint 2
You can solve the problem independently for each value of $$$\operatorname{lca}(u, v)$$$.
Hint 3
Do dynamic programming.
Hint 4
For each subtree of $$$\operatorname{lca}(u, v)$$$, we only care about how many vertices are $$$>$$$ or $$$<$$$ less than $$$a_{\operatorname{lca}(u, v)}$$$.
Hint 5
This dynamic programming solution can actually be made to work in $$$\mathcal{O}(n^2)$$$.
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define all(x) (x).begin(), (x).end()
#define allr(x) (x).rbegin(), (x).rend()
#define gsize(x) (int)((x).size())

const char nl = '\n';
typedef long long ll;
typedef long double ld;

using namespace std;

const int maxn = 1000000;

vector<int> g[maxn];
int s[maxn];
ll ans = 0;

void dfs(int v, int p = -1) {
    vector<ll> a;
    s[v] = 1;
    
    for (int u: g[v]) {
        if (u == p) continue;
        dfs(u, v);
        s[v] += s[u];
        
        a.push_back(s[u]);
    }
    
    vector<ll> dp(s[v]);
    ll cs = 0;
    for (int x: a) {
        for (ll i = cs + x; i >= 0; i--) {
            for (ll pr = min(cs, i); pr >= max(0LL, i - x); pr--) {
                ll j = i - pr;
                dp[i] = max(dp[i], dp[pr] + j * (cs - pr) + pr * (x - j));
            }
        } 
        cs += x;
    }
    
    ans += *max_element(all(dp));
    dp.clear();
    a.clear();
}

int main() {
	ios::sync_with_stdio(0); cin.tie(0);
    
    int n;
    cin >> n;
    for (int i = 1; i < n; i++) {
        int x;
        cin >> x;
        g[x - 1].push_back(i);
    }
    
    dfs(0);
    
    cout << ans << nl;
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1856D
Editorial Content:
1856D - More Wrong
Hints
Hint 1
What can you say about index $$$j$$$ if the number of inversion in $$$[p_i, p_{i + 1}, \ldots, p_{j - 1}]$$$ is the same as in $$$[p_i, p_{i + 1}, \ldots, p_j]$$$?
Hint 2
Define a function to calculate $$$f(l, r)=$$$ the position of the maximum in $$$[p_l, p_{l + 1}, \ldots, p_{r}]$$$.
Hint 3
Divide and conquer.
Hint 1
What can you say about index $$$j$$$ if the number of inversion in $$$[p_i, p_{i + 1}, \ldots, p_{j - 1}]$$$ is the same as in $$$[p_i, p_{i + 1}, \ldots, p_j]$$$?
Hint 2
Define a function to calculate $$$f(l, r)=$$$ the position of the maximum in $$$[p_l, p_{l + 1}, \ldots, p_{r}]$$$.
Hint 3
Divide and conquer.
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define all(x) (x).begin(), (x).end()
#define allr(x) (x).rbegin(), (x).rend()
#define gsize(x) (int)((x).size())

const char nl = '\n';
typedef long long ll;
typedef long double ld;

using namespace std;

int query(int l, int r) {
    if (l == r) return 0;
    cout << "? " << l << ' ' << r << endl;
    
    int res;
    cin >> res;
    return res;
}

// Finds max on p[l; r]
int solve(int l, int r) {
    if (l == r) return l;
    
    int m = (l + r) / 2;
    int a = solve(l, m);
    int b = solve(m + 1, r);
    
    int r1, r2;
    r1 = query(a, b - 1);
    r2 = query(a, b);
    
    if (r1 == r2) {
        return b;
    } else {
        return a;
    }
}

void solve() {
    int n;
    cin >> n;
    
    int ans = solve(1, n);
    cout << "! " << ans << endl;
}

int main() {
	ios::sync_with_stdio(0); cin.tie(0);
    
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1856C
Editorial Content:
1856C - To Become Max
Hints
Hint 1
Binary search on the answer.
Hint 1.1
Check if it is possible to have $$$\max(a_1,\ldots, a_n) \ge x$$$ for some $$$x$$$.
Hint 2
Fix some possible index that will be the position of the maximum in the final array.
Hint 1
Binary search on the answer.
Hint 1.1
Check if it is possible to have $$$\max(a_1,\ldots, a_n) \ge x$$$ for some $$$x$$$.
Hint 1.1
Check if it is possible to have $$$\max(a_1,\ldots, a_n) \ge x$$$ for some $$$x$$$.
Hint 2
Fix some possible index that will be the position of the maximum in the final array.
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
#define all(x) (x).begin(), (x).end()
#define allr(x) (x).rbegin(), (x).rend()
#define gsize(x) (int)((x).size())
 
const char nl = '\n';
typedef long long ll;
typedef long double ld;
 
using namespace std;
 
void solve() {
    ll n, k;
    cin >> n >> k;
    
    vector<ll> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    ll lb = 0, ub = *max_element(all(a)) + k, ans = 0;
    while (lb <= ub) {
        ll tm = (lb + ub) / 2;
        bool good = false;
        
        for (int i = 0; i < n; i++) {
            vector<ll> min_needed(n);
            min_needed[i] = tm;
            
            ll c_used = 0;
            for (int j = i; j < n; j++) {
                if (min_needed[j] <= a[j]) break;
                
                if (j + 1 >= n) {
                    c_used = k + 1;
                    break;
                }
                
                c_used += min_needed[j] - a[j];
                min_needed[j + 1] = max(0LL, min_needed[j] - 1);
            }
            
            if (c_used <= k) good = true;
        }
        
        if (good) {
            ans = tm;
            lb = tm + 1;
        } else {
            ub = tm - 1;
        }
    }
    
    cout << ans << nl;
}
 
int main() {
	ios::sync_with_stdio(0); cin.tie(0);
	
	int T;
	cin >> T;
	while (T--) solve();
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1856B
Editorial Content:
1856B - Good Arrays
Hints
Hint 1
Consider the case $$$n = 1$$$ separately.
Hint 2
Count the number of elements equal to $$$1$$$.
Hint 3
Find the sum of the array.
Hint 4
When there are a lot of elements equal to $$$1$$$ and the sum is not very big, the answer is no.
Hint 1
Consider the case $$$n = 1$$$ separately.
Hint 2
Count the number of elements equal to $$$1$$$.
Hint 3
Find the sum of the array.
Hint 4
When there are a lot of elements equal to $$$1$$$ and the sum is not very big, the answer is no.
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define all(x) (x).begin(), (x).end()
#define allr(x) (x).rbegin(), (x).rend()
#define gsize(x) (int)((x).size())

const char nl = '\n';
typedef long long ll;
typedef long double ld;

using namespace std;

void solve() {
    int n;
    cin >> n;
    
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    ll sum_a = 0, cnt_1 = 0;
    for (int x: a) {
        sum_a += x;
        if (x == 1) cnt_1++;
    }
    
    if (sum_a >= cnt_1 + n && n > 1) {
        cout << "YES" << nl;
    } else {
        cout << "NO" << nl;
    }
}

int main() {
	ios::sync_with_stdio(0); cin.tie(0);
    
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1856A
Editorial Content:
1856A - Tales of a Sort
Hints
Hint 1
How many operations are needed to make $$$a_i \le a_{i + 1}$$$ if initially, $$$a_i > a_{i + 1}$$$?
Hint 1
How many operations are needed to make $$$a_i \le a_{i + 1}$$$ if initially, $$$a_i > a_{i + 1}$$$?
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define all(x) (x).begin(), (x).end()
#define allr(x) (x).rbegin(), (x).rend()
#define gsize(x) (int)((x).size())

const char nl = '\n';
typedef long long ll;
typedef long double ld;

using namespace std;

void solve() {
    int n;
    cin >> n;
    
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    int ans = 0;
    for (int i = 0; i < n - 1; i++) {
        if (a[i] > a[i + 1]) {
            ans = max(ans, a[i]);
        }
    }
    
    cout << ans << nl;
}

int main() {
	ios::sync_with_stdio(0); cin.tie(0);
    
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1855B
Editorial Content:
1855B - Longest Divisors Interval
Hint 1
What's the answer if $$$n$$$ is odd?
Hint 2
Try to generalize Hint 1.
Hint 3
What's the answer if $$$n$$$ is not a multiple of $$$3$$$?
Hint 4
If the answer is not a multiple of $$$x$$$, the answer is $$$< x$$$. If the answer is a multiple of $$$1, \dots, x$$$, the answer is $$$\geq x$$$.
Solution
Suppose you find a valid interval $$$[l, r]$$$. Note that the interval $$$[l, r]$$$ contains at least one multiple of $$$x$$$ for each $$$1 \leq x \leq r-l+1$$$ (you can find it out by looking at the values in $$$[l, r]$$$ modulo $$$x$$$). Then, the interval $$$[1, r-l+1]$$$ is also valid and has the same length.
So, it's enough to check intervals with $$$l = 1$$$, i.e., find the smallest $$$x$$$ that does not divide $$$n$$$. The answer is $$$x-1$$$.
Complexity: $$$O(\log(\max n))$$$
--------------------------------------------------
Problem ID: 1855A
Editorial Content:
1855A - Dalton the Teacher
Hint 1
What's the most efficient way to make the sad students happy?
Hint 2
In most cases, you can make $$$2$$$ sad students happy in $$$1$$$ move.
Solution
Let $$$s$$$ be the number of sad students at the beginning. The answer is $$$\lceil \frac{s}{2} \rceil$$$.
In one move, you can make at most $$$2$$$ sad students happy (because you can change the position of at most two students), so you need at least $$$\lceil \frac{s}{2} \rceil$$$ moves.
In fact, you can make everyone happy in exactly $$$\lceil \frac{s}{2} \rceil$$$ moves:
while there are at least $$$2$$$ sad students, you can swap them and both of them will be happy;
if there is exactly $$$1$$$ sad student left, you can swap it with any other student.
Complexity: $$$O(n)$$$
--------------------------------------------------
Problem ID: 1854F
Editorial Content:
1854F - Mark and Spaceship
Hint 1
Solve the 2d version first.
Hint 2
The 4d version is not too different from the 2d one.
Hint 3
Find all the points such that the expected number of necessary moves is wrong.
Solution
The $$$2$$$-dimensional case.
Let us begin by cpnsidering the $$$2$$$-dimensional version of the problem. The solution to this simpler version provides the idea of the approach for the $$$4$$$-dimensional version.
We want to reach $$$(a, b)$$$. Can we do it with exactly $$$k$$$ moves? Two simple necessary conditions are:
$$$|a|+|b|\le 1 + 2 + \cdots + k$$$,
$$$a+b$$$ and $$$1 + 2 + \cdots + k$$$ shall have the same parity.
It turns out that this two conditions are also sufficient! One can prove it by induction on $$$k$$$ as follows. If $$$k=0$$$ or $$$k=1$$$ or $$$k=2$$$ the statement is simple, thus we may assume $$$k\ge 3$$$.
Without loss of generality we may assume $$$0\le a\le b$$$. If $$$|a|+|b-k| \le 1 + 2 + \cdots + k-1$$$, then the statement follows by inductive hypothesis. Assume by contradiction that such inequality is false. If $$$b\ge k$$$ then we have a contradiction because $$$|a|+|b-k| = |a|+|b|-k \le (1 + 2 + \cdots + k) - k$$$. Otherwise $$$b < k$$$ and the contradiction is $$$|a|+|b-k| = a + k-b \le k \le 1 + 2 + \cdots + k-1$$$.
Hence, we have shown:
Lemma 1:
The point $$$(a, b)$$$ is reachable with exactly $$$k$$$ moves if and only if $$$|a|+|b| \le 1 + 2 + \cdots + k$$$ and $$$a+b$$$ has the same parity of $$$1+2+\cdots + k$$$.
The $$$4$$$-dimensional case.
One may expect statement analogous to the one of Lemma 1 to hold also when there are $$$4$$$ coordinates. It does not, but it
almost
does and this is the crucial idea of the solution. More precisely, the number of counter examples to such statement is rather small and we can find all of them. This is the intuition behind the following definition.
Definition:
For $$$k\ge 0$$$, let $$$A_k$$$ be the set of points $$$(a, b, c, d)$$$ such that $$$|a|+|b|+|c|+|d|\le 1 + 2 + \cdots + k$$$ and $$$a+b+c+d$$$ has the same parity of $$$1 + 2 + \cdots + k$$$ but $$$(a, b, c, d)$$$ is not reachable with exactly $$$k$$$ moves.
As an immediate consequence of the definition, we have
Observation:
The point $$$(a, b, c, d)$$$ is reachable with exactly $$$k$$$ moves if and only if $$$|a|+|b|+|c|+|d| \le 1 + 2 + \dots + k$$$ and $$$a+b+c+d$$$ has the same parity of $$$1+2+\cdots + k$$$ and $$$(a, b, c, d)\not\in A_k$$$.
Thanks to this observation, if one is able to efficiently find $$$A_k$$$ for all interesting values of $$$k$$$, then solving the problem is (comparatively) easy. The following lemma is our main tool for this purpose.
Lemma 2:
Assume that $$$(a, b, c, d) \in A_k$$$ with $$$0\le a\le b\le c\le d$$$. Then, either $$$k\le 6$$$ or $$$(a, b, c, d - k) \in A_{k-1}$$$.
Proof:
The strategy is the same adopted to show Lemma 1. In some sense, we are saying that the inductive step works also in dimension $$$4$$$, but the base cases don't.
If $$$|a|+|b|+|c|+|d-k|\le 1 + 2 + \cdots + k-1$$$, then it must be $$$(a, b, c, d-k)\in A_{k-1}$$$ because if $$$(a, b, c, d-k$$$ were reachable with $$$k-1$$$ moves then $$$(a, b, c, d)$$$ were reachable with $$$k$$$ and we know that this is not true.
Assume by contradiction that $$$|a|+|b|+|c|+|d-k|> 1 + 2 + \cdots + k-1$$$. If $$$d\ge k$$$ then we reach the contradiction $$$|a|+|b|+|c|+|d-k| = a+b+c+d-k \le (1 + 2 + \dots + k) - k$$$. Otherwise, $$$d < k$$$ and thus we reach the contradiction $$$|a|+|b|+|c|+|d-k| = a+b+c+k-d\le a+b+k\le 3k-2\le 1 + 2 + \dots + k-1$$$ (for $$$k\ge 7$$$).
We can now describe the solution. Assume that we know $$$A_{k-1}$$$. First of all, notice that it is then possible to determine in $$$O(1)$$$ whether a point belongs to $$$A_k$$$ or not. To generate a list of candidate elements for $$$A_k$$$ we proceed as follows:
If $$$k\le 6$$$, we simply iterate over all points with $$$|a|+|b|+|c|+|d|\le 1 + 2 + \cdots + k$$$.
Otherwise, we iterate over the points in $$$A_{k-1}$$$ and we consider as candidate elements for $$$A_k$$$ the points that can be obtained by changing the value of one coordinate by $$$k$$$.
Thanks to Lemma 2, we know that this process finds all the elements in $$$A_k$$$. Once $$$A_0, A_1, A_2, A_3,\dots$$$ are known, the problem boils down to a (relatively) simple counting argument that we skip.
One can verify that to handle correctly all points with coordinates up to $$$1000$$$ it is necessary to compute $$$A_k$$$ for $$$0\le k \le 62$$$.
One additional cheap trick is required to make $$$A_k$$$ sufficiently small and get a sufficiently fast solution. Given $$$(a, b, c, d)$$$, the instance of the problem is equivalent if we change the signs of the coordinates or we change the order of the coordinates. Hence we shall always ``normalize'' the point so that $$$0\le a \le b\le c\le d$$$. If we do this consistently everywhere in the process, the solution becomes an order of magnitude faster. In particular, this trick guarantees $$$|A_k|\le 5000$$$ for all $$$0\le k\le 62$$$.
Bonus question:
Find an explicit closed form for the elements in $$$A_k$$$ for any $$$k$$$. (in this way one can solve the problem also with larger constraints on $$$A, B, C, D$$$; but it is tedious)
--------------------------------------------------
Problem ID: 1854E
Editorial Content:
1854E - Game Bundles
Hint 1
Go for a randomized approach.
Hint 2
Many ones are useful.
Hint 3
Either you go for a greedy or for a backpack.
Solution
We describe a randomized solution that solves the problem for $$$m$$$ up to $$$10^{11}$$$ (and, with some additional care, may be able to solve also $$$m$$$ up to $$$10^{12}$$$). We decided to give the problem with the smaller constraint $$$m\le 10^{10}$$$ to make the problem more accessible and because there may be some rare cases below $$$10^{11}$$$ for which our solution is too slow (even though we could not find any). We don't know any provably correct solution, if you have one we would be curious to see it. We expect to see many different solutions for this problem.
Main idea:
Choose suitably the values $$$a_1, a_2, \dots, a_h$$$ that belong to $$$[1,29]$$$ and then find $$$a_{h+1}, a_{h+2},\dots,a_k$$$ in $$$[31,60]$$$ by solving a backpack-like problem.
Let us describe more precisely the main idea. Assume that $$$a_1, a_2, \dots, a_h\le 30$$$ are fixed and they satisfy $$$a_1+a_2+\cdots+a_h<60$$$. For any $$$s=0,1,2,\dots,29$$$, let $$$f(s)$$$ be the number of subsets $$$I\subseteq{1,2,\dots,h}$$$ so that $$$\sum_{i\in I}a_i=s$$$. If we can find some values $$$0\le s_1,s_2,\dots,s_{k-h}\le 29$$$ so that $$$f(s_1)+f(s_2)+\cdots+f(s_{k-h})=s$$$, then by setting $$$a_{h+i} = 60-s_i$$$ for $$$i=1,2,\dots, k-h$$$ we have found a valid solution to the problem.
There are two main difficulties:
How can we find $$$s_1, s_2,\dots, s_{k-h}$$$?
How should we choose $$$a_1, a_2,\dots, a_h$$$?
Since it is important to get a good intuitive understanding of the computational complexity of the algorithm, let us say now that we will choose $$$h\le 44$$$ and (accordingly) $$$k-h=16$$$. These values are flexible (the solution would still work with $$$h\le 45$$$ and $$$k-h=45$$$ for example). We will say something more about the choice of these values when we will describe how $$$a_1,a_2,\dots, a_h$$$ shall be chosen.
The backpack problem to find $$$s_1, s_2,\dots, s_{k-h}$$$.
The naive way to find $$$s_1,\dots, s_{k-h}$$$ would be to try all of them. There are $$$\binom{k-h + 29}{29}$$$ possible ways (up to order, which does not matter). Since $$$k-h=16$$$ this number is $$$\approx 2\cdot 10^{11}$$$ which is too much to fit in the time limit.
To speed up the process, we will do as follows. Partition randomly $$$A\cup B={0,1,\dots, 29}$$$ into two sets of size $$$15$$$. We iterate over all possible $$$s_1, s_2, \dots, s_{(k-h)/2}\in A$$$ and over all possible $$$s_{(k-h)/2+1},\dots, s_{k-h}\in B$$$ and check whether the sum of one choice from the first group and one choice from the second group yields the result. This is a standard optimization for the subset sum problem. What is its complexity? It can be implemented in linear time in the size of the two groups we have to iterate over, which have size $$$\binom{(k-h)/2+15}{15}\approx 5\cdot 10^5$$$. Notice that in this faster way we will not visit all the $$$\binom{k-h+29}{29}$$$ possible choices $$$s_1,s_2,\dots, s_{k-h}$$$ because we are assuming that exactly half of them belong to $$$A$$$ and exactly half of them belong to $$$B$$$. This is not a big deal because with sufficiently high probability we will find a solution in any case.
The choice of $$$a_1, a_2,\dots, a_{h}$$$.
It remains to decide how we should select $$$a_1, a_2, \dots, a_{h}$$$. The following choice works:
Approximately the first $$$\log_2(m)$$$ values are set equal to $$$1$$$.
Five additional values are chosen randomly from $$$[1, 6]$$$ so that the total sum stays below $$$60$$$.
One should repeat the whole process until a solution is found.
Some intuition on the construction.
The choice of $$$a_1, \dots, a_{h}$$$ may seem arbitrary; let us try to justify it. The goal is to generate a set of values $$$f(0), f(1),\dots, f(29)$$$ that are simultaneously ``random enough'' and with size smaller but comparable to $$$m$$$. These two conditions are necessary to expect that the backpacking problem finds a solution with high enough probability.
If $$$a_1=a_2=\cdots=a_{h}=1$$$, then $$$f(s) = \binom{k-h}{s}$$$ and these numbers have size comparable to $$$m$$$ if $$$2^{h}$$$ is comparable to $$$m$$$. This observation explains why we start with approximately $$$\log_2(m)$$$ ones. The issue is that we need some flexibility in the process as we may need to repeat it many times, this flexibility is provided by the addition of some additional random elements which don't change the magnitude of the values $$$f(0), f(1), \dots, f(29)$$$ but that modify them as much as possible (if we added a large number it would not affect many $$$f(s)$$$ and thus it would not be very useful).
--------------------------------------------------
Problem ID: 1854D
Editorial Content:
1854D - Michael and Hotel
Hint 1
You can find any $$$a_i$$$ in $$$9$$$ queries.
Hint 2
Find the nodes in the cycle in the component with node $$$1$$$. What happens if you know the whole cycle?
Hint 3
Suppose you already know some nodes in the cycle. Can you find other nodes faster?
Hint 4
Can you "double" the number of nodes in the cycle?
Solution
The component with node $$$1$$$ contains a cycle. If you know the whole cycle (of length $$$x$$$), you can win in $$$n-x$$$ queries by asking for each node if it ends up in the cycle after $$$n$$$ moves.
You can get a node in the cycle in $$$9$$$ queries, doing a binary search on the $$$n$$$-th successor of node $$$1$$$.
How to find the rest of the cycle?
First, find $$$k$$$ nodes in the cycle, doing a binary search on the successor of the last node found. These nodes make a set $$$C$$$.
Then, check for each node if it's "sufficiently close" to $$$C$$$, by asking $$$(i, k, C)$$$. Now, you know either $$$2k$$$ nodes in the cycle, or the whole cycle.
Repeat until you get the whole cycle.
If you choose $$$k = 63$$$, you spend at most $$$9 \cdot 63 + (500 - 63) + (500 - 126) + (500 - 252) + (500 - 252) = 1874$$$ queries.
--------------------------------------------------
Problem ID: 1854C
Editorial Content:
1854C - Expected Destruction
Hint 1
Consider $$$n$$$ blocks in positions $$$S_1, S_2, \dots, S_n$$$. After how much time does block $$$x$$$ disappear? It may be convenient to put a fake "static" block in position $$$m+1$$$.
Hint 2
Block $$$x$$$ disappears when it reaches block $$$x+1$$$. But what if block $$$x+1$$$ disappears before block $$$x$$$?
Hint 3
From the perspective of block $$$x$$$, it's convenient to assume that block $$$x+1$$$ never disappears: when it touches another block $$$y$$$, it's $$$y$$$ that disappears.
Hint 4
When you consider the pair of blocks $$$x, x+1$$$, the other blocks don't really matter, and you can use linearity of expectation to calculate the contribution of each pair independently.
A reasonable interpretation is given by considering an $$$(n+1) \times (m+1)$$$ grid, where the $$$i$$$-th row initially contains a block in column $$$S_i$$$. Then, you are calculating the expected time required for the blocks $$$1, \dots, m$$$ to have another block immediately below them (in the same column).
Hint 5
Blocks $$$x, x+1$$$ both move with probability $$$1/2$$$, unless block $$$x+1$$$ has reached position $$$m+1$$$.
Hint 6
$$$dp_{i,j} =$$$ expected number of moves of block $$$x$$$ before it disappears, if the block $$$x$$$ is in position $$$i$$$ and the block $$$x+1$$$ is in position $$$j$$$.
Solution
Consider an $$$(n+1) \times (m+1)$$$ grid, where the $$$i$$$-th row initially contains a block in column $$$S_i$$$, and row $$$n+1$$$ contains a block in column $$$m+1$$$.
The set is empty if all the blocks are in column $$$m+1$$$; i.e., if every block has reached the block in the following row.
Every "connected component" of blocks (except the last one) represents an element in the set. These components move equiprobably.
Let's calculate the expected time required for the block in row $$$x$$$ to "reach" the block in row $$$x+1$$$. If you consider a single pair of blocks, every block moves with probability $$$1/2$$$, unless block $$$x+1$$$ is in column $$$m+1$$$.
So, you can calculate $$$dp_{i,j} =$$$ expected number of moves of the block $$$x$$$ before it reaches the block $$$x+1$$$, if the block $$$x$$$ is in position $$$i$$$ and the block $$$x+1$$$ is in position $$$j$$$.
The base cases are $$$dp_{i,m+1} = (m+1)-i$$$ (because only the block $$$x$$$ can move) and $$$dp_{i,i} = 0$$$ (because block $$$x$$$ has already reached block $$$x+1$$$). In the other cases, $$$dp_{i,j} = ((dp_{i+1,j} + 1) + dp_{i,j+1})/2$$$.
By linearity of expectation, the answer is the sum of $$$dp_{S_i, S_{i+1}}$$$.
Complexity: $$$O(m^2)$$$
--------------------------------------------------
Problem ID: 1854B
Editorial Content:
1854B - Earn or Unlock
Hint 1
The order of used cards doesn't matter. So, you can assume you always use the card on the top.
Hint 2
Suppose that you unlock $$$x$$$ cards in total. How many points can you get?
Hint 3
If you unlock $$$x$$$ cards, it means you end up making moves with the first $$$x$$$ cards. So, you know the total number of (cards + points) that you get.
Hint 4
If you unlock $$$x$$$ cards, the number of points is uniquely determined. It's convenient to assume that $$$x \leq 2n$$$ and the cards $$$n+1, \dots, 2n$$$ have value $$$0$$$.
Hint 5
Now you have to determine the unlockable prefixes of cards (i.e., the values of $$$x$$$ you can reach). It looks similar to knapsack.
Hint 6
You can optimize the solution using a bitset. Be careful not to use locked cards.
Solution
First, note that the order of used cards doesn't matter. If you use at least once a card that is not on the top on the deck, you can prove that using the cards in order (from the top) would give the same number of victory points.
Let's add $$$n$$$ cards with value $$$0$$$ at the end of the deck. Then, it's optimal to unlock $$$x \leq 2n$$$ cards, and use cards $$$1, \dots, x$$$, getting $$$a_1 + \dots + a_x - x + 1$$$ points.
Let's find the reachable $$$x$$$. Let $$$dp_i$$$ be a bitset that stores the reachable $$$x$$$ after using the first $$$i$$$ cards.
Base case: $$$dp_{0,1} = 1$$$.
Transitions: first, $$$dp_{i}$$$
|=
$$$dp_{i-1}$$$
<<
$$$a_i$$$. If $$$dp_{i,i} = 1$$$, you can update the answer with $$$a_1 + \dots + a_i - i + 1$$$, but you can't unlock any other card, so you have to set $$$dp_{i,i} = 0$$$ before transitioning to $$$i+1$$$.
Complexity: $$$O(n^2/w)$$$
--------------------------------------------------
Problem ID: 1854A2
Editorial Content:
1854A2 - Dual (Hard Version)
Hint 5
You can win in $$$n-1$$$ moves if all the elements are negative, but also if all the elements are positive.
Hint 6
Again, make a big positive / negative element, then use it to make everything positive / negative.
Hint 7
In how many moves can you either make everything positive or make everything negative?
Hint 8
Assume the positive elements are at least as many as the negative elements. Can you win in $$$34$$$ moves?
Hint 9
The bottleneck is making the big positive element. Is it always necessary? Can you find a better bound on the "best" number of moves?
Solution
If you either make everything positive or make everything negative, you can win in $$$n-1 \leq 19$$$ moves by making prefix sums or suffix sums, respectively. So, you have to reach one of these configurations in $$$12$$$ moves.
How to make everything positive? First, you create a big element with the maximum absolute value (this requires $$$x_1$$$ moves), then you add it to every negative element (this requires $$$x_2$$$ moves). $$$y_1$$$ and $$$y_2$$$ are defined similarly in the negative case.
So,
one of $$$x_1$$$ and $$$y_1$$$ is $$$0$$$ (because the element with the maximum absolute value at the beginning is either positive or negative), and the other one is $$$\leq 5$$$ (because you can make $$$|a_i| \geq 32$$$ in $$$5$$$ moves);
$$$x_2$$$ is the number of negative elements, $$$y_2$$$ is the number of positive elements. So, $$$x_2 + y_2 \leq n \leq 20$$$.
Therefore, you need additional $$$\min(x_1 + x_2, y_1 + y_2)$$$ moves. Since $$$x_1 + x_2 + y_1 + y_2 \leq 25$$$, $$$\min(x_1 + x_2, y_1 + y_2) \leq \lfloor \frac{25}{2} \rfloor = 12$$$, as we wanted. Now you can simulate the process in both cases (positive and negative), and choose one that requires $$$\leq 31$$$ moves in total.
Complexity: $$$O(n)$$$
--------------------------------------------------
Problem ID: 1854A1
Editorial Content:
1854A1 - Dual (Easy Version)
Hint 1
There are several solutions to the easy version. In any case, how to get $$$a_i \leq a_{i+1}$$$?
Hint 2
For example, you can try making $$$a_{i+1}$$$ bigger using a positive element.
What to do if all the elements are negative?
Hint 3
If all the elements are negative, you can win in $$$n-1$$$ moves.
If there is a positive element, you can try to make $$$a_1 \leq a_2$$$, then $$$a_2 \leq a_3$$$, etc.
Hint 4
Make a big positive element using moves $$$(i, i)$$$, then make $$$a_2$$$ bigger.
Solution
If all the elements are negative, you can make suffix sums (they are nondecreasing) with moves $$$(n-1, n), (n-2, n-1), \dots$$$
If there is at least one positive element $$$a_x$$$,
make $$$a_x > 20$$$ using $$$5$$$ moves $$$(x, x)$$$;
make $$$a_2$$$ the biggest element using $$$2$$$ moves $$$(2, x)$$$;
make $$$a_3$$$ the biggest element using $$$2$$$ moves $$$(3, 2)$$$;
...
This strategy requires $$$5 + 2(n-1) \leq 43$$$ moves.
Complexity: $$$O(n)$$$
--------------------------------------------------
Problem ID: 1853B
Editorial Content:
1853B - Fibonaccharsis
Hint 1
Can a sequence involving $$$n$$$, which is up to $$$10^5$$$, really have up to $$$10^9$$$ terms?
Solution
The terms of the fibonacci sequence will increase exponentially. This is quite intuitive, but mathematically, fibonnaci-like sequences will increase at a rate of phi to the power of $$$n$$$, where phi (the golden ratio) is about $$$1.618$$$. Thus, the maximum number of terms a sequence can have before it reaches $$$10^9$$$, or the maximum value of $$$n$$$, is pretty small (around $$$\log n$$$).
Instead of trying to fix the first two elements of the sequence and counting how many sequences $$$s$$$ will have $$$s_k = n$$$, note that we already have $$$n$$$ fixed. If we loop over the $$$k-1$$$th element of the sequence, the sequence is
still fixed
. If we know the $$$x$$$th element and $$$x-1$$$th element of $$$s$$$, we can find that $$$s_{x - 2} = s_{x} - s_{x - 1}$$$.
Thus, we can just go backwards and simulate for $$$k$$$ iterations in $$$O(\log n)$$$ since $$$k$$$ is small, breaking at any point if the current sequence is not fibonnaci-like (there are negative elements or it is not strictly increasing). Otherwise, we add $$$1$$$ to our answer.
The time complexity is $$$O(n \cdot \log n)$$$.
Code (C++)
#include <bits/stdc++.h>
using namespace std;
 
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int T; cin >> T;
    
    while (T--) {
 
        int n; int k;
        cin >> n >> k;
     
        int ans = 0;
     
        for (int i = 1; i <= n; i++) {
            int second = n; //xth element where x is k
            int first = i; //fixing x-1th element where x is k-1
            bool valid_seq = true;
            for (int j = 0; j < k - 2; j++) {
                //for s_x and s_x-1, s_x-2 = s_x - s_x-1
                int fx = first;
                first = second - fx;
                second = fx;
                valid_seq &= first <= second;
                valid_seq &= min(first, second) >= 0;
                if (!valid_seq) break; //break if the sequence is not fibonacci-like
            }
            if (valid_seq) ans++;
        }
 
        cout << ans << endl;
    }
 
}
Bonus Solution
Analysis by
awesomeguy856
$$$f[k] = F_{k-2}f[0]+F_{k-1}f[1]$$$
By the Extended Euclidean Algorithm, we can find one integral solution for this equation, since $$$\gcd (F_{k-2}, F_{k-1}) = 1 | f[k].$$$ Let this solution be $$$(f[0], f[1]) = (x, y).$$$ Then all other integral solutions are in the form $$$(x+cF_{k-1}, y-cF_{k-2}),$$$ for $$$c \in Z$$$ so we can find all valid solutions by binary search on $$$f[1],f[0] \geq 0$$$ and $$$f[1]>f[0]$$$, or just by some calculations.
--------------------------------------------------
Problem ID: 1853A
Editorial Content:
1853A - Desorting
Hint 1
To make $$$a$$$ not sorted, we just need to pick one index $$$i$$$ so $$$a_i > a_{i + 1}$$$. How do we do this?
Solution
To make $$$a$$$ not sorted, we just have to make $$$a_i > a_{i + 1}$$$ for one $$$i$$$.
In one operation, we can reduce the gap between two adjacent elements $$$i, i + 1$$$ by $$$2$$$ by adding $$$1$$$ to $$$1 \dots i$$$ and subtracting $$$1$$$ from $$${i + 1} \dots n$$$.
It is clearly optimal to pick the smallest gap between a pair of adjacent elements to minimize the number of operations we have to do. If we have $$$a_i = x, a_{i + 1} = y$$$, we can make $$$x > y$$$ within $$$\lfloor \frac{(y - x)}{2} \rfloor + 1$$$ operations.
Thus, we can just go through $$$a$$$, find the minimum difference gap, and calculate the minimum operations using the above formula. Note that if $$$a$$$ is not sorted, we can just output $$$0$$$.
The time complexity is $$$O(n)$$$.
Code (C++)
#include <bits/stdc++.h>
#include <numeric>
using namespace std;
 
int main(){
 
    ios::sync_with_stdio(false);
    cin.tie(0);
 
    int T; cin >> T;
 
    while (T--) {
 
        int n; cin >> n;
        vector<int> nums(n);
        int diff = 1e9;
        bool sorted = true;
        for (int i = 0; i < n; i++) {
            cin >> nums[i];
            if (i > 0) {
                diff = min(nums[i] - nums[i - 1], diff);
                sorted &= nums[i] >= nums[i - 1];
            }
        }
        
        if (!sorted) {
            cout << 0 << endl;
            continue;
        }
    
        cout << diff/2 + 1 << endl;
    }
}
--------------------------------------------------
Problem ID: 1852F
Editorial Content:
1852F - Panda Meetups
Hint 1
If we want to answer one of the questions (say, the question involving all the events) in polynomial time, how do we do it?
Hint 2
Construct a network with edges from the source to each of the red panda events with capacities equal to the number of red pandas, edges from red panda events to blue panda events with innite capacities if the red pandas can catch the corresponding blue pandas, and edges from each of the blue panda events to the sink with capacities equal to the number of blue pandas.
Hint 3
The next step is to use the max-flow min-cut theorem: the maximum flow is equal to the minimum number of red pandas plus blue pandas we need to remove from the graph such that no remaining red panda can reach any remaining blue panda.
How do we go from here?
Hint 4
For any cut, consider the region of the $$$x$$$-$$$t$$$ plane reachable by the remaining red pandas. No remaining blue pandas can lie in this region, and its border is a polyline that intersects each vertical line in the $$$x$$$-$$$t$$$ plane exactly once. Furthermore, the slope of every segment in this polyline has slope plus or minus $$$1$$$. Conversely, we can associate every polyline satisfying this condition with a cut; we just need to remove every red panda lying below the polyline and every blue panda lying on or above the polyline.
Now, figure out how to answer the queries online.
Solution
Read the hints to understand the solution better.
We can answer the queries online. For each $$$x$$$-coordinate $$$x$$$, maintain a treap that stores for every $$$x$$$-coordinate, the minimum cut $$$dp[x][t]$$$ associated with a polyline satisfying the condition above that starts at $$$x = -\infty$$$ and ends at $$$(x, t)$$$ when only considering events with $$$x$$$-coordinate at most $$$x$$$. When transitioning from to $$$x$$$ to $$$x+1$$$, we need to set for every $$$dp[x+1][t] = min(dp[x][t-1], dp[x][t], dp[x][t+1])$$$ for every $$$t$$$. To do this quickly, we maintain the values of $$$t$$$ where $$$dp[x][t+1] - dp[x][t] \neq 0$$$ in increasing order, of which there are at most $$$n$$$. When $$$x$$$ increases by one, each value of increases or decreases by one, depending on the sign of $$$dp[x][t+1]-dp[x][t]$$$, and some of the values of $$$t$$$ merge, decreasing the size of our treap. As long as we can process each merge in $$$\log n$$$ time, our solution will run in $$$O(n\log n)$$$ total time. When processing an event, we need to increase all $$$dp$$$ values in a suffix for red panda events, and all $$$dp$$$ values in a prefix for blue panda events. To answer a query, we just need to return the minimum prefix sum in our treap.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define ff first
#define ss second

typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

const int INF = 1e9 + 1;

void setIO() {
    ios_base::sync_with_stdio(0); cin.tie(0);
}

struct node {
    //mnpos - leftmost negative 
    //mxpos - rightmost positive
    int pos, tag, mnpos, mxpos;
    //minimum distance
    pair<int, pii> mndif;
    ll sum, pre, val;
    int weight;

    node(){}

    node(int pos_, ll val_){
        pos = pos_;
        val = val_;
        sum = val;
        pre = min((ll)0, val);
        mxpos = -INF;
        mnpos = INF;
        mndif = {INF, {INF, INF}};
        if(val > 0) mxpos = pos;
        if(val < 0) mnpos = pos;
        tag = 0;
        weight = rand();
    }
};

int sz = 1;
node treap[1000005];
int left0[1000005];
int right0[1000005];

int newnode(int pos, ll val){
    treap[sz] = node(pos, val);
    return sz++;
}

pair<int, pii> comb(int a, int b){
    if(a == -INF || b == INF) return {INF, {INF, INF}};
    return {b - a, {a, b}};
}

void pull(int x){
    treap[x].sum = treap[x].val;
    treap[x].pre = min((ll)0, treap[x].val);
    treap[x].mxpos = -INF;
    treap[x].mnpos = INF;
    treap[x].mndif = {INF, {INF, INF}};
    if(treap[x].val > 0) treap[x].mxpos = treap[x].pos;
    if(treap[x].val < 0) treap[x].mnpos = treap[x].pos;
    if(left0[x]){
        treap[x].mndif = min(treap[x].mndif, treap[left0[x]].mndif);
        treap[x].mndif = min(treap[x].mndif, comb(treap[left0[x]].mxpos, treap[x].mnpos));
        treap[x].mnpos = min(treap[x].mnpos, treap[left0[x]].mnpos);
        treap[x].mxpos = max(treap[x].mxpos, treap[left0[x]].mxpos);
        treap[x].pre = min(treap[left0[x]].pre, treap[left0[x]].sum + treap[x].pre);
        treap[x].sum += treap[left0[x]].sum; 
    }
    if(right0[x]){
        treap[x].mndif = min(treap[x].mndif, treap[right0[x]].mndif);
        treap[x].mndif = min(treap[x].mndif, comb(treap[x].mxpos, treap[right0[x]].mnpos));
        treap[x].mnpos = min(treap[x].mnpos, treap[right0[x]].mnpos);
        treap[x].mxpos = max(treap[x].mxpos, treap[right0[x]].mxpos);
        treap[x].pre = min(treap[x].pre, treap[x].sum + treap[right0[x]].pre);
        treap[x].sum += treap[right0[x]].sum;
    }
}

int move(node& x, int shift){
    int ret = x.pos;
    if(x.val < 0) ret -= shift;
    if(x.val > 0) ret += shift;
    return ret;
}

void apply(int x, int tag){
    treap[x].pos = move(treap[x], tag);
    treap[x].tag += tag;
    if(treap[x].mnpos != INF) treap[x].mnpos -= tag;
    if(treap[x].mxpos != -INF) treap[x].mxpos += tag;
    if(treap[x].mndif.ff != INF){
        treap[x].mndif.ff -= 2*tag;
        treap[x].mndif.ss.ff += tag;
        treap[x].mndif.ss.ss -= tag;
    }
}

void push(int x){
    if(!treap[x].tag) return;
    if(left0[x]) apply(left0[x], treap[x].tag);
    if(right0[x]) apply(right0[x], treap[x].tag);
    treap[x].tag = 0;
}

int merge(int a, int b){
    if(!a) return b;
    if(!b) return a;
    if(treap[a].weight < treap[b].weight){ 
        push(a);
        right0[a] = merge(right0[a], b);
        pull(a);
        return a;
    } else {
        push(b);
        left0[b] = merge(a, left0[b]);
        pull(b);
        return b;
    }
}

//splits rt's tree into [0, k) [k, INF)
pair<int, int> split(int x, int k){
    if(!x) return pair<int, int>{0, 0};
    push(x);
    pair<int, int> ret;
    if(treap[x].pos < k){
        ret = split(right0[x], k);
        right0[x] = ret.first;
        ret.first = x;
    } else {
        ret = split(left0[x], k);
        left0[x] = ret.second;
        ret.second = x;
    }
    pull(x);
    return ret;
}

int rt = 0;

void erase(int x){
    pair<int, int> a = split(rt, x);
    pair<int, int> b = split(a.second, x + 1);
    rt = merge(a.first, b.second);
}

//position, value
void insert(int a, ll b){
    if(!rt){
        rt = newnode(a, b);
        return;
    }
    pair<int, int> nw = split(rt, a);
    rt = merge(nw.first, merge(newnode(a, b), nw.second));
}

//value
ll query(int x){
    pair<int, int> a = split(rt, x);
    pair<int, int> b = split(a.second, x + 1); 
    ll ret = (b.first ? treap[b.first].val : 0);
    rt = merge(a.first, merge(b.first, b.second));
    return ret;
}

int main(){
    setIO();
    int n;
    cin >> n;
    int prv = 0;
    ll st = 0;
    for(int i = 1; i <= n; i++){
        int x, t, c;
        cin >> x >> t >> c;
        int dif = x - prv;
        //remove overlap
        while(rt && treap[rt].mndif.ff <= 2*dif){
            pair<int, pii> x = treap[rt].mndif;
            ll a = query(x.ss.ff), b = query(x.ss.ss);
            ll sub = min(a, -b);
            erase(x.ss.ff);
            erase(x.ss.ss);
            a -= sub, b += sub;
            if(a != 0) insert(x.ss.ff, a);
            if(b != 0) insert(x.ss.ss, b);
        }
        //shift everything
        if(rt){
            treap[rt].pos = move(treap[rt], dif);
            treap[rt].tag += dif;
            if(treap[rt].mnpos != INF) treap[rt].mnpos -= dif;
            if(treap[rt].mxpos != -INF) treap[rt].mxpos += dif;
            if(treap[rt].mndif.ff != INF){
                treap[rt].mndif.ff -= 2*dif;
                treap[rt].mndif.ss.ff += dif;
                treap[rt].mndif.ss.ss -= dif;
            }
        }
        ll cur = query(t + 1);
        if(cur != 0) erase(t + 1);
        if(cur - c != 0) insert(t + 1, cur - c);
        if(c > 0) st += c;
        cout << st + (!rt ? 0 : treap[rt].pre) << endl;
        prv = x;
    }
}
--------------------------------------------------
Problem ID: 1852E
Editorial Content:
1852E - Rivalries
Hint 1
For each distinct value, only the leftmost and rightmost positions actually have an effect on the power.
Hint 2
Think of each distinct value as an interval corresponding to its leftmost and rightmost positions, and let that distinct value be the value of its interval. If interval $$$x$$$ strictly contains an interval $$$y$$$ with greater value, then $$$x$$$ will not have an effect on the power and it can be discarded.
Hint 3
In order to not change the power, we can only add intervals that strictly contain an interval with greater value. Afterwards, if $$$i$$$ is not the endpoint of an interval, $$$b_i$$$ equals the largest value of an interval containing $$$i$$$.
Hint 4
There will only be at most one interval that we have to add. Assume that there are multiple intervals that we can add without changing the answer. In this case it is easy to see that its more optimal to combine the interval with smaller value into the interval with larger value. Thus, it is never optimal to add multiple intervals.
Solution
Read the hints.
We can remove all intervals that will not affect the power by iterating over them in decreasing order of value and maintain a segment tree that stores for each left endpoint of any processed intervals, the right endpoint that corresponds to it. Checking if an interval is strictly contained then becomes a range minimum query.
Assume that we know the value $$$x$$$ of the interval that we want to add. We can immediately fill the value for the interior of all intervals that correspond to a value greater than $$$x$$$. However, we also have to guarantee that $$$x$$$ is strictly contained by an interval with greater value, so we can try each interval to contain $$$x$$$. If are no unfilled indices the left or right side of the interval, then we want to replace the smallest filled on either side value with $$$x$$$. Otherwise, we can just fill in all the unfilled indices with $$$x$$$. Note that it is also possible for $$$x$$$ to not be able to be contained by any interval.
Thus, we can just try every possible $$$x$$$ in decreasing order and maintain the filled indices as we iterate. There are only at most $$$n$$$ values of $$$x$$$ to check, which is just the set of $$$a_i - 1$$$ that does not appear in $$$a$$$.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define ff first
#define ss second

typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

const int INF = 1e9 + 1;

void setIO() {
    ios_base::sync_with_stdio(0); cin.tie(0);
}

pii seg[400005];
int n;

void build(int l = 0, int r = n - 1, int cur = 0){
    seg[cur] = {INF, INF};
    if(l == r) return;
    int mid = (l + r)/2;
    build(l, mid, cur*2 + 1);
    build(mid + 1, r, cur*2 + 2);
}

void update(int x, int v, int l = 0, int r = n - 1, int cur = 0){
    if(l == r){
        seg[cur] = {v, l};
        return;
    }
    int mid = (l + r)/2;
    if(x <= mid) update(x, v, l, mid, cur*2 + 1);
    else update(x, v, mid + 1, r, cur*2 + 2);
    seg[cur] = min(seg[cur*2 + 1], seg[cur*2 + 2]);
}

pii query(int l, int r, int ul = 0, int ur = n - 1, int cur = 0){
    if(l <= ul && ur <= r) return seg[cur];
    if(l > r || ur < l || ul > r) return {INF, INF};
    int mid = (ul + ur)/2;
    return min(query(l, r, ul, mid, cur*2 + 1), query(l, r, mid + 1, ur, cur*2 + 2));
}

int main(){
    setIO();
    int t;
    cin >> t;
    for(int tt = 1; tt <= t; tt++){
        cin >> n;
        map<int, vector<int>> m;
        int arr[n];
        for(int i = 0; i < n; i++){
            cin >> arr[i];
            m[arr[i]].pb(i);
        }
        vector<int> rel; //relevant numbers
        for(auto &i : m){
            rel.pb(i.ff);
            for(int j = 1; j < i.ss.size() - 1; j++){
                arr[i.ss[j]] = 0;
            }
        }
        reverse(rel.begin(), rel.end());
        vector<int> nw;
        build();
        for(int i : rel){
            int l = m[i].front(), r = m[i].back();
            if(query(l, r).ff <= r){
                arr[l] = arr[r] = 0;
            } else {
                update(l, r);
                nw.pb(i);
            }
        }
        swap(rel, nw);
        set<int> s;
        for(int i = 0; i < n; i++) if(!arr[i]) s.insert(i);
        vector<int> vals; //possible target values
        for(int i = rel.size() - 1; i >= 0; i--){
            if(i == rel.size() - 1 || rel[i] - 1 != rel[i + 1]){
                vals.pb(rel[i] - 1);
            }
        }
        ll sum = 0, mx = 0, mxval = 0;
        int lex = -1, rex = -1;
        build();
        for(int i = 0; i < n; i++) if(!arr[i]) update(i, -1);
        reverse(vals.begin(), vals.end());
        queue<pii> upd;
        int ind = 0;
        //try to add an interval with value i
        for(int i : vals){
            vector<int> nxt;
            //try filling in all intervals > i
            while(ind < rel.size() && rel[ind] > i){
                int l = m[rel[ind]].front(), r = m[rel[ind]].back();
                set<int>::iterator it = s.lower_bound(l);
                while(it != s.end() && *it < r){
                    sum += rel[ind];
                    update(*it, rel[ind]);
                    upd.push({*it, rel[ind]});
                    it = s.erase(it);
                }
                nxt.pb(rel[ind++]);
            }
            //try each necessary interval to be strictly contained by i
            for(int j : nxt){
                int l = m[j].front(), r = m[j].back();
                if(s.size() && 0 < l && r < n - 1){
                    //find which indeces on each side to replace with i
                    pii rnw = query(r + 1, n);
                    pii lnw = query(0, l - 1);
                    if(rnw.ff == INF || lnw.ff == INF) continue;
                    ll add = (ll)i*s.size() + (rnw.ff == -1 ? 0 : i - rnw.ff) + (lnw.ff == -1 ? 0 : i - lnw.ff);
                    if(i && sum + add > mx){
                        mx = sum + add;
                        mxval = i;
                        lex = (lnw.ff == -1 ? -1 : lnw.ss);
                        rex = (rnw.ff == -1 ? -1 : rnw.ss);
                        //it is optimal to fill in all intervals > i
                        while(!upd.empty()){
                            arr[upd.front().ff] = upd.front().ss;
                            upd.pop();
                        }
                    }
                }
            }
        }
        //don't want to add any intervals
        if(s.size() == 0 && sum > mx){
            mx = sum;
            lex = rex = -1;
            //it is optimal to fill in all remaining intervals
            while(!upd.empty()){
                arr[upd.front().ff] = upd.front().ss;
                upd.pop();
            }
        }
        if(lex != -1) arr[lex] = 0;
        if(rex != -1) arr[rex] = 0;
        for(int i = 0; i < n; i++) cout << (arr[i] ? arr[i] : mxval) << " ";
        cout << endl;
    }
}
--------------------------------------------------
Problem ID: 1852D
Editorial Content:
1852D - Miriany and Matchstick
Hint 1
Solve the samples for all values of $$$k$$$.
Hint 2
What does constructing a second row from left to right look like?
Hint 3
How does knowing the possible $$$k$$$ for any first row help you construct a second row?
Hint 4
Apply dynamic programming to calculate the possible $$$k$$$, and use the information in the DP to construct a solution.
Solution
Call the number of adjacent pairs of cells with different characters the
cost
.
If we construct the second row from left to right, the amount each character adds to the cost only depends on the previous character. Thus, we can represent the problem with a DAG whose vertices represent choices for each character and whose edges represent the cost of choosing two adjacent characters. Our goal is to find a path starting from the far left and ending at the far right of cost $$$k$$$. For example, below is the DAG for the third testcase in the sample. (For convenience, we include the cost of cells in the top row with the corresponding cells in the bottom row.)
A general way to find such a path is as follows: For each vertex, store all possible costs of a path starting from the far left and ending at that vertex, which can be calculated with dynamic programming. Then we construct our path backwards from the right. For each candidate previous vertex, we check that the constructed path's cost plus the cost of the edge from this vertex plus some stored cost in this vertex equals $$$k$$$, in which case we know that some completion of the path from the far left to this vertex exists and we can choose this vertex.
Naively calculating this DP would require $$$O(n)$$$ time per operation. However, intuitively, each set of possible costs should contain almost all values between its minimum and maximum, and experiments suggest it always consists of at most two intervals. We will first formalize the DP and then prove this observation.
Let $$$\mathrm{dp}_A[i]$$$ store the set of possible values of $$$k$$$ when the grid is truncated to the first $$$i$$$ columns and the last character in the second row is $$$A$$$. Define $$$\mathrm{dp}_B[i]$$$ similarly.
Using the notation $$$[\mathrm{true}] = 1$$$, $$$[\mathrm{false}] = 0$$$, $$$S+x = \{s+x \mid s \in S\}$$$, we have the recurrences
$$$\begin{align*} \mathrm{dp}_A[i] &= \mathrm{dp}_A[i-1]\cup(\mathrm{dp}_B[i-1]+1)+[s_i \ne A]+[s_i \ne s_{i-1}] \\ \mathrm{dp}_B[i] &= \mathrm{dp}_B[i-1]\cup(\mathrm{dp}_A[i-1]+1)+[s_i \ne B]+[s_i \ne s_{i-1}] \end{align*}$$$
with initial values $$$\mathrm{dp}_A[1] = [s_1 \ne A]$$$ and $$$\mathrm{dp}_B[1] = [s_1 \ne B]$$$.
Now either we hope that each set consists of $$$O(1)$$$ intervals, or we have to prove that each set indeed consists of at most two intervals:
Proof
We will use induction to prove that the following stronger property holds for all $$$i \ge 2$$$: $$$\mathrm{dp}_A[i]$$$ and $$$\mathrm{dp}_B[i]$$$ are overlapping intervals, except that possibly one (non-endpoint) value $$$v$$$ is missing from one interval, but in that case either $$$v-1$$$ or $$$v+1$$$ is present in the other interval. ($$$i = 1$$$ must be treated separately, but it can easily be checked.)
Base case.
To prove this holds for $$$i = 2$$$, WLOG let $$$s_1 = A$$$ so $$$\mathrm{dp}_A[1] = \{0\}$$$ and $$$\mathrm{dp}_B[1] = \{1\}$$$. If $$$s_2 = A$$$, then
$$$\begin{align*} \mathrm{dp}_A[2] &= \{0\}\cup(\{1\}+1)+0+0 = \{0,2\} \\ \mathrm{dp}_B[2] &= \{1\}\cup(\{0\}+1)+1+0 = \{2\} \end{align*}$$$
which satisfies the property with $$$v = 1$$$. If $$$s_2 = B$$$, then
$$$\begin{align*} \mathrm{dp}_A[2] &= \{0\}\cup(\{1\}+1)+1+1 = \{2,4\} \\ \mathrm{dp}_B[2] &= \{1\}\cup(\{0\}+1)+0+1 = \{2\} \end{align*}$$$
which satisfies the property with $$$v = 3$$$.
Induction step.
Suppose the property holds for $$$i-1$$$.
Since the conditions of the property only depend on relative positions, for convenience we shift the sets $$$\mathrm{dp}_A[i]$$$ and $$$\mathrm{dp}_B[i]$$$ left by $$$h = [s_i \ne A]+[s_i \ne s_{i-1}]$$$ to get
$$$\begin{align*} \mathrm{dp}'_A[i] &= \mathrm{dp}_A[i]-h = \mathrm{dp}_A[i-1]\cup(\mathrm{dp}_B[i-1]+1) \\ \mathrm{dp}'_B[i] &= \mathrm{dp}_B[i]-h = \mathrm{dp}_B[i-1]\cup(\mathrm{dp}_A[i-1]+1)+(s_i = A\ ?\ 1 : -1). \end{align*}$$$
If the property holds for $$$\mathrm{dp}'$$$, then it holds for $$$\mathrm{dp}$$$.
First, we show that a missing value in $$$\mathrm{dp}'_A[i]$$$ or $$$\mathrm{dp}'_B[i]$$$ can only come directly from a missing value in $$$\mathrm{dp}_A[i-1]$$$ or $$$\mathrm{dp}_B[i-1]$$$ and not from the union operation merging two non-adjacent intervals. This is true because $$$\mathrm{dp}_A[i-1]$$$ and $$$\mathrm{dp}_B[i-1]$$$ overlap, so even after $$$1$$$ is added to either, they are still at least adjacent.
If a value $$$v$$$ is missing, WLOG let it be missing from $$$\mathrm{dp}_A[i-1]$$$.
If $$$v+1 \in \mathrm{dp}_B[i-1]$$$, then $$$\mathrm{dp}'_A[i]$$$ may be missing $$$v$$$ while $$$\mathrm{dp}'_B[i]$$$ does not miss any value. Also, since $$$v-1$$$ is adjacent to the missing value (which isn't an endpoint), it is in $$$\mathrm{dp}_A[i-1]$$$, so either $$$v+1$$$ or $$$v-1$$$ is in $$$\mathrm{dp}'_B[i]$$$. This also guarantees the intervals overlap, satisfying the property for $$$i$$$.
The case for $$$v-1 \in \mathrm{dp}_B[i-1]$$$ is very similar. $$$\mathrm{dp}'_B[i]$$$ may be missing either $$$v$$$ or $$$v+2$$$, and since $$$v+1 \in \mathrm{dp}_A[i-1]$$$, $$$v+1$$$ is in $$$\mathrm{dp}'_A[i]$$$.
If no value is missing, let $$$x$$$ be a common value in both $$$\mathrm{dp}_A[i-1]$$$ and $$$\mathrm{dp}_B[i-1]$$$. Then, $$$\mathrm{dp}'_A[i] \supseteq \{x,x+1\}$$$ and $$$\mathrm{dp}'_B[i]$$$ is a superset of either $$$\{x-1,x\}$$$ or $$$\{x+1,x+2\}$$$, so the intervals overlap.
To find the union of two sets of intervals, sort them by left endpoint and merge adjacent overlapping intervals. After computing the DP, apply the aforementioned backwards construction to obtain a valid second row.
Below is a visualization of solving the third testcase in the sample. Generate your own
here
!
Proof
We will use induction to prove that the following stronger property holds for all $$$i \ge 2$$$: $$$\mathrm{dp}_A[i]$$$ and $$$\mathrm{dp}_B[i]$$$ are overlapping intervals, except that possibly one (non-endpoint) value $$$v$$$ is missing from one interval, but in that case either $$$v-1$$$ or $$$v+1$$$ is present in the other interval. ($$$i = 1$$$ must be treated separately, but it can easily be checked.)
Base case.
To prove this holds for $$$i = 2$$$, WLOG let $$$s_1 = A$$$ so $$$\mathrm{dp}_A[1] = \{0\}$$$ and $$$\mathrm{dp}_B[1] = \{1\}$$$. If $$$s_2 = A$$$, then
$$$\begin{align*} \mathrm{dp}_A[2] &= \{0\}\cup(\{1\}+1)+0+0 = \{0,2\} \\ \mathrm{dp}_B[2] &= \{1\}\cup(\{0\}+1)+1+0 = \{2\} \end{align*}$$$
which satisfies the property with $$$v = 1$$$. If $$$s_2 = B$$$, then
$$$\begin{align*} \mathrm{dp}_A[2] &= \{0\}\cup(\{1\}+1)+1+1 = \{2,4\} \\ \mathrm{dp}_B[2] &= \{1\}\cup(\{0\}+1)+0+1 = \{2\} \end{align*}$$$
which satisfies the property with $$$v = 3$$$.
Induction step.
Suppose the property holds for $$$i-1$$$.
Since the conditions of the property only depend on relative positions, for convenience we shift the sets $$$\mathrm{dp}_A[i]$$$ and $$$\mathrm{dp}_B[i]$$$ left by $$$h = [s_i \ne A]+[s_i \ne s_{i-1}]$$$ to get
$$$\begin{align*} \mathrm{dp}'_A[i] &= \mathrm{dp}_A[i]-h = \mathrm{dp}_A[i-1]\cup(\mathrm{dp}_B[i-1]+1) \\ \mathrm{dp}'_B[i] &= \mathrm{dp}_B[i]-h = \mathrm{dp}_B[i-1]\cup(\mathrm{dp}_A[i-1]+1)+(s_i = A\ ?\ 1 : -1). \end{align*}$$$
If the property holds for $$$\mathrm{dp}'$$$, then it holds for $$$\mathrm{dp}$$$.
First, we show that a missing value in $$$\mathrm{dp}'_A[i]$$$ or $$$\mathrm{dp}'_B[i]$$$ can only come directly from a missing value in $$$\mathrm{dp}_A[i-1]$$$ or $$$\mathrm{dp}_B[i-1]$$$ and not from the union operation merging two non-adjacent intervals. This is true because $$$\mathrm{dp}_A[i-1]$$$ and $$$\mathrm{dp}_B[i-1]$$$ overlap, so even after $$$1$$$ is added to either, they are still at least adjacent.
If a value $$$v$$$ is missing, WLOG let it be missing from $$$\mathrm{dp}_A[i-1]$$$.
If $$$v+1 \in \mathrm{dp}_B[i-1]$$$, then $$$\mathrm{dp}'_A[i]$$$ may be missing $$$v$$$ while $$$\mathrm{dp}'_B[i]$$$ does not miss any value. Also, since $$$v-1$$$ is adjacent to the missing value (which isn't an endpoint), it is in $$$\mathrm{dp}_A[i-1]$$$, so either $$$v+1$$$ or $$$v-1$$$ is in $$$\mathrm{dp}'_B[i]$$$. This also guarantees the intervals overlap, satisfying the property for $$$i$$$.
The case for $$$v-1 \in \mathrm{dp}_B[i-1]$$$ is very similar. $$$\mathrm{dp}'_B[i]$$$ may be missing either $$$v$$$ or $$$v+2$$$, and since $$$v+1 \in \mathrm{dp}_A[i-1]$$$, $$$v+1$$$ is in $$$\mathrm{dp}'_A[i]$$$.
If no value is missing, let $$$x$$$ be a common value in both $$$\mathrm{dp}_A[i-1]$$$ and $$$\mathrm{dp}_B[i-1]$$$. Then, $$$\mathrm{dp}'_A[i] \supseteq \{x,x+1\}$$$ and $$$\mathrm{dp}'_B[i]$$$ is a superset of either $$$\{x-1,x\}$$$ or $$$\{x+1,x+2\}$$$, so the intervals overlap.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

#define all(x) (x).begin(), (x).end()

struct state {

    // represents a set of integers compressed as a vector
    // of non-overlapping intervals [l, r]

    basic_string<array<int, 2>> a;

    // add d to everything in the set
    friend state add(state x, int d) {
        for (auto& [l, r] : x.a)
            l += d, r += d;
        return x;
    }

    // union of two sets of integers
    friend state unite(state x, state y) {
        state z;
        merge(all(x.a), all(y.a), back_inserter(z.a));
        int j = 0;
        for (int i = 1; i < z.a.size(); i++) {
            if (z.a[i][0] <= z.a[j][1]+1)
                z.a[j][1] = max(z.a[j][1], z.a[i][1]);
            else
                z.a[++j] = z.a[i];
        }
        z.a.erase(z.a.begin() + j + 1, z.a.end());
        return z;
    }

    // whether integer k is in the set
    friend bool contains(state x, int k) {
        for (auto& [l, r] : x.a)
            if (k >= l && k <= r)
                return true;
        return false;
    }
};

// set containing only one integer d
state from_constant(int d) {
    return state({{{d, d}}});
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    int t; cin >> t;
    while (t--) {
        int n, k; cin >> n >> k;
        string s; cin >> s;

        vector<array<state, 2>> dp(n);

        dp[0][0] = from_constant(s[0] != 'A');
        dp[0][1] = from_constant(s[0] != 'B');

        for (int i = 1; i < n; i++) {
            dp[i][0] = add(unite(dp[i-1][0], add(dp[i-1][1], 1)), (s[i] != 'A') + (s[i] != s[i-1]));
            dp[i][1] = add(unite(dp[i-1][1], add(dp[i-1][0], 1)), (s[i] != 'B') + (s[i] != s[i-1]));
        }

        if (!(contains(dp[n-1][0], k) || contains(dp[n-1][1], k))) {
            cout << "NO\n";
            continue;
        }

        string ans;

        for (int i = n-1; i >= 0; i--) {
            char c = contains(dp[i][0], k - (i == n-1 ? 0 : (ans.back() != 'A'))) ? 'A' : 'B';
            k -= (c != s[i]);
            if (i > 0)
                k -= (s[i] != s[i-1]);
            if (i < n-1)
                k -= (c != ans.back());
            ans += c;
        }

        reverse(all(ans));
        cout << "YES\n" << ans << "\n";
    }
}
--------------------------------------------------
Problem ID: 1852C
Editorial Content:
1852C - Ina of the Mountain
Hint One
Suppose you knew in advance how many times each octopus will regenerate. Could you solve the problem then?
Solution
To make things easier, replace health values of $$$k$$$ with health values of $$$0$$$, so the goal is to reach $$$0$$$ health. Regeneration is now from $$$0$$$, which was formerly $$$k$$$, to $$$k-1$$$, instead of $$$1$$$ to $$$k$$$, which is now $$$1$$$ to $$$0$$$. For clarity, create a new array $$$b$$$ such that $$$b[i] = a[i] \% k$$$.
Now, instead of letting health values wrap around, we can just initially give each octopus a multiple of $$$k$$$ more health. For example, if $$$k=3$$$ and an octopus with initially $$$2$$$ health regenerates twice, we can pretend it initially had $$$2 + 2 \cdot 3 = 8$$$ health.
Create a new array $$$c$$$ storing these new healths. Since all healths will reach $$$0$$$, it also represents the number of boulders that will hit each octopus.
To find the minimum number of boulder throws, represent the health values with a histogram, where the heights of blocks are equal to the values of $$$c$$$:
Then, erase all vertical borders between blocks. The resulting segments each represent a boulder throw:
Intuitively, this should minimize the number of boulders, since any sequence of boulder throws should be rearrangeable into horizontal segments covering this histogram.
We can easily calculate the number of boulders as the sum of all
positive
adjacent differences, treating the far left and far right as having health $$$0$$$.
Formally, pad $$$c$$$ with an extra $$$0$$$ to the left and right (i.e. $$$c[0] = c[n+1] = 0$$$) and let the adjacent differences be $$$d[i] = c[i+1]-c[i]$$$. We claim the minimum number of boulder throws is $$$\mathrm{throws} = \sum_{i=0}^n{\max\{d[i],0\}}$$$.
This many is necessary, since if $$$d[i]$$$ is positive, octopus $$$i+1$$$ gets crushed $$$d[i]$$$ more times than octopus $$$i$$$, so at least $$$d[i]$$$ boulders' ranges have left endpoint $$$l = i+1$$$.
This many is achievable, as depicted above. Crush all octopuses with the highest health exactly once (crushing consecutive octopuses with the same boulder), then all octopuses with the new highest health, and so on. Each boulder's range's left endpoint corresponds with part of a positive adjacent difference.
Solution
To make things easier, replace health values of $$$k$$$ with health values of $$$0$$$, so the goal is to reach $$$0$$$ health. Regeneration is now from $$$0$$$, which was formerly $$$k$$$, to $$$k-1$$$, instead of $$$1$$$ to $$$k$$$, which is now $$$1$$$ to $$$0$$$. For clarity, create a new array $$$b$$$ such that $$$b[i] = a[i] \% k$$$.
Now, instead of letting health values wrap around, we can just initially give each octopus a multiple of $$$k$$$ more health. For example, if $$$k=3$$$ and an octopus with initially $$$2$$$ health regenerates twice, we can pretend it initially had $$$2 + 2 \cdot 3 = 8$$$ health.
Create a new array $$$c$$$ storing these new healths. Since all healths will reach $$$0$$$, it also represents the number of boulders that will hit each octopus.
To find the minimum number of boulder throws, represent the health values with a histogram, where the heights of blocks are equal to the values of $$$c$$$:
Then, erase all vertical borders between blocks. The resulting segments each represent a boulder throw:
Intuitively, this should minimize the number of boulders, since any sequence of boulder throws should be rearrangeable into horizontal segments covering this histogram.
We can easily calculate the number of boulders as the sum of all
positive
adjacent differences, treating the far left and far right as having health $$$0$$$.
Formally, pad $$$c$$$ with an extra $$$0$$$ to the left and right (i.e. $$$c[0] = c[n+1] = 0$$$) and let the adjacent differences be $$$d[i] = c[i+1]-c[i]$$$. We claim the minimum number of boulder throws is $$$\mathrm{throws} = \sum_{i=0}^n{\max\{d[i],0\}}$$$.
This many is necessary, since if $$$d[i]$$$ is positive, octopus $$$i+1$$$ gets crushed $$$d[i]$$$ more times than octopus $$$i$$$, so at least $$$d[i]$$$ boulders' ranges have left endpoint $$$l = i+1$$$.
This many is achievable, as depicted above. Crush all octopuses with the highest health exactly once (crushing consecutive octopuses with the same boulder), then all octopuses with the new highest health, and so on. Each boulder's range's left endpoint corresponds with part of a positive adjacent difference.
Hint 2
Can you figure out an $$$O(n^2)$$$ solution? And can you improve on it?
Hint 3
Suppose you already had the optimal solution for the subarray $$$a[1 \ldots i]$$$. How could you extend it to $$$a[1 \ldots i+1]$$$?
Tutorial
Read the solution in Hint One before continuing with this tutorial; it provides important definitions.
To reduce the number of possibilities for each $$$c[i]$$$, we prove the following lemma: There exists an optimal choice of $$$c$$$ (minimizing $$$\mathrm{throws}$$$) where all differences between adjacent $$$c[i]$$$ have absolute value less than $$$k$$$.
Intuitively, this is because we can decrease a $$$c[i]$$$ by $$$k$$$. Formally:
Proof of Lemma
We can prove this using a monovariant on the sum of all values in $$$c$$$.
Start with an optimal choice of $$$c$$$. If there does not exist an $$$i$$$ with $$$\lvert d[i]\rvert \geq k$$$, we are done.
Otherwise, choose one such $$$i$$$. Without loss of generality, we can assume $$$d[i]$$$ is positive, as the problem is symmetrical when flipped horizontally.
Now, decrease $$$c[i+1]$$$ by $$$k$$$. This decreases $$$d[i]$$$ by $$$k$$$ to a still-positive value, which decreases $$$\mathrm{throws}$$$ by $$$k$$$. This also increases $$$d[i+1]$$$ by $$$k$$$, which increases $$$\mathrm{throws}$$$ by
at most
$$$k$$$. Thus, $$$\mathrm{throws}$$$ does not increase, so the new $$$c$$$ is still optimal.
We can apply this operation repeatedly on any optimal solution until we do not have any more differences with absolute value $$$\geq k$$$. Since each operation decreases the sum of values in $$$c$$$ by $$$k$$$, this algorithm terminates since the sum of values in $$$c$$$ is finite.
By the previous lemma, if we have determined $$$c[i]$$$, there are at most $$$2$$$ choices for $$$c[i+1]$$$. (There is $$$1$$$ choice when $$$b[i] = b[i+1]$$$, resulting in $$$d[i] = 0$$$, $$$c[i] = c[i+1]$$$, effectively merging the two octopuses.)
We can visualize this as a DAG in the 2D plane over all points $$$(i,c[i])$$$ (over all possible choices of $$$c[i]$$$). Each point points to the points in the next column that are the closest above and below (if it exists), forming a grid-like shape. Our goal is to find a path of minimum cost from $$$(0,0)$$$ to $$$(n+1,0)$$$.
This is the DAG for the second testcase in samples:
Call each time we choose a $$$c[i+1] > c[i]$$$ (i.e. positive $$$d[i]$$$) an
ascent
. Note that the number of ascents is fixed because each nonzero $$$d[i]$$$ is either $$$x$$$ or $$$x+k$$$ for some fixed negative $$$x$$$, and there must be a fixed number of $$$+k$$$'s to make the total change from $$$c[0]$$$ to $$$c[n+1]$$$ zero.
Each ascent brings the path up to the next "row" of descents. Since these rows slope downwards, the $$$j$$$th ascent must take place at or before some index $$$i_j$$$, because otherwise $$$c[i_j+1]$$$ would be negative.
We can use the following strategy to find a path which we claim is optimal:
If we can descend, then we descend. Otherwise, either we ascend, or alternatively, we change a previous descent into an ascent so we can descend here. (This can be further simplified by having a hypothetical "descent" here, so you do not need to compare two possibilities in the implementation.) Now, the best such location for an ascent is the one with
minimum cost.
Proof
We show how to improve (or preserve the optimality of) any other path into the one chosen by this strategy. Index the ascents by the order they are chosen by the strategy, not in left-to-right order.
Let $$$j$$$ be the index of first ascent this strategy chooses that is not in the compared path. Besides the $$$j-1$$$ matching ascents, the compared path must contain at least $$$1$$$ more ascent at or before $$$i_j$$$, and because of how the strategy chooses ascents, said ascent(s) must have cost no less than the strategy’s $$$j$$$th ascent. Any can be changed to match the strategy, since the matching ascents already guarantee that each of the first $$$j-1$$$ ascents in left-to-right order happens early enough.
Repeating the above operation will obtain the strategy’s path.
We can implement the above strategy with a priority queue, where for each descent we push on the cost of the corresponding ascent, and when an ascent is required, we then pop off the minimum element. In particular, if $$$b[i] < b[i+1]$$$, then the corresponding ascent has cost $$$b[i+1]-b[i]$$$, while if $$$b[i] > b[i+1]$$$, it has cost $$$b[i+1]-b[i]+k$$$. Also, since the bottom of the DAG corresponds to $$$c[i] = b[i]$$$, an ascent is required exactly when $$$b[i] < b[i+1]$$$.
Proof of Lemma
We can prove this using a monovariant on the sum of all values in $$$c$$$.
Start with an optimal choice of $$$c$$$. If there does not exist an $$$i$$$ with $$$\lvert d[i]\rvert \geq k$$$, we are done.
Otherwise, choose one such $$$i$$$. Without loss of generality, we can assume $$$d[i]$$$ is positive, as the problem is symmetrical when flipped horizontally.
Now, decrease $$$c[i+1]$$$ by $$$k$$$. This decreases $$$d[i]$$$ by $$$k$$$ to a still-positive value, which decreases $$$\mathrm{throws}$$$ by $$$k$$$. This also increases $$$d[i+1]$$$ by $$$k$$$, which increases $$$\mathrm{throws}$$$ by
at most
$$$k$$$. Thus, $$$\mathrm{throws}$$$ does not increase, so the new $$$c$$$ is still optimal.
We can apply this operation repeatedly on any optimal solution until we do not have any more differences with absolute value $$$\geq k$$$. Since each operation decreases the sum of values in $$$c$$$ by $$$k$$$, this algorithm terminates since the sum of values in $$$c$$$ is finite.
Proof
We show how to improve (or preserve the optimality of) any other path into the one chosen by this strategy. Index the ascents by the order they are chosen by the strategy, not in left-to-right order.
Let $$$j$$$ be the index of first ascent this strategy chooses that is not in the compared path. Besides the $$$j-1$$$ matching ascents, the compared path must contain at least $$$1$$$ more ascent at or before $$$i_j$$$, and because of how the strategy chooses ascents, said ascent(s) must have cost no less than the strategy’s $$$j$$$th ascent. Any can be changed to match the strategy, since the matching ascents already guarantee that each of the first $$$j-1$$$ ascents in left-to-right order happens early enough.
Repeating the above operation will obtain the strategy’s path.
Code (C++)
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

void solve() {
	int n, k;
	cin >> n >> k;
	priority_queue<int, vector<int>, greater<int>> differences;
	int previous = 0;
	ll ans = 0;
	for (int i = 0; i < n; i++) {
		int x;
		cin >> x;
		x %= k;
		if (x > previous) {
			differences.push(x - previous);
			ans += differences.top();
  			differences.pop();
		} else {
  			differences.push(k + x - previous);
		}
		previous = x;
  	}
  	cout << ans << "\n";
}

int main() {
	int t;
	cin >> t;
	while (t--)
		solve();
}
--------------------------------------------------
Problem ID: 1852B
Editorial Content:
1852B - Imbalanced Arrays
Hint 1
You can solve the problem by picking one number from each pair $$$(n, -n)$$$, $$$(n - 1, -n + 1) \dots$$$, $$$(1, -1)$$$.
Hint 2
$$$b_i > b_j$$$ implies $$$a_i > a_j$$$.
Hint 3
First, try to determine
one
index in $$$O(n)$$$, or determine if that's impossible.
Hint 4
Sort the array $$$a$$$ to optimize the $$$O(n^2)$$$ solution.
Solution
At the start, let $$$x$$$ be an index such that $$$b_x$$$ has the greatest absolute value. If $$$b_x$$$ is negative, we have $$$a_x=0$$$, and else $$$a_x=n$$$. Moreover, we can't have $$$a_y=0,a_z=n$$$ for any indices $$$y$$$ and $$$z$$$, because that implies $$$b_y+b_z$$$ is both positive and negative, contradiction. Hence, the necessary and sufficient condition to check if we can determine an element in array $$$b$$$ with maximum absolute value is (there exists an element of array $$$a$$$ equal to $$$0$$$) xor (there exists an element of array $$$a$$$ equal to $$$n$$$). Then, we can remove that element and re-calculate the $$$a$$$ array, leading to an $$$O(n^2)$$$ solution. If the check fails at any moment, there is no valid solution.
To optimize it further, note that we can sort array $$$a$$$ at the start and keep track of them in a deque-like structure. We only need to check the front and end of the deque to see if our key condition holds. Finally, we can use a variable to record the number of positive elements deleted so far and subtract it from the front and end of the deque when checking our condition, so that each check is $$$O(1)$$$. The overall complexity becomes $$$O(n\log n)$$$ due to sorting.
Code (C++)
#include <bits/stdc++.h>
using namespace std;

int n, ans[100010];
vector<pair<int,int>> arr;

void solve() {
    cin >> n;
    arr.resize(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i].first;
        arr[i].second = i;
    }
    sort(arr.begin(), arr.end());
    int l = 0, r = n - 1, sz = n;
    while (l <= r) {
        if ((arr[r].first == n - l) ^ (arr[l].first == n - 1 - r)) {
            if (arr[r].first == n - l) {
                ans[arr[r--].second] = sz--;
            }
            else {
                ans[arr[l++].second] = -(sz--);
            }
        }
        else {
            cout << "NO" << "\n";
            return;
        }
    }
    cout << "YES" << "\n";
    for (int i = 0; i < n; i++) cout << ans[i] << " ";
    cout << "\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(nullptr);

    int t; cin >> t;
    while(t--) solve();
}
--------------------------------------------------
Problem ID: 1852A
Editorial Content:
1852A - Ntarsis' Set
Hint 1
Suppose that the numbers are arranged in a line in increasing order. Take a look at each number $$$x$$$ before some day. If it isn't deleted on that day, what new position does it occupy, and how is that impacted by its previous position?
Answer
If $$$x$$$ is between $$$a_i$$$ and $$$a_{i+1}$$$, it will move to a new position of $$$x-i$$$, since $$$i$$$ positions before it are deleted.
Answer
If $$$x$$$ is between $$$a_i$$$ and $$$a_{i+1}$$$, it will move to a new position of $$$x-i$$$, since $$$i$$$ positions before it are deleted.
Hint 2
Take this observation, and apply it to simulate the process backwards.
Solution
Suppose the numbers are arranged in a line in increasing order. Consider simulating backwards; instead of deleting the numbers at positions $$$a_1,a_2,\ldots,a_n$$$ in each operation, then checking the first number after $$$k$$$ operations, we start with the number $$$1$$$ at the front, try to insert zeroes right after positions $$$a_1-1, a_2-2, \ldots, a_{n}-n$$$ in each operation so that the zeroes will occupy positions $$$a_1, a_2, \ldots, a_n$$$ after the insertion, and after $$$k$$$ insertions, we will check the position that $$$1$$$ will end up at.
If $$$a_1$$$ is not equal to $$$1$$$, the answer is $$$1$$$. Otherwise, each insertion can be processed in $$$O(1)$$$ if we keep track of how many of $$$a_1-1, a_{2}-2,\ldots,a_{n}-n$$$ are before the current position $$$x$$$ of $$$1$$$; if $$$a_1-1$$$ through $$$a_i-i$$$ are before $$$x$$$, then we will insert $$$i$$$ zeroes before $$$x$$$.
The time complexity is $$$O(n+k)$$$ per test case. The editorial code additionally processes every insertion with the same $$$i$$$ value in $$$O(1)$$$, for $$$O(n)$$$ overall complexity.
There are alternative solutions using binary search with complexity $$$O(k\log nk)$$$ or $$$O(k\log n\log nk)$$$, and we allowed them to pass. In fact, this problem was originally proposed with $$$k \leq 10^9$$$ but we lowered the constraints.
Code (C++) -- Model Solution
#include <bits/stdc++.h>
using namespace std;

int n, k, a[200010];

void solve() {
    cin >> n >> k;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        a[i] -= i;
    }
    if (a[0] != 1) {
        cout << 1 << "\n";
        return;
    }
    a[n] = 2e9;
    //start at position 1, and find what number moves to its position
    long long ans = 1;
    int inc = 1; //how many zeroes to insert
    while (inc < n) {
        int days = (a[inc] - ans + inc - 1) / inc;
        if (days >= k){
            ans += k * inc;
            k = 0;
            break;
        }
        ans += days * inc;
        k -= days;
        while (a[inc] <= ans) inc++;
    }
    ans += 1ll * k * n;
    cout << ans << "\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(nullptr);
    
    int t; cin >> t;
    while (t--) solve();
}
Code (C++) -- Simulation (more readable)
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
const int inf = 1e9+10;
const ll inf_ll = 1e18+10;
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define cmax(x, y) (x = max(x, y))
#define cmin(x, y) (x = min(x, y))

#ifndef LOCAL
#define debug(...) 0
#else
#include "../../debug.cpp"
#endif

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    int t; cin >> t;
    while (t--) {
        ll n, k; cin >> n >> k;
        vector<ll> a(n);
        for (int i = 0; i < n; i++)
            cin >> a[i];

        ll j = 0, x = 1;
        while (k--) {
            while (j < n && a[j] <= x+j)
                j++;
            x += j;
        }

        cout << x << "\n";
    }
}
--------------------------------------------------
Problem ID: 1851G
Editorial Content:
1851G - Vlad and the Mountains
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define x first
#define y second
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()

typedef long double ld;
typedef long long ll;

using namespace std;

struct dsu{
    vector<int> p, lvl;

    dsu(int n){
        p.resize(n);
        lvl.assign(n, 0);
        iota(all(p), 0);
    }

    int get(int i){
        if(i == p[i]) return i;
        return p[i] = get(p[i]);
    }

    bool unite(int a, int b){
        a = get(a);
        b = get(b);
        if(a == b){
            return false;
        }
        if(lvl[a] < lvl[b])swap(a, b);
        p[b] = a;
        if(lvl[a] == lvl[b]){
            ++lvl[a];
        }
        return true;
    }

    bool reachable(int a, int b){
        return get(a) == get(b);
    }
};

void solve(int tc) {
    int n, m;
    cin >> n >> m;
    vector<pair<int, int>> h(n);
    for(auto &e: h) cin >> e.x;
    for(int i = 0; i < n; ++i){
        h[i].y = i;
    }
    dsu graph(n);
    vector<vector<int>> sl(n);
    for(int i = 0; i < m; ++i){
        int u, v;
        cin >> u >> v;
        --u, --v;
        if(h[u].x > h[v].x) sl[u].emplace_back(v);
        else sl[v].emplace_back(u);
    }
    int q;
    cin >> q;
    vector<pair<pair<int, int>, pair<int, int>>> req(q);
    for(auto &e: req){
        cin >> e.y.x >> e.y.y >> e.x.x;
        --e.y.x, --e.y.y;
        e.x.x += h[e.y.x].x;
    }
    for(int i = 0; i < q; ++i){
        req[i].x.y = i;
    }

    sort(all(h));
    sort(all(req));
    vector<bool> ans(q);
    int j = 0;
    for(auto e: req){
        while (j < n && h[j].x <= e.x.x) {
            for(int u: sl[h[j].y]){
                graph.unite(h[j].y, u);
            }
            ++j;
        }
        ans[e.x.y] = graph.reachable(e.y.x, e.y.y);
    }
    for(bool e: ans) cout << (e? "YES": "NO") << "\n";
}

bool multi = true;

signed main() {
    int t = 1;
    if(multi) cin >> t;
    for (int i = 1; i <= t; ++i) {
        solve(i);
        if(i < t) cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1851F
Editorial Content:
1851F - Lisa and the Martians
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
#define all(arr) arr.begin(), arr.end()

using namespace std;

const int MAXN = 200200;
const int MAXK = 30;
const int MAXMEM = MAXN * MAXK;

mt19937 rng(07062006);

struct node {
	node *chi[2] {nullptr};
	int sz = 0, id = -1;
};

int n, k;
int arr[MAXN];
node *mem = new node[MAXMEM];
node *root, *mpos;

void add_num(node* &v, int val, int i, int id) {
	if (v == nullptr) *(v = mpos++) = node();
	v->sz++;
	if (i == -1) {
		v->id = id;
		return;
	}
	add_num(v->chi[val >> i & 1], val, i - 1, id);
}

int down(node *v, int val, int i, int &x, int &jans) {
	if (i == -1) {
		jans = v->id;
		return 0;
	}
	int b = val >> i & 1;
	if (v->chi[b])
		return down(v->chi[b], val, i - 1, x ^= ((1 ^ b) << i), jans) | (1 << i);
	return down(v->chi[b ^ 1], val, i - 1, x ^= ((rng() & 1) << i), jans);
}

void build() {
	root = nullptr;
	mpos = mem;
	add_num(root, *arr, k - 1, 0);
}

tuple<int, int, int> solve() {
	int ians = 0, jans = 1, xans = 0;
	for (int i = 1; i < n; ++i) {
		int x = 0, j = -1;
		int cur = down(root, arr[i], k - 1, x, j);
		if (cur > ((arr[ians] ^ xans) & (arr[jans] ^ xans)))
			ians = j, jans = i, xans = x;
		add_num(root, arr[i], k - 1, i);
	}
	return {ians, jans, xans};
}

int main() {
	int t; cin >> t;
	while (t--) {
		cin >> n >> k;
		for (int i = 0; i < n; ++i)
			cin >> arr[i];
		build();
		auto [ians, jans, xans] = solve();
		cout << ++ians << ' ' << ++jans << ' ' << xans << endl;
	}
}
--------------------------------------------------
Problem ID: 1851E
Editorial Content:
1851E - Nastya and Potions
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define int long long

using namespace std;

vector<int> dp;
vector<bool> used;
vector<vector<int>> sl;

int get(int v){
    if(used[v]){
        return dp[v];
    }
    used[v] = true;
    int s = 0;
    for(int u: sl[v]){
        s += get(u);
    }
    if(!sl[v].empty()) dp[v] = min(dp[v], s);
    return dp[v];
}

void solve(int tc) {
    int n, k;
    cin >> n >> k;
    dp.resize(n);
    used.assign(n, false);
    sl.assign(n, vector<int>(0));
    for(int &e: dp) cin >> e;
    for(int i = 0; i < k; ++i){
        int e;
        cin >> e;
        dp[--e] = 0;
    }
    for(int i = 0; i < n; ++i){
        int m;
        cin >> m;
        sl[i].resize(m);
        for(int &e: sl[i]){
            cin >> e;
            --e;
        }
    }
    for(int i = 0; i < n; ++i){
        get(i);
    }
    for(int e: dp) cout << e << " ";
}

bool multi = true;

signed main() {
    int t = 1;
    if(multi) cin >> t;
    for (int i = 1; i <= t; ++i) {
        solve(i);
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1851D
Editorial Content:
1851D - Prefix Permutation Sums
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <set>
#include <map>

using namespace std;

typedef long long ll;

ll n;

bool isPermutation(vector<ll> a) {
    for (int i = 0; i < n; ++i) {
        if (a[i] <= 0 || a[i] > n) {
            return false;
        }
    }
    set<ll> s(a.begin(), a.end());
    return s.size() == n;
}

vector<ll> prefSumToArray(vector<ll> p) {
    vector<ll> res(n);
    res[0] = p[0];
    for (int i = 1; i < n; ++i) {
        res[i] = p[i] - p[i - 1];
    }
    return res;
}

void solve() {
    cin >> n;
    vector<ll> a(n - 1);
    for (int i = 0; i + 1 < n; ++i) {
        cin >> a[i];
    }
    ll x = n * (n + 1) / 2;
    if (a.back() != x) {
        a.push_back(x);
        vector<ll> b = prefSumToArray(a);
        if (isPermutation(b)) {
            cout << "YES\n";
        } else {
            cout << "NO\n";
        }
        return;
    }
    map<ll, int> cnt;
    cnt[a[0]]++;
    for (int i = 1; i < n - 1; ++i) {
        cnt[a[i] - a[i - 1]]++;
    }
    vector<int> cntGt1;
    for (auto p: cnt) {
        if (p.second > 1) {
            cntGt1.push_back(p.first);
        }
    }
    if (cntGt1.size() > 1) {
        cout << "NO\n";
        return;
    }
    if (cntGt1.size() == 1) {
        int x1 = cntGt1[0];
        if (cnt[x1] > 2) {
            cout << "NO\n";
            return;
        }
    }
    vector<int> cnt0;
    for (int i = 1; i <= n; ++i) {
        if (cnt[i] == 0) {
            cnt0.push_back(i);
        }
    }
    if (cnt0.size() != 2) {
        cout << "NO\n";
        return;
    }
    cout << "YES\n";
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int t;
    cin >> t;
    for (int _ = 0; _ < t; ++_) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1851C
Editorial Content:
1851C - Tiles Comeback
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;

bool solve(){
    int n, k;
    cin >> n >> k;
    vector<int>c(n);
    for(int i = 0; i < n; i++) cin >> c[i];
    int left = 0, right = 0, i = 0, j = n - 1;
    int k_left = k, k_right = k;

    if (c[0] == c[n - 1]){
        k_left = k / 2;
        k_right = k - k_left;
    }
    for(; i < n && left < k_left; i++){
        if(c[i] == c[0]) left++;
    }
    for(; j >= 0 && right < k_right; j--){
        if(c[j] == c[n - 1]) right++;
    }
    return (i - 1) < (j + 1);
}

int main(){
    int t;
    cin >> t;
    while(t--){
        cout << (solve() ? "YES" : "NO") << "\n";
    }

}
--------------------------------------------------
Problem ID: 1851B
Editorial Content:
1851B - Parity Sort
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>
using namespace std;

bool solve(){
    int n;
    cin >> n;
    vector<int>a(n), b(n);
    for(int i = 0; i < n; i++){
        cin >> a[i];
        b[i] = a[i];
    }
    sort(b.begin(), b.end());
    for(int i = 0; i < n; i++){
        if((a[i] % 2) != (b[i] % 2)) return false;
    }
    return true;

}

int main(){
    int t;
    cin >> t;
    while(t--){
        cout << (solve() ? "YES" : "NO") << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1851A
Editorial Content:
1851A - Escalator Conversations
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

#define forn(i, n) for (int i = 0; i < int(n); i++)
#define sz(v) (int)v.size()
#define all(v) v.begin(),v.end()
#define eb emplace_back



void solve() {
    int n,m,k,H; cin >> n >> m >> k >> H;
    int ans = 0;
    forn(i, n) {
        int x; cin >> x;
        ans += (H != x) && abs(H - x) % k == 0 && abs(H-x) <= (m-1) * k;
    }
    cout << ans << endl;
}

int main() {
    int t;
    cin >> t;

    forn(tt, t) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1850H
Editorial Content:
1850H - The Third Letter
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
#define ll long long
 
#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()
 
#define int long long
const int N = 2e5 + 5;
vector<pair<int, int>> adj[N];
int val[N], vis[N];
void dfs(int u) {
    vis[u] = 1;
    for(auto x: adj[u]) {
        int v = x.first, w = x.second;
        if(!vis[v]) {
            val[v] = val[u] + w;
            dfs(v);
        }
    }
}
void solve() {
    int n, m; cin >> n >> m;
    for(int i = 1; i <= n; ++i) {
        adj[i].clear();
        vis[i] = 0, val[i] = 0;
    }
    vector<array<int, 3>> c;
    for(int i = 1; i <= m; ++i) {
        int a, b, d; cin >> a >> b >> d;
        adj[a].pb({b, d});
        adj[b].pb({a, -d}); 
        c.pb({a, b, d});  
    }
    for(int i = 1; i <= n; ++i) {
        if(!vis[i]) dfs(i);
    }
    for(int i = 1; i <= m; ++i) {
        int a = c[i - 1][0], b = c[i - 1][1], d = c[i - 1][2];
        if(val[a] + d != val[b]) {
            cout << "NO\n";
            return;
        }
    }
    cout << "YES\n";
}   
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1850G
Editorial Content:
1850G - The Morning Star
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
#define startt ios_base::sync_with_stdio(false);cin.tie(0);
typedef long long  ll;
using namespace std;
#define vint vector<int>
#define all(v) v.begin(), v.end()
#define int long long
 
void solve()
{
    int n;
    cin >> n;
    map<int, int> up, side, diag1, diag2;
    int ans = 0;
    for(int i = 0; i < n; i++)
    {
        int x, y;
        cin >> x >> y;
        up[x]++;
        side[y]++;
        diag1[x-y]++;
        diag2[x+y]++;
    }
    for(auto x : up)
    {
        ans+=x.second*(x.second-1);
    }
    for(auto x : side)
    {
        ans+=x.second*(x.second-1);
    }
    for(auto x : diag1)
    {
        ans+=x.second*(x.second-1);
    }for(auto x : diag2)
    {
        ans+=x.second*(x.second-1);
    }
    cout << ans << endl;
}
 
int32_t main(){
    startt
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1850F
Editorial Content:
1850F - We Were Both Children
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
#define ll long long
 
#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()
 
void solve() {
    int n; cin >> n;
    vector<ll> cnt(n + 1, 0), mx(n + 1, 0);
    for(int i = 0; i < n; ++i) {
        int x; cin >> x;
        if(x <= n) ++cnt[x];
    }
    for(int i = 1; i <= n; ++i) {
        for(int j = i; j <= n; j += i) mx[j] += cnt[i];
    }
    cout << *max_element(all(mx)) << "\n";
}   
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1850E
Editorial Content:
1850E - Cardboard for Pictures
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
#define ll long long
 
#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()
 
#define int long long
 
void solve() {
    int n, c; cin >> n >> c;
    vector<int> a(n);
    for(int i = 0; i < n; ++i) cin >> a[i];
    int l = 1, r = 1e9;
    while(l <= r) {
        int mid = l + (r - l) / 2;
        int sumall = 0;
        for(int i = 0; i < n; ++i) {
            sumall += (a[i] + 2 * mid) * (a[i] + 2 * mid);
            if(sumall > c) break;
        }
        if(sumall == c) {
            cout << mid << "\n";
            return;
        }
        if(sumall > c) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
}   
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1850D
Editorial Content:
1850D - Balanced Round
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
#define ll long long
 
#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()
 
void solve() {
    int n, k; cin >> n >> k;
    vector<int> a(n);
    for(int i = 0; i < n; ++i) cin >> a[i];    
    sort(all(a));
    int cnt = 1, ans = 1;
    for(int i = 1; i < n; ++i) {
        if(a[i] - a[i - 1] > k) {
            cnt = 1;
        } else {
            ++cnt;
        }
        ans = max(ans, cnt);
    }
    cout << n - ans << '\n';
}   
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1850C
Editorial Content:
1850C - Word on the Paper
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200007;
const int MOD = 1000000007;
 
void solve() {
	for (int r = 0; r < 8; r++) {
		for (int c = 0; c < 8; c++) {
			char x;
			cin >> x;
			if (x != '.') {cout << x;}
		}
	}	
	cout << '\n';
}
 
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1850B
Editorial Content:
1850B - Ten Words of Wisdom
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200007;
const int MOD = 1000000007;
 
void solve() {
	int n;
	cin >> n;
	int winner = -1, best_score = 0;
	for (int i = 1; i <= n; i++) {
		int a, b;
		cin >> a >> b;
		if (b > best_score && a <= 10) {winner = i; best_score = b;}
	}
	cout << winner << '\n';
}
 
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1850A
Editorial Content:
1850A - To My Critics
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
 
void solve()
{
    int a, b, c;
    cin >> a >> b >> c;
    cout << (a+b+c-min({a,b,c}) >= 10 ? "YES\n" : "NO\n");
    
}
 
int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1849F
Editorial Content:
1849F - XOR Partition
Tutorial
Tutorial is loading...
Solution (BledDest)
#include <bits/stdc++.h>

using namespace std;

#define pb push_back
#define mp make_pair
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
typedef long long LL;
typedef pair<int, int> PII;

const int N = 200000;
const int NODES = 32 * N;
const int INF = int(2e9);

int n;
int a[N];
int nx[NODES][2], cnt[NODES], fn[NODES];
int nodeCount = 1;

void addInt(int x, int pos) {
    int ind = 0;
    for (int i = 29; i >= 0; --i) {
        int bit = (x >> i) & 1;
        if (nx[ind][bit] == 0) {
            nx[ind][bit] = nodeCount++;
        }
        ind = nx[ind][bit];
        ++cnt[ind];
    }
    fn[ind] = pos;
}

void addInt(int x) {
    int ind = 0;
    for (int i = 29; i >= 0; --i) {
        int bit = (x >> i) & 1;
        ind = nx[ind][bit];
        ++cnt[ind];
    }
}

void removeInt(int x) {
    int ind = 0;
    for (int i = 29; i >= 0; --i) {
        int bit = (x >> i) & 1;
        ind = nx[ind][bit];
        --cnt[ind];
    }
}

PII findXor(int x) {
    int ind = 0, res = 0;
    for (int i = 29; i >= 0; --i) {
        int bit = (x >> i) & 1;
        if (cnt[nx[ind][bit]]) {
            ind = nx[ind][bit];
        } else {
            ind = nx[ind][bit ^ 1];
            res |= 1 << i;
        }
    }
    return mp(res, fn[ind]);
}

int par[200000], ra[200000];

void dsuInit() {
    forn(i, n) par[i] = i, ra[i] = 1;
}

int dsuParent(int v) {
    if (v == par[v]) return v;
    return par[v] = dsuParent(par[v]);
}

int dsuMerge(int u, int v) {
    u = dsuParent(u);
    v = dsuParent(v);
    if (u == v) return 0;
    if (ra[u] < ra[v]) swap(u, v);
    par[v] = u;
    ra[u] += ra[v];
    return 1;
}

vector<int> v[200000];
vector<pair<int, PII> > toMerge;
vector<int> g[200000];
int color[200000];

void coloring(int x, int c){
	if(color[x] != -1) return;
	color[x] = c;
	for(auto y : g[x]) coloring(y, c ^ 1);
}

int main() {
    scanf("%d", &n);
    forn(i, n) scanf("%d", a + i);
    forn(i, n) addInt(a[i], i);
    dsuInit();
    for (int merges = 0; merges < n - 1; ) {
        forn(i, n) v[i].clear();
        forn(i, n) v[dsuParent(i)].pb(i);
        toMerge.clear();
        forn(i, n) if (!v[i].empty()) {
            for (int x : v[i]) {
                removeInt(a[x]);
            }
            pair<pair<int, int>, int> res = mp(mp(INF, INF), INF);
            for (int x : v[i]) {
                res = min(res, mp(findXor(a[x]), x));
            }
            toMerge.pb(mp(res.first.first, mp(res.second, res.first.second)));
            for (int x : v[i]) {
                addInt(a[x]);
            }
        }
        for (auto p : toMerge) {
            if (dsuMerge(p.second.first, p.second.second)) {
                ++merges;
				g[p.second.first].pb(p.second.second);
				g[p.second.second].pb(p.second.first);
            }
        }
    }
	forn(i, n) color[i] = -1;
	coloring(0, 1);
	forn(i, n) printf("%d", color[i]);
	puts("");
    return 0;
}
--------------------------------------------------
Problem ID: 1849E
Editorial Content:
1849E - Max to the Right of Min
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

using namespace std;

bool comp(const pair<int, int> &a, const pair<int, int> &b){
    return a.second < b.second;
}

int main(){
    int n;
    scanf("%d", &n);
    vector<pair<int, int>> stmn, stmx;
    stmn.push_back({-1, -1});
    stmx.push_back({n, -1});
    long long ans = 0;
    int len = 0;
    set<pair<int, int>> cur;
    cur.insert({-1, 0});
    cur.insert({-1, 1});
    for (int i = 0; i < n; ++i){
        int x;
        scanf("%d", &x);
        --x;
        
        while (stmn.back().first > x){
            auto it = cur.lower_bound({stmn.back().second, 0});
            auto me = it;
            auto prv = it; --prv;
            ++it;
            len -= me->first - prv->first;
            if (it != cur.end() && it->second == 0)
                len += it->first - prv->first;
            cur.erase(me);
            stmn.pop_back();
        }
        len += i - cur.rbegin()->first;
        cur.insert({i, 0});
        stmn.push_back({x, i});
        
        while (stmx.back().first < x){
            auto it = cur.lower_bound({stmx.back().second, 1});
            auto me = it;
            auto prv = it; --prv;
            ++it;
            if (it != cur.end() && it->second == 0)
                len += me->first - prv->first;
            cur.erase(me);
            stmx.pop_back();
        }
        cur.insert({i, 1});
        stmx.push_back({x, i});
        
        ans += len;
    }
    printf("%lld\n", ans - n);
}
--------------------------------------------------
Problem ID: 1849D
Editorial Content:
1849D - Array Painting
Tutorial
Tutorial is loading...
Solution (BledDest)
n = int(input())
a = list(map(int, input().split()))

ans = 0
l = 0
while l < n:
    r = l + 1
    hasTwo = (a[l] == 2)
    hasMiddleZero = False
    while r < n:
        if r - 1 > l and a[r - 1] == 0:
            hasMiddleZero = True
        if a[r] == 2:
            hasTwo = True
        good = (not hasMiddleZero) and (hasTwo or a[l] != 0 or a[r] != 0)
        if not good:
            break
        r += 1
    l = r
    ans += 1
    
print(ans)
--------------------------------------------------
Problem ID: 1849C
Editorial Content:
1849C - Binary String Copying
Tutorial
Tutorial is loading...
Solution (vovuh)
#include <bits/stdc++.h>

using namespace std;

void solve() {
    int n, m;
    string s;
    cin >> n >> m >> s;
    
    vector<int> lf(n), rg(n);
    lf[0] = -1;
    for (int i = 0; i < n; ++i) {
        if (i > 0) lf[i] = lf[i - 1];
        if (s[i] == '0') lf[i] = i;
    }
    rg[n - 1] = n;
    for (int i = n - 1; i >= 0; --i) {
        if (i + 1 < n) rg[i] = rg[i + 1];
        if (s[i] == '1') rg[i] = i;
    }
    
    set<pair<int, int>> st;
    for (int i = 0; i < m; ++i) {
        int l, r;
        cin >> l >> r;
        int ll = rg[l - 1], rr = lf[r - 1];
        if (ll > rr) {
            st.insert({-1, -1});
        } else {
            st.insert({ll, rr});
        }
    }
    
    cout << st.size() << endl;
}

int main() {
#ifdef _DEBUG
    freopen("input.txt", "r", stdin);
//  freopen("output.txt", "w", stdout);
#endif   
    int t;
    cin >> t;
    while (t--) solve();
}
--------------------------------------------------
Problem ID: 1849B
Editorial Content:
1849B - Monsters
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (auto &x : a) {
      cin >> x;
      x %= k;
      if (!x) x = k;
    }
    vector<int> ord(n);
    iota(ord.begin(), ord.end(), 0);
    stable_sort(ord.begin(), ord.end(), [&](int i, int j) {
      return a[i] > a[j];
    });
    for (auto &x : ord) cout << x + 1 << ' ';
    cout << endl;
  }
}
--------------------------------------------------
Problem ID: 1849A
Editorial Content:
1849A - Morning Sandwich
Tutorial
Tutorial is loading...
Solution (awoo)
fun main() = repeat(readLine()!!.toInt()) {
	val (b, c, h) = readLine()!!.split(' ').map { it.toInt() }
	println(minOf(b - 1, c + h) * 2 + 1)
}
--------------------------------------------------
Problem ID: 1848F
Editorial Content:
1848F - Vika and Wiki
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAXN = (1 << 20);
 
int a[MAXN];
 
int solve(int n) {
    if (n == 1) {
        if (a[0] == 0) {
            return 0;
        } else {
            return 1;
        }
    }
    int fl = true;
    for (int i = 0; i < n / 2; ++i) {
        if (a[i] != a[i + n / 2]) {
            fl = false;
        }
    }
    if (fl) {
        return solve(n / 2);
    }
    for (int i = 0; i < n / 2; ++i) {
        a[i] ^= a[i + n / 2];
    }
    return n / 2 + solve(n / 2);
}
 
int32_t main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
    }
    cout << solve(n) << endl;
    return 0;
}
--------------------------------------------------
Problem ID: 1848E
Editorial Content:
1848E - Vika and Stone Skipping
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int K = 1e6;
 
#define int long long
 
int mod;
 
int dp[K + 1];
int cnt[K + 1];
 
const int MM = 3e6 + 7;
 
int inv[MM];
 
int cc = 0;
 
int mul(int a, int b) {
    int bb = b;
    while (bb % mod == 0) {
        ++cc;
        bb /= mod;
    }
    return (a * (bb % mod)) % mod;
}
 
int dv(int a, int b) {
    int bb = b;
    while (bb % mod == 0) {
        --cc;
        bb /= mod;
    }
    return (a * inv[bb % mod]) % mod;
}
 
 
int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int x, q;
    cin >> x >> q >> mod;
    inv[1] = 1;
    for (int i = 2; i < MM && i < mod; i++) {
        inv[i] = mod - inv[mod % i] * (mod / i) % mod;
    }
    int y = x;
    for (int i = 3; i <= K; i += 2) {
        if (dp[i]) {
            continue;
        }
        for (int j = i; j <= K; j += 2 * i) {
            dp[j] = i;
        }
    }
    int ans = 1;
    while (x % 2 == 0) {
        x /= 2;
    }
    for (int i = 3; i <= K; i += 2) {
        while (x % i == 0) {
            ans = dv(ans, cnt[i] + 1);
            ++cnt[i];
            ans = mul(ans, cnt[i] + 1);
            x /= i;
        }
    }
    int f = 1;
    if (x > 1) {
        ans = mul(ans, 2);
    }
    x = y;
    for (int i = 0; i < q; ++i) {
        int d;
        cin >> d;
        while (d % 2 == 0) {
            d /= 2;
        }
        int k = d;
        while (dp[k]) {
            ans = dv(ans, cnt[dp[k]] + 1);
            ++cnt[dp[k]];
            ans = mul(ans, cnt[dp[k]] + 1);
            k /= dp[k];
        }
        if (cc) {
            cout << 0 << '\n';
        } else {
            cout << ans << '\n';
        }
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1848D
Editorial Content:
1848D - Vika and Bonuses
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define int long long
 
int f(int s, int k) {
    // (s + 20x) * (k - 4x)
    // (-80)x^2 + (20k - 4s)x + (sk)
    // -b/2a = (5k-s)/40
    int x = (5 * k - s) / 40;
    x = min(x, k / 4);
    int res = s * k;
    if (x > 0) {
        res = max(res, (s + 20 * x) * (k - 4 * x));
    }
    x = min(x + 1, k / 4);
    if (x > 0) {
        res = max(res, (s + 20 * x) * (k - 4 * x));
    }
    return res;
}
 
int32_t main() {
    int t;
    cin >> t;
    while (t--) {
        int s, k;
        cin >> s >> k;
        int ans = s * k;
        if (s % 10 == 5) {
            ans = max(ans, (s + 5) * (k - 1));
        } else if (s % 10) {
            if (s % 2 == 1) {
                s += s % 10;
                --k;
            }
            for (int i = 0; i < 4; ++i) {
                if (k > 0) {
                    ans = max(ans, f(s, k));
                }
                s += s % 10;
                --k;
            }
        }
        cout << ans << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1848C
Editorial Content:
1848C - Vika and Price Tags
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define int long long
 
int gcd(int a, int b) {
    if (a == 0) {
        return 0;
    }
    if (b == 0) {
        return 1;
    }
    if (a >= b) {
        int r = a % b;
        int k = a / b;
        if (k % 2 == 1) {
            return gcd(b, r) + k + k / 2;
        } else {
            return gcd(r, b) + k + k / 2;
        }
    }
    return 1 + gcd(b, abs(a - b));
}
 
int calc(int a, int b) {
    if (a == 0) {
        return 0;
    }
    if (b == 0) {
        return 1;
    }
    return 1 + calc(b, abs(a - b));
}
 
int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    for (int _ = 0; _ < t; ++_) {
        int n;
        cin >> n;
        vector<int> a(n);
        vector<int> b(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }
        for (int i = 0; i < n; ++i) {
            cin >> b[i];
        }
        set<int> cnt;
        for (int i = 0; i < n; ++i) {
            if (a[i] == 0 && b[i] == 0) {
                continue;
            }
            cnt.insert(gcd(a[i], b[i]) % 3);
        }
        if (cnt.size() <= 1) {
            cout << "YES" << endl;
        } else {
            cout << "NO" << endl;
        }
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1848B
Editorial Content:
1848B - Vika and the Bridge
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> c(n);
        for (int i = 0; i < n; ++i) {
            cin >> c[i];
        }
        vector<int> last(k, -1);
        vector<int> max_step(k), max2_step(k);
        for (int i = 0; i < n; ++i) {
            int step = i - last[c[i] - 1];
            if (step > max_step[c[i] - 1]) {
                max2_step[c[i] - 1] = max_step[c[i] - 1];
                max_step[c[i] - 1] = step;
            } else if (step > max2_step[c[i] - 1]) {
                max2_step[c[i] - 1] = step;
            }
            last[c[i] - 1] = i;
        }
        for (int i = 0; i < k; ++i) {
            int step = n - last[i];
            if (step > max_step[i]) {
                max2_step[i] = max_step[i];
                max_step[i] = step;
            } else if (step > max2_step[i]) {
                max2_step[i] = step;
            }
        }
        int ans = 1e9;
        for (int i = 0; i < k; ++i) {
            ans = min(ans, max((max_step[i] + 1) / 2, max2_step[i]));
        }
        cout << ans - 1 << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1848A
Editorial Content:
1848A - Vika and Her Friends
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define int long long
 
int32_t main() {
    int t;
    cin >> t;
    while (t--) {
        int n, m, k;
        cin >> n >> m >> k;
        int x, y;
        cin >> x >> y;
        string ans = "YES\n";
        for (int i = 0; i < k; ++i) {
            int xx, yy;
            cin >> xx >> yy;
            if ((x + y) % 2 == (xx + yy) % 2) {
                ans = "NO\n";
            }
        }
        cout << ans;
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1847F
Editorial Content:

--------------------------------------------------
Problem ID: 1847E
Editorial Content:

--------------------------------------------------
Problem ID: 1847D
Editorial Content:

--------------------------------------------------
Problem ID: 1847C
Editorial Content:
1847C — Vampiric Powers, anyone?
proof
Lets denote $$$f(u,v) =$$$ xor of all $$$a_i$$$ such that $$$min(u,v) \leq i < max(u,v)$$$. In the first operation you add $$$f(n,i)$$$. I.e. $$$[u_1,v_1)=[n,i)$$$. It can be proven that $$$f(u_k,v_k) = f(v_{k-1},v_k)$$$ in the $$$k$$$-th operation which is a range.
proof
Suppose we have taken $$$k$$$ ranges that already satisfy this property. Now, I add a new $$$k+1$$$-th range. So, first I need to take the $$$k$$$-th range $$$f(u_k,v_k)$$$. Now I'm xoring it with the range $$$f(u_{k - 1}, v_{k - 1})$$$. As [ $$$u_k, v_k$$$) and [ $$$u_{k - 1}, v_{k - 1}$$$) share an endpoint, the result for these ranges will be a range.
proof
For two ranges $$$f(x,y)$$$ and $$$f(y,z)$$$, if the two ranges do not intersect, the result will be the sum of the two ranges $$$f(x,z)$$$. If the two ranges intersect, then the intersections will be cancelled out, and the result will be the difference $$$f(x,z)$$$.
proof
Suppose we have taken $$$k$$$ ranges that already satisfy this property. Now, I add a new $$$k+1$$$-th range. So, first I need to take the $$$k$$$-th range $$$f(u_k,v_k)$$$. Now I'm xoring it with the range $$$f(u_{k - 1}, v_{k - 1})$$$. As [ $$$u_k, v_k$$$) and [ $$$u_{k - 1}, v_{k - 1}$$$) share an endpoint, the result for these ranges will be a range.
proof
For two ranges $$$f(x,y)$$$ and $$$f(y,z)$$$, if the two ranges do not intersect, the result will be the sum of the two ranges $$$f(x,z)$$$. If the two ranges intersect, then the intersections will be cancelled out, and the result will be the difference $$$f(x,z)$$$.
proof
For two ranges $$$f(x,y)$$$ and $$$f(y,z)$$$, if the two ranges do not intersect, the result will be the sum of the two ranges $$$f(x,z)$$$. If the two ranges intersect, then the intersections will be cancelled out, and the result will be the difference $$$f(x,z)$$$.
solution
#include <bits/stdc++.h>
using namespace std;
 
int main() {
    cin.tie(0)->sync_with_stdio(0);
    int ntest;
    cin >> ntest;
    while (ntest--) {
        int n;
        cin >> n;
        vector<int> a(n);
        for (auto &i : a)
            cin >> i;
 
        int const max_value = 1 << 8;
        vector<char> has_pref(max_value);
        has_pref[0] = true;
        int cur_xor = 0;
        int ans = 0;
        for (auto i : a) {
            cur_xor ^= i;
            for (int pref = 0; pref < max_value; ++pref) {
                if (has_pref[pref]) {
                    ans = max(ans, pref ^ cur_xor);
                }
            }
            has_pref[cur_xor] = true;
        }
 
        cout << ans << '\n';
    }
}
--------------------------------------------------
Problem ID: 1847B
Editorial Content:

--------------------------------------------------
Problem ID: 1847A
Editorial Content:

--------------------------------------------------
Problem ID: 1846G
Editorial Content:
1846G - Rudolf and CodeVid-23
Hint 1
Bitmasks
Hint 2
Weighted graph
Hint 3
Dijkstra's algorithm
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int ttt;
    cin >> ttt;
    while (ttt--) {
        int n, m;
        cin >> n >> m;
        bitset<10> tmp;
        cin >> tmp;
        int s = (int) tmp.to_ulong();
        vector<pair<pair<int, int>, int>> edges(m);
        for (int i = 0; i < m; i++) {
            cin >> edges[i].second;
            cin >> tmp;
            edges[i].first.first = ((1 << n) - 1) ^ (int) tmp.to_ulong();
            cin >> tmp;
            edges[i].first.second = (int) tmp.to_ulong();
        }
        vector<int> dist(1 << n, INT_MAX);
        dist[s] = 0;
        set<pair<int, int>> q = {{0, s}};
        while (!q.empty()) {
            auto [d, v] = *q.begin();
            q.erase(q.begin());
            for (int i = 0; i < m; i++) {
                int to = v & edges[i].first.first;
                to |= edges[i].first.second;
                if (dist[to] > d + edges[i].second) {
                    q.erase({dist[to], to});
                    dist[to] = d + edges[i].second;
                    q.insert({dist[to], to});
                }
            }
        }
        if (dist[0] == INT_MAX) dist[0] = -1;
        cout << dist[0] << '\n';
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1846F
Editorial Content:
1846F - Rudolph and Mimic
Hint 1
How number of objects of each type will change after the mimic transformation?
Hint 2
What if all the current objects have the same value?
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <map>

using namespace std;

int main() {
	int test_cases;
	cin >> test_cases;
	for (int test_case = 0; test_case < test_cases; test_case++) {
		int n;
		cin >> n;
		vector<int> v(n);
		map<int, int> m;
		for (int i = 0; i < n; i++) {
			cin >> v[i];
			m[v[i]]++;
		}
		vector<int> elements_to_erase;
		int ans;
		for (int i = 0; i < 5; i++) {
			if (v.size() - elements_to_erase.size() == 1) {
				cout << "! " << ans << endl;
				break;
			}
			cout << "- " << elements_to_erase.size() << " ";
			for (int j = 0; j < elements_to_erase.size(); j++) {
				cout << elements_to_erase[j] << " ";
			}
			cout << endl;
			vector<int> new_v;
			map<int, int> new_m;
			for (int j = 0; j < v.size() - elements_to_erase.size(); j++) {
				int x;
				cin >> x;
				new_v.push_back(x);
				new_m[x]++;
			}
			elements_to_erase.clear();
			int tm = -1;
			for (auto& k : new_m) {
				if (k.second > m[k.first]) {
					tm = k.first;
				}
			}
			if (tm != -1) {
				for (int j = 0; j < new_v.size(); j++) {
					if (new_v[j] != tm)
						elements_to_erase.push_back(j + 1);
					else
						ans = j + 1;
				}
				m.clear();
				m[tm] = new_m[tm];
			}
			v = new_v;
		}
	}
	return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1846E2
Editorial Content:
1846E2 - Rudolf and Snowflakes (hard version)
Hint 1
1 + k + k
2
+ k
3
+ ... + k
p
Hint 2
What maximum value of k can be reached for the current constrains on n?
Hint 3
Can we precalculate for some n and snowflakes with 4 or more levels if there is appropriate k?
Hint 4
How can we check snowflakes with 3 levels separately?
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>

using namespace std;

using LL = long long;

set<long long> nums;

int main() {

    for (long long k = 2; k <= 1000000; ++k) {
        long long val = 1 + k;
        long long p = k*k;
        for (int cnt = 3; cnt <= 63; ++cnt) {
            val += p;
            if (val > 1e18) break;
            nums.insert(val);
            if (p > (long long)(1e18) / k) break;
            p *= k;
        }
    }



    int _ = 0, __ = 1;
    cin >> __;

    for (int _ = 0; _ < __; ++_) {
        long long n;
        cin >> n;
        if (n < 3)
        {
            cout << "NO" << endl;
            continue;
        }
        long long d = 4*n - 3;
        long long sq = sqrt(d);
        long long sqd = -1;
        for (long long i = max(0ll, sq - 5); i <= sq + 5; ++i) {
            if (i*i == d)
            {
                sqd = i;
                break;
            }
        }
        if (sqd != -1 && (sqd - 1) % 2 == 0 && (sqd - 1) / 2 > 1)
        {
            cout << "YES" << endl;
            continue;
        }

        if (nums.count(n)) cout << "YES" << endl;
        else cout << "NO" << endl;

    }


    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1846E1
Editorial Content:
1846E1 - Rudolf and Snowflakes (simple version)
Hint 1
1 + k + k
2
+ k
3
+ ... + k
p
Hint 2
What maximum value of k can be reached for the current constrains on n?
Hint 3
Can we precalculate for each n if there is appropriate k?
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>

using namespace std;

using LL = long long;

set<long long> nums;

int main() {

    for (long long k = 2; k <= 1000; ++k) {
        long long val = 1 + k;
        long long p = k*k;
        for (int cnt = 2; cnt <= 20; ++cnt) {
            val += p;
            if (val > 1e6) break;
            nums.insert(val);            
            p *= k;
        }
    }



    int _ = 0, __ = 1;
    cin >> __;

    for (int _ = 0; _ < __; ++_) {
        long long n;
        cin >> n;
        

        if (nums.count(n)) cout << "YES" << endl;
        else cout << "NO" << endl;

    }


    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1846D
Editorial Content:
1846D - Rudolph and Christmas Tree
Hint 1
Consider all the triangles in order from bottom to top.
Hint 2
What if the current triangle intersects with the next one?
Hint 3
Trapezoid
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cout.precision(10); cout.setf(ios::fixed);
    int ttt;
    cin >> ttt;
    while (ttt--) {
        int n, d, h;
        cin >> n >> d >> h;
        vector<int> y(n);
        for(int i = 0; i < n; i++){
            cin >> y[i];
        }
        long double ans = (long double)d * h / 2.0;
        for (int i = 0; i + 1 < n; ++i) {
            if (y[i + 1] >= y[i] + h) ans += (long double)d * h / 2.0;
            else{
                long double d2 = (long double)d * (y[i] + h - y[i + 1]) / h;
                long double nh = y[i + 1] - y[i];
                ans += (d + d2) / 2.0 * nh;
            }
        }
        cout << ans << '\n';
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1846C
Editorial Content:
1846C - Rudolf and the Another Competition
Hint 1
What is the optimal order of task solving?
Hint 2
t
1
≤ t
2
≤ t
3
≤ ... ≤ t
m
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define int long long

using namespace std;

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int ttt;
    cin >> ttt;
    while(ttt--){
        int n, m, h;
        cin >> n >> m >> h;
        pair<int, long long> rud;
        int ans = 1;
        for(int i = 0; i < n; i++){
            vector<int> cur(m);
            for(int j = 0; j < m; j++){
                cin >> cur[j];
            }
            std::sort(cur.begin(), cur.end());
            int task_cnt = 0;
            long long penalty = 0, sum = 0;
            for(int j = 0; j < m; j++){
                if (sum + cur[j] > h) break;
                sum += cur[j];
                penalty += sum;
                task_cnt++;
            }
            if (i){
                if (make_pair(-task_cnt, penalty) < rud) ans++;
            } else rud = {-task_cnt, penalty};
        }
        cout << ans << '\n';
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1846B
Editorial Content:
1846B - Rudolph and Tic-Tac-Toe
Hint 1
What is the win condition to be checked?
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <string>


using namespace std;

int main() {
	int test_cases;
	cin >> test_cases;
	for (int test_case = 0; test_case < test_cases; test_case++) {
		vector<string> v(3);
		for (int i = 0; i < 3; i++)
			cin >> v[i];
		string ans = "DRAW";
		for(int i = 0; i < 3; i++) {
			if (v[i][0] == v[i][1] && v[i][1] == v[i][2] && v[i][0] != '.')
				ans=v[i][0];
		}
		for (int i = 0; i < 3; i++) {
			if (v[0][i] == v[1][i] && v[1][i] == v[2][i] && v[0][i] != '.')
				ans=v[0][i];
		}
		if (v[0][0] == v[1][1] && v[1][1] == v[2][2] && v[0][0] != '.')
			ans=v[0][0];
		if (v[0][2] == v[1][1] && v[1][1] == v[2][0] && v[0][2] != '.')
			ans=v[0][2];
		cout << ans << endl;
	}
	return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1846A
Editorial Content:
1846A - Rudolph and Cut the Rope
Hint 1
What if the nail with the rope is the only one?
Hint 2
How long should be rope to reach the ground?
Tutorial
Tutorial is loading...
Solution
#include <iostream>

using namespace std;


int main() {
	int test_cases;
	cin >> test_cases;

	for (int test_case = 0; test_case < test_cases; test_case++) {
		int n;
		cin >> n;
		int ans = 0;
		for (int i = 0; i < n; i++) {
			int a, b;
			cin >> a >> b;
			if (a > b)
				ans++;
		}
		cout << ans << endl;
	}

	return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1845F
Editorial Content:
1845F - Swimmers in the Pool
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>

using namespace std;

#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define forn(i, n) for(int i = 0; i < int(n); i++)
#define sz(a) int((a).size())

#define x first
#define y second

typedef long long li;
typedef pair<int, int> pt;

template<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {
	return out << "(" << p.x << ", " << p.y << ")";
}
template<class A> ostream& operator <<(ostream& out, const vector<A> &v) {
	fore(i, 0, sz(v)) {
		if(i) out << " ";
		out << v[i];
	}
	return out;
}

const int INF = int(1e9);
const li INF64 = li(1e18);

const int LOGN = 19;
const int N = (1 << LOGN) + 555;

struct comp {
	double x, y;
	comp(double x = .0, double y = .0) : x(x), y(y) {}
	inline comp conj() { return comp(x, -y); }
};

inline comp operator +(const comp &a, const comp &b) {
	return comp(a.x + b.x, a.y + b.y);
}

inline comp operator -(const comp &a, const comp &b) {
	return comp(a.x - b.x, a.y - b.y);
}

inline comp operator *(const comp &a, const comp &b) {
	return comp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

inline comp operator /(const comp &a, const double &b) {
	return comp(a.x / b, a.y / b);
}

namespace FFT {
	const double PI = acosl(-1.0);
	vector<comp> w[LOGN];
	vector<int> rv;

	void precalc() {
		forn(st, LOGN) {
			w[st].resize(1 << st);
			forn(i, 1 << st) {
				double ang = PI / (1 << st) * i;
				w[st][i] = comp(cos(ang), sin(ang));
			}
		}
		rv.assign(1 << LOGN, 0);
	    fore(i, 1, sz(rv))
			rv[i] = (rv[i >> 1] >> 1) | ((i & 1) << (LOGN - 1));
	}
	
	inline void fft(comp a[N], int n, bool inv) {
		int ln = __builtin_ctz(n);
		forn(i, n) {
	        int ni = rv[i] >> (LOGN - ln);
	        if(i < ni) swap(a[i], a[ni]);
	    }
	
		for(int st = 0; st < ln; st++) {
			int len = 1 << st;
			for(int k = 0; k < n; k += (len << 1))
				fore(pos, k, k + len) {
					comp l = a[pos];
					comp r = a[pos + len] * w[st][pos - k];
					
					a[pos] = l + r;
					a[pos + len] = l - r;
				}
		}
	
		if(inv) {
			forn(i, n)
				a[i] = a[i] / n;
			reverse(a + 1, a + n);
		}
	}
	
	comp aa[N], bb[N], cc[N];
	
	inline void multiply(int a[N], int sza, int b[N], int szb, int c[N], int &szc) {
		int ln = 1;
		while(ln < (sza + szb)) // sometimes works max(sza, szb)
			ln <<= 1;
			
		forn(i, ln)
			aa[i] = (i < sza ? a[i] : comp());
		forn(i, ln)
			bb[i] = (i < szb ? b[i] : comp());
			
		fft(aa, ln, false);
		fft(bb, ln, false);
		
		forn(i, ln)
			cc[i] = aa[i] * bb[i];
			
		fft(cc, ln, true);
		
		szc = ln;
		forn(i, szc)
			c[i] = int(cc[i].x + 0.5);
	}
}

const int MOD = int(1e9) + 7;
int norm(int a) {
	while (a >= MOD)
		a -= MOD;
	while (a < 0)
		a += MOD;
	return a;
}
int mul(int a, int b) {
	return int(a * 1ll * b % MOD);
}

li l, t;
int n;
vector<int> v;

inline bool read() {
	if(!(cin >> l >> t >> n))
		return false;
	v.resize(n);
	fore (i, 0, n)
		cin >> v[i];
	return true;
}

int mu[N], minD[N];
vector<int> divs[N];

void precalcDivs(int N) {
	fore (d, 1, N) {
		for (int v = d; v < N; v += d)
			divs[v].push_back(d);
	}
	
	mu[1] = 1;
	fore (d, 2, N) {
		if (minD[d] == 0)
			minD[d] = d;
		
		if (minD[d] != minD[d / minD[d]])
			mu[d] = -mu[d / minD[d]];
		
		for (int v = 2 * d; v < N; v += d) {
			if (minD[v] == 0)
				minD[v] = d;
		}
	}
}

int vs[2][N], res[N], ps[N];
li mxk[N];

inline void solve() {
	FFT::precalc();

	fore (i, 0, n) {
		vs[0][v[i]] = 1;
		vs[1][v[i]] = 1;
	}
	int sz = 1 + *max_element(v.begin(), v.end());
	
	int szRes = 0;
	FFT::multiply(vs[0], sz, vs[1], sz, res, szRes);
	
	fore (i, 0, szRes) {
		if (!(i & 1) && vs[0][i >> 1] > 0)
			res[i]--;
		if (res[i] > 0) {
			ps[i] = 1;
		}
	}
	
	memset(vs[1], 0, sizeof vs[1]);
	fore (i, 0, n)
		vs[1][sz - 1 - v[i]] = 1;
	FFT::multiply(vs[0], sz, vs[1], sz, res, szRes);
	
	fore (i, sz, szRes) {
		if (res[i] > 0) {
			ps[i - sz + 1] = 1;
		}
	}
	
	precalcDivs(2 * sz);
	
	int ans = 0;
	for (int i = N - 1; i > 0; i--) {
		if (ps[i] > 0)
			mxk[i] = max(mxk[i], t * 1ll * i / (2ll * l));
		
		for (int d : divs[i]) {
//			ans += mu[d] * (mxk[i] / d);
			ans = norm(ans + mu[d] * int((mxk[i] / d) % MOD));
			mxk[i / d] = max(mxk[i / d], mxk[i] / d);
		}
	}
	cout << ans << endl;
}

int main() {
#ifdef _DEBUG
	freopen("input.txt", "r", stdin);
	int tt = clock();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(15);
	
	if(read()) {
		solve();
		
#ifdef _DEBUG
		cerr << "TIME = " << clock() - tt << endl;
		tt = clock();
#endif
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1845E
Editorial Content:
1845E - Boxes and Balls
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

const int MOD = int(1e9) + 7;

int add(int a, int b){
	a += b;
	if (a >= MOD)
		a -= MOD;
	return a;
}

int main() {
	int n, k;
	scanf("%d%d", &n, &k);
	vector<int> a(n);
	forn(i, n) scanf("%d", &a[i]);
	int lim = 1;
	while (lim * (lim + 1) < k * 2) ++lim;
	vector<vector<vector<int>>> dp(2, vector<vector<int>>(2 * lim + 1, vector<int>(k + 1)));
	dp[0][lim][0] = 1;
	forn(ii, n){
		int i = ii & 1;
		int ni = i ^ 1;
		dp[ni] = vector<vector<int>>(2 * lim + 1, vector<int>(k + 1));
		forn(j, 2 * lim + 1) forn(t, k + 1) if (dp[i][j][t]){
			forn(z, 2){
				int nj = j + z - a[ii];
				int nt = t + abs(nj - lim);
				if (nt <= k) dp[ni][nj][nt] = add(dp[ni][nj][nt], dp[i][j][t]);
			}
		}
	}
	int ans = 0;
	for (int t = k & 1; t <= k; t += 2)
		ans = add(ans, dp[n & 1][lim][t]);
	printf("%d\n", ans);
	return 0;
}
--------------------------------------------------
Problem ID: 1845D
Editorial Content:
1845D - Rating System
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

using li = long long;

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    li delta = 0, ans = 0;
    li sum = 0, mx = 0;
    for (int i = 0; i < n; ++i) {
      li x; cin >> x;
      sum += x;
      mx = max(mx, sum);
      if (sum - mx < delta) {
        delta = sum - mx;
        ans = mx;
      }
    }
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1845C
Editorial Content:
1845C - Strong Password
Tutorial
Tutorial is loading...
Solution (awoo)
import sys
for _ in range(int(sys.stdin.readline())):
	s = [int(c) for c in sys.stdin.readline().strip()]
	n = len(s)
	m = int(sys.stdin.readline())
	l = sys.stdin.readline()
	r = sys.stdin.readline()
	mx = 0
	for i in range(m):
		li = int(l[i])
		ri = int(r[i])
		nmx = mx
		for c in range(li, ri + 1):
			cur = mx
			while cur < n and s[cur] != c:
				cur += 1
			nmx = max(nmx, cur)
		mx = nmx + 1
	print("YES" if mx > n else "NO")
--------------------------------------------------
Problem ID: 1845B
Editorial Content:
1845B - Come Together
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>

using namespace std;

#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define sz(a) int((a).size())

#define x first
#define y second

typedef long long li;
typedef pair<int, int> pt;

pt A, B, C;

inline bool read() {
	if(!(cin >> A.x >> A.y))
		return false;
	cin >> B.x >> B.y;
	cin >> C.x >> C.y;
	return true;
}

int dist(const pt &A, const pt &B) {
	return abs(A.x - B.x) + abs(A.y - B.y);
}

inline void solve() {
	cout << (dist(A, B) + dist(A, C) - dist(B, C)) / 2 + 1 << endl;
}

int main() {
#ifdef _DEBUG
	freopen("input.txt", "r", stdin);
	int tt = clock();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(15);
	
	int t; cin >> t;
	while (t--) {
		read();
		solve();
		
#ifdef _DEBUG
		cerr << "TIME = " << clock() - tt << endl;
		tt = clock();
#endif
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1845A
Editorial Content:
1845A - Forbidden Integer
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	n, k, x = map(int, input().split())
	if x != 1:
		print("YES")
		print(n)
		print(*([1] * n))
	elif k == 1 or (k == 2 and n % 2 == 1):
		print("NO")
	else:
		print("YES")
		print(n // 2)
		print(*([3 if n % 2 == 1 else 2] + [2] * (n // 2 - 1)))
--------------------------------------------------
Problem ID: 1844H
Editorial Content:
1844H - Multiple of Three Cycles
Hint 1
The partially formed permutation is composed of several paths and cycles. Only the length of each path/cycle modulo $$$3$$$ matters.
Hint 2
The problem reduces to the following: Given $$$a$$$ $$$1$$$s, $$$b$$$ $$$2$$$s, and $$$c$$$ $$$0$$$s, how many ways are there to build a permutation on these objects so that each cycle sums to a multiple of $$$3$$$? Let $$$f(a,b,c)$$$ be the answer. Write some dynamic programming recurrences for $$$f(a,b,c)$$$.
Hint 3
Note that $$$f(a,b,c) = (a+b+c)f(a,b,c-1)$$$ (choose the next object of any $$$0$$$ and merge them).
Why is this useful?
This allows us to eliminate the $$$c$$$ parameter, multiplying the answer by a factorial and inverse factorial.
Why is this useful?
This allows us to eliminate the $$$c$$$ parameter, multiplying the answer by a factorial and inverse factorial.
Hint 4
Let $$$f(a,b) = f(a,b,0)$$$. Write down not one, but two recurrence relations $$$f(a,b)$$$ satisfies.
What are the recurrences?
We have $$$f(a,b) = b(a+b-1)f(a-1,b-1) + (a-1)f(a-2,b+1)$$$ when $$$a > 0$$$ (choose the next object of any $$$1$$$ and merge them) and also $$$f(a,b) = a(a+b-1)f(a-1,b-1) + (b-1)f(a+1,b-2)$$$ when $$$b > 0$$$ (choose the next object of any $$$2$$$ and merge them).
What are the recurrences?
We have $$$f(a,b) = b(a+b-1)f(a-1,b-1) + (a-1)f(a-2,b+1)$$$ when $$$a > 0$$$ (choose the next object of any $$$1$$$ and merge them) and also $$$f(a,b) = a(a+b-1)f(a-1,b-1) + (b-1)f(a+1,b-2)$$$ when $$$b > 0$$$ (choose the next object of any $$$2$$$ and merge them).
Hint 5
These recurrences mean that given any two of $$$f(a,b),f(a-1,b-1),f(a+2,b-1),f(a-1,b+2)$$$, we can solve for the other two.
Hint 6
Consider the pairs $$$(a,b)$$$ that arise from the $$$n$$$ queries. These pairs can be visualized as a walk in the plane, where each each pair does not differ from the previous pair by much. If we carefully use the recurrences to solve for values of $$$f(a,b)$$$ from values we already know, we can answer all queries on this walk while calculating only $$$\mathcal{O}(n)$$$ values of $$$f(a,b)$$$.
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
using namespace std;
typedef long long int LLI;
#define MOD 998244353

int parent[300000],siz[300000];
int find(int n) {
    if (parent[n] != n) parent[n] = find(parent[n]);
    return parent[n];
}
int queries[600000][3],ans[600000];
int fact[300000],invfact[300000],invn[300000];
int inv(int n) {
    int e = MOD-2,r = 1;
    while (e > 0) {
        if (e & 1) r = ((LLI) r*n) % MOD;
        e >>= 1;
        n = ((LLI) n*n) % MOD;
    }
    return r;
}
int main() {
    int i;
    int n,x,y,bad = 1e9;
    int num[3];
    scanf("%d",&n);
    for (i = 0; i < n; i++) parent[i] = i,siz[i] = 1;
    num[0] = 0,num[1] = n,num[2] = 0;
    for (i = 0; i < n; i++) {
        scanf("%d %d",&x,&y);
        x--,y--;
        if (find(x) != find(y)) {
            num[siz[find(x)] % 3]--;
            num[siz[find(y)] % 3]--;
            siz[find(y)] += siz[find(x)];
            parent[find(x)] = find(y);
            num[siz[find(y)] % 3]++;
        }
        else if ((siz[find(x)] % 3) == 0) num[0]--;
        else if (bad == 1e9) bad = i;
        copy(num,num+3,queries[i]);
    }

    fact[0] = 1;
    for (i = 1; i < n; i++) fact[i] = ((LLI) i*fact[i-1]) % MOD;
    invfact[n-1] = inv(fact[n-1]);
    for (i = n-2; i >= 0; i--) invfact[i] = ((LLI) (i+1)*invfact[i+1]) % MOD;
    for (i = 1; i < n; i++) invn[i] = ((LLI) invfact[i]*fact[i-1]) % MOD;

    int m = n;
    while (num[1]+num[2] > 0) {
        int a = (num[1] > 0) ? 1:2;
        num[a]--;
        int b = (num[1] > 0) ? 1:2;
        num[b]--;
        num[(a+b) % 3]++;
        copy(num,num+3,queries[m++]);
    }
    x = 1,y = 1;
    int u = 1,v = 8;
    auto f = [&]() {
        assert(x > 0);
        int nu = (((v-(((LLI) (y+1)*(x+y+1)) % MOD)*u) % MOD)*invn[x]) % MOD;
        int nv = ((((LLI) x*(x+y+2)) % MOD)*nu+(LLI) (y+2)*v) % MOD;
        x--,y += 2,u = nu,v = nv;
        if (u < 0) u += MOD;
        if (v < 0) v += MOD;
    };
    auto g = [&]() {
        assert(y > 0);
        int nu = (((v-(((LLI) (x+1)*(x+y+1)) % MOD)*u) % MOD)*invn[y]) % MOD;
        int nv = ((((LLI) y*(x+y+2)) % MOD)*nu+(LLI) (x+2)*v) % MOD;
        x += 2,y--,u = nu,v = nv;
        if (u < 0) u += MOD;
        if (v < 0) v += MOD;
    };
    for (i = m-1; i >= 0; i--) {
        int a = queries[i][1],b = queries[i][2],c = queries[i][0];
        if ((a == 0) && (b == 0)) ans[i] = 1;
        else if ((a == x) && (b == y)) ans[i] = u;
        else if ((a == x-1) && (b == y+2)) f(),ans[i] = u;
        else if ((a == x+2) && (b == y-1)) g(),ans[i] = u;
        else if ((a == x+1) && (b == y+1)) {
            if (x > 0) f(),g(),ans[i] = u;
            else g(),f(),ans[i] = u;
        }
        else assert(0);
        ans[i] = ((LLI) ans[i]*fact[a+b+c]) % MOD;
        ans[i] = ((LLI) ans[i]*invfact[a+b]) % MOD;
    }
    for (i = 0; i < n; i++) printf("%d\n",(i >= bad) ? 0:ans[i]);

    return 0;
}
--------------------------------------------------
Problem ID: 1844G
Editorial Content:
1844G - Tree Weights
Hint 1
Model the problem as a system of linear equations.
Hint 2
Let $$$x_u$$$ be the sum of the weights of the edges on the path from node $$$1$$$ to node $$$u$$$. The equations are of the form $$$x_i + x_{i+1} - 2x_{\text{lca}(i,i+1)} = d_i$$$.
Hint 3
The intended solution does not do anything like attempt to maintain paths/virtual trees of known weight. One easily overlooked detail that is essential to the solution is that $$$x_i$$$ are integers.
Hint 4
Solve the equations modulo $$$2$$$ first, so that the $$$2x_{\text{lca}(i,i+1)}$$$ term disappears.
Hint 5
After solving the equations modulo $$$2$$$, we can similarly solve modulo $$$4$$$, $$$8$$$, etc.
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
using namespace std;
typedef long long int LLI;
typedef vector<pair<int,int> > vpii;
#define mp make_pair
#define pb push_back

vpii adjList[100000];
LLI d[100000];
int parent[100000][17],parenti[100000],depth[100000];
int doDFS(int u,int p,int d) {
    parent[u][0] = p,depth[u] = d;
    for (auto [v,i]: adjList[u]) {
        if (v != p) parenti[v] = i,doDFS(v,u,d+1);
    }
    return 0;
}
int logn;
int lca(int u,int v) {
    int i;
    if (depth[u] < depth[v]) swap(u,v);
    for (i = logn-1; i >= 0; i--) {
        if ((parent[u][i] != -1) && (depth[parent[u][i]] >= depth[v])) u = parent[u][i];
    }
    if (u == v) return u;
    for (i = logn-1; i >= 0; i--) {
        if (parent[u][i] != parent[v][i]) u = parent[u][i],v = parent[v][i];
    }
    return parent[u][0];
}
int lcas[100000],bit[100000];
LLI ans[100000],w[100000];
int main() {
    int i;
    int n,u,v;
    scanf("%d",&n);
    for (i = 0; i < n-1; i++) {
        scanf("%d %d",&u,&v);
        u--,v--;
        adjList[u].pb(mp(v,i));
        adjList[v].pb(mp(u,i));
    }
    for (i = 0; i < n-1; i++) scanf("%lld",&d[i]);

    int j;
    doDFS(0,-1,0);
    for (i = 1; (1 << i) < n; i++) {
        for (j = 0; j < n; j++) {
            if (parent[j][i-1] != -1) parent[j][i] = parent[parent[j][i-1]][i-1];
            else parent[j][i] = -1;
        }
    }
    logn = i;
    for (i = 0; i < n-1; i++) lcas[i] = lca(i,i+1);

    for (i = 0; i < 57; i++) {
        bit[0] = 0;
        for (j = 0; j < n-1; j++) bit[j+1] = bit[j]^(d[j] & 1);
        for (j = 0; j < n-1; j++) d[j] = (d[j]-bit[j]-bit[j+1]+2*bit[lcas[j]])/2;
        for (j = 0; j < n; j++) ans[j] |= ((LLI) bit[j] << i);
    }
    for (i = 0; i < n-1; i++) {
        if (d[i] != 0) {
            printf("-1\n");
            return 0;
        }
    }
    for (i = 1; i < n; i++) {
        w[parenti[i]] = ans[i]-ans[parent[i][0]];
        if (w[parenti[i]] <= 0) {
            printf("-1\n");
            return 0;
        }
    }
    for (i = 0; i < n-1; i++) printf("%lld\n",w[i]);

    return 0;
}
--------------------------------------------------
Problem ID: 1844F2
Editorial Content:
1844F2 - Min Cost Permutation (Hard Version)
Hint 4
We need to optimize the $$$\mathcal{O}(n^2)$$$ greedy with some data structures. There exist solutions with varying levels of data structure implementation depending on how much effort is put into characterizing the answer array. For a short solution, start by simplifying the formula $$$(*)$$$ (in the solution for the easy version) to get a cleaner description.
Hint 5
The condition is actually equivalent to ($$$a_{i-1}-a_{i+1} \le |c|$$$ or $$$a_{i-1} = a_i$$$ or $$$a_i = a_{i+1}$$$) and ($$$b_{k-1}-a_i \le |c|$$$).
Hint 6
Maintain a linked list of the unused entries of $$$a$$$ and a set of unused entries that satisfy ($$$a_{i-1}-a_{i+1} \le |c|$$$ or $$$a_{i-1} = a_i$$$ or $$$a_i = a_{i+1}$$$).
Solution (hard version)
1844F2 - Min Cost Permutation (Hard Version)
Let $$$c < 0$$$.
We now simplify condition $$$(*)$$$, which involves considering a few cases depending on the sign of the terms. It turns out that the condition is equivalent to ($$$a_{i-1}-a_{i+1} \le |c|$$$ or $$$a_{i-1} = a_i$$$ or $$$a_i = a_{i+1}$$$) and ($$$b_{k-1}-a_i \le |c|$$$) (for full details, see the overall proof below).
Sort $$$a$$$ in nonincreasing order so that $$$a_1 \ge a_2 \ge \dots \ge a_n$$$. We can simulate the greedy algorithm from the easy version with the help of a linked list of the unused elements of $$$a$$$ and a set of $$$a_i$$$ which satisfy the first part of the condition, ($$$a_{i-1}-a_{i+1} \le |c|$$$ or $$$a_{i-1} = a_i$$$ or $$$a_i = a_{i+1}$$$). Here, $$$a_{i-1}$$$ and $$$a_{i+1}$$$ actually refer to the closest unused elements of $$$a$$$, which are $$$a_i$$$'s left and right pointers in the linked list, respectively.
Each time, we query the set for its smallest element $$$a_i$$$ that satisfies $$$a_i \ge b_{k-1}-|c|$$$. If this element does not exist, then we take $$$a_i$$$ to be the largest element in the linked list. Then, we set $$$b_k := a_i$$$, delete $$$a_i$$$ from the linked list, and update the set with the left and right elements of $$$a_i$$$ if they now satisfy the condition.
One small observation is that in the answer $$$b$$$, $$$b_1 = a_1$$$ and $$$b_n = a_n$$$. This may simplify the implementation since it means that some edge cases of $$$(*)$$$ actually don't need to be checked. It is also actually not necessary to check the $$$a_{i-1} = a_i$$$ or $$$a_i = a_{i+1}$$$ condition.
The time complexity is $$$\mathcal{O}(n \log n)$$$.
Proofs
The case $$$n \le 2$$$ is trivial. In the following, we only consider the case $$$c < 0$$$ and $$$n \ge 3$$$. The case $$$c \ge 0$$$ follows by symmetry (reverse the array).
Let $$$c' := -c$$$ to reduce confusion with negative signs, and WLOG let $$$a_1 \ge a_2 \ge \dots \ge a_n$$$.
Instead of considering $$$\sum_{i=1}^{n-1} |b_{i+1}-b_i-c|$$$, consider a permutation $$$b$$$ that minimizes the
augmented cost
$$$|b_1-b_n-c|+\sum_{i=1}^{n-1} |b_{i+1}-b_i-c|$$$. By circular symmetry, WLOG rotate $$$b$$$ so that $$$b_n = a_n$$$.
We will perform a sequence of steps to sort $$$b$$$ in nonincreasing order without ever increasing the augmented cost. Consider looking at $$$b_{n-1},b_{n-2},\dots,b_1$$$ in order, such that when we look at $$$b_k$$$, we have the invariant that $$$b_{k+1} \ge b_{k+2} \ge \dots \ge b_n = a_n$$$. If $$$b_k \ge b_{k+1}$$$, do not do anything. Otherwise, since $$$b_k \ge a_n = b_n$$$, there exists an index $$$k+1 \le i < n$$$ such that $$$b_i \ge b_k \ge b_{i+1}$$$. Consider deleting $$$b_k$$$ from the array and reinserting it between index $$$i$$$ and $$$i+1$$$. We have the following results:
Claim 1
: Deleting $$$b_k$$$ decreases the augmented cost by at least $$$c'$$$.
Proof
: Let $$$x := b_{k-1}-b_k$$$ (or $$$b_n-b_1$$$ if $$$k = 1$$$) and $$$y := b_{k+1}-b_k \ge 0$$$. We need to check that $$$|x-y-c'|+c' \le |x-c'|+|-y-c'|$$$, which follows from $$$|x-c'|+|-y-c'| = |x-c'|+y+c' \ge |x-y-c'|+c'$$$ (we use the triangle inequality in the last step).
Note that equality holds if and only if $$$x-c' \le 0$$$, i.e. $$$b_{k-1}-b_k \le c'$$$.
Claim 2
: Reinserting $$$b_k$$$ increases the augmented cost by at most $$$c'$$$.
Proof
: Let $$$x := b_i-b_k \ge 0$$$ and $$$y := b_k-b_{i+1} \ge 0$$$. We need to check that $$$|x-c'|+|y-c'| \le |x+y-c'|+c'$$$. Consider four cases:
If $$$x,y \ge c'$$$, then $$$|x-c'|+|y-c'| = x+y-2c' < (x+y-c')+c' = |x+y-c'|+c'$$$.
If $$$x \ge c', y \le c'$$$, then $$$|x-c'|+|y-c'| = x-y \le (x+y-c')+c' = |x+y-c'|+c'$$$.
If $$$x \le c', y \ge c'$$$, then $$$|x-c'|+|y-c'| = y-x \le (x+y-c')+c' = |x+y-c'|+c'$$$.
If $$$x,y \le c'$$$, then $$$|x-c'|+|y-c'| = 2c'-x-y = (c'-x-y)+c' \le |x+y-c'|+c'$$$.
Note that equality holds if and only if $$$x = 0$$$ or $$$y = 0$$$ or $$$c'-x-y \ge 0$$$, i.e. $$$b_i-b_{i+1} \le c'$$$ or $$$b_i = b_k$$$ or $$$b_k = b_{i+1}$$$.
Therefore, each step does not increase the augmented cost. After all the steps, $$$b$$$ will be sorted in nonincreasing order. Therefore, the smallest possible augmented cost is $$$|a_1-a_n-c|+\sum_{i=1}^{n-1} |a_{i+1}-a_i-c|$$$.
Now note that $$$|a_1-a_n-c| = (a_1-a_n)+c'$$$ is the
maximum
possible value of $$$|b_1-b_n-c|$$$! This means that the minimum cost cannot be less than the minimum augmented cost minus $$$(a_1-a_n)+c'$$$. It follows that the minimum cost is obtained by sorting $$$a$$$ in nonincreasing order, and furthermore,
any
optimal permutation $$$b$$$ satisfies $$$b_1 = a_1$$$ and $$$b_n = a_n$$$.
Furthermore, suppose we have fixed $$$b_1,\dots,b_k$$$ and also $$$b_n = a_n$$$. By a similar argument (looking at $$$b_{n-1},\dots,b_{k+1}$$$ and reinserting them to the right), one optimal permutation $$$b_{k+1},\dots,b_n$$$ of the remaining elements is to sort them in nonincreasing order. Our greedy algorithm can only reach states where the optimal remaining permutation satisfies $$$b_n = a_n$$$, so it is correct.
Note that condition $$$(*)$$$ is similar to equality being achieved in both claim 1 and claim 2. It follows that $$$(*)$$$ is equivalent to ($$$a_{i-1}-a_{i+1} \le |c|$$$ or $$$a_{i-1} = a_i$$$ or $$$a_i = a_{i+1}$$$) and ($$$b_{k-1}-a_i \le |c|$$$) as claimed.
1844F2 - Min Cost Permutation (Hard Version)
Proofs
The case $$$n \le 2$$$ is trivial. In the following, we only consider the case $$$c < 0$$$ and $$$n \ge 3$$$. The case $$$c \ge 0$$$ follows by symmetry (reverse the array).
Let $$$c' := -c$$$ to reduce confusion with negative signs, and WLOG let $$$a_1 \ge a_2 \ge \dots \ge a_n$$$.
Instead of considering $$$\sum_{i=1}^{n-1} |b_{i+1}-b_i-c|$$$, consider a permutation $$$b$$$ that minimizes the
augmented cost
$$$|b_1-b_n-c|+\sum_{i=1}^{n-1} |b_{i+1}-b_i-c|$$$. By circular symmetry, WLOG rotate $$$b$$$ so that $$$b_n = a_n$$$.
We will perform a sequence of steps to sort $$$b$$$ in nonincreasing order without ever increasing the augmented cost. Consider looking at $$$b_{n-1},b_{n-2},\dots,b_1$$$ in order, such that when we look at $$$b_k$$$, we have the invariant that $$$b_{k+1} \ge b_{k+2} \ge \dots \ge b_n = a_n$$$. If $$$b_k \ge b_{k+1}$$$, do not do anything. Otherwise, since $$$b_k \ge a_n = b_n$$$, there exists an index $$$k+1 \le i < n$$$ such that $$$b_i \ge b_k \ge b_{i+1}$$$. Consider deleting $$$b_k$$$ from the array and reinserting it between index $$$i$$$ and $$$i+1$$$. We have the following results:
Claim 1
: Deleting $$$b_k$$$ decreases the augmented cost by at least $$$c'$$$.
Proof
: Let $$$x := b_{k-1}-b_k$$$ (or $$$b_n-b_1$$$ if $$$k = 1$$$) and $$$y := b_{k+1}-b_k \ge 0$$$. We need to check that $$$|x-y-c'|+c' \le |x-c'|+|-y-c'|$$$, which follows from $$$|x-c'|+|-y-c'| = |x-c'|+y+c' \ge |x-y-c'|+c'$$$ (we use the triangle inequality in the last step).
Note that equality holds if and only if $$$x-c' \le 0$$$, i.e. $$$b_{k-1}-b_k \le c'$$$.
Claim 2
: Reinserting $$$b_k$$$ increases the augmented cost by at most $$$c'$$$.
Proof
: Let $$$x := b_i-b_k \ge 0$$$ and $$$y := b_k-b_{i+1} \ge 0$$$. We need to check that $$$|x-c'|+|y-c'| \le |x+y-c'|+c'$$$. Consider four cases:
If $$$x,y \ge c'$$$, then $$$|x-c'|+|y-c'| = x+y-2c' < (x+y-c')+c' = |x+y-c'|+c'$$$.
If $$$x \ge c', y \le c'$$$, then $$$|x-c'|+|y-c'| = x-y \le (x+y-c')+c' = |x+y-c'|+c'$$$.
If $$$x \le c', y \ge c'$$$, then $$$|x-c'|+|y-c'| = y-x \le (x+y-c')+c' = |x+y-c'|+c'$$$.
If $$$x,y \le c'$$$, then $$$|x-c'|+|y-c'| = 2c'-x-y = (c'-x-y)+c' \le |x+y-c'|+c'$$$.
Note that equality holds if and only if $$$x = 0$$$ or $$$y = 0$$$ or $$$c'-x-y \ge 0$$$, i.e. $$$b_i-b_{i+1} \le c'$$$ or $$$b_i = b_k$$$ or $$$b_k = b_{i+1}$$$.
Therefore, each step does not increase the augmented cost. After all the steps, $$$b$$$ will be sorted in nonincreasing order. Therefore, the smallest possible augmented cost is $$$|a_1-a_n-c|+\sum_{i=1}^{n-1} |a_{i+1}-a_i-c|$$$.
Now note that $$$|a_1-a_n-c| = (a_1-a_n)+c'$$$ is the
maximum
possible value of $$$|b_1-b_n-c|$$$! This means that the minimum cost cannot be less than the minimum augmented cost minus $$$(a_1-a_n)+c'$$$. It follows that the minimum cost is obtained by sorting $$$a$$$ in nonincreasing order, and furthermore,
any
optimal permutation $$$b$$$ satisfies $$$b_1 = a_1$$$ and $$$b_n = a_n$$$.
Furthermore, suppose we have fixed $$$b_1,\dots,b_k$$$ and also $$$b_n = a_n$$$. By a similar argument (looking at $$$b_{n-1},\dots,b_{k+1}$$$ and reinserting them to the right), one optimal permutation $$$b_{k+1},\dots,b_n$$$ of the remaining elements is to sort them in nonincreasing order. Our greedy algorithm can only reach states where the optimal remaining permutation satisfies $$$b_n = a_n$$$, so it is correct.
Note that condition $$$(*)$$$ is similar to equality being achieved in both claim 1 and claim 2. It follows that $$$(*)$$$ is equivalent to ($$$a_{i-1}-a_{i+1} \le |c|$$$ or $$$a_{i-1} = a_i$$$ or $$$a_i = a_{i+1}$$$) and ($$$b_{k-1}-a_i \le |c|$$$) as claimed.
Implementation
#include <bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
#define mp make_pair

int a[200000],b[200000],l[200000],r[200000];
set<pii> S;
int main() {
    int i;
    int t,n,c;
    scanf("%d",&t);
    while (t--) {
        scanf("%d %d",&n,&c);
        for (i = 0; i < n; i++) scanf("%d",&a[i]);
        if (c >= 0) {
            sort(a,a+n);
            for (i = 0; i < n; i++) printf("%d%c",a[i],(i == n-1) ? '\n':' ');
            continue;
        }

        sort(a,a+n,greater<int>());
        b[0] = a[0];
        for (i = 0; i < n; i++) l[i] = (i+n-1) % n,r[i] = (i+1) % n;
        for (i = 2; i < n-1; i++) {
            if (a[l[i]]-a[r[i]] <= -c) S.insert(mp(a[i],i));
        }
        for (i = 1; i < n; i++) {
            int u;
            auto it = S.lower_bound(mp(b[i-1]+c,0));
            if (it == S.end()) u = r[0];
            else u = it->second,S.erase(it);
            b[i] = a[u];
            int x = l[u],y = r[u];
            r[x] = y,l[y] = x;
            S.erase(mp(a[x],x)),S.erase(mp(a[y],y));
            if ((x != 0) && (l[x] != 0) && (r[x] != 0) && (a[l[x]]-a[r[x]] <= -c)) S.insert(mp(a[x],x));
            if ((y != 0) && (l[y] != 0) && (r[y] != 0) && (a[l[y]]-a[r[y]] <= -c)) S.insert(mp(a[y],y));
        }
        for (i = 0; i < n; i++) printf("%d%c",b[i],(i == n-1) ? '\n':' ');
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1844F1
Editorial Content:
1844F1 - Min Cost Permutation (Easy Version)
Hint 1
Solve the case $$$c \ge 0$$$ first. There is a very simple description of the answer.
Another Hint
What is the answer when $$$c = 0$$$?
Another Hint
What is the answer when $$$c = 0$$$?
Hint 2
When $$$c \ge 0$$$, the answer is the array sorted in nondecreasing order.
Hint 3
When $$$c < 0$$$, the minimum cost is achieved by sorting the array in nonincreasing order, but this is not the lexicographically smallest. Try to greedily form the lexicographically smallest array one element at a time.
Solution (easy version)
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
using namespace std;
typedef long long int LLI;

int a[200000];
int main() {
    int i,j;
    int t,n,c;
    scanf("%d",&t);
    while (t--) {
        scanf("%d %d",&n,&c);
        for (i = 0; i < n; i++) scanf("%d",&a[i]);
        if (c >= 0) {
            sort(a,a+n);
            for (i = 0; i < n; i++) printf("%d%c",a[i],(i == n-1) ? '\n':' ');
            continue;
        }

        sort(a,a+n,greater<int>());
        for (i = 0; i < n; i++) {
            for (j = n-1; j > i; j--) {
                LLI diff = -abs(a[j]-a[j-1]-c);
                if (j < n-1) {
                    diff -= abs(a[j+1]-a[j]-c);
                    diff += abs(a[j+1]-a[j-1]-c);
                }
                if (i == 0) diff += abs(a[i]-a[j]-c);
                else {
                    diff -= abs(a[i]-a[i-1]-c);
                    diff += abs(a[i]-a[j]-c);
                    diff += abs(a[j]-a[i-1]-c);
                }
                if (diff == 0) {
                    for (; j > i; j--) swap(a[j],a[j-1]);
                }
            }
        }
        for (i = 0; i < n; i++) printf("%d%c",a[i],(i == n-1) ? '\n':' ');
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1844E
Editorial Content:
1844E - Great Grids
Hint 1
Try to find a characterization of all great grids.
Hint 2
There are two approaches that lead to the same conclusion. Approach 1 is more clever and leads more easily to the conclusion, while approach 2 is perhaps more natural to consider. Feel free to read the hint towards the approach that sounds better.
Hint Towards Approach 1
Think of the letters as numbers modulo $$$3$$$ and look at differences of adjacent cells.
Hint Towards Approach 2
Draw a
/
or
\
for each $$$2 \times 2$$$ subgrid connecting the equal letters, and look for patterns.
Hint Towards Approach 1
Think of the letters as numbers modulo $$$3$$$ and look at differences of adjacent cells.
Hint Towards Approach 2
Draw a
/
or
\
for each $$$2 \times 2$$$ subgrid connecting the equal letters, and look for patterns.
Hint 3
In either approach, we can associate a type to each row and column, which has one of two possibilities. The constraints correspond to a row and a column needing to have the same or different types.
Hint 4
The problem reduces to checking the $$$2$$$-colourability of a graph.
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
using namespace std;
typedef vector<pair<int,int> > vpii;
#define mp make_pair
#define pb push_back

vpii adjList[4000];
int colour[4000],bad = 0;
int doDFS(int u,int c) {
    if (colour[u] != -1) {
        if (colour[u] != c) bad = 1;
        return 0;
    }
    colour[u] = c;
    for (auto [v,e]: adjList[u]) doDFS(v,c^e);
    return 0;
}
int main() {
    int i;
    int t,n,m,k;
    int x1,y1,x2,y2;
    scanf("%d",&t);
    while (t--) {
        scanf("%d %d %d",&n,&m,&k);
        for (i = 0; i < k; i++) {
            scanf("%d %d %d %d",&x1,&y1,&x2,&y2);
            x1--,y1--,x2--,y2--;
            adjList[min(x1,x2)].pb(mp(n+min(y1,y2),(x1+y1 != x2+y2)));
            adjList[n+min(y1,y2)].pb(mp(min(x1,x2),(x1+y1 != x2+y2)));
        }

        fill(colour,colour+n+m,-1),bad = 0;
        for (i = 0; i < n+m; i++) {
            if (colour[i] == -1) doDFS(i,0);
        }
        printf(bad ? "NO\n":"YES\n");

        for (i = 0; i < n+m; i++) adjList[i].clear();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1844D
Editorial Content:
1844D - Row Major
Hint 1
Describe, using a graph, all the pairs of characters in $$$s$$$ that need to be different.
Hint 2
Consider the smallest positive integer that does not divide $$$n$$$.
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
using namespace std;

char s[1000001];
int main() {
    int i;
    int t,n;
    scanf("%d",&t);
    while (t--) {
        scanf("%d",&n);
        int c = 1;
        while ((n % c) == 0) c++;
        for (i = 0; i < n; i++) s[i] = 'a'+(i % c);
        s[n] = '\0';
        printf("%s\n",s);
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1844C
Editorial Content:
1844C - Particles
Hint 1
The answer is the sum of some subset of $$$c_1,\dots,c_n$$$. Think about which subsets are obtainable.
Hint 2
Consider the set of even-indexed particles and the set of odd-indexed particles.
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
using namespace std;
typedef long long int LLI;

int c[200000];
int main() {
    int i;
    int t,n;
    scanf("%d",&t);
    while (t--) {
        scanf("%d",&n);
        for (i = 0; i < n; i++) scanf("%d",&c[i]);

        int allneg = 1;
        for (i = 0; i < n; i++) allneg &= (c[i] < 0);
        if (allneg) printf("%d\n",*max_element(c,c+n));
        else {
            LLI ans1 = 0,ans2 = 0;
            for (i = 0; i < n; i++) {
                if (i & 1) ans1 += max(c[i],0);
                else ans2 += max(c[i],0);
            }
            printf("%lld\n",max(ans1,ans2));
        }
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1844B
Editorial Content:
1844B - Permutations & Primes
Hint 1
In order for $$$(l,r)$$$ to contribute to the primality, we must have $$$\operatorname{MEX}(a_l,\dots,a_r) \ge 2$$$, so there is some value $$$1$$$ between indices $$$l$$$ and $$$r$$$.
Hint 2
To maximize the number of pairs $$$(l,r)$$$ that contain the value $$$1$$$, we should put $$$1$$$ near the middle of the array.
Hint 3
To minimize the number of pairs $$$(l,r)$$$ where $$$\operatorname{MEX}(a_l,\dots,a_r) \ge 2$$$ but is not prime, we should put $$$2$$$ and $$$3$$$ at the ends of the array.
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
using namespace std;

int a[200000];
int main() {
    int i;
    int t,n;
    scanf("%d",&t);
    while (t--) {
        scanf("%d",&n);
        if (n == 1) printf("1\n");
        else if (n == 2) printf("1 2\n");
        else {
            int c = 4;
            fill(a,a+n,0);
            a[0] = 2,a[n/2] = 1,a[n-1] = 3;
            for (i = 0; i < n; i++) {
                if (a[i] == 0) a[i] = c++;
            }
            for (i = 0; i < n; i++) printf("%d%c",a[i],(i == n-1) ? '\n':' ');
        }
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1844A
Editorial Content:
1844A - Subtraction Game
Hint 1
There exists a small $$$n$$$ where the second player can win.
Hint 2
If $$$a \ge 2$$$, then $$$n = 1$$$ works.
Solution
Tutorial is loading...
Implementation
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t,a,b;
    scanf("%d",&t);
    while (t--) {
        scanf("%d %d",&a,&b);
        printf("%d\n",a+b);
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1843F2
Editorial Content:
1843F2 - Omsk Metro (hard version)
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
typedef long long ll;
 
struct info {
    int sum, minPrefL, maxPrefL, minPrefR, maxPrefR, minSeg, maxSeg;
 
    info(int el = 0) {
        sum = el;
        minSeg = minPrefL = minPrefR = min(el, 0);
        maxSeg = maxPrefL = maxPrefR = max(el, 0);
    }
};
 
struct question {
    int u, v, x;
};
 
info merge(info& a, info& b) {
    info res;
    res.sum = a.sum + b.sum;
    res.minPrefL = min(a.minPrefL, a.sum + b.minPrefL);
    res.maxPrefL = max(a.maxPrefL, a.sum + b.maxPrefL);
    res.minPrefR = min(a.minPrefR + b.sum, b.minPrefR);
    res.maxPrefR = max(a.maxPrefR + b.sum, b.maxPrefR);
    res.minSeg = min({a.minSeg, b.minSeg, a.minPrefR + b.minPrefL});
    res.maxSeg = max({a.maxSeg, b.maxSeg, a.maxPrefR + b.maxPrefL});
    return res;
}
 
const int MAXN = 200100;
const int lg = 17;
 
int up[lg + 1][MAXN];
info ans[lg + 1][MAXN];
int d[MAXN];
 
void solve() {
    int n;
    cin >> n;
 
    for (int i = 0; i <= lg; i++) up[i][0] = 0;
    ans[0][0] = info(1);
    d[0] = 0;
 
    int cur = 0;
    for (int q = 0; q < n; q++) {
        char c;
        cin >> c;
        if (c == '+') {
            int v, x;
            cin >> v >> x;
            v--;
            cur++;
 
            d[cur] = d[v] + 1;
 
            up[0][cur] = v;
            for (int j = 0; j <= lg - 1; j++) up[j + 1][cur] = up[j][up[j][cur]];
 
            ans[0][cur] = info(x);
            for (int j = 0; j <= lg - 1; j++) ans[j + 1][cur] = merge(ans[j][cur], ans[j][up[j][cur]]);
        } else {
            int u, v, x;
            cin >> u >> v >> x;
            u--; v--;
            
            if (d[u] < d[v]) swap(u, v);
 
            int dif = d[u] - d[v];
            info a, b;
            for (int i = lg; i >= 0; i--) {
                if ((dif >> i) & 1) {
                    a = merge(a, ans[i][u]);
                    u = up[i][u];
                }
            }
 
            if (u == v) {
                a = merge(a, ans[0][u]);
            } else {
                for (int i = lg; i >= 0; i--) {
                    if (up[i][u] != up[i][v]) {
                        a = merge(a, ans[i][u]);
                        u = up[i][u];
                        b = merge(b, ans[i][v]);
                        v = up[i][v];
                    }
                }
 
                a = merge(a, ans[1][u]);
                b = merge(b, ans[0][v]);
            }
 
            swap(b.minPrefL, b.minPrefR);
            swap(b.maxPrefL, b.maxPrefR);
 
            info res = merge(a, b);
            if (res.minSeg <= x && x <= res.maxSeg) {
                cout << "Yes\n";
            } else {
                cout << "No\n";
            }
        }
    }
}
 
int main() {
    int tests;
    cin >> tests;
    while (tests--) {
        solve();
    }
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1843F1
Editorial Content:
1843F1 - Omsk Metro (simple version)
Tutorial
Tutorial is loading...
Solution
class info:
    mn_suf = 0
    mx_suf = 0
    mn_ans = 0
    mx_ans = 0
 
def solve():
    n = int(input())
    
    start = info()
    start.mx_suf = start.mx_ans = 1
    
    st = [start]
    for i in range(n):
        com = input().split()
        if (com[0] == '+'):
            v = int(com[1]) - 1
            x = int(com[2])
 
            pref = st[v]
            cur = info()
 
            cur.mn_suf = min(0, pref.mn_suf + x)
            cur.mx_suf = max(0, pref.mx_suf + x)
            cur.mn_ans = min(pref.mn_ans, cur.mn_suf)
            cur.mx_ans = max(pref.mx_ans, cur.mx_suf)
 
            st.append(cur)
        else:
            v = int(com[2]) - 1
            x = int(com[3])
 
            if st[v].mn_ans <= x <= st[v].mx_ans:
                print("Yes")
            else:
                print("No")
 
t = int(input())
for testCase in range(t):
    solve()
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1843E
Editorial Content:
1843E - Tracking Segments
Tutorial
Tutorial is loading...
Solution
def solve():
    n, m = map(int, input().split())
    segs = []
    for i in range(m):
        l, r = map(int, input().split())
        l -= 1
        segs.append([l, r])
    q = int(input())
    ord = [0] * q
    for i in range(q):
        ord[i] = int(input())
        ord[i] -= 1
    l = 0
    r = q + 1
    while r - l > 1:
        M = (l + r) // 2
        cur = [0] * n
        for i in range(M):
            cur[ord[i]] = 1
        pr = [0] * (n + 1)
        for i in range(n):
            pr[i+1] = pr[i] + cur[i]
        ok = False
        for i in segs:
            if(pr[i[1]] - pr[i[0]] > (i[1] - i[0]) // 2):
                ok = True
                break
        if ok:
            r = M
        else:
            l = M
    if r == q + 1:
        r = -1
    print(r)
 
tc = int(input())
for T in range(tc):
    solve()
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1843D
Editorial Content:
1843D - Apple Tree
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
 
vector<vector<int>> g;
vector<ll> cnt;
 
void dfs(int v, int p) {
    if (g[v].size() == 1 && g[v][0] == p) {
        cnt[v] = 1;
    } else {
        for (auto u : g[v]) {
            if (u != p) {
                dfs(u, v);
                cnt[v] += cnt[u];
            }
        }
    }
}
 
void solve() {
    int n, q;
    cin >> n;
 
    g.assign(n, vector<int>());
    
    for (int i = 0; i < n - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--; v--;
        g[u].push_back(v);
        g[v].push_back(u);
    }
 
    cnt.assign(n, 0);
    dfs(0, -1);
 
    cin >> q;
    for (int i = 0; i < q; i++) {
        int c, k;
        cin >> c >> k;
        c--; k--;
 
        ll res = cnt[c] * cnt[k];
        cout << res << '\n';
    }
}
 
signed main() {
    int tests;
    cin >> tests;
    while (tests--) {
        solve();
    }
 
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1843C
Editorial Content:
1843C - Sum in Binary Tree
Tutorial
Tutorial is loading...
Solution
t = int(input())
for _ in range(t):
    n = int(input())
    s = 0
    while n >= 1:
        s += n
        n //= 2
    print(s)
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1843B
Editorial Content:
1843B - Long Long
Tutorial
Tutorial is loading...
Solution
T = int(input())
for _ in range(T):
    n = int(input())
    a = list(map(int, input().split()))
    
    sum = 0
    cnt = 0
    open = False
    for x in a:
        sum += abs(x)
        if x < 0 and not open:
            open = True
            cnt += 1
        if x > 0:
            open = False
 
    print(sum, cnt)
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1843A
Editorial Content:
1843A - Sasha and Array Coloring
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    a = [int(x) for x in input().split()]
    a.sort()
    ans = 0
    for i in range(n // 2):
        ans += a[-i-1] - a[i]
    print(ans)
    
    
t = int(input())
for _ in range(t):
    solve()
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1842I
Editorial data not available.
--------------------------------------------------
Problem ID: 1842H
Editorial data not available.
--------------------------------------------------
Problem ID: 1842G
Editorial data not available.
--------------------------------------------------
Problem ID: 1842F
Editorial data not available.
--------------------------------------------------
Problem ID: 1842E
Editorial data not available.
--------------------------------------------------
Problem ID: 1842D
Editorial data not available.
--------------------------------------------------
Problem ID: 1842C
Editorial data not available.
--------------------------------------------------
Problem ID: 1842B
Editorial data not available.
--------------------------------------------------
Problem ID: 1842A
Editorial data not available.
--------------------------------------------------
Problem ID: 1841F
Editorial Content:
1841F - Monocarp and a Strategic Game
Tutorial
Tutorial is loading...
Solution (TheWayISteppedOutTheCar)
#include <iostream>
#include <algorithm>
using namespace std;
#define int long long
#define x first
#define y second
const int MAXN = 2e6 + 16;
int a[MAXN], b[MAXN];
pair<int, int> v[MAXN];
int section(pair<int, int> a) {
    if (a.x > 0 && a.y >= 0)
        return 0;
    else if (a.x <= 0 && a.y > 0)
        return 1;
    else if (a.x < 0 && a.y <= 0)
        return 2;
    else
        return 3;
}
bool cmp(pair<int, int> a, pair<int, int> b) {
    if (section(a) != section(b))
        return section(a) < section(b);
    else
        return (__int128)a.x * (__int128)b.y - (__int128)a.y * (__int128)b.x > 0;
}
void print(__int128 x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    if (x > 9) print(x / 10);
    putchar(x % 10 + '0');
}
signed main() {
    ios_base::sync_with_stdio(false);
    
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i) {
		vector<int> t(4);
		for(int j = 0; j < 4; j++)
			cin >> t[j];
		a[i] = t[0] - t[1];
		b[i] = t[2] - t[3];
	}
    int it = 0;
    __int128 sx = 0, sy = 0;
    for (int i = 0; i < n; ++i) {
        v[i << 1].x = a[it];
        v[i << 1].y = b[it];
        ++it;
        v[i << 1 ^ 1].x = -v[i << 1].x;
        v[i << 1 ^ 1].y = -v[i << 1].y;
        if (!v[i << 1].x && !v[i << 1].y) {
            --i, --n;
            continue;
        }
        if (v[i << 1].y < 0 || (!v[i << 1].y && v[i << 1].x < 0))
            sx += v[i << 1].x, sy += v[i << 1].y;
    }
    sort(v, v + 2 * n, cmp);
    __int128 ans = sx * sx + sy * sy;
    for (int i = 0; i < 2 * n; ++i) {
        sx += v[i].x;
        sy += v[i].y;
        ans = std::max(ans, sx * sx + sy * sy);
    }
    print(ans);

    return 0;
}
--------------------------------------------------
Problem ID: 1841E
Editorial Content:
1841E - Fill the Matrix
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

struct seg{
	int l, r;
};

bool operator <(const seg &a, const seg &b){
	return a.l < b.l;
}

int main() {
	int t;
	scanf("%d", &t);
	while (t--){
		int n;
		scanf("%d", &n);
		vector<int> a(n);
		forn(i, n) scanf("%d", &a[i]);
		long long m;
		scanf("%lld", &m);
		map<seg, int> used;
		used[{0, n}] = n;
		vector<int> ord(n);
		iota(ord.begin(), ord.end(), 0);
		sort(ord.begin(), ord.end(), [&a](int x, int y){
			return a[x] > a[y];
		});
		long long ans = 0;
		int j = 0;
		vector<long long> cnt(n + 1);
		for (int i = n; i >= 0; --i){
			while (j < n && a[ord[j]] >= i){
				auto it = used.upper_bound({ord[j], -1});
				--it;
				auto tmp = it->first;
				cnt[tmp.r - tmp.l] += it->second - i;
				used.erase(it);
				if (tmp.l != ord[j])
					used[{tmp.l, ord[j]}] = i;
				if (tmp.r != ord[j] + 1)
					used[{ord[j] + 1, tmp.r}] = i;
				++j;
			}
		}
		for (int i = n; i > 0; --i){
			long long t = min(cnt[i], m / i);
			ans += t * 1ll * (i - 1);
			m -= t * 1ll * i;
			if (t != cnt[i] && m > 0){
				ans += m - 1;
				m = 0;
			}
		}
		printf("%lld\n", ans);
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1841D
Editorial Content:
1841D - Pairs of Segments
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

bool comp(const pair<int, int>& a, const pair<int, int>& b)
{
	return a.second < b.second;
}

void solve()
{
	int n;
	scanf("%d", &n);
	vector<pair<int, int>> s(n);
	for(int i = 0; i < n; i++)
		scanf("%d %d", &s[i].first, &s[i].second);
	
	vector<pair<int, int>> pairs;
	for(int i = 0; i < n; i++)
		for(int j = i + 1; j < n; j++)
			if(max(s[i].first, s[j].first) <= min(s[i].second, s[j].second))
				pairs.push_back(make_pair(min(s[i].first, s[j].first), max(s[i].second, s[j].second)));
			
	int cnt_pairs = 0;
	sort(pairs.begin(), pairs.end(), comp);
	int last_pos = -1;
	for(auto x : pairs)
		if(x.first > last_pos)
		{
			cnt_pairs++;
			last_pos = x.second;
		}
		
	printf("%d\n", n - cnt_pairs * 2);
}

int main()
{
	int t;
	scanf("%d", &t);
	for(int i = 0; i < t; i++) solve();
}
--------------------------------------------------
Problem ID: 1841C
Editorial Content:
1841C - Ranom Numbers
Tutorial
Tutorial is loading...
Solution 1 (Neon)
#include <bits/stdc++.h>

using namespace std;

const int val[] = {1, 10, 100, 1000, 10000};
const int INF = 1e9;

string s;
int dp[2][5][2];

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    cin >> s;
    reverse(s.begin(), s.end());
    for (int j = 0; j < 5; ++j)
      dp[0][j][0] = dp[0][j][1] = -INF;
    dp[0][0][0] = 0;
    for (auto c : s) {
      int x = c - 'A';
      for (int j = 0; j < 5; ++j)
        dp[1][j][0] = dp[1][j][1] = -INF;
      for (int j = 0; j < 5; ++j) {
      	for (int t = 0; t < 2; ++t) {
      	  for (int y = 0; y < 5; ++y) {
      	  	int nj = max(j, y);
      	  	int nt = t + (x != y);
      	  	if (nt < 2) dp[1][nj][nt] = max(dp[1][nj][nt], dp[0][j][t] + (y < nj ? -val[y] : val[y]));
      	  }	
      	}
      }
      swap(dp[0], dp[1]);
    }
    int ans = -INF;
    for (int j = 0; j < 5; ++j)
      ans = max(ans, max(dp[0][j][0], dp[0][j][1]));
    cout << ans << '\n';
  }
}
Solution 2 (BledDest)
def replace_char(s, i, c):
    return s[:i] + c + s[i + 1:]
    
def id(c):
    return ord(c) - ord('A')
    
def evaluate(s):
    t = s[::-1]
    ans = 0
    max_id = -1
    for x in t:
        i = id(x)
        if max_id > i:
            ans -= 10 ** i
        else:
            ans += 10 ** i
        max_id = max(max_id, i)
    return ans

t = int(input())
for i in range(t):
    s = input()
    candidates = []
    for x in ['A', 'B', 'C', 'D', 'E']:
        for y in ['A', 'B', 'C', 'D', 'E']:
            if not (x in s):
                continue
            candidates.append(replace_char(s, s.find(x), y))
            candidates.append(replace_char(s, s.rfind(x), y))
    print(max(map(evaluate, candidates)))
--------------------------------------------------
Problem ID: 1841B
Editorial Content:
1841B - Keep it Beautiful
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	q = int(input())
	a = []
	cnt = 0
	for x in map(int, input().split()):
		nw_cnt = cnt + (len(a) > 0 and a[-1] > x)
		if nw_cnt == 0 or (nw_cnt == 1 and x <= a[0]):
			a.append(x)
			cnt = nw_cnt
			print('1', end="")
		else:
			print('0', end="")
	print()
--------------------------------------------------
Problem ID: 1841A
Editorial Content:
1841A - Game with Board
Tutorial
Tutorial is loading...
Solution (BledDest)
t = int(input())
for i in range(t):
    n = int(input())
    print('Alice' if n >= 5 else 'Bob')
--------------------------------------------------
Problem ID: 1840G2
Editorial Content:
1840G2 - In Search of Truth (Hard Version)
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define int long long
 
const int MAXN = 1e6 + 7;
 
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
 
int pos[MAXN];
 
const int K = 400;
const int T = 300;
 
int get() {
    return rng() % MAXN;
}
 
int32_t main() {
    int num;
    cin >> num;
    int start = num;
    int cur_delta = 0;
    int N0 = num;
    for (int i = 0; i < K; ++i) {
        int delta = get();
        cout << '+' << " " << delta << endl;
        cur_delta += delta;
        cin >> num;
        N0 = max(N0, num);
    }
    cout << '-' << " " << cur_delta << endl;
    cin >> num;
    cout << '+' << " " << N0 - 1 << endl;
    cur_delta = N0 - 1;
    cin >> num;
    pos[num] = N0;
    for (int i = 0; i < T; ++i) {
        ++cur_delta;
        cout << '+' << " " << 1 << endl;
        cin >> num;
        pos[num] = N0 + i + 1;
        if (num == start) {
            cout << '!' << " " << N0 + i << endl;
            return 0;
        }
    }
    cout << '-' << " " << cur_delta << endl;
    cin >> num;
    int ans = 0;
    while (true) {
        cout << '-' << " " << T << endl;
        ans += T;
        cin >> num;
        if (pos[num]) {
            cout << '!' << " " << ans + pos[num] - 1 << endl;
            return 0;
        }
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1840G1
Editorial Content:
1840G1 - In Search of Truth (Easy Version)
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
#define int long long
 
const int MAXN = 1e6 + 7;
 
int pos[MAXN];
 
int32_t main() {
    int num;
    cin >> num;
    int ans = 0;
    int cur = 1;
    pos[num] = 1;
    for (int i = 0; i < 1000; ++i) {
        cout << '+' << " " << 1 << endl;
        ++cur;
        cin >> num;
        if (pos[num]) {
            cout << '!' << " " << cur - pos[num] << endl;
            return 0;
        }
        pos[num] = cur;
    }
    while (true) {
        cout << '+' << " " << 1000 << endl;
        cur += 1000;
        cin >> num;
        if (pos[num]) {
            cout << '!' << " " << cur - pos[num] << endl;
            return 0;
        }
        pos[num] = cur;
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1840F
Editorial Content:
1840F - Railguns
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int q;
    cin >> q;
    while (q--) {
        int n, m;
        cin >> n >> m;
        int r;
        cin >> r;
        bool free[n + 1][m + 1][r + 1];
        for (int i = 0; i <= n; ++i) {
            for (int j = 0; j <= m; ++j) {
                for (int k = 0; k <= r; ++k) {
                    free[i][j][k] = true;
                }
            }
        }
        for (int i = 0; i < r; ++i) {
            int t, d, coord;
            cin >> t >> d >> coord;
            if (d == 1) {
                for (int j = 0; j <= m; ++j) {
                    if (0 <= t - coord - j && t - coord - j <= r) {
                        free[coord][j][t - coord - j] = false;
                    }
                }
            } else {
                for (int j = 0; j <= n; ++j) {
                    if (0 <= t - coord - j && t - coord - j <= r) {
                        free[j][coord][t - coord - j] = false;
                    }
                }
            }
        }
        bool dp[n + 1][m + 1][r + 1];
        for (int i = 0; i <= n; ++i) {
            for (int j = 0; j <= m; ++j) {
                for (int k = 0; k <= r; ++k) {
                    dp[i][j][k] = !(i || j || k);
                    if (free[i][j][k]) {
                        if (i && dp[i - 1][j][k]) {
                            dp[i][j][k] = true;
                        }
                        if (j && dp[i][j - 1][k]) {
                            dp[i][j][k] = true;
                        }
                        if (k && dp[i][j][k - 1]) {
                            dp[i][j][k] = true;
                        }
                    }
                }
            }
        }
        int ans = -1;
        for (int t = r; t >= 0; --t) {
            if (dp[n][m][t]) {
                ans = n + m + t;
            }
        }
        cout << ans << "\n";
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1840E
Editorial Content:
1840E - Character Blocking
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int x;
    cin >> x;
    while (x--) {
        vector<string> s(2);
        cin >> s[0] >> s[1];
        int n = s[0].size();
        int bad = 0;
        for (int i = 0; i < n; ++i) {
            if (s[0][i] != s[1][i]) {
                ++bad;
            }
        }
        int t, q;
        cin >> t >> q;
        queue<pair<int, int>> unblock;
        for (int i = 0; i < q; ++i) {
            while (!unblock.empty() && unblock.front().first == i) {
                if (s[0][unblock.front().second] != s[1][unblock.front().second]) {
                    ++bad;
                }
                unblock.pop();
            }
            int type;
            cin >> type;
            if (type == 1) {
                int pos;
                cin >> pos;
                if (s[0][pos - 1] != s[1][pos - 1]) {
                    --bad;
                }
                unblock.emplace(i + t, pos - 1);
            } else if (type == 2) {
                int num1, pos1, num2, pos2;
                cin >> num1 >> pos1 >> num2 >> pos2;
                --num1; --pos1; --num2; --pos2;
                if (s[num1][pos1] != s[1 ^ num1][pos1]) {
                    --bad;
                }
                if (s[num2][pos2] != s[1 ^ num2][pos2]) {
                    --bad;
                }
                swap(s[num1][pos1], s[num2][pos2]);
                if (s[num1][pos1] != s[1 ^ num1][pos1]) {
                    ++bad;
                }
                if (s[num2][pos2] != s[1 ^ num2][pos2]) {
                    ++bad;
                }
            } else {
                cout << (!bad ? "YES" : "NO") << "\n";
            }
        }
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1840D
Editorial Content:
1840D - Wooden Toy Festival
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }
        sort(a.begin(), a.end());
        int l = -1, r = 1e9;
        while (r - l > 1) {
            int m = (l + r) >> 1;
            int i = 0;
            while (i + 1 < a.size() && a[i + 1] - a[0] <= 2 * m) {
                ++i;
            }
            int j = n - 1;
            while (j - 1 >= 0 && a.back() - a[j - 1] <= 2 * m) {
                --j;
            }
            ++i; --j;
            if (i > j || a[j] - a[i] <= 2 * m) {
                r = m;
            } else {
                l = m;
            }
        }
        cout << r << "\n";
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1840C
Editorial Content:
1840C - Ski Resort
Tutorial
Tutorial is loading...
Solution
testCases = int(input())
 
for testCase in range(testCases):
    n, k, q = map(int, input().split(' '))
    a = list(map(int, input().split(' ')))
    
    ans = 0
    len = 0
    for i in range(n):
        if a[i] <= q:
            len += 1
        else:
            if len >= k:
                ans += (len - k + 1) * (len - k + 2) // 2
            len = 0
    
    if len >= k:
        ans += (len - k + 1) * (len - k + 2) // 2
    print(ans)
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1840B
Editorial Content:
1840B - Binary Cafe
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
int32_t main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        k = min(k, 30);
        cout << min(n, (1 << k) - 1) + 1 << "\n";
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1840A
Editorial Content:
1840A - Cipher Shifer
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int t; cin >> t;
    while (t--) {
        int n; cin >> n;
        string s; cin >> s;
        int i = 0;
        while (i < n) {
            int start = i;
            cout << s[i++];
            while (s[i++] != s[start]);
        }
        cout << endl;
    }
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1839E
Editorial Content:
1839E - Decreasing Game
Hint
Consider the graph with $$$n$$$ vertices $$$1, 2, \ldots, n$$$, and on each round of the game, connect vertices $$$i$$$ and $$$j$$$. What can you say about this graph?
Hint
This graph is a tree.
Hint
Vertices of a tree can be divided into two parts, such that all edges connect vertices from different parts.
Hint
If the second player won the game, then sums of elements in both parts were equal in initial array $$$a$$$.
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1839D
Editorial Content:
1839D - Ball Sorting
Hint
Consider the set of balls that were never moved by operations of type 2.
Hint
The relative order of these balls never changes, so their colors must form an increasing sequence.
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1839C
Editorial Content:
1839C - Insert Zero and Invert Prefix
Hint
After every operation, the last element of $$$b$$$ is equal to $$$0$$$.
Hint
If the last element of $$$a$$$ is $$$0$$$, then you can always achieve $$$b = a$$$ with some sequence of operations.
Hint
Try to solve the problem if $$$a$$$ consists of $$$k$$$ ones followed by single zero.
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1839B
Editorial Content:
1839B - Lamps
Hint
Try to solve the problem if all $$$a_i$$$ are equal.
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1839A
Editorial Content:
1839A - The Good Array
Hint
The first and last elements are always equal to $$$1$$$.
Hint
There are at least $$$\lceil \frac{n - 1}{k} \rceil$$$ ones among the first $$$n - 1$$$ elements.
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1838F
Editorial Content:
1838F - Stuck Conveyor
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;

char grid[110][110];
int n;
vector<pair<int, int>> snake;
map<pair<int, int>, char> getChar = {
    {{1, 0}, 'v'},
    {{-1, 0}, '^'},
    {{0, 1}, '>'},
    {{0, -1}, '<'}
};

pair<pair<int, int>, char> getBeltAndDir(pair<int, int> p) {
    if(p.first == -1) return {p, 'X'};
    pair<int, int> q = p;

    if(p.first == 0) q.first++;
    if(p.second == 0) q.second++;
    if(p.first > n) q.first--;
    if(p.second > n) q.second--;

    return {q, getChar[{p.first - q.first, p.second - q.second}]};
}

pair<pair<int, int>, char> query(int idx) {

    cout << "? " << snake[idx].first << ' ' << snake[idx].second << endl;

    for(int i = 1; i <= n; ++i) {
        for(int j = 1; j <= n; ++j)
            cout << grid[i][j];
        cout << endl;
    }

    int i, j; cin >> i >> j;

    return getBeltAndDir({i, j});
}

void fillGrid() {
    for(int i = 0; i < n * n; ++i) {
        int dx = snake[i + 1].first - snake[i].first;
        int dy = snake[i + 1].second - snake[i].second;

        grid[snake[i].first][snake[i].second] = getChar[{dx, dy}];
    }
}

int main() {
    cin >> n;

    for(int i = 1; i <= n; ++i)
        if(i % 2 == 0)
            for(int j = n; j >= 1; --j)
                snake.emplace_back(i, j);
        else
            for(int j = 1; j <= n; ++j)
                snake.emplace_back(i, j);

    snake.emplace_back(n + 1, (n % 2 ? n : 1));
    fillGrid();

    auto ans = query(0);

    if(ans.second != 'X') {

        snake.pop_back();
        reverse(snake.begin(), snake.end());
        snake.emplace_back(0, 1);
        fillGrid();

        ans = query(0);
    }

    if(ans.second == 'X') {

        int id = 0;
        for(int j = 13; j >= 0; --j)
            if(id + (1 << j) < n * n && query(id + (1 << j)).second == 'X')
                id += (1 << j);

        ans.first = snake[id];

        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= n; ++j)
                if(i < ans.first.first) grid[i][j] = '^';
                else if(i > ans.first.first) grid[i][j] = 'v';
                else grid[i][j] = j < ans.first.second ? '<' : '>';
            
        ans.second = query(id).second;
    }

    cout << "! " << ans.first.first << ' ' << ans.first.second << ' ' << ans.second << endl;
}
--------------------------------------------------
Problem ID: 1838E
Editorial Content:
1838E - Count Supersequences
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;

typedef long long int ll;

ll M = 1000000007;

ll pw(ll a, ll p) { return p ? pw(a * a % M, p / 2) * (p & 1 ? a : 1) % M : 1; }

ll inv(ll a) { return pw(a, M - 2); }

int main() {

    ll t; cin >> t;
    for(ll tc = 1; tc <= t; ++tc) {

        ll n, m, k, ai;
        cin >> n >> m >> k;
        for(ll i = 0; i < n; ++i) cin >> ai;

        ll ans = pw(k, m), mCi = 1;

        for(ll i = 0; i < n; ++i) {
            ans = (ans + M - mCi * pw(k - 1, m - i) % M) % M;
            mCi = mCi * (m - i) % M * inv(i + 1) % M;
        }

        cout << ans << '\n';
    }
}
--------------------------------------------------
Problem ID: 1838D
Editorial Content:
1838D - Bracket Walk
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;

int main() {

    int n, q; string s;
    cin >> n >> q >> s;

    set<int> a;

    for(int i = 1; i <= n; ++i)
        if((i % 2) != (s[i - 1] == '('))
            a.insert(i);

    while(q--) {
        int i; cin >> i;

        if(a.count(i)) a.erase(i);
        else a.insert(i);

        if(n % 2) cout << "NO\n";
        else if(a.size() && (*a.begin() % 2 || !(*a.rbegin() % 2))) cout << "NO\n";
        else cout << "YES\n";
    }
}
--------------------------------------------------
Problem ID: 1838C
Editorial Content:
1838C - No Prime Differences
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;

int main() {

    int t; cin >> t;
    for(int tc = 1; tc <= t; ++tc) {

        int n, m; cin >> n >> m;

        for(int i = 0; i < n; ++i) {
            for(int j = 0; j < m; ++j) {
                if(i % 2 == 0) cout << (n / 2 + i / 2) * m + j + 1 << ' ';
                else cout << (i / 2) * m + j + 1 << ' ';
            }
            cout << '\n';
        }
    }
}
--------------------------------------------------
Problem ID: 1838B
Editorial Content:
1838B - Minimize Permutation Subarrays
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
#define N 200010

int idx[N];

int main() {

    int t; cin >> t;
    for(int tc = 1; tc <= t; ++tc) {

        int n; cin >> n;

        for(int i = 1; i <= n; ++i) {
            int x; cin >> x;
            idx[x] = i;
        }

        if(idx[n] < min(idx[1], idx[2])) {
            cout << idx[n] << ' ' << min(idx[1], idx[2]) << '\n';
        } else if(idx[n] > max(idx[1], idx[2])) {
            cout << idx[n] << ' ' << max(idx[1], idx[2]) << '\n';
        } else {
            cout << idx[1] << ' ' << idx[2] << '\n';
        }
    }
}
--------------------------------------------------
Problem ID: 1838A
Editorial Content:
1838A - Blackboard List
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;

int main() {

    int t; cin >> t;
    for(int tc = 1; tc <= t; ++tc) {

        int n; cin >> n;
        int mn = INT_MAX, mx = INT_MIN;

        for(int i = 0; i < n; ++i) {
            int x; cin >> x;
            mn = min(mn, x);
            mx = max(mx, x);
        }

        if(mn < 0) cout << mn << '\n';
        else cout << mx << '\n';
    }
}
--------------------------------------------------
Problem ID: 1837F
Editorial Content:
1837F - Editorial for Two
Tutorial
Tutorial is loading...
Solution 1 (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

int main() {
	int t;
	scanf("%d", &t);
	while (t--){
		int n, k;
		scanf("%d%d", &n, &k);
		vector<int> a(n);
		forn(i, n) scanf("%d", &a[i]);
		
		vector<int> pr(n + 1), su(n + 1);
		auto check = [&](long long x){
			forn(_, 2){
				priority_queue<int> cur;
				pr[0] = 0;
				long long cursum = 0;
				forn(i, n){
					cur.push(a[i]);
					cursum += a[i];
					while (cursum > x){
						cursum -= cur.top();
						cur.pop();
					}
					pr[i + 1] = cur.size();
				}
				reverse(a.begin(), a.end());
				swap(pr, su);
			}
			reverse(su.begin(), su.end());
			forn(i, n + 1) if (pr[i] + su[i] >= k) return true;
			return false;
		};
		
		long long l = 1, r = accumulate(a.begin(), a.end(), 0ll);
		long long res = 0;
		while (l <= r){
			long long m = (l + r) / 2;
			if (check(m)){
				res = m;
				r = m - 1;
			}
			else{
				l = m + 1;
			}
		}
		printf("%lld\n", res);
	}
}
Solution 2 (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

int main() {
	int t;
	scanf("%d", &t);
	while (t--){
		int n, k;
		scanf("%d%d", &n, &k);
		vector<int> a(n);
		forn(i, n) scanf("%d", &a[i]);
		vector<pair<int, int>> xs(n);
		forn(i, n) xs[i] = {a[i], i};
		sort(xs.begin(), xs.end());
		forn(i, n) a[i] = lower_bound(xs.begin(), xs.end(), make_pair(a[i], i)) - xs.begin();
		
		vector<int> lstpr(n), lstsu(n);
		forn(_, 2){
			set<int> cur;
			forn(i, n){
				auto it = cur.insert(a[i]).first;
				if (it == cur.begin())
					lstpr[i] = n;
				else
					lstpr[i] = *(--it);
			}
			swap(lstpr, lstsu);
			reverse(a.begin(), a.end());
		}
		
		vector<int> pr(n + 1), su(n + 1);
		vector<int> prv(n + 2), nxt(n + 2);
		
		auto check = [&](long long x){
			forn(_, 2){
				int cnt = 0;
				prv[n + 1] = n;
				nxt[n] = n + 1;
				pr[0] = 0;
				int mn = 1e9;
				long long cursum = 0;
				forn(i, n){
					if (mn < a[i]){
						pr[i + 1] = cnt;
						continue;
					}
					nxt[a[i]] = nxt[lstpr[i]];
					prv[nxt[a[i]]] = a[i];
					prv[a[i]] = lstpr[i];
					nxt[prv[a[i]]] = a[i];
					cursum += xs[a[i]].first;
					++cnt;
					while (cursum > x){
						mn = min(mn, prv[n + 1]);
						cursum -= xs[prv[n + 1]].first;
						prv[n + 1] = prv[prv[n + 1]];
						nxt[prv[n + 1]] = n + 1;
						--cnt;
					}
					pr[i + 1] = cnt;
				}
				reverse(a.begin(), a.end());
				swap(lstpr, lstsu);
				swap(pr, su);
			}
			reverse(su.begin(), su.end());
			forn(i, n + 1) if (pr[i] + su[i] >= k) return true;
			return false;
		};
		
		long long l = 1, r = 0;
		for (int x : a) r += xs[x].first;
		long long res = 0;
		while (l <= r){
			long long m = (l + r) / 2;
			if (check(m)){
				res = m;
				r = m - 1;
			}
			else{
				l = m + 1;
			}
		}
		printf("%lld\n", res);
	}
}
--------------------------------------------------
Problem ID: 1837E
Editorial Content:
1837E - Playoff Fixing
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

const int MOD = 998244353;

int main() {
	int k;
	scanf("%d", &k);
	vector<int> a(1 << k);
	forn(i, 1 << k){
		scanf("%d", &a[i]);
		if (a[i] != -1) --a[i];
	}
	int ans = 1;
	for (int st = k - 1; st >= 0; --st){
		int big = 1 << st, fr = 0;
		vector<int> na(1 << st);
		forn(i, 1 << st){
			int mn = min(a[2 * i], a[2 * i + 1]);
			int mx = max(a[2 * i], a[2 * i + 1]);
			if (mn == -1){
				if (mx >= (1 << st)){
					--big;
					na[i] = -1;
				}
				else if (mx != -1){
					na[i] = mx;
				}
				else{
					na[i] = -1;
					++fr;
				}
				continue;
			}
			if ((a[2 * i] < (1 << st)) == (a[2 * i + 1] < (1 << st))){
				puts("0");
				return 0;
			}
			na[i] = mn;
			--big;
		}
		forn(_, fr) ans = ans * 2ll % MOD;
		for (int i = 1; i <= big; ++i) ans = ans * 1ll * i % MOD;
		a = na;
	}
	printf("%d\n", ans);
}
--------------------------------------------------
Problem ID: 1837D
Editorial Content:
1837D - Bracket Coloring
Tutorial
Tutorial is loading...
Solution (BledDest)
#include <bits/stdc++.h>
 
using namespace std;

int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int t;
    cin >> t;
    for(int i = 0; i < t; i++)
    {
        int n;
        cin >> n;
        string s;
        cin >> s;
        vector<int> bal(n + 1);
        for(int j = 0; j < n; j++)
            if(s[j] == '(')
                bal[j + 1] = bal[j] + 1;
            else
                bal[j + 1] = bal[j] - 1;

        if(bal.back() != 0)
            cout << -1 << endl;
        else
        {
            if(*min_element(bal.begin(), bal.end()) == 0 || *max_element(bal.begin(), bal.end()) == 0)
            {
                cout << 1 << endl;
                for(int j = 0; j < n; j++)
                {
                    if(j) cout << " ";
                    cout << 1;
                }
                cout << endl;
            }
            else
            {
                cout << 2 << endl;
                vector<int> ans;
                int cur = 0;
                while(cur < n)
                {
                    int w = (s[cur] == '(' ? 1 : 2);
                    do
                    {
                        cur++;
                        ans.push_back(w);
                    }
                    while(bal[cur] != 0);
                }
                for(int j = 0; j < n; j++)
                {
                    if(j) cout << " ";
                    cout << ans[j];
                }
                cout << endl;
            }
        }
    }    
}
--------------------------------------------------
Problem ID: 1837C
Editorial Content:
1837C - Best Binary String
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    string s;
    cin >> s;
    char x = '0';
    for (auto& c : s) {
      if (c == '?') c = x;
      x = c;
    }
    cout << s << '\n';
  }
}
--------------------------------------------------
Problem ID: 1837B
Editorial Content:
1837B - Comparison String
Tutorial
Tutorial is loading...
Solution (BledDest)
#include <bits/stdc++.h>
 
using namespace std;

int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int t;
    cin >> t;
    for(int i = 0; i < t; i++)
    {
        int n;
        cin >> n;
        string s;
        cin >> s;
        int ans = 1, cur = 1;
        for(int i = 1; i < n; i++)
        {
            if(s[i] != s[i - 1]) cur = 1;
            else cur++;
            ans = max(ans, cur);
        }
        cout << ans + 1 << endl;
    }    
}
--------------------------------------------------
Problem ID: 1837A
Editorial Content:
1837A - Grasshopper on a Line
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	x, k = map(int, input().split())
	if x % k != 0:
		print(1)
		print(x)
	else:
		print(2)
		print(1, x - 1)
--------------------------------------------------
Problem ID: 1836B
Editorial Content:
1836B - Astrophysicists
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
int main()
{
	int t;
	scanf ("%d", &t);
	while (t--) {
		long long n, k, g;
		scanf ("%lld %lld %lld", &n, &k, &g);
 
		long long stolen = min((g - 1) / 2 * n, k * g);
		long long rest = (k * g - stolen) % g;
 
		if (rest > 0) {
		    stolen -= (g - 1) / 2;
		    long long last = ((g - 1) / 2 + rest) % g;
 
		    if (last * 2 < g) {
		        stolen += last;
		    } else {
		        stolen -= g - last;
		    }
		}
 
		printf ("%lld\n", stolen);
	}
}
--------------------------------------------------
Problem ID: 1836A
Editorial Content:
1836A - Destroyer
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
 
const int N = 1e6;
 
int main()
{
    int cases;
    scanf("%d", &cases);
    
    while (cases--) {
    	int n;
    	scanf ("%d", &n);
    	
    	vector <int> cnt(n + 1);
    	for (int i = 0; i < n; i++) {
    		int d;
    		scanf("%d", &d);
    		if (d < n) {
        		cnt[d]++;
    		} else {
    		    cnt[n] = N;
    		}
    	}
    	
    	bool good = true;
    	for (int i = 1; i <= n; i++) if (cnt[i] > cnt[i-1]) {
    	    good = false;
    	    break;
    	}
    	
    	puts(good ? "YES" : "NO");
    }
}
--------------------------------------------------
Problem ID: 1835F
Editorial Content:
1835F - Good Graph
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define forr(i, n) for (int i = 0; i < n; i++)
#define FOREACH(iter, coll) for (auto iter = coll.begin(); iter != coll.end(); ++iter)
#define FOREACHR(iter, coll) for (auto iter = coll.rbegin(); iter != coll.rend(); ++iter)
#define lbound(P, K, FUN) ({auto SSS=P, PPP = P-1, KKK=(K)+1; while(PPP+1!=KKK) {SSS = (PPP+(KKK-PPP)/2); if(FUN(SSS)) KKK = SSS; else PPP = SSS;} PPP; })
#define testy()    \
    int _tests;    \
    cin >> _tests; \
    FOR(_test, 1, _tests)
#define CLEAR(tab) memset(tab, 0, sizeof(tab))
#define CONTAIN(el, coll) (coll.find(el) != coll.end())
#define FOR(i, a, b) for (int i = a; i <= b; i++)
#define FORD(i, a, b) for (int i = a; i >= b; i--)
#define MP make_pair
#define PB push_back
#define ff first
#define ss second
#define deb(X) X;
#define SIZE(coll) ((int)coll.size())

using namespace std;

const int MXN = 1007;
int n, m;
vector<int> G[MXN];
bitset<MXN> bs[MXN], edge[MXN];

// MATCHING

const int MXM = 1007 * 2;
int skojX[MXM], skojY[MXM];
bool vis[MXM];

bool dfs_m(int x)
{
    vis[x] = 1;
    FOREACH(it, G[x])
    if (!skojY[*it] || (!vis[skojY[*it]] && dfs_m(skojY[*it])))
    {
        skojX[x] = *it;
        skojY[*it] = x;
        return 1;
    }
    return 0;
}

bool skoj()
{
    int czy = 1;
    int res = 0;
    while (czy)
    {
        czy = 0;
        CLEAR(vis);
        FOR(i, 1, n)
        if (!vis[i] && !skojX[i] && dfs_m(i))
        {
            czy = 1;
            res++;
        }
    }
    return res == n;
}

// END OF MATCHING

void dfs(int nr, bitset<MXN> &visited, bitset<MXN> &to_visit)
{
    visited[nr] = 1;
    to_visit[nr] = 0;
    to_visit = to_visit | (edge[nr] & (~visited));
    for (int i = to_visit._Find_first(); i < SIZE(to_visit); i = to_visit._Find_next(i))
        dfs(i, visited, to_visit);
}

int solve()
{
    cin >> n >> m;
    forr(i, m)
    {
        int a, b;
        cin >> a >> b;
        G[a].PB(b);
    }

    int rres = skoj();
    if (rres)
    {
        FOR(i, 1, n)
        {
            for (auto j : G[i])
            {
                edge[i][skojY[j]] = 1;
            }
        }
        unordered_map<bitset<MXN>, vector<int>> mapa;
        vector<pair<int, int>> vec, res;
        FOR(i, 1, n)
        {
            bitset<MXN> to_visit;
            dfs(i, bs[i], to_visit);
            mapa[bs[i]].PB(i);
        }

        for (auto p : mapa)
        {
            vector<int> l = p.ss;
            vec.PB({bs[l[0]].count(), l[0]});
            if (l.size() == 1)
            {
                res.PB({l[0], l[0]});
                continue;
            }
            for (int i = 0; i < SIZE(l); i++)
            {
                res.PB({l[i], l[i]});
                res.PB({l[i], l[(i + 1) % SIZE(l)]});
            }
        }
        sort(vec.begin(), vec.end());
        forr(i, SIZE(vec))
        {
            int nr = vec[i].ss;
            bitset<MXN> b;
            for (int j = i - 1; j >= 0; j--)
                if (vec[j].ff < vec[i].ff)
                {
                    int nr2 = vec[j].ss;
                    if (bs[nr][nr2] && !b[nr2])
                    {
                        b |= bs[nr2];
                        res.PB({nr, nr2});
                    }
                }
        }

        cout << "YES" << '\n';
        cout << res.size() << '\n';
        for (auto p : res)
            cout << p.ff << " " << p.ss + n << '\n';
    }
    else
    {
        CLEAR(vis);
        FOR(i, 1, n)
        {
            if (skojX[i] == 0)
            {
                dfs_m(i);
                break;
            }
        }
        vector<int> v;
        FOR(i, 1, n)
        {
            if (vis[i])
                v.PB(i);
        }
        cout << "NO" << '\n';
        cout << v.size() << '\n';
        for (auto el : v)
            cout << el << " ";
        cout << '\n';
    }

    return 0;
}

int main()
{
    std::ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    solve();

    return 0;
}
--------------------------------------------------
Problem ID: 1835E
Editorial Content:
1835E - Old Mobile
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
constexpr int MAX_M = 1000 + 7;
constexpr int PRECISION = 9;
constexpr long long MOD = 1e9 + 7;
 
long long mod_inv[MAX_M];
long long DP[MAX_M][MAX_M][2][2];
long long DPprob[MAX_M][MAX_M][2][2];
bool updated[MAX_M][MAX_M][2][2];
// DP[correct][incorrect][backspace][bad suffix]
 
long long calc_mod_inv(long long n)
{
    long long res = 1;
    long long exp = MOD - 2;
 
    while (exp)
    {
        if (exp & 1)
        {
            res = (res * n) % MOD;
        }
 
        exp >>= 1;
        n = (n * n) % MOD;
    }
 
    return res;
}
 
void calc_DP(int digits, int needed)
{
    DP[0][0][0][0] = 0;
    DPprob[0][0][0][0] = 1;
 
    struct ID
    {
        int x, y, z, s;
    };
 
    queue <ID> dp_queue;
    dp_queue.push({0, 0, 0, 0});
 
    while(!dp_queue.empty())
    {
        auto [x, y, z, s] = dp_queue.front();
        dp_queue.pop();
 
        if (updated[x][y][z][s])
        {
            continue;
        }
 
        updated[x][y][z][s] = true;
 
        long long left = digits + 1 - x - y - z;
        long long corr = needed - x;
        long long incorr = digits - needed - y;
        long long prob = DPprob[x][y][z][s];
 
        if (corr == 0 and s == 0)
        {
            // done
            continue;
        }
 
        // correct suffix
        if (s == 0)
        {
            if (corr > 0)
            {
                // found the one correct digit (no need to delete)
                long long opt_prob = (prob * mod_inv[left]) % MOD;
                DPprob[x + 1][y][z][0] = (DPprob[x + 1][y][z][0] + opt_prob) % MOD;
                DP[x + 1][y][z][0] = (DP[x + 1][y][z][0] + DP[x][y][z][0] * mod_inv[left]) % MOD;
 
                // found a needed but currently wrong digit (needs to be deleted)
                if (corr > 1)
                {
                    if (z == 0) // if backspace is not known, the suffix is bad
                    {
                        long long opt_prob = ((prob * (corr - 1) % MOD) * mod_inv[left]) % MOD;
                        DPprob[x + 1][y][z][1] = (DPprob[x + 1][y][z][1] + opt_prob) % MOD;
 
                        DP[x + 1][y][z][1] = (DP[x + 1][y][z][1] + ((corr - 1) * mod_inv[left] % MOD) * DP[x][y][z][0] + 2 * opt_prob) % MOD;
                        dp_queue.push({x + 1, y, z, 1});
                    }
                    else // if backspace is known, the suffix can be instantly repaired
                    {
                        long long opt_prob = ((prob * (corr - 1) % MOD) * mod_inv[left]) % MOD;
                        DPprob[x + 1][y][z][0] = (DPprob[x + 1][y][z][0] + opt_prob) % MOD;
                        DP[x + 1][y][z][0] = (DP[x + 1][y][z][0] + ((corr - 1) * mod_inv[left] % MOD) * DP[x][y][z][0] + 2 * opt_prob) % MOD;
                    }
                }
 
                dp_queue.push({x + 1, y, z, 0});
            }
 
            if (incorr > 0)
            {
                // found an incorrect digit
                if (z == 0)
                {
                    long long opt_prob = (prob * incorr % MOD) * mod_inv[left] % MOD;
                    DPprob[x][y + 1][z][1] = (DPprob[x][y + 1][z][1] + opt_prob) % MOD;
                    DP[x][y + 1][z][1] = (DP[x][y + 1][z][1] + (incorr * mod_inv[left] % MOD) * DP[x][y][z][0] + 2 * opt_prob) % MOD;
                    dp_queue.push({x, y + 1, z, 1});
                }
                else // suffix can be repaired
                {
                    long long opt_prob = ((prob * incorr % MOD) * mod_inv[left]) % MOD;
                    DPprob[x][y + 1][z][0] = (DPprob[x][y + 1][z][0] + opt_prob) % MOD;
                    DP[x][y + 1][z][0] = (DP[x][y + 1][z][0] + (incorr * mod_inv[left] % MOD) * DP[x][y][z][0] + 2 * opt_prob) % MOD;
                    dp_queue.push({x, y + 1, z, 0});
                }
            }
 
            if (z == 0)
            {
                if (x > 0) // deleted correct digit
                {
                    long long opt_prob = prob * mod_inv[left] % MOD;
                    DPprob[x][y][1][0] = (DPprob[x][y][1][0] + opt_prob) % MOD;
                    DP[x][y][1][0] = (DP[x][y][1][0] + mod_inv[left] * DP[x][y][0][0] + 2 * opt_prob) % MOD;
                }
                else // deleted nothing
                {
                    long long opt_prob = prob * mod_inv[left] % MOD;
                    DPprob[x][y][1][0] = (DPprob[x][y][1][0] + opt_prob) % MOD;
                    DP[x][y][1][0] = (DP[x][y][1][0] + mod_inv[left] * DP[x][y][0][0] + opt_prob) % MOD;
                }
 
                dp_queue.push({x, y, 1, 0});
            }
        }
 
        if (s == 1)
        {
            if (corr > 0)
            {
                // found a needed but currently wrong digit (needs to be deleted)
                long long opt_prob = (prob * corr % MOD) * mod_inv[left] % MOD;
                DPprob[x + 1][y][z][1] = (DPprob[x + 1][y][z][1] + opt_prob) % MOD;
                DP[x + 1][y][z][1] = (DP[x + 1][y][z][1] + (corr * mod_inv[left] % MOD) * DP[x][y][z][1] + 2 * opt_prob) % MOD;
                dp_queue.push({x + 1, y, z, 1});
            }
 
            if (incorr > 0)
            {
                // found an incorrect digit
                long long opt_prob = (prob * incorr % MOD) * mod_inv[left] % MOD;
                DPprob[x][y + 1][z][1] = (DPprob[x][y + 1][z][1] + opt_prob) % MOD;
                DP[x][y + 1][z][1] = (DP[x][y + 1][z][1] + (incorr * mod_inv[left] % MOD) * DP[x][y][z][1] + 2 * opt_prob) % MOD;
                dp_queue.push({x, y + 1, z, 1});
            }
 
            if (z == 0)
            {
                // deleted bad suffix
                long long opt_prob = prob * mod_inv[left] % MOD;
                DPprob[x][y][1][0] = (DPprob[x][y][1][0] + opt_prob) % MOD;
                DP[x][y][1][0] = (DP[x][y][1][0] + mod_inv[left] * DP[x][y][0][1]) % MOD;
                dp_queue.push({x, y, 1, 0});
            }
        }
    }
}
 
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
 
    mod_inv[0] = 1;
    for (int i = 1; i < MAX_M; ++i) {
        mod_inv[i] = calc_mod_inv(i);
        assert (mod_inv[i] * i % MOD == 1);
    }
 
    int n, m;
    cin >> n >> m;
 
    set <int> different_digits;
 
    for (int i = 0; i < n; ++i)
    {
        int p;
        cin >> p;
 
        different_digits.insert(p);
    }
 
    int needed = different_digits.size();
 
    calc_DP(m, needed);
 
    long long result = 0;
 
    for (int i = 0; i <= MAX_M; ++i)
    {
        result = (result + DP[needed][i][0][0]) % MOD;
        result = (result + DP[needed][i][1][0]) % MOD;
    }
 
    cout << (result + n) % MOD << "\n";
 
    return 0;
}
--------------------------------------------------
Problem ID: 1835D
Editorial Content:
1835D - Doctor's Brown Hypothesis
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>
using namespace std;
 
#define sz(s) (int)s.size()
#define all(s) s.begin(), s.end()
#define pb push_back
#define FOR(i, n) for(int i = 0; i < n; i++)
 
using vi = vector<int>;
using vvi = vector<vi>;
 
struct SCC {
    int cnt = 0;
    vi vis, scc_nr;
    vvi scc_list, DAG;
 
    SCC(){}
 
    SCC(vvi & G){
        // G is 0 indexed!
        int n = sz(G);
        vvi G_rev(n);
        vis = scc_nr = vi(n);
 
        vi postorder;
        for(int i = 0; i < n; i++)
            if(!vis[i])
                dfs_post(i, G, G_rev, postorder);
        
        vis = vi(n);
        while(sz(postorder)){
            auto akt = postorder.back();
            postorder.pop_back();
            if(!vis[akt]){
                DAG.emplace_back();
                scc_list.emplace_back();
                dfs_rev(akt, G_rev);
                cnt++;
            }
        }
 
        // optional
        for(int i = 0; i < sz(DAG); i++){
            sort(all(DAG[i]));
            DAG[i].resize(unique(all(DAG[i])) - DAG[i].begin());
        }
    }
 
    void dfs_post(int start, vvi & G, vvi & G_rev, vi & postorder){
        vis[start] = 1;
        for(auto & u : G[start]){
            G_rev[u].pb(start);
            if(!vis[u])
                dfs_post(u, G, G_rev, postorder);
        }
        
        postorder.pb(start);
    }
 
    void dfs_rev(int start, vvi & G_rev){
        vis[start] = true;
        scc_list.back().pb(start);
        scc_nr[start] = cnt;
 
        for(auto & u : G_rev[start])
            if(!vis[u])
                dfs_rev(u, G_rev);
            else if(scc_nr[u] != cnt)
                DAG[scc_nr[u]].pb(cnt);
    }
};
 
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
 
    long long n, m, k;
    cin >> n >> m >> k;
 
    vvi G(n);
 
    set<pair<int, int>> edges;
    for (int i = 0; i < m; i++)
    {
        int a, b;
        cin >> a >> b;
        a--, b--;
        G[a].pb(b);
        edges.insert({a, b});
    }
 
    SCC scc(G);
    vi coloring(n, -1);
 
    auto try_coloring = [&](int num_col, const vi& group)
    {
        vi visited;
        function<bool(int)> dfs = [&](int start){
            visited.pb(start);
            
            bool good_coloring = true;
            for (auto & u : G[start])
            {
                if (scc.scc_nr[u] != scc.scc_nr[start])
                {
                    continue;
                }
                if (coloring[u] == -1)
                {
                    coloring[u] = (coloring[start] + 1) % num_col;
                    good_coloring &= dfs(u);
                }
                else
                {
                    good_coloring &= coloring[u] == (coloring[start] + 1) % num_col;
                }
 
                if (not good_coloring)
                {
                    break;    
                }
            }
 
            return good_coloring;
        };
 
        coloring[group[0]] = 0;
        if (not dfs(group[0]))
        {
            for (auto & u : visited)
            {
                coloring[u] = -1;
            }
            return vvi();
        }
        else
        {
            vvi ret(num_col);
            for (auto & u : visited)
            {
                ret[coloring[u]].push_back(u);
            }
            return ret;
        }
    };
 
    long long ans = 0;
    vi depths(n, -1);
 
    for (vi& group : scc.scc_list)
    {
        n = sz(group);
 
        if (n == 1 and edges.count({group[0], group[0]}) == 0)
        {
            continue;
        }
        int gcd = -1;
        function<void(int)> dfs_depths = [&](int start)
        {
            for (auto & u : G[start])
            {
                if (scc.scc_nr[u] != scc.scc_nr[start])
                {
                    continue;
                }
 
                if (depths[u] == -1)
                {
                    depths[u] = depths[start] + 1;
                    dfs_depths(u);
                }
                else {
                    int diff = abs(depths[u] - (depths[start] + 1));
                    if (diff)
                    {
                        if (gcd == -1)
                        {
                            gcd = diff;
                        }
                        else
                        {
                            gcd = __gcd(gcd, diff);
                        }
                    }
                }
            }
        };
 
        depths[group[0]] = 0;
        dfs_depths(group[0]);
        assert(gcd != -1);
 
        vvi by_color = try_coloring(gcd, group);
 
        assert(sz(by_color) != 0);
        if (k % gcd == 0)
        {
            FOR (i, gcd)
            {
                ans += sz(by_color[i]) + 1ll * sz(by_color[i]) * (sz(by_color[i]) - 1) / 2;
            }
        }
        else if (k % gcd * 2 == gcd)
        {
            FOR (i, gcd / 2)
            {
                ans += 1ll * sz(by_color[i]) * sz(by_color[i + gcd / 2]);
            }
        }
    }
    cout << ans << '\n';
}
--------------------------------------------------
Problem ID: 1835C
Editorial Content:
1835C - Twin Clusters
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

void solve()
{
    int k, n;
    scanf("%d", &k);

    n = 2 << k;

    vector <long long> input(n + 1);
    vector <int> memHighBits(1 << k, -1);
    vector <pair <int, int> > memLowBits(1 << k, {-1, -1});
    
    auto addInterval = [&memLowBits, &input](int s, int e) {
        const int remXor = input[e] ^ input[s - 1];
        auto &[os, oe] = memLowBits[remXor];

        if (os == -1) {
            os = s, oe = e;
            return false;
        }

        if (oe < s) {
            printf("%d %d %d %d\n", os, oe, s, e);
        } else {
            printf("%d %d %d %d\n", min(s, os), max(s, os) - 1, oe + 1, e);
        }

        return true;
    };

    memHighBits[0] = 0;
    for (int i = 1; i <= n; ++i) {
        scanf("%lld", &input[i]);
        input[i] ^= input[i - 1];
    }

    for (int i = 1; i <= n; ++i) {
        if (memHighBits[input[i] >> k] != -1) {
            if (addInterval(memHighBits[input[i] >> k] + 1, i)) {
                break;
            }
        }

        memHighBits[input[i] >> k] = i;
    }
}

int main()
{
    int cases;
    scanf("%d", &cases);

    while (cases--) {
        solve();
    }

    return 0;
}
--------------------------------------------------
Problem ID: 1835B
Editorial Content:
1835B - Lottery
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
#define forr(i, n) for (int i = 0; i < n; i++)
#define FOREACH(iter, coll) for (auto iter = coll.begin(); iter != coll.end(); ++iter)
#define FOREACHR(iter, coll) for (auto iter = coll.rbegin(); iter != coll.rend(); ++iter)
#define lbound(P, K, FUN) ({auto SSS=P, PPP = P-1, KKK=(K)+1; while(PPP+1!=KKK) {SSS = (PPP+(KKK-PPP)/2); if(FUN(SSS)) KKK = SSS; else PPP = SSS;} PPP; })
#define testy()    \
    int _tests;    \
    cin >> _tests; \
    FOR(_test, 1, _tests)
#define CLEAR(tab) memset(tab, 0, sizeof(tab))
#define CONTAIN(el, coll) (coll.find(el) != coll.end())
#define FOR(i, a, b) for (int i = a; i <= b; i++)
#define FORD(i, a, b) for (int i = a; i >= b; i--)
#define MP make_pair
#define PB push_back
#define ff first
#define ss second
#define deb(X) X;
#define SIZE(coll) ((int)coll.size())
 
#define M 1000000007
#define INF 1000000007LL
 
using namespace std;
 
long long n, m, k;
long long poz_l, poz_p;
vector<long long> v;
 
long long policz_ile(long long strzal)
{
    while (poz_l < n && v[poz_l] < strzal)
        poz_l++;
    while (poz_p < n && v[poz_p] <= strzal)
        poz_p++;
 
    long long pocz = poz_p < k ? 0 : (strzal + v[poz_p - k]) / 2 + 1;
    long long kon = poz_l + k - 1 >= n ? m : (v[poz_l + k - 1] + strzal - 1) / 2;
 
    return max(0ll, kon - pocz + 1);
}
 
int solve()
{
    cin >> n >> m >> k;
    long long a;
    forr(i, n)
    {
        cin >> a;
        v.PB(a);
    }
    sort(v.begin(), v.end());
    v.PB(m + 1);
    long long res = policz_ile(0), best = 0;
    forr(i, n)
    {
        long long pocz = i == 0 ? max(0ll, v[i] - 2) : max(v[i] - 2, v[i - 1] + 3);
        long long kon = min(m, v[i] + 2);
        for (long long s = pocz; s <= kon; s++)
        {
            long long ile = policz_ile(s);
 
            if (ile > res)
            {
                res = ile;
                best = s;
            }
        }
    }
    cout << res << " " << best << '\n';
 
    return 0;
}
 
int main()
{
    std::ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
 
    solve();
 
    return 0;
}
--------------------------------------------------
Problem ID: 1835A
Editorial Content:
1835A - k-th equality
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

int power(int a, int e) {
    if (e == 0) return 1;
    return e == 1 ? a : a * power(a, e-1);
}

void answer(int a, int b) {
    std::cout << a << " + " << b << " = " << a+b << std::endl;
}

int main() {
    using ll = long long;
    
    int t;
    std::cin >> t;
    while (t--) {

        int a, b, c;
        ll k;
        std::cin >> a >> b >> c >> k;
        
        bool good = false;
    
        for (int i = power(10, a-1); i < power(10, a); ++i) {
            int left = std::max(power(10, b-1), power(10, c-1) - i);
            int right = std::min(power(10, b)-1, power(10, c) - 1 - i);
            if (left > right) continue;
    
            int have = right - left + 1;
            if (k <= have) {
                answer(i, left + k - 1);
                good = true;
                break;
            }
    
            k -= have;
        }
    
        if (!good) std::cout << "-1" << std::endl;
    }

    return 0;
}
--------------------------------------------------
Problem ID: 1834F
Editorial Content:
1834F - Typewriter
--------------------------------------------------
Problem ID: 1834E
Editorial Content:
1834E - MEX of LCM
--------------------------------------------------
Problem ID: 1834D
Editorial Content:
1834D - Survey in Class
--------------------------------------------------
Problem ID: 1834C
Editorial Content:
1834C - Game with Reversing
--------------------------------------------------
Problem ID: 1834B
Editorial Content:
1834B - Maximum Strength
--------------------------------------------------
Problem ID: 1834A
Editorial Content:
1834A - Unit Array
--------------------------------------------------
Problem ID: 1833G
Editorial Content:
1833G - Ksyusha and Chinchilla
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;
typedef pair<int, int> ipair;

const int MAXN = 200200;

int n;
vector<ipair> gr[MAXN];
vector<int> res;
queue<int> qu;
int par[MAXN], ipar[MAXN], deg[MAXN], hard[MAXN];

void init() {
	res.clear();
	while (!qu.empty()) qu.pop();
	memset(deg, 0, sizeof(int) * n);
	memset(hard, 0, sizeof(int) * n);
	for (int v = 0; v < n; ++v)
		gr[v].clear();
}

void dfs(int v, int p, int ip) {
	par[v] = p;
	ipar[v] = ip;
	for (auto [u, i]: gr[v]) {
		if (u == p) continue;
		dfs(u, v, i);
		++deg[v];
		hard[v] += (deg[u] > 0);
	}
}

void build() {
	dfs(0, -1, -1);
}

bool rempar(int v) {
	int u = par[v];
	if (u == -1) return true;
	par[v] = -1;
	res.push_back(ipar[v]);
	--deg[u], --hard[u];
	if (deg[u]) {
		if (!hard[u]) qu.push(u);
		return true;
	}
	if (par[u] == -1) return false;
	--hard[par[u]];
	if (!hard[par[u]]) qu.push(par[u]);
	return true;
}

bool solve() {
	if (n % 3) return false;
	for (int v = 0; v < n; ++v)
		if (!hard[v] && deg[v]) qu.push(v);
	while (!qu.empty()) {
		int v = qu.front(); qu.pop();
		if (deg[v] > 2) return false;
		if (deg[v] == 2) {
			if (!rempar(v)) return false;
		} else if (deg[v] == 1) {
			if (par[v] == -1) return false;
			for (auto [u, i]: gr[par[v]]) {
				if (u == par[par[v]] || u == v || par[u] == -1) continue;
				if (!deg[u]) return false;
				res.push_back(i);
				par[u] = -1;
			}
			if (!rempar(par[v])) return false;
		}
	}
	return true;
}

int main() {
	int t; cin >> t;
	while (t--) {
		cin >> n, init();
		for (int i = 1; i < n; ++i) {
			int v, u; cin >> v >> u, --v, --u;
			gr[v].emplace_back(u, i);
			gr[u].emplace_back(v, i);
		}
		build();
		if (!solve()) {
			cout << -1 << endl;
			continue;
		}
		cout << res.size() << endl;
		for (int id: res)
			cout << id << ' ';
		cout << endl;
	}
}
--------------------------------------------------
Problem ID: 1833F
Editorial Content:
1833F - Ira and Flamenco
Tutorial
Tutorial is loading...
Solution
/*
         `)
        _ \
      (( }/  ,_
      )))__ /
     (((---'
       \ '
        )|____.---- )
       / \ `       (
      / ' \ `      )
     /  '  \  `   /
    /   '       _/
   /   _!____.-'
  /_.-'/    \
     |`_    |`_
*/
#include <bits/stdc++.h>

using namespace std;
typedef pair<int, int> ipair;

const int MAXN = 200200;
const int MAXK = MAXN;
const int MOD = 1000000007;

inline int add(int a, int b) {
	return (a + b >= MOD ? a + b - MOD : a + b);
}

inline int mul(int a, int b) {
	return 1LL * a * b % MOD;
}

int n, m, k;
int arr[MAXN], brr[MAXN], cnt[MAXK];

void build() {
	sort(arr, arr + n);
	memcpy(brr, arr, sizeof(int) * n);
	k = unique(arr, arr + n) - arr;
	for (int j = 0; j < k; ++j)
		cnt[j] = upper_bound(brr, brr + n, arr[j]) - lower_bound(brr, brr + n, arr[j]);
}

inline void push(stack<ipair> &S, int x) {
	S.emplace(x, mul(x, S.empty() ? 1 : S.top().second));
}

int solve() {
	if (k < m) return 0;
	stack<ipair> S1, S2;
	for (int j = 0; j < m; ++j)
		push(S1, cnt[j]);
	int ans = 0;
	for (int j = m; j <= k; ++j) {
		if (arr[j - 1] - arr[j - m] == m - 1)
			ans = add(ans, mul(S1.empty() ? 1 : S1.top().second, S2.empty() ? 1 : S2.top().second));
		if (S2.empty()) {
			for (; !S1.empty(); S1.pop())
				push(S2, S1.top().first);
		}
		S2.pop();
		push(S1, cnt[j]);
	}
	return ans;
}

int main() {
	int t; cin >> t;
	while (t--) {
		cin >> n >> m;
		for (int i = 0; i < n; ++i)
			cin >> arr[i];
		build();
		cout << solve() << endl;
	}
}
--------------------------------------------------
Problem ID: 1833E
Editorial Content:
1833E - Round Dance
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <algorithm>

using namespace std;

typedef long long ll;

void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    vector<set<int>> g(n);
    vector<set<int>> neighbours(n);
    vector<int> d(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        a[i]--;
        g[i].insert(a[i]);
        g[a[i]].insert(i);
    }
    for (int i = 0; i < n; ++i) {
        d[i] = g[i].size();
    }
    int bamboos = 0, cycles = 0;
    vector<bool> vis(n);
    for (int i = 0; i < n; ++i) {
        if (!vis[i]) {
            queue<int> q;
            q.push(i);
            vis[i] = true;
            vector<int> component = {i};
            while (!q.empty()) {
                int u = q.front();
                q.pop();
                for (int v: g[u]) {
                    if (!vis[v]) {
                        vis[v] = true;
                        q.push(v);
                        component.push_back(v);
                    }
                }
            }
            bool bamboo = false;
            for (int j: component) {
                if (d[j] == 1) {
                    bamboo = true;
                    break;
                }
            }
            if (bamboo) {
                bamboos++;
            } else {
                cycles++;
            }
        }
    }
    cout << cycles + min(bamboos, 1) << ' ' << cycles + bamboos << '\n';
}

int main() {
    int t;
    cin >> t;
    for (int _ = 0; _ < t; ++_) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1833D
Editorial Content:
1833D - Flipper
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

#define forn(i, n) for (int i = 0; i < int(n); i++)
#define sz(v) (int)v.size()
#define all(v) v.begin(),v.end()
#define eb emplace_back



void solve() {
    int n; cin >> n;
    vector<int> p(n);
    for (auto &e : p) cin >> e;

    int r = 0;
    for (int i = 0; i < n; ++i) {
        if (p[min(n-1, r+1)] <= p[min(n-1, i+1)]) {
            r = i;
        }
    }
    vector<int> ans;
    for (int i = r + 1; i < n; ++i) ans.eb(p[i]);
    ans.eb(p[r]);
    for (int i = r-1; i >= 0; --i) {
        if (p[i] > p[0]) {
            ans.eb(p[i]);
        } else {
            for (int j = 0; j <= i; ++j) {
                ans.eb(p[j]);
            }
            break;
        }
    }
    for (auto e : ans) cout << e << ' ';
    cout << endl;
}

int main() {
    int t;
    cin >> t;

    forn(tt, t) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1833C
Editorial Content:
1833C - Vlad Building Beautiful Array
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    a = [int(x) for x in input().split()]
    a.sort()
    if a[0] % 2 == 1:
        print("YES")
        return
    for i in range(n):
        if a[i] % 2 == 1:
            print("NO")
            return
    print("YES")


t = int(input())
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 1833B
Editorial Content:
1833B - Restore the Weather
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>
using namespace std;
void  solve(){
    int n, k;
    cin >> n >> k;
    vector<pair<int, int>>a(n);
    vector<int>b(n), ans(n);
    for(int i = 0; i < n; i++){
        cin >> a[i].first;
        a[i].second = i;
    }
    for(auto &i : b) cin >> i;
    sort(b.begin(), b.end());
    sort(a.begin(), a.end());

    for(int i = 0; i < n; i++){
        ans[a[i].second] = b[i];
    }
    for(auto &i : ans) cout << i << ' ';
    cout << endl;
}
int main(){
    int t;
    cin >> t;
    while(t--) solve();
}
--------------------------------------------------
Problem ID: 1833A
Editorial Content:
1833A - Musical Puzzle
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    s = input()
    cnt = set()
    for i in range(1, n):
        cnt.add(s[i - 1] + s[i])
    print(len(cnt))


t = int(input())
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 1832F
Editorial Content:
1832F - Zombies
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

struct seg{
	int l, r;
};

int n;
vector<long long> dp_before, dp_cur;
vector<vector<long long>> bst;

void compute(int l, int r, int optl, int optr){
	if (l > r) return;
	int mid = (l + r) / 2;
	pair<long long, int> best = {-1, -1};
	for (int k = optl; k <= min(mid, optr); k++)
		best = max(best, {(k ? dp_before[k - 1] : 0) + bst[k][mid], k});
	dp_cur[mid] = best.first;
	int opt = best.second;
	compute(l, mid - 1, optl, opt);
	compute(mid + 1, r, opt, optr);
}

struct node{
    long long c0;
    int c1;
};

vector<node> f;

void update(int x, int a, int b){
	for (int i = x; i < int(f.size()); i |= i + 1){
		f[i].c0 += b;
		f[i].c1 += a;
	}
}

void update(int l, int r, int a, int b){
	update(l, a, b);
	update(r, -a, -b);
}

long long get(int pos, int x){
	long long res = 0;
	for (int i = x; i >= 0; i = (i & (i + 1)) - 1)
		res += f[i].c0 + f[i].c1 * 1ll * pos;
	return res;
}

int main() {
	int k, x, m;
	scanf("%d%d%d%d", &n, &k, &x, &m);
	vector<seg> a(n);
	forn(i, n) scanf("%d%d", &a[i].l, &a[i].r);
	sort(a.begin(), a.end(), [&](const seg &a, const seg &b){
		return a.l + a.r < b.l + b.r;
	});
	
	vector<int> pos;
	forn(i, n){
		pos.push_back(a[i].l);
		pos.push_back(a[i].r - m);
	}
	sort(pos.begin(), pos.end());
	pos.resize(unique(pos.begin(), pos.end()) - pos.begin());
	int cds = pos.size();
	
	vector<array<int, 4>> npos(n);
	forn(i, n){
		npos[i][0] = lower_bound(pos.begin(), pos.end(), a[i].l - m) - pos.begin();
		npos[i][1] = lower_bound(pos.begin(), pos.end(), a[i].l) - pos.begin();
		npos[i][2] = lower_bound(pos.begin(), pos.end(), a[i].r - m) - pos.begin();
		npos[i][3] = lower_bound(pos.begin(), pos.end(), a[i].r) - pos.begin();
	}
	
	vector<long long> pr(n + 1);
	forn(i, n) pr[i + 1] = pr[i] + x - (m + a[i].r - a[i].l);
	
	auto upd = [&](int i){
		if (a[i].r - a[i].l >= m){
			update(npos[i][0], npos[i][1], 1, m - a[i].l);
			update(npos[i][1], npos[i][2], 0, m);
			update(npos[i][2], npos[i][3], -1, a[i].r);
		}
		else{
			update(npos[i][0], npos[i][2], 1, m - a[i].l);
			update(npos[i][2], npos[i][1], 0, a[i].r - a[i].l);
			update(npos[i][1], npos[i][3], -1, a[i].r);
		}
	};
	
	bst.resize(n, vector<long long>(n, -1));
	vector<vector<int>> opt(n, vector<int>(n));
	forn(r, n) for (int l = r; l >= 0; --l){
		if (l == r) f.assign(cds, {0, 0});
		upd(l);
		int L = (l == r ? (l == 0 ? 0 : opt[l - 1][l - 1]) : opt[l][r - 1]);
		int R = (l == r ? int(pos.size()) - 1 : opt[l + 1][r]);
		for (int k = L; k <= R; ++k){
			long long cur = pr[r + 1] - pr[l] + get(pos[k], k);
			if (cur > bst[l][r]){
				bst[l][r] = cur;
				opt[l][r] = k;
			}
		}
	}
	
	dp_before.resize(n);
	dp_cur.resize(n);
	for (int i = 0; i < n; i++)
		dp_before[i] = bst[0][i];

	for (int i = 1; i < k; i++){
		compute(0, n - 1, 0, n - 1);
		dp_before = dp_cur;
	}
	
	printf("%lld\n", dp_before[n - 1]);
	return 0;
}
--------------------------------------------------
Problem ID: 1832E
Editorial Content:
1832E - Combinatorics Problem
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

const int MOD = 998244353;

int add(int x, int y, int mod = MOD)
{
	return ((x + y) % mod + mod) % mod;
}

int mul(int x, int y, int mod = MOD)
{
	return (x * 1ll * y) % mod;
}

int binpow(int x, int y, int mod = MOD)
{
	int z = add(1, 0, mod);
	while(y > 0)
	{
		if(y % 2 == 1) z = mul(z, x, mod);
		y /= 2;
		x = mul(x, x, mod);
	}
	return z;
}

vector<int> psum(vector<int> v)
{
	vector<int> ans(1, 0);
	for(auto x : v) ans.push_back(add(ans.back(), x));
	return ans;
}

int main()
{
	int n;
	cin >> n;
	vector<int> a(n);
	cin >> a[0];
	int x, y, m, k;
	cin >> x >> y >> m >> k;
	for(int i = 1; i < n; i++)
		a[i] = add(mul(a[i - 1], x, m), y, m);
	
	for(int i = 0; i <= k; i++)
		a = psum(a);
	long long ans = 0;
	
	for(int i = 1; i <= n; i++)
		ans ^= (a[i + 1] * 1ll * i);
	cout << ans << endl;
}
--------------------------------------------------
Problem ID: 1832D2
Editorial Content:
1832D2 - Red-Blue Operations (Hard Version)
Tutorial
Tutorial is loading...
Solution (awoo)
n, q = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
pr = [10**9 for i in range(n + 1)]
for i in range(n):
	pr[i + 1] = min(pr[i], a[i] - i)
s = sum(a) - n * (n - 1) // 2
ans = []
for k in map(int, input().split()):
	if k < n:
		ans.append(min(pr[k] + k, a[k]))
		continue
	if k % 2 == n % 2:
		ns = s - pr[n] * n
		ans.append(pr[n] + k - (max(0, (k - n) // 2 - ns) + n - 1) // n)
	else:
		nmn = min(pr[n - 1], a[n - 1] - k)
		ns = (s + (n - 1) - k) - nmn * n
		ans.append(nmn + k - (max(0, (k - (n - 1)) // 2 - ns) + n - 1) // n)
print(*ans)
--------------------------------------------------
Problem ID: 1832D1
Editorial Content:
1832D1 - Red-Blue Operations (Easy Version)
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1832C
Editorial Content:
1832C - Contrast Value
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int& x : a) cin >> x;
    n = unique(a.begin(), a.end()) - a.begin();
    int ans = n;
    for (int i = 0; i + 2 < n; ++i) {
      ans -= (a[i] < a[i + 1] && a[i + 1] < a[i + 2]);
      ans -= (a[i] > a[i + 1] && a[i + 1] > a[i + 2]);
    }
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1832B
Editorial Content:
1832B - Maximum Sum
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	n, k = map(int, input().split())
	a = sorted(list(map(int, input().split())))
	ans = 0
	pr = [0] * (n + 1)
	for i in range(n):
		pr[i + 1] = pr[i] + a[i]
	for i in range(k + 1):
		ans = max(ans, pr[n - (k - i)] - pr[2 * i])
	print(ans)
--------------------------------------------------
Problem ID: 1832A
Editorial Content:
1832A - New Palindrome
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  int t;
  cin >> t;
  while (t--) {
    string s;
    cin >> s;
    s = s.substr(0, s.size() / 2);
    int k = unique(s.begin(), s.end()) - s.begin();
    cout << (k == 1 ? "NO" : "YES") << '\n';
  }
}
--------------------------------------------------
Problem ID: 1831B
Editorial Content:
1831B — Array Merging
Hints
Hint 1
When we merge two arrays $$$a$$$ and $$$b$$$, we can force the resulting array to have $$$[a_{l_1},a_{l_1+1},\ldots,a_{r_1},b_{l_2},b_{l_2+1},\ldots,b_{r_1}]$$$ as a subarray, for some $$$1 \le l_1 \le r_1 \le n$$$ and $$$1 \le l_2 \le r_2 \le n$$$.
Hint 2
If $$$a_{l_1}=b_{l_1}$$$, then we can achieve a contiguous sequence of $$$(r_1-l_1+1)+(r_2-l_2+1)$$$ equal elements in the resulting array.
Hint 1
When we merge two arrays $$$a$$$ and $$$b$$$, we can force the resulting array to have $$$[a_{l_1},a_{l_1+1},\ldots,a_{r_1},b_{l_2},b_{l_2+1},\ldots,b_{r_1}]$$$ as a subarray, for some $$$1 \le l_1 \le r_1 \le n$$$ and $$$1 \le l_2 \le r_2 \le n$$$.
Hint 2
If $$$a_{l_1}=b_{l_1}$$$, then we can achieve a contiguous sequence of $$$(r_1-l_1+1)+(r_2-l_2+1)$$$ equal elements in the resulting array.
Solution
Let $$$max_a(x)$$$ be the length of the longest subarray from $$$a$$$ containing only elements equal to $$$x$$$. If $$$x$$$ doesn't appear in $$$a$$$, then $$$max_a(x)=0$$$.
Similarly, let $$$max_b(x)$$$ be the length of the longest subarray from $$$b$$$ containing only elements equal to $$$x$$$. If $$$x$$$ doesn't appear in $$$b$$$, then $$$max_b(x)=0$$$.
$$$max_a$$$ and $$$max_b$$$ can be computed in $$$O(N)$$$ by scanning the array while updating current maximal subarray.
When merging two arrays, it is possible to force a particular subarray $$$[a_{l_1},a_{l_1+1},\ldots,a_{r_1}]$$$ to be adjacent to another particular subarray $$$[b_{l_2},b_{l_2+1},\ldots,b_{r_2}]$$$ in the merged array.
Proof
We can construct the merged array as follows:
$$$[a_1,a_2,\ldots,a_{l_1-1}]+[b_1,b_2,\ldots,b_{l_2-1}]+[a_{l_1},a_{l_1+1},\ldots,a_{r_1},b_{l_2},b_{l_2+1},\ldots,b_{r_2}]+[\ldots]$$$
If $$$a_{l_1}=b_{l_2}$$$, then the merged array will have a subarray consisting of $$$(r_1-l_1+1)+(r_2-l_2+1)$$$ equal elements.
Therefore, the answer is equal to:
$$$max_{i=1}^{2 \cdot n}(max_a(i)+max_b(i))$$$
Time complexity per testcase: $$$O(N)$$$.
Proof
We can construct the merged array as follows:
$$$[a_1,a_2,\ldots,a_{l_1-1}]+[b_1,b_2,\ldots,b_{l_2-1}]+[a_{l_1},a_{l_1+1},\ldots,a_{r_1},b_{l_2},b_{l_2+1},\ldots,b_{r_2}]+[\ldots]$$$
Code (tibinyte, C++)
#include <bits/stdc++.h>

using namespace std;

int32_t main()
{
    cin.tie(nullptr)->sync_with_stdio(false);
    int q;
    cin >> q;
    while (q--)
    {
        int n;
        cin >> n;
        vector<int> a(n + 1);
        vector<int> b(n + 1);
        for (int i = 1; i <= n; ++i)
        {
            cin >> a[i];
        }
        for (int i = 1; i <= n; ++i)
        {
            cin >> b[i];
        }
        vector<int> fa(n + n + 1);
        vector<int> fb(n + n + 1);
        int p = 1;
        for (int i = 2; i <= n; ++i)
        {
            if (a[i] != a[i - 1])
            {
                fa[a[i - 1]] = max(fa[a[i - 1]], i - p);
                p = i;
            }
        }
        fa[a[n]] = max(fa[a[n]], n - p + 1);

        p = 1;
        for (int i = 2; i <= n; ++i)
        {
            if (b[i] != b[i - 1])
            {
                fb[b[i - 1]] = max(fb[b[i - 1]], i - p);
                p = i;
            }
        }
        fb[b[n]] = max(fb[b[n]], n - p + 1);

        int ans = 0;
        for (int i = 1; i <= n + n; ++i)
        {
            ans = max(ans, fa[i] + fb[i]);
        }

        cout << ans << '\n';
    }
}
Rate problem
Good problem
Ok problem
Bad problem
Didn't solve it, idk
--------------------------------------------------
Problem ID: 1831A
Editorial Content:
1831A — Twin Permutations
Hints
Hint 1
If $$$a_i+b_i \le a_{i+1}+b_{i+1}$$$, then $$$a_i+b_i$$$ can be equal to $$$a_{i+1}+b_{i+1}$$$.
Hint 2
Building on the idea from the first hint, can we build a permutation $$$b$$$ such that $$$a_1+b_1=a_2+b_2=\ldots=a_n+b_n$$$?
Hint 1
If $$$a_i+b_i \le a_{i+1}+b_{i+1}$$$, then $$$a_i+b_i$$$ can be equal to $$$a_{i+1}+b_{i+1}$$$.
Hint 2
Building on the idea from the first hint, can we build a permutation $$$b$$$ such that $$$a_1+b_1=a_2+b_2=\ldots=a_n+b_n$$$?
Solution
Since $$$a_i+b_i \le a_{i+1}+b_{i+1}$$$, then $$$a_i+b_i$$$ can be equal to $$$a_{i+1}+b_{i+1}$$$.
Therefore, any permutation $$$b$$$ which satisfies $$$a_1+b_1=a_2+b_2=\ldots=a_n+b_n$$$ is a valid answer.
If $$$b_i=n+1-a_i$$$, then:
$$$b$$$ is a permutation;
$$$a_1+b_1=a_2+b_2=\ldots=a_n+b_n=n+1$$$
Consequently, $$$b=[n+1-a_1,n+1-a_2,\ldots,n+1-a_i,\ldots,n+1-a_n]$$$ is a valid answer.
Time complexity per test case : $$$O(N)$$$
Code (Gheal, C++)
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
void tc(){
    ll n;
    cin>>n;
    for(ll i=0;i<n;i++){
        ll x;
        cin>>x;
        cout<<n+1-x<<' ';
    }
    cout<<'\n';
}
int main()
{
    ios_base::sync_with_stdio(false); cin.tie(0);
    ll t; cin>>t; while(t--)
        tc();
    return 0;
}
Rate Problem
Good problem
Ok problem
Bad problem
Didn't solve it, idk
--------------------------------------------------
Problem ID: 1830F
Editorial Content:
1830F — The Third Grace
Solution
Let $$$dp_i$$$ be the maximum sum of costs of activated points that are $$$< i$$$ over all states that has point $$$i$$$ activated.
When we transition from $$$dp_i$$$ to $$$dp_j$$$, we need to add the cost contributed by point $$$i$$$. The number of ranges where point $$$i$$$ is the largest coordinate within it are the ranges $$$[l,r]$$$ which satisfy $$$l \leq i \leq r < j$$$. So we have $$$dp_j = \max\limits_{i < j}(dp_i + p_i \cdot S_{i,j})$$$ where $$$S_{i,j}$$$ is the number of ranges $$$[l,r]$$$ which satisfy $$$l \leq i \leq r < j$$$. Now, we note that $$$S_{i,j} z$$$
With some work, we can get calculate this $$$dp$$$ in $$$O(n^2)$$$. But this will be too slow, let's try to speed this up.
Let us define $$$dp_{i,j} = \max\limits_{k \leq i}(dp_k + p_k \cdot S_{k,j})$$$. We have $$$dp_{j-1,j}=dp_j$$$. Our goal is to go from (implictly) storing $$$dp_{i,i+1},dp_{i,i+2},\ldots,dp_{i,n}$$$ to $$$dp_{i+1,i+2},dp_{i+1,i+3},\ldots,dp_{i+1,n}$$$. As $$$dp_i + p_i \cdot S_{i,j}$$$ looks like a linear function w.r.t. $$$S_{i,j}$$$, we can try to use convex hull data structures to maintain it.
Let's figure out how $$$S_{i+1,j}$$$ relates to $$$S_{i,j}$$$. We need to subtract the number of ranges with $$$r=i$$$ and add the number of ranges with $$$l=i+1$$$ and $$$r < j$$$. This corresponds to $$$S_{i,*}$$$ and $$$S_{i+1,*}$$$ differing by amortized $$$O(1)$$$ suffix increment updates. Also, note that $$$S_{i,*}$$$ is non-decreasing.
So we want to support the following data structure: Initially we have an arrays $$$A$$$ and $$$X$$$ that are both initially $$$0$$$. Handle the following updates:
1 m c
$$$A_i \gets \max(A_i,m \cdot X_i + c)$$$ for all $$$i$$$
2 j k
$$$X_i \gets X_i + k$$$ for all $$$j \leq i$$$. It is guaranteed that $$$X$$$ will always be non-decreasing.
3 i
find $$$A_i$$$
This can be maintained in a lichao tree in $$$O(log ^2)$$$ time. In each lichao node, we need to store $$$s,m,e$$$, the start, middle and end indices and their corresponding $$$X$$$ values $$$X_s,X_m,X_e$$$ respectively. This way, we can support operations $$$1$$$ and $$$3$$$ already.
To support operation $$$2$$$, note that in a lichao tree, you can use $$$O(log^2)$$$ time to push down all lines that covers a certain point (refer to
https://codeforces.com/blog/entry/86731)
. This way, all lines in the li chao tree are in $$$[1,j)$$$ or $$$[j,n]$$$, so you can do lazy updates on both the coordinates of the lines and the $$$X$$$ values.
The time complexity is $$$O(n \log^2)$$$.
There is another solution that works in $$$O(m \log^3)$$$ that we are unable to optimize further yet. Let us flip the array so that the condition is on the activated point with the smallest coordinate. Then we have $$$dp_j = \max\limits_{i < j}(dp_i + p_j \cdot S_{i,j})$$$ where $$$S_{i,j}$$$ counts the number of ranges $$$[l,r]$$$ such that $$$i< l \leq j \leq r$$$.
Now, we want to store the linear function $$$dp_i + x \cdot S_{i,j}$$$ in some sort of data structure so that we can evaluate the maximum value with $$$x=p_j$$$. Unfortunately, the value of $$$S_{i,j}$$$ can change by suffix additions, similar to above.
But since $$$S_{i,j}$$$ is non-increasing here, that means the optimal $$$i$$$ that maximizes $$$dp_i + x \cdot S_{i,j}$$$ decreases when $$$x$$$ increases. That is, for $$$l_1 \leq r_1< l_2 \leq r_2$$$ and we have two data structures that can get the maximum $$$f_j(x)=dp_i+x \cdot S_{i,j}$$$ for $$$l_j \leq i \leq r_j$$$ respectively. We can combine these $$$2$$$ data structures to make it for $$$[l_1,r_1] \cup [l_2,r_2]$$$ by binary searching the point $$$X$$$ where for all $$$x \leq X$$$, $$$f_1(x) \leq f_2(x)$$$ and for all $$$X \leq x,f_1(x) \geq f_2(x)$$$. Since querying this data structure takes $$$O(\log n)$$$, it takes $$$O(\log ^2)$$$ time to combine two such data structures. If we use a segment tree, we only need to rebuild $$$O(\log^3)$$$ different data structures (the rest can be handled using lazy tags), giving us a time complexity of $$$O(\log^3)$$$.
Code (errorgorn, C++)
//もう布団の中から出たくない
//布団の外は寒すぎるから
//布団の中から出たくない
//布団の中はあたたかすぎるから

#include <bits/stdc++.h>
using namespace std;

#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt")

#define int long long
#define ll long long
#define ii pair<ll,ll>
#define iii pair<ii,ll>
#define fi first
#define se second
#define endl '\n'
#define debug(x) cout << #x << ": " << x << endl

#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define lb lower_bound
#define ub upper_bound

#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

mt19937 rng(chrono::system_clock::now().time_since_epoch().count());

const ll INF=1e18;

struct line{
	ll m,c;
	
	line (ll _m,ll _c){
		m=_m,c=_c;
	}
	
	ll get(ll x){
		return m*x+c;
	}
};

struct node{
	int s,e,m;
	int vs=0,ve=0,vm=0;
	line val={0,-INF};
	int lazy=0;
	node *l,*r;
	
	node(int _s,int _e){
		s=_s,e=_e,m=s+e>>1;
		
		if (s!=e){
			l=new node(s,m);
			r=new node(m+1,e);
		}
	}
	
	void propo(){
		if (lazy==0) return;
		
		val.c-=val.m*lazy;
		vs+=lazy;
		ve+=lazy;
		vm+=lazy;
		
		if (s!=e){
			l->lazy+=lazy;
			r->lazy+=lazy;
		}
		lazy=0;
	}
	
	void update(int i){
		if (s==i) lazy++;
		else{
			if (val.c!=-INF){
				l->propo(),r->propo();
				l->update(val),r->update(val);
				val={0,-INF};
			}
			
			if (m<i) r->update(i);
			else l->update(i),r->update(m+1);
			
			l->propo(),r->propo();
			vs=l->vs,vm=l->ve,ve=r->ve;
		}
	}
	
	void update(line i){
		bool lo=i.get(vs)>val.get(vs);
		bool mi=i.get(vm)>val.get(vm);
		bool hi=i.get(ve)>val.get(ve);
		
		if (mi) swap(i,val);
		
		if (s==e || i.c==-INF || lo==hi) return;
		
		l->propo(),r->propo();
		if (lo!=mi) l->update(i);
		else r->update(i);
	}
	
	ii query(ll i){
		propo();
		
        if (s==e) return {val.get(vs),vs};
		else if (i<=m){
			auto temp=l->query(i);
			return {max(temp.fi,val.get(temp.se)),temp.se};
		}
		else{
			auto temp=r->query(i);
			return {max(temp.fi,val.get(temp.se)),temp.se};
		}
	}
} *root;

const int maxn = 1e6;
const int maxm = 1e6;

int n,m;
ii arr[maxn+1];
ii brr[maxm+1];

int ans[maxm+1];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin.exceptions(ios::badbit | ios::failbit);
	
	int TC;
	cin>>TC;
	while (TC--){
		cin>>n>>m;
		rep(x,1,n+1) cin>>arr[x].fi>>arr[x].se;
		rep(x,1,m+1){
            cin>>brr[x].se;
            brr[x].fi = x;
        }
    
		sort(arr+1,arr+n+1);
		
		root=new node(0,m+1);
		root->update({0,0});
		
		int curr=1;
		rep(x,0,m+2){
			while (curr<=n && arr[curr].fi==x) root->update(arr[curr++].se+1);
			auto temp=root->query(x);
			root->update({brr[x].se,temp.fi-brr[x].se*temp.se});
		}
		
		cout<<root->query(m+1).fi<<endl;
	}
}
Code (valeriu, C++)
#include <bits/stdc++.h>
#define all(x) (x).begin(),(x).end()
using namespace std;

using ll = long long;
using ld = long double;

//#define int ll
#define sz(x) ((int)(x).size())

using pii = pair<ll,ll>;
using tii = tuple<int,int,int>;

const int nmax = 5e5 + 5, qmax = 2e6 + 5;
const ll inf = 1e18 + 5; 

struct line {
  ll m = 0, b = -inf;
  ll operator()(const ll& x) const {
     return m * x + b;
  }
  bool operator ==(const line& x) const { return m == x.m && b == x.b; }
};

int M;

namespace AINT {
  struct Node {
    int vl = 0, vmid = 0, vr = 0;
    line val = line{0, -inf};
    Node() {;}
    void operator += (const int &x) { vl += x, vmid += x, vr += x; val.b -= val.m * x; }
  } aint[qmax * 4];
  int lazy[qmax * 4];
  
  void push(int node) {
    lazy[2 * node] += lazy[node];
    aint[2 * node] += lazy[node];
    lazy[2 * node + 1] += lazy[node];
    aint[2 * node + 1] += lazy[node];
    lazy[node] = 0;
  }
  void pushline(line x, int node = 1, int cl = 0, int cr = M) {
    bool l = x(aint[node].vl) > aint[node].val(aint[node].vl), m = x(aint[node].vmid) > aint[node].val(aint[node].vmid), r = x(aint[node].vr) > aint[node].val(aint[node].vr);
    if(m) swap(x, aint[node].val);
    if(cl == cr || x == line() || l == r) return;
    
    int mid = cl + cr >> 1;
    push(node);
    if(m != l) pushline(x, 2 * node, cl, mid);
    else pushline(x, 2 * node + 1, mid + 1, cr);
    return;
  }
  void add(int l, int node = 1, int cl = 0, int cr = M) {
    if(cl >= l) {
      lazy[node]++;
      aint[node] += 1;
      return;
    }
    if(cr < l) return;
    int mid = cl + cr >> 1;
    
    push(node);
    
    pushline(aint[node].val, 2 * node, cl, mid);
    pushline(aint[node].val, 2 * node + 1, mid + 1, cr);
    aint[node].val = line{0, -inf};
    
    add(l, 2 * node, cl, mid);
    add(l, 2 * node + 1, mid + 1, cr);
    aint[node].vl = aint[2 * node].vl;
    aint[node].vmid = aint[2 * node].vr;
    aint[node].vr = aint[2 * node + 1].vr;
  }
  pii query(ll p, int node = 1, int cl = 0, int cr = M) {
    if(cl == cr) return pii{aint[node].val(aint[node].vl), aint[node].vl};
    int mid = cl + cr >> 1;
    push(node);
    auto [mxv, atrv] = p <= mid? query(p, 2 * node, cl, mid) : query(p, 2 * node + 1, mid + 1, cr);
    return pii{max(mxv, aint[node].val(atrv)), atrv};
  } 
  
  void init(int node = 1, int cl = 0, int cr = M) {
    aint[node] = Node();
    lazy[node] = 0;
    if(cl == cr) return;
    int mid = cl + cr >> 1;
    init(2 * node, cl, mid);
    init(2 * node + 1, mid + 1, cr);
    return;
  }
};

vector<int> atraddp[qmax];
ll val[qmax];

void testcase() {
  int n, m;
  cin >> n >> m;
  M = m + 2;
  for(int i = 0, l, r; i < n; i++) {
    cin >> l >> r;
    atraddp[l].emplace_back(r + 1);
  }
  for(int i = 1; i <= m; i++)
    cin >> val[i];
  
  AINT::init();
  AINT::pushline({0, 0});
  
  for(int i = 0; i < m + 2; i++) {
    for(auto x : atraddp[i])
      AINT::add(x);
    auto [a, b] = AINT::query(i);
    //cerr << a << ' ' << b << '\n';
    AINT::pushline({val[i], a - val[i] * b});
  }
  
  for(int i = 0; i < m + 2; i++)
    atraddp[i].clear();
  
  cout << AINT::query(m + 1).first << '\n';
}

signed main() {
  cin.tie(0) -> sync_with_stdio(0);
  int t;
  cin >> t;
  while(t--) testcase();
  
}

/**
      Anul asta se da centroid.
-- Surse oficiale
*/
Rate problem
Good problem
Ok problem
Bad problem
Didn't solve it, idk
--------------------------------------------------
Problem ID: 1830E
Editorial Content:
1830E — Bully Sort
Solution
First of all, we notice that if some element moves left, it will never move right.
Proof
Proving this is not hard, imagine $$$S$$$ to be the set of suffix minimas. Then if an element is in $$$S$$$ we know that $$$p_x \le x$$$.
Since after every bully swap an element cannot disappear from $$$S$$$ and after each bully swap, the $$$2$$$ swapped elements can only get closer to their desired position, we conclude the proof.
Obviously, if an element moves right, it will never move left since it will continue to move right until it reaches its final position.
By the $$$2$$$ claims above, we conclude that left and right movers are distinct.
Now suppose we swap indicies $$$i$$$ and $$$j$$$ and note that such swap kills $$$2 \cdot (j-i) - 1$$$ inversions and the left mover $$$j$$$ moves $$$j-i$$$ steps.
Now the magic is that if we let $$$s$$$ be the sum over $$$2 \cdot (i-p_i)$$$ for all left movers we have $$$s - ans = inversions$$$, thus our answer is just $$$s-inversions$$$.
Now to handle the data structure part, we just need to be able to calculate inversions while being able to perform point updates. There are many ways to do this, for example for using a fenwick tree and a bitwise trie/ordered_set in $$$O(nlog^2n)$$$.
Proof
Proving this is not hard, imagine $$$S$$$ to be the set of suffix minimas. Then if an element is in $$$S$$$ we know that $$$p_x \le x$$$.
Since after every bully swap an element cannot disappear from $$$S$$$ and after each bully swap, the $$$2$$$ swapped elements can only get closer to their desired position, we conclude the proof.
Code (tibinyte, fenwick tree + ordered_set C++)
#include <bits/stdc++.h>

#include <ext/pb_ds/assoc_container.hpp>

#include <ext/pb_ds/tree_policy.hpp>

using namespace std;

using namespace __gnu_pbds;

#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>

typedef long long ll;

/*               .___                 __                 __           .__
  ____  ____   __| _/____     _______/  |______ ________/  |_  ______ |  |__   ___________   ____
_/ ___\/  _ \ / __ |/ __ \   /  ___/\   __\__  \\_  __ \   __\/  ___/ |  |  \_/ __ \_  __ \_/ __ \
\  \__(  <_> ) /_/ \  ___/   \___ \  |  |  / __ \|  | \/|  |  \___ \  |   Y  \  ___/|  | \/\  ___/
 \___  >____/\____ |\___  > /____  > |__| (____  /__|   |__| /____  > |___|  /\___  >__|    \___  >
     \/           \/    \/       \/            \/                 \/       \/     \/            \/
*/

struct bit
{
  int n;
  vector<ordered_set> lesgo;
  void resize(int _n)
  {
    n = _n;
    lesgo = vector<ordered_set>(n + 1);
  }
  void update(int pos, int val, int sign)
  {
    for (int i = pos; i <= n; i += i & (-i))
    {
      if (sign == -1)
      {
        lesgo[i].erase(val);
      }
      if (sign == 1)
      {
        lesgo[i].insert(val);
      }
    }
  }
  int query_smaller(int pos, int val)
  {
    int ans = 0;
    for (int i = pos; i; i -= i & (-i))
    {
      ans += lesgo[i].order_of_key(val);
    }
    return ans;
  }
  int query_greater(int pos, int val)
  {

    int ans = 0;
    for (int i = pos; i; i -= i & (-i))
    {
      int sz = lesgo[i].size();
      ans += sz - lesgo[i].order_of_key(val + 1);
    }
    return ans;
  }
  int query_smaller(int st, int dr, int val)
  {
    return query_smaller(dr, val) - query_smaller(st - 1, val);
  }
  int query_greater(int st, int dr, int val)
  {
    return query_greater(dr, val) - query_greater(st - 1, val);
  }
};

int32_t main()
{
  cin.tie(nullptr)->sync_with_stdio(false);
  int n, q;
  cin >> n >> q;
  vector<int> a(n + 1);
  for (int i = 1; i <= n; ++i)
  {
    cin >> a[i];
  }
  bit lesgo;
  lesgo.resize(n);
  for (int i = 1; i <= n; ++i)
  {
    lesgo.update(i, a[i], 1);
  }

  ll inv = 0;

  for (int i = 1; i <= n; ++i)
  {
    inv += lesgo.query_greater(1, i, a[i]);
  }

  ll sum = 0;

  for (int i = 1; i <= n; ++i)
  {
    sum += max(a[i] - i, 0);
  }

  while (q--)
  {
    int x, y;
    cin >> x >> y;
    if (x != y)
    {
      lesgo.update(x, a[x], -1);
      lesgo.update(y, a[y], -1);
      sum -= max(a[x] - x, 0);
      sum -= max(a[y] - y, 0);
      if (x + 1 <= y - 1)
      {
        int lesgo1 = lesgo.query_smaller(x + 1, y - 1, a[x]);
        int lesgo2 = lesgo.query_greater(x + 1, y - 1, a[y]);
        inv += 2 * (y - x - 1 - lesgo1 - lesgo2);
      }

      if (a[x] > a[y])
      {
        inv--;
      }
      else
      {
        inv++;
      }

      swap(a[x], a[y]);
      sum += max(a[x] - x, 0);
      sum += max(a[y] - y, 0);
      lesgo.update(x, a[x], 1);
      lesgo.update(y, a[y], 1);
    }
    cout << sum + sum - inv << '\n';
  }
}
Code (tibinyte, sqrt decomposition, C++)
#include <bits/stdc++.h>

using namespace std;

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

int random(int st, int dr)
{
  uniform_int_distribution<int> dist(st, dr);
  return dist(rng);
}

typedef long long ll;

/*               .___                 __                 __           .__
  ____  ____   __| _/____     _______/  |______ ________/  |_  ______ |  |__   ___________   ____
_/ ___\/  _ \ / __ |/ __ \   /  ___/\   __\__  \\_  __ \   __\/  ___/ |  |  \_/ __ \_  __ \_/ __ \
\  \__(  <_> ) /_/ \  ___/   \___ \  |  |  / __ \|  | \/|  |  \___ \  |   Y  \  ___/|  | \/\  ___/
 \___  >____/\____ |\___  > /____  > |__| (____  /__|   |__| /____  > |___|  /\___  >__|    \___  >
     \/           \/    \/       \/            \/                 \/       \/     \/            \/
*/

struct decomp
{
  vector<int> a;
  vector<pair<int, int>> buckets;
  vector<int> sp;
  vector<int> spbucket;
  vector<int> wh;
  const int sz = 400;
  void resize(int n)
  {
    a = vector<int>(n + 1);
    sp = vector<int>(n + 1);
    wh = vector<int>(n + 1);
    for (int i = 1; i <= n; i += sz)
    {
      int st = i;
      int dr = min(n, st + sz - 1);
      for (int j = st; j <= dr; ++j)
      {
        wh[j] = (int)buckets.size();
      }
      buckets.push_back({st, dr});
      spbucket.push_back(0);
    }
  }
  void update(int pos, int x)
  {
    a[pos] += x;
    int qui = wh[pos];
    sp[buckets[qui].first] = a[buckets[qui].first];
    for (int i = buckets[qui].first + 1; i <= buckets[qui].second; ++i)
    {
      sp[i] = sp[i - 1] + a[i];
    }
    spbucket[0] = sp[buckets[0].second];
    for (int i = 1; i < (int)buckets.size(); ++i)
    {
      spbucket[i] = spbucket[i - 1] + sp[buckets[i].second];
    }
  }
  int query(int pos)
  {
    int qui = wh[pos];
    int ans = sp[pos];
    if (qui)
    {
      ans += spbucket[qui - 1];
    }
    return ans;
  }
};

struct geralt
{
  vector<int> a;
  vector<decomp> lesgo;
  vector<pair<int, int>> buckets;
  vector<int> wh;
  const int sz = 3000;
  void resize(int n)
  {
    a = vector<int>(n + 1);
    wh = vector<int>(n + 1);
    for (int i = 1; i <= n; i += sz)
    {
      int st = i;
      int dr = min(n, st + sz - 1);
      for (int j = st; j <= dr; ++j)
      {
        wh[j] = (int)buckets.size();
      }
      buckets.push_back({st, dr});
      lesgo.push_back({});
      lesgo.back().resize(n);
    }
  }
  void update(int pos, int val)
  {
    int qui = wh[pos];
    if (a[pos] != 0)
    {
      lesgo[qui].update(a[pos], -1);
    }
    a[pos] = val;
    lesgo[qui].update(a[pos], 1);
  }
  int query_brute(int st, int dr, int val)
  {
    int ans = 0;
    for (int i = st; i <= dr; ++i)
    {
      if (a[i] <= val)
      {
        ans++;
      }
    }
    return ans;
  }
  int query_smaller(int st, int dr, int val) // number of values <= val in st...dr
  {
    if (wh[st] == wh[dr])
    {
      return query_brute(st, dr, val);
    }
    int qui1 = wh[st], qui2 = wh[dr];
    int ans = query_brute(st, buckets[qui1].second, val) + query_brute(buckets[qui2].first, dr, val);
    qui1++;
    qui2--;
    for (int i = qui1; i <= qui2; ++i)
    {
      ans += lesgo[i].query(val);
    }
    return ans;
  }
  int query_greater(int st, int dr, int val) // number of values > val in st...dr
  {
    return (dr - st + 1) - query_smaller(st, dr, val);
  }
};

int32_t main()
{
  cin.tie(nullptr)->sync_with_stdio(false);
  int n, q;
  cin >> n >> q;
  vector<int> a(n + 1);
  for (int i = 1; i <= n; ++i)
  {
    cin >> a[i];
  }

  geralt lesgo;
  lesgo.resize(n);

  ll inv = 0;

  for (int i = 1; i <= n; ++i)
  {
    lesgo.update(i, a[i]);
    inv += lesgo.query_greater(1, i, a[i]);
  }

  ll sum = 0;

  for (int i = 1; i <= n; ++i)
  {
    sum += max(a[i] - i, 0);
  }

  while (q--)
  {
    int x, y;
    cin >> x >> y;
    if (x != y)
    {
      sum -= max(a[x] - x, 0);
      sum -= max(a[y] - y, 0);
      if (x + 1 <= y - 1)
      {
        int lesgo1 = lesgo.query_smaller(x + 1, y - 1, a[x]);
        int lesgo2 = lesgo.query_greater(x + 1, y - 1, a[y]);
        inv += 2 * (y - x - 1 - lesgo1 - lesgo2);
      }

      if (a[x] > a[y])
      {
        inv--;
      }
      else
      {
        inv++;
      }

      swap(a[x], a[y]);
      sum += max(a[x] - x, 0);
      sum += max(a[y] - y, 0);
      lesgo.update(x, a[x]);
      lesgo.update(y, a[y]);
    }
    cout << sum + sum - inv << '\n';
  }
}
Code (errorgorn, divide and conquer, C++)
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define ii pair<int,int>
#define i4 tuple<int,int,int,int>
#define fi first
#define se second
#define endl '\n'
#define debug(x) cout << #x << ": " << x << endl

#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define lb lower_bound
#define ub upper_bound

#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

mt19937 rng(chrono::system_clock::now().time_since_epoch().count());

struct FEN{ //we want to count the reverse
	int arr[500005];
	
	void update(int i,int k){
		i=500005-i;
		
		while (i<500005){
			arr[i]+=k;
			i+=i&-i;
		}
	}
	
	int query(int i){
		i=500005-i;
		
		int res=0;
		while (i){
			res+=arr[i];
			i-=i&-i;
		}
		return res;
	}
} fen;

int n,q;
int arr[500005];
long long ans[50005];

void dnc(int l,int r,vector<i4> upd,vector<i4> que){
	vector<i4> updl,updr;
	vector<i4> quel,quer;
	
	int m=l+r>>1;
	
	for (auto [a,b,c,d]:upd){
		if (c<=m) updl.pub({a,b,c,d});
		else updr.pub({a,b,c,d});
	}
	
	for (auto [a,b,c,d]:que){
		if (c<=m) quel.pub({a,b,c,d});
		else quer.pub({a,b,c,d});
	}
	
	int i=0;
	for (auto it:quer){
		while (i<sz(updl) && get<0>(updl[i])<get<0>(it)){
			fen.update(get<1>(updl[i]),get<3>(updl[i]));
			i++;
		}
		
		ans[get<2>(it)]+=fen.query(get<1>(it))*get<3>(it);
	}
	while (i){
		i--;
		fen.update(get<1>(updl[i]),-get<3>(updl[i]));
	}
	
	if (l!=m) dnc(l,m,updl,quel);
	if (m+1!=r) dnc(m+1,r,updr,quer);
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin.exceptions(ios::badbit | ios::failbit);
	
	cin>>n>>q;
	rep(x,1,n+1) cin>>arr[x];
	
	vector<i4> upd,que;
	
	rep(x,1,n+1) upd.pub({x,arr[x],-1,1});
	rep(x,1,n+1) que.pub({x,arr[x],0,-1});
	rep(x,1,n+1) ans[0]+=abs(x-arr[x]);
	
	rep(x,1,q+1){
		int a,b;
		cin>>a>>b;
		
		if (a==b) continue;
		if (arr[a]<arr[b]) ans[x]--;
		else ans[x]++;
		
		upd.pub({a,arr[a],x-1,-1});
		upd.pub({b,arr[b],x-1,-1});
		ans[x]-=abs(a-arr[a])+abs(b-arr[b]);
		
		swap(arr[a],arr[b]);
		
		upd.pub({a,arr[a],x,1});
		upd.pub({b,arr[b],x,1});
		ans[x]+=abs(a-arr[a])+abs(b-arr[b]);
		
		que.pub({b,arr[b],x,-2});
		que.pub({b,arr[a],x,2});
		que.pub({a,arr[b],x,2});
		que.pub({a,arr[a],x,-2});
		
	}
	
	sort(all(upd)),sort(all(que));
	
	dnc(-1,q,upd,que);
	
	rep(x,1,q+1) ans[x]+=ans[x-1];
	rep(x,1,q+1) cout<<ans[x]<<" "; cout<<endl;
}
Rate problem
Good problem
Ok problem
Bad problem
Didn't solve it, idk
--------------------------------------------------
Problem ID: 1830D
Editorial Content:
1830D — Mex Tree
Hints
Hint 1
Why is bipartite coloring not always optimal?
Hint 2
How good is a bipartite coloring actually?
Hint 1
Why is bipartite coloring not always optimal?
Hint 2
How good is a bipartite coloring actually?
Solution
Disclaimer: I (
tibinyte2006
) wanted to cut $$$O(n \sqrt{n})$$$ memory because I thought that setting 1024 MB memory limit would spoil the solution. So only blame me for this.
We will do a complementary problem which is finding the minimum loss of a coloring. The initial cost is the maximum possible cost, $$$n \cdot (n+1)$$$.
If we analyze how good a bipartite coloring of the given tree is we can note that $$$loss \le 2 \cdot n$$$
Now suppose the tree has a connected component of size $$$k$$$. We can note that in such a coloring $$$loss \ge \frac{k \cdot (k+1)}{2}$$$
By the $$$2$$$ claims above, we can note that in an optimal coloring, the maximum size $$$k$$$ of a connected component respects $$$\frac{k \cdot (k+1)}{2} \le 2 \cdot n$$$. Thus we can safely say $$$k \le \sqrt{4 \cdot n}$$$.
Now let $$$dp_{i,j,color}$$$ be the minimum loss if we color the subtree of $$$i$$$ and the connected component of vertex $$$i$$$ has size $$$j$$$. We can calculate this in a knapsack style by adding subtrees successively. The computation takes $$$O(n \cdot \sqrt{n})$$$ if we use the $$$7$$$-th trick from
this
blog.
Now we are only left to optimize memory, since now it's $$$O(n \cdot \sqrt{n})$$$. We can directly apply
this
to get linear memory.
However, the bound of $$$k \le \sqrt{4 \cdot n}$$$ is overestimated, for $$$n=200000$$$ it can be proven that the worst case for $$$k$$$ is $$$258$$$.
Proof Sketch
Assume have a connected component of size $$$k$$$ we want it to be colored $$$0$$$ across all optimal colorings. Then we can attach to each node some subtrees such that after flipping its whole subtree the total cost doesn't increase. We will assume all subtrees are leaves for simplicity. Doing such, we can get some inequalities about the number of leaves we need to attatch to each node.
In a star tree, the number of leaves we should attatch to nodes has the smallest sum.
Proof Sketch
Assume have a connected component of size $$$k$$$ we want it to be colored $$$0$$$ across all optimal colorings. Then we can attach to each node some subtrees such that after flipping its whole subtree the total cost doesn't increase. We will assume all subtrees are leaves for simplicity. Doing such, we can get some inequalities about the number of leaves we need to attatch to each node.
In a star tree, the number of leaves we should attatch to nodes has the smallest sum.
Code (tibinyte, C++)
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int lim = 893;
const int inf = 1e16;

struct dp_state
{
    vector<int> a;
    vector<int> b;
    void init()
    {
        a.resize(lim + 1, inf);
        b.resize(lim + 1, inf);
        a[1] = 1;
        b[1] = 2;
    }
};

int32_t main()
{
    cin.tie(nullptr)->sync_with_stdio(false);
    int q;
    cin >> q;
    while (q--)
    {
        int n;
        cin >> n;
        vector<vector<int>> g(n + 1);
        vector<int> sz(n + 1);

        for (int i = 1; i < n; ++i)
        {
            int x, y;
            cin >> x >> y;
            g[x].push_back(y);
            g[y].push_back(x);
        }

        function<int(int, int)> shuffle_kids = [&](int node, int parent)
        {
            int sz = 1;
            pair<int, int> best;
            for (int i = 0; i < (int)g[node].size(); ++i)
            {
                if (g[node][i] != parent)
                {
                    int sz2 = shuffle_kids(g[node][i], node);

                    best = max(best, {sz2, i});

                    sz += sz2;
                }
            }
            if (!g[node].empty())
            {
                swap(g[node][0], g[node][best.second]);
            }
            return sz;
        };
        shuffle_kids(1, 0);

        vector<vector<int>> merged(2 * lim + 1, vector<int>(2, inf));

        function<dp_state(int, int)> dfs = [&](int node, int parent)
        {
            dp_state dp;
            sz[node] = 1;
            bool hasinit = false;
            for (auto i : g[node])
            {
                if (i != parent)
                {
                    dp_state qui = dfs(i, node);
                    if (!hasinit)
                    {
                        dp.init();
                        hasinit = true;
                    }
                    for (int j = 0; j <= min(sz[node], lim) + min(sz[i], lim); ++j)
                    {
                        merged[j][0] = merged[j][1] = inf;
                    }
                    for (int k = 1; k <= min(sz[node], lim); ++k)
                    {
                        for (int l = 1; l <= min(sz[i], lim); ++l)
                        {
                            merged[k][0] = min(merged[k][0], dp.a[k] + qui.b[l]);
                            merged[k][1] = min(merged[k][1], dp.b[k] + qui.a[l]);
                            merged[k + l][0] = min(merged[k + l][0], dp.a[k] + qui.a[l] + k * l);
                            merged[k + l][1] = min(merged[k + l][1], dp.b[k] + qui.b[l] + k * l * 2);
                        }
                    }
                    sz[node] += sz[i];
                    for (int k = 1; k <= min(sz[node], lim); ++k)
                    {
                        dp.a[k] = merged[k][0];
                        dp.b[k] = merged[k][1];
                    }
                }
            }
            if (!hasinit)
            {
                dp.init();
                hasinit = true;
            }
            return dp;
        };
        dp_state dp = dfs(1, 0);
        int ans = inf;
        for (int i = 1; i <= lim; ++i)
        {
            ans = min(ans, dp.a[i]);
            ans = min(ans, dp.b[i]);
        }
        cout << n * (n + 1) - ans << '\n';
    }
}
Rate problem
Good problem
Ok problem
Bad problem
Didn't solve it, idk
--------------------------------------------------
Problem ID: 1830C
Editorial Content:
1830C — Hyperregular Bracket Strings
Hints
Hint 1
While not necessarily a hint, this problem cannot be solved without knowing that there are $$$C_n=\frac{1}{n+1}\binom{2n}{n}$$$ Regular Bracket Strings of length $$$2 \cdot n$$$.
Hint 2
What's the answer if $$$q=1$$$?
Hint 3
What's the answer if $$$q=2$$$ and the two intervals partially overlap?
Hint 4
Based on the previous hint, we can get rid of all partially overlapping intervals. The remaining intervals will have a tree-like structure.
Hint 5
Finding the tree is actually unnecessary and also very difficult.
Hint 6
The brackets on the positions covered by the same
subset
of intervals must form an RBS.
Hint 7
Hashing. Xor hashing specifically.
Hint 1
While not necessarily a hint, this problem cannot be solved without knowing that there are $$$C_n=\frac{1}{n+1}\binom{2n}{n}$$$ Regular Bracket Strings of length $$$2 \cdot n$$$.
Hint 2
What's the answer if $$$q=1$$$?
Hint 3
What's the answer if $$$q=2$$$ and the two intervals partially overlap?
Hint 4
Based on the previous hint, we can get rid of all partially overlapping intervals. The remaining intervals will have a tree-like structure.
Hint 5
Finding the tree is actually unnecessary and also very difficult.
Hint 6
The brackets on the positions covered by the same
subset
of intervals must form an RBS.
Hint 7
Hashing. Xor hashing specifically.
Solution
First and foremost, the number of regular bracket strings of length $$$2 \cdot n$$$ is equal to $$$C_n=\frac{1}{n+1}\binom{2n}{n}$$$.
Secondly, for a bracket string $$$\overline{s_1s_2 \ldots s_k}$$$, let:
$$$f(s_i) = \begin{cases} 1, & \text{if }s_i=\text{'('} \\ -1, & \text{if }s_i=\text{')'} \end{cases}$$$
$$$\Delta_i=\sum_{j=1}^i f(s_j)$$$
A bracket string $$$\overline{s_1s_2 \ldots s_k}$$$ is a regular bracket string if both of the following statements are true:
$$$\Delta_k=0$$$
$$$\Delta_i \ge 0, i=\overline{1,k}$$$
From now on we'll call a set of indices $$$i_1 < i_2 < \ldots < i_k$$$ a
group
if $$$\overline{s_{i_1}s_{i_2}\ldots s_{i_k}}$$$ must be an RBS.
There are two main cases to consider, both of which can be proven with the aforementioned conditions for a string to be an RBS:
Case 1: Included intervals
Let's consider two intervals $$$[l_1,r_1]$$$ and $$$[l_2,r_2]$$$ such that $$$l_1 \le l_2 \le r_2 \le r_1$$$.
The two groups formed by these intervals are:
$$$[l_2,r_2]$$$
$$$[l_1,l_2-1] \cup [r_2+1,r_1]$$$
Case 2: Partially overlapping intervals
Let's consider two intervals $$$[l_1,r_1]$$$ and $$$[l_2,r_2]$$$ such that $$$l_1 \lt l_2 \le r_1 \lt r_2$$$.
The three groups formed by these two intervals are:
$$$[l_1,l_2-1]$$$
$$$[l_2,r_1]$$$
$$$[r_1+1,r_2]$$$
By taking both of these cases into account, we can conclude that all indices $$$i_k$$$ covered by the same
subset
of intervals are part of the same group.
Finding the subset of intervals which cover a certain index $$$i$$$ can be implemented using difference arrays and xor hashing.
How does xor hashing on difference arrays work?
Each interval $$$[l_i,r_i]$$$ will be assigned a random 64-bit value $$$v_i$$$.
The value of a subset of intervals $$$i_1,i_2,\ldots,i_k$$$ is equal to $$$v_{i_1} \wedge v_{i_2} \wedge \ldots \wedge v_{i_k}$$$.
For each interval $$$[l_i,r_i]$$$, $$$\text{diff}[l_i] \wedge = v_i$$$, $$$\text{diff}[r_i+1] \wedge = v_i$$$.
The value of the subset of intervals which cover position $$$i$$$ is equal to $$$\text{diff}[1] \wedge \text{diff}[2] \wedge \ldots \wedge \text{diff}[i]$$$.
Time complexity: $$$O(maxn \cdot log(mod))$$$ for precomputing every $$$C_n$$$, and $$$O(k\cdot log(k))$$$ per test case.
Case 1: Included intervals
Let's consider two intervals $$$[l_1,r_1]$$$ and $$$[l_2,r_2]$$$ such that $$$l_1 \le l_2 \le r_2 \le r_1$$$.
The two groups formed by these intervals are:
$$$[l_2,r_2]$$$
$$$[l_1,l_2-1] \cup [r_2+1,r_1]$$$
Case 2: Partially overlapping intervals
Let's consider two intervals $$$[l_1,r_1]$$$ and $$$[l_2,r_2]$$$ such that $$$l_1 \lt l_2 \le r_1 \lt r_2$$$.
The three groups formed by these two intervals are:
$$$[l_1,l_2-1]$$$
$$$[l_2,r_1]$$$
$$$[r_1+1,r_2]$$$
How does xor hashing on difference arrays work?
Each interval $$$[l_i,r_i]$$$ will be assigned a random 64-bit value $$$v_i$$$.
The value of a subset of intervals $$$i_1,i_2,\ldots,i_k$$$ is equal to $$$v_{i_1} \wedge v_{i_2} \wedge \ldots \wedge v_{i_k}$$$.
For each interval $$$[l_i,r_i]$$$, $$$\text{diff}[l_i] \wedge = v_i$$$, $$$\text{diff}[r_i+1] \wedge = v_i$$$.
The value of the subset of intervals which cover position $$$i$$$ is equal to $$$\text{diff}[1] \wedge \text{diff}[2] \wedge \ldots \wedge \text{diff}[i]$$$.
Code (Gheal, C++)
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
const int NMAX=3e5+5, MOD=998244353;

mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());
uniform_int_distribution<ll> rnd(0,LLONG_MAX);

ll fact[NMAX], invfact[NMAX], C[NMAX];

ll binPow(ll x, ll y){
    ll ans=1;
    for(;y ;y>>=1, x = x*x%MOD)
        if(y&1)
            ans = ans*x%MOD;
    return ans;
}
map<ll,ll> diff,freq;
void add_interval(ll l, ll r){
    ll Hash = rnd(gen);
    diff[l] ^= Hash, diff[r+1] ^= Hash;
}
void tc(){
    ll n,k;
    cin>>n>>k;
    diff.clear(), freq.clear();
    add_interval(1,n); /// the initial string must be an RBS

    for(ll i=0;i<k;i++){
        ll l,r;
        cin>>l>>r;
        add_interval(l,r);
    }
    ll Hash = diff[1];

    for(map<ll,ll> :: iterator it=next(diff.begin()); it!=diff.end(); it++){
        freq[Hash] += it->first - prev(it)->first;
        Hash ^= it->second;
    }

    ll ans=1;

    for(const auto& it : freq)
        ans=ans*C[it.second]%MOD;

    cout<<ans<<'\n';
}

int main()
{
    fact[0] = invfact[0] = 1;
    for(ll i=1; i<NMAX; i++){
        fact[i] = fact[i-1] * i % MOD;
        invfact[i] = binPow(fact[i], MOD - 2);
    }

    for(ll i=0; i*2<NMAX; i++) C[i*2] = fact[i*2] * invfact[i] % MOD * invfact[i+1] % MOD;

    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    ll t;
    cin>>t;
    while(t--)
        tc();
    return 0;
}
Rate problem
Good problem
Ok problem
Bad problem
Didn't solve it, idk
--------------------------------------------------
Problem ID: 1830B
Editorial Content:
1830B — The BOSS Can Count Pairs
Hints
Hint 1
Since $$$b_i \le n$$$ and $$$b_j \le n$$$, $$$b_i+b_j = a_i \cdot a_j \le 2 \cdot n$$$.
Hint 2
Since $$$a_i \cdot a_j \le 2 \cdot n$$$, then $$$\min(a_i,a_j) \le \sqrt{2 \cdot n}$$$.
Hint 1
Since $$$b_i \le n$$$ and $$$b_j \le n$$$, $$$b_i+b_j = a_i \cdot a_j \le 2 \cdot n$$$.
Hint 2
Since $$$a_i \cdot a_j \le 2 \cdot n$$$, then $$$\min(a_i,a_j) \le \sqrt{2 \cdot n}$$$.
Solution
Since $$$b_i \le n$$$ and $$$b_j \le n$$$, $$$b_i+b_j = a_i \cdot a_j \le 2 \cdot n$$$. Therefore, $$$\min(a_i,a_j) \le \sqrt{2 \cdot n}$$$.
Let $$$lim=\sqrt{2 \cdot n}$$$ and $$$fr[a_i][b_i]$$$ be the number of pairs $$$(a_i,b_i)$$$ from the input such that $$$a_i \le lim$$$.
A pair $$$(i,j)$$$ is
good
if it satisfies $$$a_i \cdot a_j=b_i+b_j$$$.
Firstly, we'll count the number of good pairs $$$(i,j)$$$ such that $$$a_i=a_j$$$. Since $$$min(a_i,a_j) \le lim$$$, we can see that $$$a_i=a_j \le lim$$$.
This sum can be written as:
$$$\frac{\sum_{i=1}^{n}fr[a_i][a_i \cdot a_i - b_i]-\sum_{i=1}^{lim}fr[i][\frac{i \cdot i}{2}]}{2}$$$
The remaining good pairs will have $$$a_i \neq a_j$$$, and instead of counting the pairs which have $$$i \lt j$$$, we can count the pairs which have $$$a_i \gt a_j$$$.
Since $$$a_j=min(a_i,a_j)$$$, we can say that $$$a_j \le lim$$$.
Substituting $$$a_j$$$ for $$$j$$$, this second sum can be written as:
$$$\sum_{i=1}^n \sum_{j=1}^{min(a_i-1,\frac{2\cdot n}{a_i})}fr[j][a_i \cdot j-b_i]$$$
Since we've already established that $$$j \le lim = \sqrt{2 \cdot n}$$$, calculating this sum takes $$$O(n\sqrt{n})$$$ time.
Be especially careful when calculating these sums, as $$$a_i \cdot a_i - b_i$$$ and $$$a_i \cdot j-b_i$$$ can end up being either negative or greater than $$$n$$$.
Time complexity per testcase: $$$O(n \sqrt n)$$$
Code (Gheal, C++)
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
const ll NMAX=2e5+5,SQRMAX=635,MOD=1e9+7;

int fr[SQRMAX][NMAX];
ll a[NMAX],b[NMAX];
void tc(){
    ll n,ans=0;
    cin>>n;
    ll lim=sqrt(n*2);
    for(ll i=0;i<n;i++){
        cin>>a[i];
    }
    for(ll i=0;i<n;i++){
        cin>>b[i];
        if(a[i]<=lim)
            fr[a[i]][b[i]]++;
    }
    for(ll i=0;i<n;i++){
        if(a[i]<=lim){
            if(a[i]*a[i]-b[i]>=1 && a[i]*a[i]-b[i]<=n)
                ans+=fr[a[i]][a[i]*a[i]-b[i]];
        }
    }
    for(ll i=2;i<=lim;i+=2)
        ans-=fr[i][i*i/2];
    ans/=2;

    for(ll i=0;i<n;i++){
        for(ll j=1;j<=lim && j<a[i] && j*a[i]<=2*n;j++){
            if(j*a[i]-b[i]>=1 && j*a[i]-b[i]<=n)
                ans+=fr[j][j*a[i]-b[i]];
        }
    }
    for(ll i=0;i<n;i++){
        if(a[i]<=lim)
            fr[a[i]][b[i]]=0;
    }
    cout<<ans<<'\n';
}
int main()
{
    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    ll t;
    cin>>t;
    while(t--)
        tc();
    return 0;
}
Code (Vladithur, Python)
for _ in range(int(input())):
    n = int(input())
    
    ta = list(map(int, input().split()))
    tb = list(map(int, input().split()))
    
    a = [(x, y) for x, y in zip(ta, tb)]
    a.sort()
    
    cnt = [0] * (2 * n + 1)
    pr = 0
    ans = 0
    
    for i in range(n):
        if pr != a[i][0]:
            pr = a[i][0]
            
            if pr * pr > 2 * n:
                break
                
            cnt = [0] * (2 * n + 1)
            for j in range(i + 1, n):
                t = a[i][0] * a[j][0] - a[j][1]
                if t >= 0 and t <= 2 * n:
                    cnt[t] += 1
        
        ans += cnt[a[i][1]]
        
        if i + 1 < n:
            t = a[i][0] * a[i + 1][0] - a[i + 1][1]
            if t >= 0 and t <= 2 * n:
                cnt[t] -= 1
    
    print(ans)
Rate problem
Good problem
Ok problem
Bad problem
Didn't solve it, idk
--------------------------------------------------
Problem ID: 1830A
Editorial Content:
1830A — Copil Copac Draws Trees
Hints
Hint 1
What is the answer if $$$n=3$$$?
Hint 2
The previous case can be generalised to find the answer for any tree.
Hint 1
What is the answer if $$$n=3$$$?
Hint 2
The previous case can be generalised to find the answer for any tree.
Solution
This problem can be solved via dynamic programming. From here on out, step $$$1$$$ from the statement will be called a "scan".
Let $$$dp[i]$$$ be the number of scans needed to activate node $$$i$$$, and $$$id[i]$$$ be the index (in the order from the input) of the edge which activated node $$$i$$$.
Intially, since only $$$1$$$ is active, $$$dp[1]=1$$$ and $$$id[1]=0$$$.
We will perform a dfs traversal starting from node $$$1$$$. When we process an edge $$$(u,v)$$$, one of the following two cases can happen:
If $$$index((u,v)) \ge id[u]$$$, we can visit $$$v$$$ in the same scan as $$$u$$$:
$$$dp[v]=dp[u]$$$, $$$id[v]=index((u,v))$$$
If $$$index((u,v)) \lt id[u]$$$, $$$v$$$ will be visited in the next scan after $$$dp[u]$$$:
$$$dp[v]=dp[u]+1$$$, $$$id[v]=index((u,v))$$$
The answer is $$$max_{i=1}^n(dp[i])$$$.
Time complexity per test case: $$$O(n)$$$
Code (Gheal, C++)
#include<bits/stdc++.h>

using namespace std;
const int NMAX = 2e5+5;
int dp[NMAX], id[NMAX];
vector<pair<int,int>> edg[NMAX];
void dfs(int u){
    for(auto it : edg[u]){
        if(dp[it.first] == 0){
            dp[it.first] = dp[u] + (it.second <= id[u]);
            id[it.first] = it.second;
            dfs(it.first);
        }
    }
}
void tc(){
    int n;
    cin>>n;
    for(int i=1; i<=n; i++) dp[i] = id[i] = 0, edg[i].clear();
    for(int i=1; i<n; i++){
        int u,v;
        cin>>u>>v;
        edg[u].push_back({v,i});
        edg[v].push_back({u,i});
    }
    dp[1] = 1;
    dfs(1);
    int ans = 0;
    for(int i=1; i<=n; i++) ans=max(ans,dp[i]);
    cout<<ans<<'\n';
}
int main()
{
    ios_base::sync_with_stdio(false);
    int t;
    cin>>t;
    while(t--)
        tc();
    return 0;
}
Code (alecs, C++)
#include <bits/stdc++.h>

const int NMAX = 3e5 + 5, INF = 1e9;

int n, f[NMAX], d[NMAX];
std :: vector < std :: pair < int, int > > G[NMAX];

void DFS(int node, int t) {
    f[node] = true;

    for (int i = 0; i < G[node].size(); ++ i) {
        int u = G[node][i].first, c = G[node][i].second;

        if (f[u] == false) {
            d[u] = (c < t) + d[node];
            DFS(u, c);
        }
    }

    return;
}

int main() {
    std :: ios_base :: sync_with_stdio(false);
    std :: cin.tie(nullptr);
    
    int tc;
    
    std :: cin >> tc;
    
    while (tc --) {
        std :: cin >> n;
    
        for (int i = 1, u, v; i < n; ++ i) {
            std :: cin >> u >> v;
    
            G[u].push_back({v, i});
            G[v].push_back({u, i});
        }
        
        for (int i = 1; i <= n; ++ i)
            f[i] = false;
    
        d[1] = 0;
        DFS(1, n);
    
        int Max = 0;
    
        for (int i = 1; i <= n; ++ i)
            Max = std :: max(Max, d[i]);
    
        std :: cout << Max << "\n";
        
        for (int i = 1; i <= n; ++ i)
            G[i].clear();
    }

    return 0;
}
Rate problem
Good problem
Ok problem
Bad problem
Didn't solve it, idk
--------------------------------------------------
Problem ID: 1829H
Editorial Content:
1829H - Don't Blame Me
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;

#define ll long long
 
#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()

const int mod = 1e9 + 7;
void solve() {
    int n, x; cin >> n >> x;
    vector<int> a(n + 1);
    vector<vector<int>> dp(n + 1, vector<int>(1 << 6, 0));
    for(int i = 1; i <= n; ++i) {
        cin >> a[i];
        for(int mask = 0; mask < (1 << 6); ++mask) {
            dp[i][mask] += dp[i - 1][mask];
            if(dp[i][mask] >= mod) dp[i][mask] -= mod;
            dp[i][mask & a[i]] += dp[i - 1][mask];
            if(dp[i][mask & a[i]] >= mod) dp[i][mask & a[i]] -= mod;
        }
        dp[i][a[i]] = (dp[i][a[i]] + 1) % mod;
    }
    int ans = 0;
    for(int mask = 0; mask < (1 << 6); ++mask) {
        if(__builtin_popcount(mask) == x) {
            ans = (ans + dp[n][mask]) % mod;
        }
    }
    cout << ans << "\n";
}   
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1829G
Editorial Content:
1829G - Hits Different
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

long long ans[2000007];
long long a[1500][1500] = {}, curr = 1;

void solve() {
	int n;
	cin >> n;
	cout << ans[n] << '\n';
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	for (int i = 1; i < 1500; i++) {
		for (int j = i - 1; j >= 1; j--) {
			a[j][i - j] = a[j - 1][i - j] + a[j][i - j - 1] - a[j - 1][i - j - 1] + curr * curr;
			ans[curr] = a[j][i - j];
			curr++;
		}
	}
	
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1829F
Editorial Content:
1829F - Forever Winter
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

const int MAX = 200007;
const int MOD = 1000000007;

void solve() {
	int n, m;
	cin >> n >> m;
	int cnt[n + 1];
	for (int i = 1; i <= n; i++) {
		cnt[i] = 0;
	}
	for (int i = 0; i < m; i++) {
		int u, v;
		cin >> u >> v;
		cnt[u]++;
		cnt[v]++;
	}
	map<int, int> cnts;
	for (int i = 1; i <= n; i++) {
		cnts[cnt[i]]++;
	}
	vector<int> v;
	for (auto p : cnts) {
		v.push_back(p.second);
	}
	sort(v.begin(), v.end());
	if (v.size() == 3) {
		cout << v[1] << ' ' << v[2] / v[1] << '\n';
	}
	else {
		cout << v[0] - 1 << ' ' << v[1] / (v[0] - 1) << '\n';
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1829E
Editorial Content:
1829E - The Lakes
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
#define startt ios_base::sync_with_stdio(false);cin.tie(0);
typedef long long  ll;
using namespace std;
#define vint vector<int>
#define all(v) v.begin(), v.end()
#define MOD 1000000007
#define MOD2 998244353
#define MX 1000000000
#define MXL 1000000000000000000
#define PI (ld)2*acos(0.0)
#define pb push_back
#define sc second
#define fr first
#define endl '\n'
#define ld long double
#define NO cout << "NO" << endl
#define YES cout << "YES" << endl

int n, m;
bool vis[1005][1005];
int a[1005][1005];

int dfs(int i, int j)
{
    vis[i][j] = true;
    int ans = a[i][j];
    if(i != 0 && a[i-1][j] != 0 && !vis[i-1][j])
    {
        ans+=dfs(i-1, j);
    }
    if(i != n-1 && a[i+1][j] != 0 && !vis[i+1][j])
    {
        ans+=dfs(i+1, j);
    }
    if(j != 0 && a[i][j-1] != 0 && !vis[i][j-1])
    {
        ans+=dfs(i, j-1);
    }
    if(j != m-1 && a[i][j+1] != 0 && !vis[i][j+1])
    {
        ans+=dfs(i, j+1);
    }
    return ans;
}

void solve()
{
    cin >> n >> m;
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < m; j++)
        {
            vis[i][j] = false;
            cin >> a[i][j];
        }
    }
    int ans = 0;
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < m; j++)
        {
            if(!vis[i][j] && a[i][j] != 0)
            {
                ans = max(ans, dfs(i, j));
            }
        }
    }
    cout << ans << endl;
}

int32_t main(){
    startt
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1829D
Editorial Content:
1829D - Gold Rush
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

bool ok(int n, int m) {
	if (n == m) {return true;}
	else if (n % 3 != 0) {return false;}
	else {return (ok(n / 3, m) || ok(2 * n / 3, m));}
}

void solve() {
	int n, m;
	cin >> n >> m;
	cout << (ok(n, m) ? "YES" : "NO") << '\n';
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1829C
Editorial Content:
1829C - Mr. Perfectly Fine
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;

#define ll long long

#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()

#define            pb                push_back
#define          sz(a)               (int)a.size()

void solve() {
    int n; cin >> n;
    map<string, int> mp;
    mp["00"] = mp["01"] = mp["10"] = mp["11"] = 1e9;
    int ans = 1e9;
    for(int i = 0; i < n; ++i) {
        int x; cin >> x; string s; cin >> s;
        mp[s] = min(mp[s], x);
    }
    if(min(mp["11"], mp["10"] + mp["01"]) > (int)1e6) {
        cout << "-1\n";
    } else {
        cout << min(mp["11"], mp["10"] + mp["01"]) << "\n";
    }
}

int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1829B
Editorial Content:
1829B - Blank Space
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;

void solve()
{
    int n;
    cin >> n;
    int a[n];
    int cnt = 0, ans = 0;
    for(int i = 0; i < n; i++)
    {
        cin >> a[i];
        if(a[i] == 0)
        {
            cnt++;
        }
        else
        {
            ans = max(ans, cnt);
            cnt = 0;
        }
    }
    cout << max(ans, cnt) << endl;
}

int32_t main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1829A
Editorial Content:
1829A - Love Story
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

void solve()
{
    string s, c = "codeforces";
    cin >> s;
    int ans = 0;
    for(int i = 0; i < 10; i++)
    {
        if(s[i] != c[i])
        {
            ans++;
        }
    }
    cout << ans << endl;
}

int32_t main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1828B
Editorial Content:
1828B - Permutation Swap
Hint 1
In order to move $$$p_i$$$ to its right position, what does the value of $$$k$$$ have to satisfy?
Solution
In order to move $$$p_i$$$ to position $$$i$$$, it is easy to see that $$$|p_i - i|$$$ has to be divisible by $$$k$$$.
So, $$$|p_1 - 1|, |p_2 - 2|, \ldots, |p_n - n|$$$ has to be all divisible by $$$k$$$. The largest possible value of $$$k$$$ turns out to be the
greatest common divisor
of integers $$$|p_1 - 1|, |p_2 - 2|, \ldots, |p_n - n|$$$.
Time complexity: $$$\mathcal{O}(n + \log{n})$$$
Implementation
#include <bits/stdc++.h>
 
using namespace std;
 
signed main() {
    
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
 
    int t;
    cin >> t;
    while (t--) {
    	int n, res = 0;
    	cin >> n;
    	for (int i = 1; i <= n; i++) {
    		int x; cin >> x;
    		res = __gcd(res, abs(x - i));
    	}
    	cout << res << "\n";
    }
    
}
--------------------------------------------------
Problem ID: 1828A
Editorial Content:
1828A - Divisible Array
Hint 1
Remember the sum of the first $$$n$$$ positive integers?
Hint 2
Every positive integer is divisible by $$$1$$$.
Solution
Consider the array $$$a = \left[1, 2, \ldots, n\right]$$$ that satisfies the second condition. It has the sum of $$$1 + 2 + \dots + n = \frac{n(n+1)}{2}$$$.
One solution is to notice that if we double every element $$$(a=\left[2, 4, 6, \ldots, 2n\right])$$$, the sum becomes $$$\frac{n(n+1)}{2} \times 2 = n(n + 1)$$$, which is divisible by $$$n$$$.
Another solution is to increase the value of $$$a_1$$$ until the sum becomes divisible by $$$n$$$. This works because every integer is divisible by $$$1$$$, and we only need to increase $$$a_1$$$ by at most $$$n$$$.
Time complexity: $$$\mathcal{O}(n)$$$
Implementation 1
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
 
    int t;
    cin >> t;
    while (t--) {
    	int n;
    	cin >> n;
    	for (int i = 1; i <= n; i++) cout << i * 2 << " ";
    	cout << "\n";
    }
}
Implementation 2
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define fi first
#define se second
const int N=2e6+1;
const ll mod=998244353;
ll n,m;
ll a[N],b[N];
void solve(){
	cin >> n;
	ll s=0;
	for(int i=n; i>=2 ;i--){
		a[i]=i;
		s=(s+i)%n;
	}
	a[1]=n-s;
	for(int i=1; i<=n ;i++) cout << a[i] << ' ';
	cout << '\n';
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);
	int t;cin >> t;
	while(t--){
		solve();
	}
}
--------------------------------------------------
Problem ID: 1827F
Editorial Content:
1827F - Copium Permutation
Solution
Solve the problem for fixed $$$k$$$
Call the last $$$n-k$$$ elements as special numbers.
Observation
: In optimal rearrangement, every maximal segment of special numbers will be placed on consecutive positions in either ascending order or descending order. For simplicity, from now on we will call maximal segment of special number as maximal segment.
For example, take a permutation $$$p=[7, 5, 8, 1, 4, 2, 6, 3]$$$ and $$$k=2$$$, the maximal segments are $$$[1, 4]$$$, $$$[6, 6]$$$ and $$$[8, 8]$$$.
We divide the set of copium subarrays into three parts, one for those lie entirely on prefix $$$p[1..k]$$$, one for those lie entirely on suffix $$$p[k+1..n]$$$, and one for the rest. The number of subarrays in the first part can be calculated with the algorithm used in
526F - Pudding Monsters
. The number of subarrays in the second part can be easily deduced from above observation.
Define an array $$$good=[good_1,good_2,\ldots,good_m]$$$ such that for each $$$i$$$: $$$good_i<good_{i+1}$$$ and subarray $$$p[good_i..k]$$$ contains consecutive nonspecial numbers.
For example, take a permutation $$$p=[1, 5, 4,3,7,8,9,2,10,6]$$$ and $$$k=5$$$, then $$$good=[1, 4, 5]$$$.
We will process $$$good$$$ array from right to left while adding special numbers from left to right. Let us consider $$$good_i$$$, first add all special numbers which are missing from subarray $$$[good_i, k]$$$ at the end of current permutation. If $$$[good_i, k]$$$ is not already copium, we increase our answer by one. Denote $$$mn_i$$$ and $$$mx_i$$$ as the minimum and maximum number in subarray $$$[good_i, k]$$$. Loot at two maximal segments, one contains $$$mn_i-1$$$ and one contains $$$mx_i+1$$$. We can place them here to increase the answer.
For example, let $$$n=10$$$, $$$k=5$$$, $$$good_i=3$$$ and the current permutation $$$p=[1, 10, 4, 5, 7, 6]$$$. The two maximal segments are $$$[2, 3]$$$ and $$$[8, 9]$$$. We can place them like $$$[1, 10, 4, 5, 7, 6, 8, 9, 3, 2]$$$ to increase the answer by 4. Furthermore, we can see that three good positions $$$3$$$, $$$4$$$ and $$$5$$$ benefit from maximal segment $$$[8, 9]$$$. In general, consider consecutive good positions $$$good_i, good_{i+1},\ldots, good_j$$$ satisfying $$$mx_i=mx_{i+1}=\ldots=mx_j$$$, all of them can benefit from the same maximal segment if for all $$$i\le x< j$$$, subarray $$$[good_x..good_{x+1}-1]$$$ is copium $$$(*)$$$.
There is a similar condition when we consider consecutive good positions having the same $$$mn$$$. So the algorithm goes like this: For each value of $$$mn$$$ and $$$mx$$$, find the longest segment of good positions satisfying condition $$$(*)$$$, then multiply with the length of corresponding maximal segment and add to the answer.
Solve for each $$$k$$$
We will calculate the answer for each $$$k$$$ from $$$0$$$ to $$$n$$$ in this order. We will store the longest segment for each prefix of $$$mn$$$-equivalent and $$$mx$$$-equivalent positions. Note that when going from $$$k-1$$$ to $$$k$$$, only a suffix of $$$good$$$ will no longer be good, so we can manually delete them one by one from right to left, then add $$$k$$$. There will be at most $$$2$$$ good positions we need to consider. The first one, of course, is $$$k$$$. If $$$p_{k-1}<p_k$$$ or $$$p_{k-1}>p_k$$$, let $$$j$$$ be the last position satisfying $$$p_j>p_k$$$ or $$$p_j<p_k$$$, the second one is the first good position after $$$j$$$ and it satisfies a property: It must be the last position in the $$$mn$$$-equivalent or $$$mx$$$-equivalent positions. The proof is left as an exercise. Therefore, updating this position will not affect the positions behind it. The overall complexity is $$$\mathcal{O}(n\log n)$$$.
--------------------------------------------------
Problem ID: 1827E
Editorial Content:
1827E - Bus Routes
Hint 1
You do not need to consider all pairs of nodes, only some of them will do.
Hint 2
Find an equivalent condition of the statement.
Hint 2.1
Let $$$S(u)$$$ be the set of all nodes reachable by u using at most one route. Consider all $$$S(l)$$$ where $$$l$$$ is a leaf in the tree.
Hint 2.1
Let $$$S(u)$$$ be the set of all nodes reachable by u using at most one route. Consider all $$$S(l)$$$ where $$$l$$$ is a leaf in the tree.
Solution
First, notice that for a pair of nodes $$$(u, v)$$$ such that $$$u$$$ is not a leaf, we can find a leaf $$$l$$$ such that path $$$(l, v)$$$ fully covers path $$$(u, v)$$$. Therefore, we only need to care about whether all pairs of leaves can reach each other using at most $$$2$$$ routes.
Lemma
The condition above is equivalent to: There exists a node $$$c$$$ such that $$$c$$$ can reach all leaves by using at most one route.
Proof
The necessity part is trivial, so let's prove the sufficiency part.
Let the leaves of the tree be $$$l_1, l_2, \ldots, l_m$$$.
Let $$$S(u)$$$ be the induced subgraph of all nodes reachable by $$$u$$$ using at most one route. If $$$u$$$ and $$$v$$$ is reachable within two routes, then the intersection of $$$S(v)$$$ and $$$S(u)$$$ is non-empty. We need to prove that the intersection of all $$$S(l_i)$$$ is non-empty.
If $$$l_i$$$, $$$l_j$$$, and $$$l_k$$$ are pairwise reachable within two paths, then the intersection of $$$S(l_i)$$$, $$$S(l_j)$$$, and $$$S(l_k)$$$ must be pairwise non-empty. Since the graph is a tree, it follows trivially that intersection of $$$S(l_i)$$$, $$$S(l_j)$$$, and $$$S(l_k)$$$ must be non-empty. We can generalize this to all leaves, thus proving the sufficiency part.
To check if an answer exists or not, we can use this
trick from ko_osaga
to find how many $$$S(l_i)$$$ covers each node in $$$\mathcal O(n)$$$. The answer is YES when there is a node $$$c$$$ that is covered by all $$$S(l_i)$$$.
To find the two candidates when the answer is NO, notice that one of them is the first leaf $$$l_x$$$ such that there is no node $$$c$$$ that is covered by $$$S(l_1), \ldots, S(l_x)$$$. We can find $$$l_x$$$ with binary search. To find the other one, root the tree at $$$l_x$$$ and define $$$lift_u$$$ as the lowest node reachable by $$$u$$$ using at most one route. The other candidate is a node $$$l_y$$$ such that $$$lift_{l_y}$$$ is not in $$$S(l_x)$$$.
Time complexity: $$$\mathcal O(n \log n)$$$.
Tester's solution: Root the tree at some non-leaf vertex. Define $$$lift_u$$$ as the lowest node (minimum depth) reachable by $$$u$$$ using at most one route. Take the node $$$v$$$ with the deepest (maximum depth) $$$lift_v$$$. Then the answer for this problem is $$$\texttt{YES}$$$ iff for every leaf $$$l$$$, either $$$l$$$ lie in $$$lift_v$$$ 's subtree or $$$l$$$ has a path to $$$lift_v$$$.
Implementation 1
#include <bits/stdc++.h>

using namespace std;

const int N = 5e5 + 5;
const int LOG = 19;

/// lca stuff
int tin[N], timer = 0;
vector<int> path, rmq[LOG];

/// some tree stuff
vector<int> adj[N], leaf, topo;
int n, m, par[N], val[N];

/// trips
vector<int> trip[N];

void dfs_pre(int u) {
  topo.push_back(u);
  tin[u] = timer++;
  for (int v : adj[u])
     if (v != par[u]) {
      path.push_back(u);
      rmq[0].push_back(tin[u]);
      par[v] = u; dfs_pre(v);
     }
}

int get_min(int l, int r) {
  int k = 31 - __builtin_clz(r - l);
  return min(rmq[k][l], rmq[k][r - (1 << k)]);
}

int lca(int u, int v) {
  if (u == v) return u;
  tie(u, v) = minmax(tin[u], tin[v]);
  return path[get_min(u, v)];
}

int lca_reroot(int r, int u, int v) {
  return lca(r, u) ^ lca(r, v) ^ lca(u, v);
}

void calc_val() {
  for (int u : topo)
    for (int v : adj[u])
      if (v != par[u]) val[u] += val[v];
}

void add(int u) {
  for (int v : trip[u])
    if (v < 0) val[-v]--;
    else val[v]++;
}

bool check(int l) {
  for (int u = 1; u <= n; u++) val[u] = 0;
  for (int i = 0; i < l; i++) add(leaf[i]);
  calc_val();
  for (int u = 1; u <= n; u++)
    if (val[u] == l) return true;
  return false;
}

void solve() {
  cin >> n >> m;
    
  /// reset 
  for (int i = 1; i <= n; i++) {
    adj[i].clear(); trip[i].clear();
  }
  timer = 0; leaf.clear(); topo.clear();
  path.clear(); rmq[0].clear();

  for (int i = 1; i < n; i++) {
    int u, v; cin >> u >> v;
    adj[u].push_back(v);
    adj[v].push_back(u);
  }
  /// leaves only
  for (int i = 1; i <= m; i++) {
    int u, v; cin >> u >> v;
    if (adj[u].size() == 1)
      trip[u].push_back(v);
    if (adj[v].size() == 1)
      trip[v].push_back(u);
  }
  
  if (n == 1) {
    cout << "YES\n"; return;
  }
  
  /// prepare
  dfs_pre(1);
  reverse(topo.begin(), topo.end());
  for (int k = 1; (1 << k) <= n; k++) {
    rmq[k].resize(n - (1 << k) + 1);
    for (int i = 0; i + (1 << k) <= n; i++)
      rmq[k][i] = min(rmq[k - 1][i],
      rmq[k - 1][i + (1 << (k - 1))]);
  }
  
  for (int u = 1; u <= n; u++)
    if (adj[u].size() == 1) {
      leaf.push_back(u);
      trip[u].push_back(u);
      sort(trip[u].begin(), trip[u].end(),
      [&](int x, int y) {
        return tin[x] < tin[y];});
      int l = trip[u].size();
      for (int i = 0; i + 1 < l; i++)
        trip[u].push_back(-lca
        (trip[u][i], trip[u][i + 1]));
      trip[u].push_back(-par[lca
      (trip[u][0], trip[u][l - 1])]);
    }
  
  /// find longest prefix of leaves 
  int l = 0;
  for (int k = LOG - 1; k >= 0; k--)
    if (l + (1 << k) <= leaf.size()
    && check(l + (1 << k))) l += 1 << k;

  if (l == leaf.size()) {
    cout << "YES\n"; return;
  }
  
  cout << "NO\n";

  for (int u = 1; u <= n; u++) val[u] = 0;
  add(leaf[l]); calc_val();
  
  for (int u : leaf) {
    bool good = false;
    for (int v : trip[u]) {
      if (v <= 0) break;
      if (val[lca_reroot(leaf[l], u, v)]) {
        good = true; break;
      }
    }
    if (!good) {
      cout << leaf[l] << ' ' << u << '\n';
      return;
    }
  }
}

int main() {
  cin.tie(0)->sync_with_stdio(0);
  
  int t; cin >> t;
  
  while (t--) solve();
}
Implementation 2
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
const ll INF = 1e18;
const int maxn = 2e6 + 10;
const int mod = 1e9 + 7;
const int mo = 998244353;
using pi = pair < ll, ll > ;
using vi = vector < ll > ;
using pii = pair < pair < ll, ll > , ll > ;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
vector < int > G[maxn];
int n, m;
int h[maxn];
int eu[maxn];
pair < int, int > rmq[maxn][21];
int l = 0;
int st[maxn];
int out[maxn];
int low[maxn];
pair < int, int > ed[maxn];
int par[maxn];
int ok[maxn];
int d[maxn];
void dfs(int u, int pa) {
  eu[++l] = u;
  st[u] = l;
  for (auto v: G[u]) {
    if (v == pa) continue;
    par[v] = u;
    h[v] = h[u] + 1;
    dfs(v, u);
    eu[++l] = u;
  }
  out[u] = l;
}
void init() {
  for (int j = 1; (1 << j) <= l; j++) {
    for (int i = 1; i <= l; i++) {
      rmq[i][j] = min(rmq[i][j - 1], rmq[i + (1 << (j - 1))][j - 1]);
    }
  }
}
int LCA(int u, int v) {
  if (st[u] > st[v]) {
    swap(u, v);
  }
  int k = log2(st[v] - st[u] + 1);
  return min(rmq[st[u]][k], rmq[st[v] - (1 << k) + 1][k]).second;
}
bool check(int u, int pa, int c) {
  if (st[pa] <= st[c] && st[c] <= out[pa]) {
    if (st[c] <= st[u] && st[u] <= out[c]) {
      return true;
    }
    return false;
  }
  return false;
}
void solve() {
  cin >> n >> m;
  l = 0;
  for (int i = 1; i <= n; i++) {
    G[i].clear();
  }
  for (int i = 1; i < n; i++) {
    int x, y;
    cin >> x >> y;
    G[x].push_back(y);
    G[y].push_back(x);
  }
  dfs(1, -1);
  for (int i = 1; i <= l; i++) {
    rmq[i][0] = {st[eu[i]], eu[i]};
  }
  init();
  for (int i = 1; i <= n; i++) {
    low[i] = i;
    ok[i] = 0;
  }
  for (int i = 1; i <= m; i++) {
    int x, y;
    cin >> x >> y;
    ed[i] = {x, y};
    int u = LCA(x, y);
    if (h[low[x]] > h[u]) {
      low[x] = u;
    }
    if (h[low[y]] > h[u]) {
      low[y] = u;
    }
  }
  int need = 0;
  for (int i = 2; i <= n; i++) {
    if (low[i] != 1 && G[i].size() == 1) {
      if (need == 0 || h[low[need]] < h[low[i]]) {
        need = i;
      }
    }
  }
  if (need == 0) {
    cout << "YES\n";
    return;
  }
  for (int i = 1; i <= m; i++) {
    int u = LCA(ed[i].first, ed[i].second);
    if (G[ed[i].first].size() == 1 && check(ed[i].second, u, low[need])) {
      ok[ed[i].first] = 1;
    }
    if (G[ed[i].second].size() == 1 && check(ed[i].first, u, low[need])) {
      ok[ed[i].second] = 1;
    }
  }
  for (int i = 1; i <= n; i++) {
    if (G[i].size() == 1) {
      if (st[low[need]] <= st[i] && st[i] <= out[low[need]]) {
        continue;
      }
      if (ok[i] == 0) {
        cout << "NO\n";
        cout << need << " " << i << "\n";
        return;
      }
    }
  }
  cout << "YES\n";
  return;
}
signed main() {
  cin.tie(0), cout.tie(0) -> sync_with_stdio(0);
  int t;
  cin >> t;
  while (t--) solve();
  return 0;
}
sorry gamegame
--------------------------------------------------
Problem ID: 1827D
Editorial Content:
1827D - Two Centroids
Hint1
Is the answer related to the centroid of the current tree?
Hint2
How much the centroid will move after one query?
Solution
Observation
: The answer for the tree with $$$n$$$ vertices equals $$$n-2\cdot mx$$$ where $$$mx$$$ is the largest subtree among the centroid's children.
Lemma
: After one query, the centroid will move at most one edge, and when the centroid move, the tree before the query already has two centroids.
Proof
:
Suppose the tree before the query has $$$n$$$ vertices and the current centroid is $$$u$$$. Let $$$v_1, v_2,\ldots,v_k$$$ are the children of $$$u$$$ and the next query vertex $$$x$$$ is in subtree $$$v_1$$$. Clearly, the centroid is either $$$u$$$ or in the subtree $$$v_1$$$. Consider the latter case, because the size of subtree $$$v_1$$$ does not greater than $$$\lfloor \frac{n}{2}\rfloor$$$, the size of newly formed subtree including $$$u$$$ is greater or equal to $$$\lceil \frac{n}{2}\rceil$$$. Moving one or more edges away from $$$v_1$$$ will increase the size of this new subtree by one or more, and the vertex can not become centroid because $$$\lceil \frac{n}{2}\rceil+1>\lfloor \frac{n+1}{2}\rfloor$$$.
The second part is easy to deduce from the above proof.
We will solve this problem offline. First, we compute the Euler tour of the final tree and use "range add query" data structures like Binary indexed tree (BIT) or Segment tree to maintain each subtree's size. We will maintain the size of the largest subtree among the centroid's children $$$mx$$$. In the case where the centroid does not move, we just update $$$mx$$$ with the size of the subtree including the newly added vertex, otherwise, we set $$$mx$$$ to $$$\lfloor \frac{n}{2}\rfloor$$$ due to the lemma. The time complexity is $$$\mathcal{O}(n \log{n})$$$.
Implementation
#include <bits/stdc++.h>

using namespace std;

const int N = 500005;
const int LOG = 19;

vector<int> adj[N];
int tin[N], tout[N], timer;
int par[LOG][N], bit[N], dep[N];

void dfs(int u) {
  tin[u] = ++timer;
  dep[u] = dep[par[0][u]] + 1;
  for (int k = 1; k < LOG; k++)
    par[k][u] = par[k - 1][par[k - 1][u]];
  for (int v : adj[u]) dfs(v);
  tout[u] = timer;  
}

void add(int u) {
  for (int i = tin[u]; i < N; i += i & -i)
    bit[i]++;
}

int get(int u) {
  int res = 0;
  for (int i = tout[u]; i > 0; i -= i & -i)
    res += bit[i];
  for (int i = tin[u] - 1; i > 0; i -= i & -i)
    res -= bit[i];
  return res;
}

int jump(int u, int d) {
  for (int k = 0; k < LOG; k++)
    if (d >> k & 1) u = par[k][u];
  return u;
}

bool cover(int u, int v) {
  return tin[u] <= tin[v] && tin[v] <= tout[u];
}

void solve() {
  int n; cin >> n;
  
  /// reset
  timer = 0;
  for (int i = 1; i <= n; i++) {
    bit[i] = 0; adj[i].clear();
  }
  
  for (int i = 2; i <= n; i++) {
    cin >> par[0][i];
    adj[par[0][i]].push_back(i);
  }
  dfs(1); add(1);
  int cen = 1, max_siz = 0;
  for (int u = 2; u <= n; u++) {
    add(u);
    if (cover(cen, u)) {
      int v = jump(u, dep[u] - dep[cen] - 1);
      int siz = get(v);
      if (siz >= (u + 1) / 2) {
        cen = v; max_siz = u / 2;
      } else max_siz = max(max_siz, siz);
    } else {
      int siz = get(cen);
      if (siz < (u + 1) / 2) {
        cen = par[0][cen]; max_siz = u / 2;
      } else max_siz = max(max_siz, u - siz);
    }
    cout << u - 2 * max_siz << " \n"[u == n];
  }
}

int main() {
  cin.tie(0)->sync_with_stdio(0);
  int t; cin >> t;
  while (t--) solve();
}
flowerletter :pensive:
--------------------------------------------------
Problem ID: 1827C
Editorial Content:
1827C - Palindrome Partition
Hint1
Try to construct beautiful string greedily.
Hint2
What happens when we have two even palindromes share one of their endpoints?
Solution
For the simplicity of the solution, we will abbreviate even palindrome as evp.
Lemma
: Consider a beautiful string $$$t$$$, we can find the
unique maximal
partition for it by greedily choosing the smallest possible evp in each step from the left. Here maximal means maximum number of parts.
Proof
: Suppose $$$t[0..l)$$$ is smallest prefix which is an evp and $$$t[0..r)$$$ is the first part in the partition of $$$t$$$, here $$$t[l..r)$$$ mean substring $$$t_l t_{l+1}\ldots t_{r-1}$$$. We consider two cases:
$$$2l\le r$$$: In this case, it is clear that $$$t[0..l)$$$, $$$t[l..r - l)$$$ and $$$t[r-l..r)$$$ are evps, so we can replace $$$t[0..r)$$$ with them.
$$$2l>r$$$: In this case, due to the fact that $$$t[r-l..l)$$$ and $$$t[0..l)$$$ are evps, $$$t[0..2l-r)$$$ is also an evp, which contradicts to above assumption that $$$t[0..l)$$$ is the smallest.
We can use dynamic programming to solve this problem. Let $$$dp_i$$$ be the number of beautiful substrings starting at $$$i$$$. For all $$$i$$$ from $$$n-1$$$ to $$$0$$$, if there are such $$$next_i$$$ satisfying $$$s[i..next_i)$$$ is the smallest evp beginning at $$$i$$$, then $$$dp_i=dp_{next_i}+1$$$, otherwise $$$dp_i=0$$$. The answer will be the sum of $$$dp_i$$$ from $$$0$$$ to $$$n-1$$$.
To calculate the $$$next$$$ array, first, we use Manacher algorithm or hashing to find the maximum $$$pal_i$$$ satisfying $$$s[i-pal_i..i+pal_i)$$$ is an evp for each $$$i$$$. Then for all $$$0\le i< n$$$, $$$next_i=2j-i$$$ where $$$j$$$ is smallest position such that $$$i<j$$$ and $$$j-pal_j\le i$$$. The time complexity is $$$\mathcal{O}(n \log{n})$$$.
Implementation
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 500005;
const int LOG = 19;
 
int n, pal[N], rmq[LOG][N], cnt[N];
string s;
 
int main() {
  cin.tie(0)->sync_with_stdio(0);
  int t; cin >> t;
  while (t--) {
    cin >> n >> s;
    for (int i = 0, l = 0, r = 0; i < n; i++) {
      pal[i] = i >= r ? 0 : min(pal[l + r - i], r - i);
      while (i + pal[i] < n && i - pal[i] - 1 >= 0
      && s[i + pal[i]] == s[i - pal[i] - 1]) pal[i]++;
      if (i + pal[i] > r) {
        l = i - pal[i]; r = i + pal[i];
      }
    }
    for (int i = 0; i < n; i++)
      rmq[0][i] = i - pal[i];
    for (int k = 1; k < LOG; k++)
      for (int i = 0; i + (1 << k) <= n; i++)
        rmq[k][i] = min(rmq[k - 1][i],
        rmq[k - 1][i + (1 << (k - 1))]);
    for (int i = 1; i <= n; i++)
      cnt[i] = 0;
    for (int i = 0; i < n; i++) {
      int j = i + 1;
      for (int k = LOG - 1; k >= 0; k--)
        if (j + (1 << k) <= n && rmq[k][j] > i)
          j += 1 << k;
      if (2 * j - i <= n)
        cnt[2 * j - i] += cnt[i] + 1;
      
    }
    long long res = 0;
    for (int i = 1; i <= n; i++)
      res += cnt[i];
    cout << res << '\n';
  }
}
Bonus
Solve the problem in $$$\mathcal{O}(n)$$$.
--------------------------------------------------
Problem ID: 1827B2
Editorial Content:
1827B2 - Range Sorting (Hard Version)
Hint 1
What is the minimum cost to sort just one subarray?
Hint 2
What happens when two operations intersect each other?
Hint 3
When can we sort two adjacency ranges independently?
Hint 4
Try to calculate the contribution of each position.
Solution
Let $$$a[l..r]$$$ denotes the subarray $$$a_l,a_{l+1},\ldots,a_r$$$.
Observation 1
: In an optimal sequence of operations for one subarray, there will be no two operations that intersect each other. In other words, a subarray will be divided into non-overlapping subarrays, and we will apply a range-sort operation to each subarray.
Proof
: Suppose there are two operations $$$[l_1,r_1]$$$ and $$$[l_2,r_2]$$$ that intersect each other, we can replace them with one operation $$$[\min(l_1,l_2),\max(r_1,r_2)]$$$ which does not increase the cost.
Observation 2
: Consider $$$k$$$ positions $$$l\le i_1<i_2<\ldots < i_k < r$$$, then we can sort subarrays $$$a[l..i_1],$$$ $$$a[i_1+1..i_2],$$$ $$$\ldots,$$$ $$$a[i_k+1..r]$$$ independently iff $$$\max(a[l..i_x])<\min(a[i_x+1..r])$$$ for all $$$1\le x\le k$$$.
Proof
: The obvious necessary and sufficient condition required to sort subarrays $$$a[l..i_1],$$$ $$$a[i_1+1..i_2],$$$ $$$\ldots,$$$ $$$a[i_k+1..r]$$$ independently is $$$\max(a[i_{x-1}+1..i_x])<\min(a[i_x+1..i_{x+1}])$$$ for all $$$1\le x\le k$$$, here we denote $$$x_0=l-1$$$ and $$$x_{k+1}=r$$$. It is not hard to prove that this condition is equal to the one stated above.
With these observations, we can conclude that the answer for a subarray $$$a[l..r]$$$ equals the $$$r-l$$$ minus the number of positions $$$k$$$ such that $$$l\le k\lt r$$$ and $$$\max(a[l..k])<\min(a[k+1..r])$$$ $$$(*)$$$. Let us analyze how to calculate the sum of this value over all possible $$$l$$$ and $$$r$$$.
Consider a position $$$i$$$ ($$$1\le i\le n$$$), let's count how many triplets $$$(l, k, r)$$$ satisfy $$$(*)$$$ and $$$min(a[k+1..r]) = a_i$$$. It means that $$$k$$$ must be the closest position to the left of $$$i$$$ satisfying $$$a_k<a_i$$$. Denotes $$$x$$$ as the closest position to the left of $$$k$$$ such that $$$a_x>a_i$$$, and $$$y$$$ as the closest position to the right of $$$i$$$ such that $$$a_y<a_i$$$.
We can see that a triplet $$$(l, k, r)$$$ with $$$x<l\le k$$$ and $$$i\le r<y$$$ will match our condition. In other words, we will add to the answer $$$(k - x) \cdot (y - i)$$$.
In the easy version, we can find such values of $$$x, k, y$$$ for each $$$i$$$ in $$$\mathcal{O}(n)$$$ and end up with a total complexity of $$$O(n^2)$$$. We can further optimize the algorithm by using sparse table and binary lifting and achieve a time complexity of $$$\mathcal{O}(n \log{n})$$$, which is enough to solve the hard version.
There is an $$$\mathcal{O}(n)$$$ solution described
here
.
Implementation 1
#include <bits/stdc++.h>

using namespace std;

const int N = 500005;
const int LOG = 19;

int a[N], r[N], rmq[LOG][N];

void solve() {
  int n; cin >> n;
  long long res = 0;
  vector<int> s;
  a[0] = a[n + 1] = 0;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
    rmq[0][i] = a[i];
    res += 1ll * i * (i - 1) / 2;
  }
  s.push_back(n + 1);
  for (int i = n; i > 0; i--) {
    while (a[s.back()] > a[i])
      s.pop_back();
    r[i] = s.back();
    s.push_back(i);
  }
  for (int k = 1; k < LOG; k++)
    for (int i = (1 << k); i <= n; i++)
      rmq[k][i] = max(rmq[k - 1][i], rmq[k - 1][i - (1 << (k - 1))]);
  s.clear();
  s.push_back(0);
  for (int i = 1; i <= n; i++) {
    while (a[s.back()] > a[i])
      s.pop_back();
    int j = s.back();
    for (int k = LOG - 1; k >= 0; k--)
      if (j >= (1 << k) && rmq[k][j] < a[i])
        j -= 1 << k;
    res -= 1ll * (r[i] - i) * (s.back() - j);
    s.push_back(i);
  }
  cout << res << '\n';
}

int main() {
  cin.tie(0)->sync_with_stdio(0);
  int t; cin >> t;
  while (t--) solve();
}
Implementation 2
#include <bits/stdc++.h>
using namespace std;

const int N = 3e5 + 5;

int n;
int a[N];

pair <int, int> b[N];

signed main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
int tests; cin >> tests; while (tests--){
    cin >> n;
    for (int i = 1; i <= n; i++){
        cin >> a[i];
    }

    for (int i = 1; i <= n; i++){
        b[i] = make_pair(a[i], i);
    }
    sort(b + 1, b + n + 1);

    set <int> sttlo = {0, n + 1}, stthi = {0, n + 1};
    for (int i = 1; i <= n; i++){
        stthi.emplace(i);
    }
    long long ans = 0;
    for (int len = 1; len <= n; len++){
        ans += (long long)(len - 1) * (n - len + 1);
    }
    for (int i = 1; i <= n; i++){
        int idx = b[i].se;
        stthi.erase(idx); sttlo.emplace(idx);
 
        int x2 = *stthi.lower_bound(idx);
        int x1 = *prev(stthi.lower_bound(idx));
        if (x2 == n + 1){
            continue;
        }
        int x3 = *sttlo.lower_bound(x2);
        ans -= (long long)(idx - x1) * (x3 - x2);
    }
    cout << ans << endl;
}
}
Bonus
Solve the problem when the beauty of an array is (minimum time needed to sort)$$$^2$$$.
--------------------------------------------------
Problem ID: 1827B1
Editorial Content:

--------------------------------------------------
Problem ID: 1827A
Editorial Content:
1827A - Counting Orders
Hint 1
Sort the array $$$b$$$, and fix the values from $$$a_n$$$ to $$$a_1$$$.
Solution
First, we can sort the array $$$b$$$, as it does not change the answer.
Let's try to choose the values of $$$a$$$ from $$$a_n$$$ to $$$a_1$$$. How many ways are there to choose the value of $$$a_i$$$?
The new $$$a_i$$$ must satisfies $$$a_i > b_i$$$. But some of the candidates are already chosen as $$$a_j$$$ for some $$$j > i$$$. However, since $$$a_j > b_j \ge b_i$$$, we know that there are exactly $$$(n - i)$$$ candidates already chosen previously by all values of $$$j > i$$$. So, there are (number of $$$k$$$ such that $$$a_k > b_i$$$) $$$- (n - i)$$$ ways to choose the value of $$$a_i$$$.
We can use two pointers or binary search to efficiently find the (number of $$$k$$$ such that $$$a_k > b_i$$$) for all $$$i$$$.
Time complexity: $$$\mathcal O(n \log n)$$$.
Implementation
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;

struct testcase{
    testcase(){
        int n; cin >> n;
        vector<int> a(n);
        for (int i=0; i<n; i++) cin >> a[i];
        sort(a.begin(), a.end());
        vector<int> b(n);
        for (int i=0; i<n; i++) cin >> b[i];
        sort(b.begin(), b.end(), greater<>());
        ll result = 1;
        for (int i=0; i<n; i++){
            int geq_count = a.size() - (upper_bound(a.begin(), a.end(), b[i]) - a.begin());
            result = result * max(geq_count - i, 0) % MOD;
        }
        cout << result << "\n";
    }
};

signed main(){
    cin.tie(0)->sync_with_stdio(0);
    int t; cin >> t;
    while (t--) testcase();
}
--------------------------------------------------
Problem ID: 1826F
Editorial Content:
1826F - Fading into Fog
Hint1
What happens in the general case after 2 queries?
Answer
There are $$$O(n^2)$$$ candidates for an answer.
Answer
There are $$$O(n^2)$$$ candidates for an answer.
Hint2
Can we solve the question in 3 queries?
Answer
Yes!
Answer
Yes!
Hint3
How to choose the third query, so that we don't intersect any bad candidates?
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1826E
Editorial Content:
1826E - Walk the Runway
Hint1
What is the relation between two models that go one after another in a show?
Hint2
If you calculate the relation "model $$$i$$$ can go before model $$$j$$$" somehow, how to calculate the answer?
Answer
Use DP on the graph.
Answer
Use DP on the graph.
Hint3
How to calculate this relation fast enough?
Answer
Bitsets
Answer
Bitsets
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1826D
Editorial Content:
1826D - Running Miles
Hint1
What can we say about the position of the maximum elements relative to $$$[l, r]$$$?
Hint2
You can use DP, or otherwise:
Iterate over the middle maximum element and choose $$$[l, r]$$$ greedily.
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1826C
Editorial Content:
1826C - Dreaming of Freedom
Hint1
What is the number of options that is present in the infinite amount of rounds?
Hint2
Choose the smallest such number of options.
Hint3
How does this number and $$$m$$$ relate to the answer?
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1826B
Editorial Content:
1826B - Lunatic Never Content
Hint1
How to solve for $$$n = 2$$$?
Hint2
How to solve for $$$n = 4$$$?
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1826A
Editorial Content:
1826A - Trust Nobody
Hint1
Check each number of liars independently.
Hint2
How to check, whether there are exactly $$$x$$$ liars?
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1825B
Editorial Content:

--------------------------------------------------
Problem ID: 1825A
Editorial Content:

--------------------------------------------------
Problem ID: 1824E
Editorial Content:

--------------------------------------------------
Problem ID: 1824D
Editorial Content:

--------------------------------------------------
Problem ID: 1824C
Editorial Content:

--------------------------------------------------
Problem ID: 1824B2
Editorial Content:

--------------------------------------------------
Problem ID: 1824B1
Editorial Content:

--------------------------------------------------
Problem ID: 1824A
Editorial Content:

--------------------------------------------------
Problem ID: 1823F
Editorial Content:
1823F - Random Walk
Editorial
Tutorial is loading...
Solution C++
#include <bits/stdc++.h>
 
using namespace std;
 
const int mod = 998244353;
 
int main(){
    int n, s, t;
    cin >> n >> s >> t;
    s--, t--;
 
    vector < vector <int> > g(n);
    vector <int> previous(n, -1);
    vector <int> inPath(n);
    vector <long long> res(n);
 
    for (int i = 0; i < n - 1; i++) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].push_back(b);
        g[b].push_back(a);
    }
 
    function <void (int, int)> dfs = [&] (int v, int p) {
        for (int to : g[v]) {
            if (to == p) continue;
            previous[to] = v;
            dfs(to, v);
        }
    };
 
    function <void (int, int, long long)> dfs2 = [&] (int v, int p, long long k) {
        res[v] = k * (long long)g[v].size();
        for (int to : g[v]) {
            if (to == p) continue;
            dfs2(to, v, k);
        }
    };
 
    dfs(s, -1);
 
    int ptr = t;
    inPath[t] = true;
 
    while (ptr != s) {
        res[previous[ptr]] = res[ptr] + 2;
        ptr = previous[ptr];
        inPath[ptr] = true;
    }
 
    for (int v = 0; v < n; v++) {
        if (inPath[v]) {
            res[v] = res[v] / 2 * (long long)g[v].size();
            for (int to : g[v]) {
                if (!inPath[to]) {
                    dfs2(to, v, res[v] / (int)g[v].size());
                }
            }
        }
    }
 
    res[t]++;
 
    for (long long i : res)
        cout << i % mod << ' ';
    cout<<'\n';
 
    return 0;
}
Solution Python
from sys import setrecursionlimit
import threading
 
mod = 998244353
 
def main():
    n, s, t = map(int, input().split())
    s -= 1
    t -= 1
    
    g = [[] for i in range(0, n)]
    previous = [-1 for i in range(0, n)]
    inPath = [False for i in range(0, n)]
    res = [0 for i in range(0, n)]
    
    for i in range(0, n - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        g[a].append(b)
        g[b].append(a)
    
    def dfs(v, p):
        for to in g[v]:
            if to == p:
                continue
            previous[to] = v
            dfs(to, v)
    
    def dfs2(v, p, k):
        res[v] = k * len(g[v])
        for to in g[v]:
            if to == p:
                continue
            dfs2(to, v, k)
    
    dfs(s, -1)
    
    ptr = t
    inPath[t] = True
    
    while ptr != s:
        res[previous[ptr]] = res[ptr] + 2
        ptr = previous[ptr]
        inPath[ptr] = True
    
    for v in range(0, n):
        if inPath[v]:
            res[v] = res[v] // 2 * len(g[v])
            for to in g[v]:
                if not inPath[to]:
                    dfs2(to, v, res[v] // len(g[v]))
    
    res[t] += 1
    
    for i in res:
        print(i % mod, end = ' ')
    print("")
 
setrecursionlimit(10 ** 9)
threading.stack_size(2 ** 27)
thread = threading.Thread(target=main)
thread.start()
--------------------------------------------------
Problem ID: 1823E
Editorial Content:
1823E - Removing Graph
Editorial
Tutorial is loading...
Solution C++
#include <bits/stdc++.h>

using namespace std;

int main() {
    int n, l, r;
    cin >> n >> l >> r;
    vector < vector <int> > g(n);
    for (int i = 0; i < n; i++) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].push_back(b);
        g[b].push_back(a);
    }

    int res=0, size;
    vector <int> used(n);

    function <void(int)> dfs = [&] (int v) {
        used[v] = true;
        size++;
        for (int to : g[v]) {
            if (!used[to])
                dfs(to);
        }
    };

    for (int i = 0; i < n; i++) {
        if (!used[i]) {
            size = 0;
            dfs(i);
            if (size <= l + r - 1) {
                res ^= size / l;
            }
        }
    }

    if (res)
        cout << "Alice\n";
    else
        cout << "Bob\n";

    return 0;
}
Solution Python
from sys import setrecursionlimit
import threading

def main():
    n, l, r = map(int, input().split())

    g = [[] for i in range(0, n)]
    for i in range(0, n):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        g[a].append(b)
        g[b].append(a)

    res = 0
    used = [False for i in range(0, n)]

    def dfs(v):
        used[v] = True
        size = 1
        for to in g[v]:
            if not used[to]:
                size += dfs(to)
        return size

    for i in range(0, n):
        if not used[i]:
            size = dfs(i)
            if size <= l + r - 1:
                res ^= size // l

    if res:
        print("Alice")
    else:
        print("Bob")

setrecursionlimit(10 ** 9)
threading.stack_size(2 ** 27)
thread = threading.Thread(target=main)
thread.start()
--------------------------------------------------
Problem ID: 1823D
Editorial Content:
1823D - Unique Palindromes
Editorial
Tutorial is loading...
Solution C++
#include <bits/stdc++.h>

using namespace std;

int main() {
    int tt;
    cin >> tt;
    while (tt--) {
        int n, k;
        cin >> n >> k;
        vector <int> x(k), c(k);
        for (int i = 0; i < k; i++)
            cin >> x[i];
        for (int i = 0; i < k; i++)
            cin >> c[i];

        if (c[0] < 3 || c[0] > x[0]) {
            cout << "NO\n";
            continue;
        }

        string s;

        char cur = 'a';
        for (int i = 0; i < c[0] - 3; i++)
            s.push_back('a');

        for (int i = c[0] - 3; i < x[0]; i++) {
            s.push_back(cur);
            cur++;
            if (cur == 'd') cur = 'a';
        }

        bool good = true;
        for (int j = 1; j < k; j++) {
            int dx = x[j] - x[j - 1];
            int dc = c[j] - c[j - 1];
            if (dc > dx) {
                good = false;
                break;
            }

            for (int i = 0; i < dc; i++)
                s.push_back('c' + j);
            for (int i = dc; i < dx; i++) {
                s.push_back(cur);
                cur++;
                if (cur == 'd') cur = 'a';
            }
        }

        if (good)
            cout << "YES" << endl << s << endl;
        else
            cout << "NO" << endl;
    }

    return 0;
}
Solution Python
for tt in range(int(input())):
    n, k = map(int, input().split())
    x = list(map(int, input().split()))
    c = list(map(int, input().split()))

    if c[0] < 3 or c[0] > x[0]:
        print("NO")
        continue

    s = ""
    cur = 'a'

    for i in range(0, c[0] - 3):
        s += "a"

    for i in range(c[0] - 3, x[0]):
        s += cur
        cur = chr(ord(cur) + 1)
        if cur == 'd':
            cur = 'a'

    good = True
    for j in range(1, k):
        dx = x[j] - x[j - 1]
        dc = c[j] - c[j - 1]
        if dc > dx:
            good = False
            break

        for i in range(0, dc):
            s += chr(ord('c') + j)
        for i in range(dc, dx):
            s += cur
            cur = chr(ord(cur) + 1)
            if cur == 'd':
                cur = 'a'

    if good:
        print("YES")
        print(s)
    else:
        print("NO")
Notes
There were initially simpler version of this problem with $$$k = 1$$$, but it coincided with other problem.
Also, how does checker in this problem works?
--------------------------------------------------
Problem ID: 1823C
Editorial Content:
1823C - Strongly Composite
Editorial
Tutorial is loading...
Solution C++
#include <bits/stdc++.h>

using namespace std;

int main() {
    int tt;
    cin >> tt;
    while (tt--) {
        int n;
        cin >> n;
        map <int,int> a;
        for (int i = 0; i < n; i++) {
            int x;
            cin >> x;
            for (int j = 2; j * j <= x; j++) {
                while (x % j == 0) {
                    x /= j;
                    a[j]++;
                }
            }
            if (x != 1) {
                a[x]++;
            }
        }

        int res = 0, rem = 0;

        for (pair <int, int> p : a) {
            int num = p.first;
            int cnt = p.second;
            res += cnt / 2;
            rem += cnt % 2;
        }

        res += rem / 3;
        cout << res << '\n';
    }

    return 0;
}
Solution Python
def is_prime(x):
    i = 2
    while i * i <= x:
        if x % i == 0:
            return False
        i += 1
    return True

def is_strongly_composite(x):
    m = []
    i = 2
    while i * i <= x:
        while x % i == 0:
            x = x // i
            m.append(i)
        i += 1
    if not x == 1:
        m.append(i)
    return (len(m) >= 3 or (len(m) == 2 and m[0] == m[1]))

for tt in range(int(input())):
    n = int(input())
    lst = list(map(int, input().split()))
    a = {}
    for x in lst:
        i = 2
        while i * i <= x:
            while x % i == 0:
                x = x // i
                if i in a:
                    a[i] += 1
                else:
                    a[i] = 1
            i += 1
        if x != 1:
            if x in a:
                a[x] += 1
            else:
                a[x] = 1

    res, rem = 0, 0

    for num in a:
        cnt = a[num]
        res += cnt // 2
        rem += cnt % 2

    res += rem // 3
    print(res)
Notes
There were initially more complex version of this task. Can you solve it?
You are given $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$a_i > 1$$$). You can perform the following operation with array $$$a$$$ any number of times:
choose two indices $$$i$$$ and $$$j$$$ ($$$i < j$$$);
erase elements $$$a_i$$$ and $$$a_j$$$ from $$$a$$$;
insert element $$$a_i \cdot a_j$$$ in $$$a$$$.
After performing one such operation, the length of $$$a$$$ decreases by one.
Let's say that array $$$a$$$ is good, if it contains only strongly composite numbers.
What is the minimum number of operation you need to perform to make array $$$a$$$ good?
--------------------------------------------------
Problem ID: 1823B
Editorial Content:
1823B - Sort with Step
Editorial
Tutorial is loading...
Solution C++
#include <bits/stdc++.h>

using namespace std;

int main() {
    int tt;
    cin >> tt;
    while (tt--) {
        int n, k;
        cin >> n >> k;
        vector <int> p(n);
        for (int i = 0; i < n; i++) {
            cin >> p[i];
            p[i]--;
        }

        int bad = 0;
        for (int i=0; i<n; i++) {
            if (p[i] % k != i % k) {
                bad++;
            }
        }

        if(bad == 0)
            cout << 0 << '\n';
        else if(bad == 2)
            cout << 1 << '\n';
        else
            cout << -1 << '\n';
    }

    return 0;
}
Solution Python
for tt in range(int(input())):
    n, k = map(int, input().split())
    p = list(map(int, input().split()))
    for i in range(0, n):
        p[i] -= 1

    bad = 0
    for i in range(0, n):
        if p[i] % k != i % k:
            bad += 1

    if bad == 0:
        print(0)
    elif bad == 2:
        print(1)
    else:
        print(-1)
--------------------------------------------------
Problem ID: 1823A
Editorial Content:
1823A - A-characteristic
Editorial
Tutorial is loading...
Solution C++
#include <bits/stdc++.h>

using namespace std;

int main() {
    int tt;
    cin >> tt;
    while (tt--) {
        int n, k, x = -1;
        cin >> n >> k;
        for (int i = 0; i <= n; i++) {
            if (i * (i - 1) / 2 + (n - i) * (n - i - 1) / 2 == k) {
                x = i;
            }
        }
        if (x == -1)
            cout << "NO\n";
        else {
            cout << "YES\n";
            for (int i = 0; i < n; i++) {
                if (i < x)
                    cout << 1 << ' ';
                else
                    cout << -1 << ' ';
            }
            cout << '\n';
        }
    }

    return 0;
}
Solution Python
for tt in range(int(input())):
    n, k = map(int, input().split())
    x = -1

    for i in range(0, n + 1):
        if i * (i - 1) / 2 + (n - i) * (n - i - 1) / 2 == k:
            x = i

    if x == -1:
        print("NO")
    else:
        print("YES")
        for i in range(0, n):
            if i < x:
                print("1 ", end = '')
            else:
                print("-1 ", end = '')
        print("")
--------------------------------------------------
Problem ID: 1822G2
Editorial Content:
1822G2 - Magic Triples (Hard Version)
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int K = 1e6;
const int MAX_VAL = 1e9;

int32_t main() {
    int t;
    scanf("%d", &t);
    for (int _ = 0; _ < t; ++_) {
        int n;
        scanf("%d", &n);
        vector<int> a(n);
        map<int, int> cnt;
        for (int i = 0; i < n; ++i) {
            scanf("%d", &a[i]);
            ++cnt[a[i]];
        }
        ll ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += (ll)(cnt[a[i]] - 1) * (cnt[a[i]] - 2);
        }
        for (auto el : cnt) {
            int num = el.first;
            int val = el.second;
            if (num > K) {
                for (int b = 2; b * num <= MAX_VAL; ++b) {
                    if (num % b == 0 && cnt.find(num / b) != cnt.end() && cnt.find(num * b) != cnt.end()) {
                        ans += (ll)(cnt[num / b]) * (cnt[num * b]) * val;
                    }
                }
            } else {
                for (int b = 2; b * b <= num; ++b) {
                    if (num % b == 0) {
                        if ((ll)num * b <= (ll)MAX_VAL && cnt.find(num / b) != cnt.end() && cnt.find(num * b) != cnt.end()) {
                            ans += (ll)(cnt[num / b]) * (cnt[num * b]) * val;
                        }
                        if (b * b != num) {
                            if ((ll)num * num / b <= (ll)MAX_VAL && cnt.find(b) != cnt.end() && cnt.find(num / b * num) != cnt.end()) {
                                ans += (ll)(cnt[b]) * (cnt[num / b * num]) * val;
                            }
                        }
                    }
                }
                if (num > 1 && (ll)num * num <= (ll)MAX_VAL && cnt.find(1) != cnt.end() && cnt.find(num * num) != cnt.end()) {
                    ans += (ll)(cnt[1]) * (cnt[num * num]) * val;
                }
            }
        }
        printf("%lld\n", ans);
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1822G1
Editorial Content:
1822G1 - Magic Triples (Easy Version)
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int MAX_VAL = 1e6;

int cnt[MAX_VAL + 1];

int32_t main() {
    int t;
    cin >> t;
    for (int _ = 0; _ < t; ++_) {
        int n;
        cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
            ++cnt[a[i]];
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += (cnt[a[i]] - 1) * (cnt[a[i]] - 2);
            for (int b = 2; a[i] * b * b <= MAX_VAL; ++b) {
                ans += cnt[a[i] * b] * cnt[a[i] * b * b];
            }
        }
        cout << ans << "\n";
        for (int i = 0; i < n; ++i) {
            --cnt[a[i]];
        }
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1822F
Editorial Content:
1822F - Gardening Friends
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>

using namespace std;

struct Value {
    int64_t value = 0;
    int vertex = 0;
};

vector<vector<int>> nei;
vector<vector<int>> depth_vertex;
vector<int> depth;
vector<int> parent;

void dfs(int v, int p = -1, int cnt = 0) {
    depth_vertex[cnt].push_back(v);
    depth[v] = cnt;
    parent[v] = p;
    for (int u : nei[v]) {
        if (u == p) continue;
        dfs(u, v, cnt + 1);
    }
}

void solve() {
    int n, root = 1;
    int64_t k_wei, cost;
    cin >> n >> k_wei >> cost;

    nei.clear();
    nei.resize(n + 1);
    depth_vertex.clear();
    depth_vertex.resize(n + 1);
    depth.clear();
    depth.resize(n + 1);
    parent.clear();
    parent.resize(n + 1);

    for (int _ = 0; _ < n - 1; ++_) {
        int u, v;
        cin >> u >> v;
        nei[u].push_back(v);
        nei[v].push_back(u);
    }

    dfs(root);

    vector<pair<Value, Value>> down(n + 1);

    for (int tin = n; tin >= 0; --tin) {
        for (int v : depth_vertex[tin]) {
            for (int u : nei[v]) {
                if (u == parent[v]) continue;
                if (down[u].first.value + 1 > down[v].first.value) {
                    down[v].first.value = down[u].first.value + 1;
                    down[v].first.vertex = u;
                }
            }
            for (int u : nei[v]) {
                if (u == parent[v] || u == down[v].first.vertex) continue;
                if (down[u].first.value + 1 > down[v].second.value) {
                    down[v].second.value = down[u].first.value + 1;
                }
            }
        }
    }

    vector<int64_t> up(n + 1, 0);

    for (int tin = 1; tin <= n; ++tin) {
        for (int v : depth_vertex[tin]) {
            int p = parent[v];
            up[v] = up[p] + 1;
            if (down[p].first.vertex == v) {
                up[v] = max(up[v], down[p].second.value + 1);
            } else {
                up[v] = max(up[v], down[p].first.value + 1);
            }
        }
    }

    int64_t ans = -1'000'000'000'000'000'002;

    for (int v = 1; v <= n; ++v) {
        ans = max(ans, k_wei * max(up[v], down[v].first.value) - cost * int64_t(depth[v]));
    }

    cout << ans << endl;

}

int main()
{
    int t;
    cin >> t;
    for (int _ = 1; _ <= t; ++_) {
        solve();
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1822E
Editorial Content:
1822E - Making Anti-Palindromes
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

void solve(int n, string & s) {
    if (n % 2 == 1) {
        cout << -1 << endl;
        return;
    }
    vector<int> cnt(26);
    for (int i = 0; i < n; ++i) {
        ++cnt[s[i] - 'a'];
    }
    for (int i = 0; i < 26; ++i) {
        if (cnt[i] * 2 > n) {
            cout << -1 << endl;
            return;
        }
    }
    int pairs = 0;
    vector<int> cnt_pairs(26);
    for (int i = 0; i * 2 < n; ++i) {
        if (s[i] == s[n - i - 1]) {
           ++pairs;
           ++cnt_pairs[s[i] - 'a'];
        }
    }
    for (int i = 0; i < 26; ++i) {
        if (cnt_pairs[i] * 2 > pairs) {
            cout << cnt_pairs[i] << endl;
            return;
        }
    }
    cout << (pairs + 1) / 2 << endl;
}

int32_t main() {
    int t;
    cin >> t;
    for (int _ = 0; _ < t; ++_) {
        int n;
        cin >> n;
        string s;
        cin >> s;
        solve(n, s);
    }
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1822D
Editorial Content:
1822D - Super-Permutation
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

int main() {
    int q;
    cin >> q;
    while (q--) {
        int n;
        cin >> n;
        if (n == 1) {
            cout << "1\n";
            continue;
        }
        if (n % 2) {
            cout << "-1\n";
        } else {
            for (int i = 0; i < n; ++i) {
                if (i % 2) {
                    cout << i << " ";
                } else {
                    cout << n - i << " ";
                }
            }
            cout << "\n";
        }
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1822C
Editorial Content:
1822C - Bun Lover
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

#define int long long

int32_t main() {
    int q;
    cin >> q;
    while (q--) {
        int n;
        cin >> n;
        cout << ((n + 1) * n) + n + 2 << "\n";
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1822B
Editorial Content:
1822B - Karina and Array
Tutorial
Tutorial is loading...
Solution
t = int(input())
 
for testCase in range(t):
    n = int(input())
    a = list(map(int, input().split(' ')))
    a.sort()
    print(max(a[0] * a[1], a[-1] * a[-2]))
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1822A
Editorial Content:
1822A - TubeTube Feed
Tutorial
Tutorial is loading...
Solution
def solve():
    n, t = map(int, input().split())
    a = [int(x) for x in input().split()]
    b = [int(x) for x in input().split()]
    bst = -2
    for i in range(n):
        if i + a[i] <= t and (bst == -2 or b[bst] < b[i]):
            bst = i
    print(bst + 1)
 
 
t = int(input())
for _ in range(t):
    solve()
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1821F
Editorial Content:
1821F - Timber
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
using namespace std;

#define forn(i, n) for(int i = 0; i < int(n); i++) 

const int MOD = 998244353;

int add(int a, int b){
	a += b;
	if (a >= MOD)
		a -= MOD;
	if (a < 0)
		a += MOD;
	return a;
}

int mul(int a, int b){
	return a * 1ll * b % MOD;
}

int binpow(int a, int b){
	int res = 1;
	while (b){
		if (b & 1)
			res = mul(res, a);
		a = mul(a, a);
		b >>= 1;
	}
	return res;
}

int main(){
	int n, m, k;
	scanf("%d%d%d", &n, &m, &k);
	
	vector<int> fact(2 * n + 1), rfact(2 * n + 1);
	fact[0] = 1;
	for (int i = 1; i <= 2 * n; ++i) fact[i] = mul(fact[i - 1], i);
	rfact[2 * n] = binpow(fact[2 * n], MOD - 2);
	for (int i = 2 * n - 1; i >= 0; --i) rfact[i] = mul(rfact[i + 1], i + 1);
	auto cnk = [&](int n, int k){
		if (k < 0 || n < 0 || k > n) return 0;
		return mul(fact[n], mul(rfact[k], rfact[n - k]));
	};
	auto snb = [&](int n, int k){
		return cnk(n + k, k);
	};
	
	int pw2 = 1;
	int ans = 0;
	for (int i = m; i >= 0; --i){
		int cur = 0;
		if (n - (m - i) * 1ll * (k + 1) - i * 1ll * (2 * k + 1) >= 0)
			cur = mul(snb(n - (m - i) * (k + 1) - i * (2 * k + 1), m), mul(pw2, cnk(m, i)));
		ans = add(ans, i & 1 ? -cur : cur);
		pw2 = mul(pw2, 2);
	}
	
	printf("%d\n", ans);
}
--------------------------------------------------
Problem ID: 1821E
Editorial Content:
1821E - Rearrange Brackets
Tutorial
Tutorial is loading...
Solution 1 (awoo)
#include <bits/stdc++.h>

using namespace std;
 
#define forn(i, n) for(int i = 0; i < int(n); i++) 

const long long INF64 = 1e18;

long long dp[2][11][11][6];

int main(){
	int t;
	cin >> t;
	while (t--){
		int k;
		cin >> k;
		string s;
		cin >> s;
		int n = s.size();
		forn(balo, 2 * k + 1) forn(balc, 2 * k + 1) forn(mv, k + 1) dp[0][balo][balc][mv] = INF64;
		dp[0][k][k][0] = 0;
		int act = 0;
		forn(ii, n){
			int i = ii & 1;
			int ni = i ^ 1;
			forn(balo, 2 * k + 1) forn(balc, 2 * k + 1) forn(mv, k + 1)
				dp[ni][balo][balc][mv] = INF64;
			forn(mv, k + 1) forn(balo, 2 * k + 1) forn(balc, 2 * k + 1) if (dp[i][balo][balc][mv] != INF64){
				int bal = act - balo + balc;
				if (balo >= 0 && mv < k)
					dp[i][balo - 1][balc][mv + 1] = min(dp[i][balo - 1][balc][mv + 1], dp[i][balo][balc][mv] + bal);
				if (balc >= 0 && mv < k && bal > 0)
					dp[i][balo][balc - 1][mv + 1] = min(dp[i][balo][balc - 1][mv + 1], dp[i][balo][balc][mv]);
				if (s[ii] == '('){
					dp[ni][balo][balc][mv] = min(dp[ni][balo][balc][mv], dp[i][balo][balc][mv] + bal);
					if (balo + 1 <= 2 * k)
						dp[ni][balo + 1][balc][mv] = min(dp[ni][balo + 1][balc][mv], dp[i][balo][balc][mv]);
				}
				else{
					if (bal > 0)
						dp[ni][balo][balc][mv] = min(dp[ni][balo][balc][mv], dp[i][balo][balc][mv]);
					if (balc + 1 <= 2 * k)
						dp[ni][balo][balc + 1][mv] = min(dp[ni][balo][balc + 1][mv], dp[i][balo][balc][mv]);
				}
			}
			act += (s[ii] == '(' ? 1 : -1);
		}
		printf("%lld\n", *min_element(dp[n & 1][k][k], dp[n & 1][k][k] + k + 1));
	}
}
Solution 2 (awoo)
for _ in range(int(input())):
	k = int(input())
	s = input()
	n = len(s)
	st = []
	cnt = [0 for i in range(n + 1)]
	ans = 0
	for i in range(n):
		if s[i] == '(':
			ans += len(st)
			st.append(i)
		else:
			cnt[(i - st.pop()) // 2] += 1
	for i in range(n, -1, -1):
		t = min(k, cnt[i])
		ans -= t * i
		k -= t
	print(ans)
--------------------------------------------------
Problem ID: 1821D
Editorial Content:
1821D - Black Cells
Tutorial
Tutorial is loading...
Solution (adedalic)
fun main() {
    repeat(readln().toInt()) {
        val (n, k) = readln().split(' ').map { it.toInt() }
        val l = readln().split(' ').map { it.toInt() }
        val r = readln().split(' ').map { it.toInt() }

        var ans = 2e9.toInt()
        var cntShort = 0
        var lenLong = 0
        for (i in 0 until n) {
            val curLen = r[i] - l[i] + 1
            if(curLen > 1)
                lenLong += curLen
            else
                cntShort++

            if (lenLong < k) {
                if (lenLong + cntShort >= k) {
                    val cntSegs = (i + 1 - cntShort) + (k - lenLong)
                    ans = minOf(ans, r[i] + 2 * cntSegs)
                }
            }
            else {
                ans = minOf(ans, r[i] - (lenLong - k) + 2 * (i + 1 - cntShort))
                break
            }
        }
        if (ans == 2e9.toInt())
            ans = -1
        println(ans)
    }
}
--------------------------------------------------
Problem ID: 1821C
Editorial Content:
1821C - Tear It Apart
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	s = input()
	n = len(s)
	ans = n
	for x in range(26):
		c = chr(x + ord('a'))
		i = 0
		cur = 0
		while i < n:
			j = i
			while j < n and (s[j] == c) == (s[i] == c):
				j += 1
			if s[i] != c:
				cur = max(cur, j - i)
			i = j
		if cur == 0:
			ans = 0
			break
		pw = 0
		while (1 << pw) <= cur:
			pw += 1
		ans = min(ans, pw)
	print(ans)
--------------------------------------------------
Problem ID: 1821B
Editorial Content:
1821B - Sort the Subarray
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

int main()
{
	int t;
	scanf("%d", &t);
	for(int i = 0; i < t; i++)
	{
		int n;
		scanf("%d", &n);
		vector<int> a(n);
		for(int i = 0; i < n; i++)
			scanf("%d", &a[i]);
		vector<int> a1(n);
		for(int i = 0; i < n; i++)
			scanf("%d", &a1[i]);
		int diffl = -1, diffr = -1;
		for(int j = 0; j < n; j++)
		{
			if(a[j] != a1[j])
			{
				diffr = j;
				if(diffl == -1)
					diffl = j;
			}
		}
		while(diffl > 0 && a1[diffl - 1] <= a1[diffl])
			diffl--;
		while(diffr < n - 1 && a1[diffr + 1] >= a1[diffr])
			diffr++;
		printf("%d %d\n", diffl + 1, diffr + 1);
	}
}
--------------------------------------------------
Problem ID: 1821A
Editorial Content:
1821A - Matching
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

int main()
{
	int t;
	cin >> t;
	for(int i = 0; i < t; i++)
	{
		string s;
		cin >> s;
		int ans = 1;
		if(s[0] == '0') ans = 0;
		if(s[0] == '?') ans = 9;
		for(int j = 1; j < s.size(); j++)
			if(s[j] == '?')
				ans *= 10;
		cout << ans << endl;
	}
}
--------------------------------------------------
Problem ID: 1820B
Editorial Content:
1820B - JoJo's Incredible Adventures
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

int main() {
    ios::sync_with_stdio(0); cin.tie(0);

    int t = 1;
    cin >> t;
    while (t--) {
        string s; cin >> s; s += s;
        int k = 0, z = 0;
        for (char c : s) {
            z = c == '1' ? z+1 : 0;
            k = max(k, z);
        }
        const int n = s.size() / 2;

        if (k > n) {
            cout << (ll)n*n << '\n';
        } else {
            const ll side_a = (k+1)/2;
            const ll side_b = (k+2)/2;
            cout << side_a * side_b << '\n';
        }
    }
}
--------------------------------------------------
Problem ID: 1820A
Editorial Content:
1820A - Yura's New Name
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        string s;
        cin >> s;
        if (s == "^") {
            cout << 1 << '\n';
            continue;
        }
        int ans = 0;
        if (s[0] == '_')
            ++ans;
        if (s.back() == '_')
            ++ans;
        for (int i = 0; i < (int) s.size() - 1; ++i) {
            if (s[i] == '_' && s[i + 1] == '_')
                ++ans;
        }
        cout << ans << '\n';
    }
}
--------------------------------------------------
Problem ID: 1819F
Editorial Content:
1819F - Willy-nilly, Crack, Into Release!
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;
using pi = pair<int, int>;
using ll = long long;

const int Q = 1e5;
const int N = 20;
const int V = N*Q;

const ll LINF = 1e18;

struct MinMaxValue {
    ll min_value;
    ll max_value;

    MinMaxValue operator * (const MinMaxValue& x) const {
        if (x.max_value < 0 || max_value < 0) {
            return MinMaxValue { 0, -1 };
        }

        return MinMaxValue {
            .min_value = x.min_value + min_value,
            .max_value = x.max_value + max_value
        };
    }

    MinMaxValue operator + (const MinMaxValue& x) const {
        if (x.max_value == -1) return *this;
        if (max_value == -1) return x;

        return MinMaxValue {
            .min_value = min(x.min_value, min_value),
            .max_value = max(x.max_value, max_value)
        };
    }

    MinMaxValue& operator += (const MinMaxValue& x) {
        return *this = *this + x;
    }

    void Reset() {
        min_value = 0;
        max_value = -1;
    }
};

struct {
    MinMaxValue dig, ver, hor;
    int cnt;
    int go[4];
} nd[V];
int vc = 0;
MinMaxValue dig[N+1], ver[N+1], hor[N+1];

std::set<ll> words;

int NewVertex(int h) {
    int* go = nd[vc].go;
    go[0] = go[1] = go[2] = go[3] = -1;
    nd[vc].dig = dig[h];
    nd[vc].hor = hor[h];
    nd[vc].ver = ver[h];
    nd[vc].cnt = 0;
    return vc++;
}

tuple<const MinMaxValue&, const MinMaxValue&, const MinMaxValue&, int> GetState(int v, int h) {
    return v == -1 ? make_tuple(cref(dig[h]), cref(ver[h]), cref(hor[h]), 0)
                   : make_tuple(cref(nd[v].dig), cref(nd[v].ver), cref(nd[v].hor), nd[v].cnt);
}

void Calculate(int v, int h, int corner) {
    auto [dig0, ver0, hor0, cnt0] = GetState(nd[v].go[corner^0], h-1);
    auto [dig1, ver1, hor1, cnt1] = GetState(nd[v].go[corner^1], h-1);
    auto [dig2, ver2, hor2, cnt2] = GetState(nd[v].go[corner^2], h-1);
    auto [dig3, ver3, hor3, cnt3] = GetState(nd[v].go[corner^3], h-1);

    nd[v].cnt = cnt0 + cnt1 + cnt2 + cnt3;

    nd[v].dig.Reset();
    if (cnt0 == 0) nd[v].dig += hor2 * dig3 * ver1;
    if (cnt3 == 0) nd[v].dig += ver2 * dig0 * hor1;

    nd[v].hor = ver0 * dig2 * dig3 * ver1;
    if (cnt2 + cnt3 == 0) nd[v].hor += hor0 * hor1;

    nd[v].ver = hor0 * dig1 * dig3 * hor2;
    if (cnt1 + cnt3 == 0) nd[v].ver += ver0 * ver2;
}

void UpdateCount(int v, int h, int corner, ll msk, ll msk_save) {
    if (h == 0) {
        if (nd[v].cnt == 0) {
            words.insert(msk_save);
        } else {
            words.erase(msk_save);
        }
        nd[v].cnt ^= 1;
    } else {
        UpdateCount(nd[v].go[msk & 3], h-1, msk & 3, msk >> 2, msk_save);
        Calculate(v, h, corner);
    }
}

bool near_symbols[256][256];

MinMaxValue GetAnswer(int h) {
    int v = 0;

    if (nd[v].cnt == 0) {
        return MinMaxValue { .min_value = 2, .max_value = 4 * dig[h-1].max_value };
    }

    MinMaxValue res; res.Reset();

    bool cycle_len2 = false;
    if (nd[v].cnt <= 1) cycle_len2 = true;
    if (nd[v].cnt == 2) {
        string s, t;

        for (ll msk =       *words.begin(); s.size() < h; msk >>= 2) s.push_back("abdc"[msk & 3]);
        for (ll msk = *next(words.begin()); t.size() < h; msk >>= 2) t.push_back("abdc"[msk & 3]);
        auto flag = near_symbols[s.back()][t.back()];

        if (s.substr(0, h-1) == t.substr(0, h-1) && flag) {
            cycle_len2 = true;
        }

        int s_suf = 0, t_suf = 0;
        while (s_suf < h && s[h - s_suf - 1] == s.back()) ++s_suf;
        while (t_suf < h && t[h - t_suf - 1] == t.back()) ++t_suf;

        if (s_suf == t_suf && s_suf < h && flag && s.substr(0, h-s_suf-1) == t.substr(0, h-t_suf-1)
                && s.back() == t[h - s_suf - 1]
                && t.back() == s[h - t_suf - 1]) cycle_len2 = true;
    }

    if (cycle_len2) {
        res.min_value = 2;
        res.max_value = 2;
    }

    while (h != 0) {
        const int v0 = nd[v].go[0], v1 = nd[v].go[1], v2 = nd[v].go[2], v3 = nd[v].go[3];
        const auto& dig0 = get<0>(GetState(v0, h-1));
        const auto& dig1 = get<0>(GetState(v1, h-1));
        const auto& dig2 = get<0>(GetState(v2, h-1));
        const auto& dig3 = get<0>(GetState(v3, h-1));

        if(dig0.max_value > 0 && dig1.max_value > 0 && dig2.max_value > 0 && dig3.max_value > 0) {
            res += dig0 * dig1 * dig2 * dig3;
        }

        --h;
        if (v0 != -1 && nd[v0].cnt == nd[v].cnt) { v = v0; continue; }
        if (v1 != -1 && nd[v1].cnt == nd[v].cnt) { v = v1; continue; }
        if (v2 != -1 && nd[v2].cnt == nd[v].cnt) { v = v2; continue; }
        if (v3 != -1 && nd[v3].cnt == nd[v].cnt) { v = v3; continue; }
        break;
    }
    return res;
}

int main() {
    ios::sync_with_stdio(0); cin.tie(0);

    int n, q; cin >> n >> q;
    vector<ll> v(q);

    for (int i = 0; i < 4; ++i) {
        int j = (i + 1) % 4;
        near_symbols['a' + i]['a' + j] = true;
        near_symbols['a' + j]['a' + i] = true;
    }

    dig[0] = ver[0] = hor[0] = { 1, 1 };
    for (int i = 1; i <= n; ++i) {
        dig[i] = hor[i-1] * dig[i-1] * ver[i-1];
        hor[i] = ver[i] = hor[i-1] * hor[i-1] + ver[i-1] * ver[i-1] * dig[i-1] * dig[i-1];
    }

    int m_root = NewVertex(n); // make_root
    assert(m_root == 0);

    for (int i = 0; i < q; ++i) {
        string s; cin >> s;
        for (int j = 0; j < n; ++j) {
            v[i] += (s[j] == 'b' || s[j] == 'c' ? 1ll : 0) << (2*j);
            v[i] += (s[j] == 'c' || s[j] == 'd' ? 2ll : 0) << (2*j);
        }

        int w = 0;
        for (int j = 0; j < n; ++j) {
            int& next = nd[w].go[(v[i] >> (2*j)) & 3];
            if (next == -1) next = NewVertex(n-j-1);
            w = next;
        }
    }

    for (ll msk : v) {
        UpdateCount(0, n, 0, msk, msk);
        auto [a, b] = GetAnswer(n);

        if (a > b) {
            cout << -1 << '\n';
        } else {
            cout << a << " " << b << '\n';
        }
    }
}
--------------------------------------------------
Problem ID: 1819E
Editorial Content:
1819E - Roads in E City
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define x first
#define y second

using namespace std;

mt19937 rnd;

struct solve {

vector<pair<int, int>> r;

vector<vector<pair<int, int>>> s;

vector<int> ans;

int n, m;

static constexpr int rep = 45;

int dfs(int a, int p, int b) {
	for (auto i : s[a]) {
		if (i.x == b) {
			return i.y;
		}
		if (i.x == p) {
			continue;
		}

		int x = dfs(i.x, a, b);

		if (x != -1) {
			return x;
		}
	}
	return -1;
}

solve() {
	cin >> n >> m;
	r.resize(m);
	for (int i = 0; i < m; i++) {
		cin >> r[i].x >> r[i].y;
		r[i].x--;
		r[i].y--;
	}

	s.resize(n);
	ans.resize(m, -1);
	int cnt = 0;
	for (int i = 0; i < m; i++) {
		rem(i);
		for (int j = 0; j < rep; j++) {
			if (!ask_end(i)) {
				ans[i] = 1;
				break;
			}
		}
		if (ans[i] == 1) {
			add(i);
			cnt++;
			s[r[i].x].emplace_back(r[i].y, i);
			s[r[i].y].emplace_back(r[i].x, i);
		}
	}

	assert(cnt == n - 1);

	for (int i = 0; i < m; i++) {
		if (ans[i] != -1) continue;
		ans[i] = 1;

		int c = dfs(r[i].x, -1, r[i].y);
		rem(c);
		add(i);
		for (int j = 0; j < rep; j++) {
			if (!ask_end(i)) {
				ans[i] = 0;
				break;
			}
		}
		rem(i);
		add(c);
	}
	cout << "!";
	for (int i = 0; i < m; i++) {
		cout << ' ' << ans[i];
	}
	cout << endl;
	int x;
	cin >> x;
	if (x != 1) {
		exit(1);
	}
}

void rem(int x) {
	cout << "- " << x + 1 << endl;
}

void add(int x) {
	cout << "+ " << x + 1 << endl;
}

bool ask(int a) {
	cout << "? " << a + 1 << endl;
	// cerr << "? " << a + 1 << endl;
	int x;
	cin >> x;
	return x == 1;
}

bool ask_end(int i) {
	// cerr << "ask_end " << i << endl;
	int a = r[i].x;
	if (rnd() % 2) {
		a = r[i].y;
	}
	return ask(a);
}

};

int main() {
	int t;
	cin >> t;
	for (int i = 0; i < t; i++) {
		solve();
	}
}
--------------------------------------------------
Problem ID: 1819D
Editorial Content:
1819D - Misha and Apples
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#include <exception>

using namespace std;
using ll = long long;

void solve() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> apples(n);
    for (int i = 0; i < n; ++i) {
        int k;
        cin >> k;
        for (int j = 0; j < k; ++j) {
            int x;
            cin >> x;
            apples[i].push_back(x);
        }
    }
    // vector<int> last(m + 1, -1);
    unordered_map<int, int> last;
    auto get_last = [&](int i) {
        if (!last.count(i)) {
            return -1;
        } else {
            return last[i];
        }
    };
    vector<char> can_zero(n + 1, false);
    vector<int> prev(n + 1, 0);
    can_zero[0] = true;
    int oops = -1;
    for (int i = 0; i < n; ++i) {
        if (apples[i].empty()) {
            can_zero[i + 1] = true;
            last[0] = i;
        } else {
            int nearest_pair = get_last(0);
            int new_oops = oops;
            for (int x : apples[i]) {
                nearest_pair = max(nearest_pair, get_last(x));
                new_oops = max(new_oops, get_last(x));
                last[x] = i;
            }
            if (nearest_pair != -1) {
                int nearest_zero = prev[nearest_pair];
                if (oops < nearest_zero) {
                    can_zero[i + 1] = true;
                }
            }
            oops = new_oops;
        }
        if (can_zero[i + 1]) {
            prev[i + 1] = i + 1;
        } else {
            prev[i + 1] = prev[i];
        }
    }
    // vector<char> used(m + 1, false);
    unordered_set<int> used;
    vector<int> max_cnt(n + 1, 0);
    int current_cnt = 0;
    for (int i = n - 1; i >= 0; --i) {
        bool fail = false;
        if (apples[i].empty()) {
            used.insert(0);
        }
        for (int x : apples[i]) {
            if (used.count(x)) {
                fail = true;
                break;
            }
            used.insert(x);
            ++current_cnt;
        }
        if (fail) {
            break;
        }
        if (used.count(0)) {
            max_cnt[i] = m;
        } else {
            max_cnt[i] = current_cnt;
        }
    }
    int ans = 0;
    for (int i = 0; i <= n; ++i) {
        if (can_zero[i]) {
            ans = max(ans, max_cnt[i]);
        }
    }
    cout << ans << '\n';
}

int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    int t = 1;
    cin >> t;
    while (t--) solve();
}
--------------------------------------------------
Problem ID: 1819C
Editorial Content:
1819C - The Fox and the Complete Tree Traversal
Editorial
Tutorial is loading...
Solution
// #pragma comment(linker, "/stack:200000000")
// #pragma GCC optimize("Ofast,no-stack-protector")
// #pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")
// #pragma GCC optimize("unroll-loops")

#include <stdio.h>
#include <bits/stdc++.h>

#ifdef PERVEEVM_LOCAL
    #define debug(x) std::cerr << (#x) << ":\t" << (x) << std::endl
#else
    #define debug(x) 238
#endif

#define fastIO std::ios_base::sync_with_stdio(false); std::cin.tie(0); std::cout.tie(0)
#define NAME "File"

using ll = long long;
using ld = long double;

#ifdef PERVEEVM_LOCAL
    std::mt19937 rnd(238);
#else
    std::mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());
#endif

template<typename T>
bool smin(T& a, const T& b) {
    if (b < a) {
        a = b;
        return true;
    }
    return false;
}

template<typename T>
bool smax(T& a, const T& b) {
    if (a < b) {
        a = b;
        return true;
    }
    return false;
}

const double PI = atan2(0.0, -1.0);
const int INF = 0x3f3f3f3f;
const ll LINF = (ll)2e18;
const int N = 200100;

std::vector<int> g[N];
int d[N], par[N];
bool onDiameter[N];

void dfs(int v, int p, int depth) {
	d[v] = depth;
	par[v] = p;

	for (auto to : g[v]) {
		if (to != p) {
			dfs(to, v, depth + 1);
		}
	}
}

void run() {
	int n;
	scanf("%d", &n);

	for (int i = 0; i < n - 1; ++i) {
		int from, to;
		scanf("%d%d", &from, &to);
		g[from - 1].push_back(to - 1);
		g[to - 1].push_back(from - 1);
	}    

	dfs(0, 0, 0);
	int v1 = 0;
	for (int i = 0; i < n; ++i) {
		if (d[i] > d[v1]) {
			v1 = i;
		}
	}

	dfs(v1, v1, 0);
	int v2 = v1;
	for (int i = 0; i < n; ++i) {
		if (d[i] > d[v2]) {
			v2 = i;
		}
	}

	std::vector<int> diameter;
	for (int v = v2; v != v1; v = par[v]) {
		onDiameter[v] = true;
		diameter.push_back(v);
	}
	onDiameter[v1] = true;
	diameter.push_back(v1);
	std::reverse(diameter.begin(), diameter.end());

	for (int i = 0; i < n; ++i) {
		if (onDiameter[i]) {
			continue;
		}
		if (!onDiameter[par[i]]) {
			printf("No\n");
			return;
		}
	}

	printf("Yes\n");
	std::vector<int> ans;
	for (int i = 0; i < (int)diameter.size(); i += 2) {
		ans.push_back(diameter[i]);
		if (i + 1 != (int)diameter.size()) {
			for (auto to : g[diameter[i + 1]]) {
				if (!onDiameter[to]) {
					ans.push_back(to);
				}
			}
		}
	}

	if (diameter.size() % 2 == 0) {
		for (int i = (int)diameter.size() - 1; i > 0; i -= 2) {
			ans.push_back(diameter[i]);
			if (i - 1 >= 0) {
				for (auto to : g[diameter[i - 1]]) {
					if (!onDiameter[to]) {
						ans.push_back(to);
					}
				}
			}
		}
	} else {
		for (int i = (int)diameter.size() - 1; i > 0; i -= 2) {
			ans.push_back(diameter[i - 1]);
			if (i - 2 >= 0) {
				for (auto to : g[diameter[i - 2]]) {
					if (!onDiameter[to]) {
						ans.push_back(to);
					}
				}
			}
		}
	}

	assert((int)ans.size() == n);
	for (auto i : ans) {
		printf("%d ", i + 1);
	}
	printf("\n");
}

int main(void) {
    // freopen(NAME".in", "r", stdin);
    // freopen(NAME".out", "w", stdout);

    #ifdef PERVEEVM_LOCAL
        auto start = std::chrono::high_resolution_clock::now();
    #endif

    run();

    #ifdef PERVEEVM_LOCAL
        auto end = std::chrono::high_resolution_clock::now();
        std::cerr << "Execution time: "
                  << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count()
                  << " ms" << std::endl;
    #endif

    return 0;
}
--------------------------------------------------
Problem ID: 1819B
Editorial Content:
1819B - The Butcher
Editorial
Tutorial is loading...
Solution
//#pragma GCC target("trapv")
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <string>
#include <cmath>
#include <map>
#include <iostream>
#include <list>
#include <stack>
#include <cassert>
using namespace std;

typedef long long ll;
typedef long double ld;

#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);

const ll INF = 1e9 * 1e9 + 100, SZ = 1100;

ll n;
vector<pair<ll, ll>> vec;
map<ll, pair<ll, ll>> blocks;

pair<ll, ll> solve() {
	set<pair<ll, ll>> widest, longest;

	for (size_t i = 0; i < vec.size(); i++) {
		widest.insert({ vec[i].first, i });
		longest.insert({ vec[i].second, i });

		blocks[i] = vec[i];
	}

	pair<ll, ll> ans = { -1, -1 };
	bool mode = 0;
	ll prevw = INF, prevh = INF, prv = -1;
	bool cringe = 0;
	while (widest.size() != 0) {
		if (mode == 0) {
			ll cur = (*widest.rbegin()).first, sum = 0;
			if (ans.second == -1) ans.second = cur;
			prv = blocks[(*widest.rbegin()).second].second;

			while (widest.size() > 0 && (*widest.rbegin()).first == cur) {
				auto it = (--widest.end());
				longest.erase({blocks[it->second].second, it->second });
				sum += blocks[it->second].second;
				widest.erase(it);
			}

			if (!cringe) ans.first = sum;
			prv = sum;
			if (prevw == INF) {
				prevh = cur;
			} else {
				prevw -= sum;
				if (prevh != cur) return { -1, -1 };
			}
		} else {
			ll cur = (*longest.rbegin()).first, sum = 0;
			if (!cringe) {
				ans.first = cur + prv;
				cringe = 1;
			}

			while (longest.size() > 0 && (*longest.rbegin()).first == cur) {
				auto it = (--longest.end());
				widest.erase({ blocks[it->second].first, it->second });
				sum += blocks[it->second].first;
				longest.erase(it);
			}

			if (prevw == INF) {
				prevw = cur;
				prevh -= sum;
				if (prevw != cur) return { -1, -1 };
			} else {
				prevh -= sum;
				if (prevw != cur) return { -1, -1 };
			}
		}

		mode ^= 1;
	}

	if (prevh == 0 || prevw == 0 || prevh == INF || prevw == INF) {
		return ans;
	} else {
		return { -1, -1 };
	}
}

signed main() {
	fastInp;

    ll t;
    cin >> t;
    
    while (t--) {
        vec.clear();
        blocks.clear();
    	cin >> n;
    
    	vec.resize(n);
    	for (auto& c : vec) cin >> c.first >> c.second;
    
    	vector<pair<ll, ll>> ans;
    
    	ans.push_back(solve());
    	swap(ans.back().first, ans.back().second);
    	if (ans.back().first == -1) ans.pop_back();
    
    	for (auto& c : vec) swap(c.first, c.second);
    
    	ans.push_back(solve());
    	if (ans.back().first == -1) ans.pop_back();
    
    	if (ans.size() == 2 && ans[0] == ans[1]) {
    		ans.pop_back();
    	}
    	cout << ans.size() << "\n";
    
    	for (auto c : ans) cout << c.first << " " << c.second << "\n";
    }
    
	return 0;
}
--------------------------------------------------
Problem ID: 1819A
Editorial Content:
1819A - Constructive Problem
Editorial
Tutorial is loading...
Solution
//  Nikita Golikov, 2023

#include <bits/stdc++.h>

using namespace std;

using uint = unsigned int;
using ll = long long;
using ull = unsigned long long;

#ifdef GOLIKOV
    #define debug(x) cerr << (#x) << ":\t" << (x) << endl
#else
    #define debug(x) 238;
#endif

template <class A, class B>
bool smin(A& x, B&& y) {
  if (y < x) {
    x = y;
    return true;
  }
  return false;
}

template <class A, class B>
bool smax(A& x, B&& y) {
  if (x < y) {
    x = y;
    return true;
  }
  return false;
}

template <class T>
int calcMex(vector<T> v) {
  sort(v.begin(), v.end());
  v.erase(unique(v.begin(), v.end()), v.end());
  int n = int(v.size());
  for (int i = 0; i < n; ++i) if (v[i] != i) return i;
  return n;
}

bool solveTest() {
  int n; cin >> n;
  vector<int> a(n);
  map<int, int> leftOcc, rightOcc;
  for (int i = 0; i < n; ++i) {
    cin >> a[i];
    rightOcc[a[i]] = i;
    if (!leftOcc.count(a[i])) leftOcc[a[i]] = i;
  }
  int mex = calcMex(a);
  if (leftOcc.count(mex + 1)) {
    int L = leftOcc[mex + 1], R = rightOcc[mex + 1];
    for (int i = L; i <= R; ++i) {
      a[i] = mex;
    }
    int mx = calcMex(a);
    assert(mx <= mex + 1);
    return mx == mex + 1;
  }
  for (int i = 0; i < n; ++i) {
    assert(a[i] != mex);
    if (a[i] > mex || (leftOcc[a[i]] != rightOcc[a[i]])) {
      return true;
    }
  }
  return false;
}

int main() {
#ifdef GOLIKOV
  assert(freopen("in", "rt", stdin));
  auto _clock_start = chrono::high_resolution_clock::now();
#endif
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int t; cin >> t;
  while (t--) {
    cout << (solveTest() ? "Yes" : "No") << '\n';
  }

#ifdef GOLIKOV
  cerr << "Executed in " << chrono::duration_cast<chrono::milliseconds>(
      chrono::high_resolution_clock::now()
          - _clock_start).count() << "ms." << endl;
#endif
  return 0;
}
--------------------------------------------------
Problem ID: 1818B
Editorial Content:
1818B - Indivisible
Editorial
Tutorial is loading...
Solution
void solve() {
    int n;
    cin >> n;
    if(n == 1) {
        cout << 1 << "\n";
    } else if(n % 2) {
        cout << -1 << "\n";
    } else {
        int a[n];
        iota(a, a + n, 1);
        for(int i = 0; i < n; i += 2) {
            swap(a[i], a[i + 1]);
        }
        for(auto it: a) {
            cout << it << ' ';
        }
        cout << "\n";
    }
}
--------------------------------------------------
Problem ID: 1818A
Editorial Content:
1818A - Politics
Editorial
Tutorial is loading...
Solution
void solve() {
    int n, k;
    cin >> n >> k;
    string t[n];
    int ans = n;
    for(int i = 0; i < n; i++) {
        cin >> t[i];
        if(t[i] != t[0]) {
            ans--;
        }
    }
    cout << ans << "\n";
}
--------------------------------------------------
Problem ID: 1817F
Editorial Content:
1817F - Entangled Substrings
Editorial
Tutorial is loading...
Solution
map<char, int> to[maxn];
int len[maxn], link[maxn];
int last, sz = 1;

void add_letter(char c) {
    int p = last;
    last = sz++;
    len[last] = len[p] + 1;
    for(; to[p][c] == 0; p = link[p]) {
        to[p][c] = last;
    }
    int q = to[p][c];
    if(q != last) {
        if(len[q] == len[p] + 1) {
            link[last] = q;
        } else {
            int cl = sz++;
            len[cl] = len[p] + 1;
            link[cl] = link[q];
            to[cl] = to[q];
            link[last] = link[q] = cl;
            for(; to[p][c] == q; p = link[p]) {
                to[p][c] = cl;
            }
        }
    }
}

int term[maxn];
int used[maxn], comp[maxn], dist[maxn];
vector<int> in_comp[maxn];

void dfs(int v = 0) {
    comp[v] = v;
    dist[v] = 0;
    used[v] = 1;
    for(auto [c, u]: to[v]) {
        if(!used[u]) {
            dfs(u);
        }
        if(to[v].size() == 1 && !term[v]) {
            comp[v] = comp[u];
            dist[v] = dist[u] + 1;
        }
    }
    in_comp[comp[v]].push_back(v);
}

void solve() {
    string s;
    cin >> s;
    for(auto c: s) {
        add_letter(c);
    }
    for(int p = last; p; p = link[p]) {
        term[p] = 1;
    }
    term[0] = 1;
    dfs();
    int64_t ans = 0;
    for(int v = 0; v < sz; v++) {
        if(in_comp[v].size()) {
            int m = in_comp[v].size();
            sort(all(in_comp[v]), [&](int a, int b) {
                return dist[a] > dist[b];
            });
            vector<int64_t> A(m), B(m);
            for(int i = 0; i < m; i++) {
                int u = in_comp[v][i];
                int L = dist[u];
                int R = L + len[link[u]];
                // L' must be larger than R
                int cnt = len[u] - len[link[u]];
                A[i] = (int64_t)cnt * L;
                B[i] = cnt;
                if(i > 0) {
                    A[i] += A[i - 1];
                    B[i] += B[i - 1];
                }
                auto it = upper_bound(all(in_comp[v]), R, [&](int R, int b) {
                    return R > dist[b];
                }) - begin(in_comp[v]);
                if(it) {
                    it--;
                    ans += A[it] - B[it] * R;
                }
            }
        }
    }
    cout << ans << "\n";
}
--------------------------------------------------
Problem ID: 1817E
Editorial Content:
1817E - Half-sum
Editorial
Tutorial is loading...
Solution
// split into 1, ..., k and k+1, ..., n
pair<int, istring> check_k(istring const& a, int k) {
    int n = size(a);
    istring A(n, 0), B(n, 0);
    for(int i = 0; i < n; i++) {
        if(i <= k) {
            A[min(k, i + 1)] += a[i];
        } else {
            B[min(n - k - 2, n - i)] += a[i];
        }
    }
    // multiply by 2^(n - i - 1) instead of dividing by 2^i
    reverse(all(A));
    reverse(all(B));
    int carry = 0;
    // subtract A from B and normalize base 2
    for(int i = 0; i < n; i++) {
        B[i] -= A[i] - carry;
        carry = B[i] >> 1; // floor(B[i] / 2)
        B[i] &= 1;
    }
    if(carry < 0) {
        return {-1, {}}; // it's always possible to make it positive
    }
    while(carry) {
        B.push_back(carry & 1);
        carry >>= 1; 
    }
    while(!B.empty() && B.back() == 0) {
        B.pop_back();
    }
    reverse(all(B));
    return {(int)size(B) - n, B};
}

const int mod = 1e9 + 7;

int bpow(int x, int n) {
    if(!n) {
        return 1;
    } else if(n % 2) {
        return int64_t(x) * bpow(x, n - 1) % mod;
    } else {
        return bpow(int64_t(x) * x % mod, n / 2);
    }
}

int inv(int x) {
    return bpow(x, mod - 2);
}

void solve() {
    int n;
    cin >> n;
    istring a(n, 0);
    for(int i = 0; i < n; i++) {
        cin >> a[i];
    }
    sort(all(a));
    auto cand = check_k(a, 0);
    int cnt = 0;
    for(int i = 1; i < n; i++) {
        if(a[i] != a[i - 1]) {
            cand = max(cand, check_k(a, i - 1));
            cnt++;
            if(cnt == 30) {
                break;
            }
        }
    }
    cnt = 0;
    istring b = a;
    reverse(all(b));
    for(int i = 1; i < n; i++) {
        if(b[i] != b[i - 1]) {
            cand = max(cand, check_k(a, n - i - 1));
            cnt++;
            if(cnt == 30) {
                break;
            }
        }
    }
    auto [sz, ansf] = cand;
    int ans = 0;
    for(size_t i = 0; i < size(ansf); i++) {
        ans = (ans + bpow(2, (mod - 1) + (sz - i)) * ansf[i]) % mod;
    }
    cout << ans << "\n";
}
--------------------------------------------------
Problem ID: 1817D
Editorial Content:
1817D - Toy Machine
Editorial
Instead of caring about the positions of all the toys, we only need to care about the position of the special toy with index $$$k$$$. The other toys can be treated as undistinguishable.
The intended way of solving this problem is playing the game in the webpage, trying to come up with some simple combinations of operations that make the special toy move to another position in a predictable way. Using these building blocks in a smart way, finding a way to move the special toy to the topleft.
As the size of the grid can be up to $$$100\,000$$$ and we can make $$$1\,000\,000$$$ moves, we will be aiming for a solution which does a linear number of moves.
There are lots of potential solutions which use a linear number of moves, here is a relatively painless one:
Do casework on $$$k$$$:
Case $$$1$$$: If $$$1 \leq k < \frac{n-1}{2}$$$, we initally make one $$$\texttt{R}$$$ button press to align the toys with the right boundary. After this, there is an easy pattern to expose all the toys in the left halve, one by one: $$$\texttt{DRURDRUR...}$$$ repeated. When the special toy is exposed, the repeating pattern is stopped, and $$$\texttt{DL}$$$ are pressed. Toy $$$k$$$ will be moved to the topleft corner.
Visualization
Left halve solution for $$$n=15$$$.
Case $$$2$$$: If $$$k = \frac{n-1}{2}$$$, the puzzle can be solved in two moves: $$$\texttt{DL}$$$.
Visualization
Solution for middle toy and $$$n=15$$$.
Case $$$3$$$: If $$$\frac{n-1}{2} < k \leq n-2$$$, we try to reduce back to case $$$1$$$, by moving the special toy to the left halve, and ensuring that all other toys are in the top row. Using symmetry, we can apply case $$$1$$$ to $$$k^\prime = n-1 - k$$$, but mirror all horizontal moves, to move the toy to the topright corner. The other toys are no longer all in the top row. To fix this, the last pattern we need is again $$$\texttt{DRURDRUR...}$$$ repeated. After a while of repeating this, all toys will be in the right halve of the board, occupying the top and bottom row. To finish moving the special toy (which stayed in the topright corner), we do the buttons presses $$$\texttt{LDRU}$$$. All toys end up in the top row, and the special toy will be at position $$$k_\text{new} = \frac{n-1}{2} - 1$$$, so this successfully reduces to case $$$1$$$.
Visualization
Full solution for right halve for $$$n=15$$$.
How many moves does this take? In case $$$1$$$ the pattern $$$\texttt{DRUR}$$$ needs to be repeated at most $$$\approx \frac{n}{2}$$$ times. In case $$$3$$$, we need to use the first pattern $$$\frac{n}{2}$$$ times, and we use the second pattern $$$\frac{n}{2}$$$ times. We reduce down to case $$$1$$$, but luckily the special toy is already close to the correct position, so only a constant number of extra moves are done.
So in total, this solution uses $$$O(1) + \max \left( 4\frac{n}{2}, 4 \cdot 2 \frac{n}{2} \right) = 4n + O(1)$$$ moves. So this solution fits well within the constraints, although it is pretty wasteful.
Bonus: Can you prove that the optimal number of moves needed in the worstcase (over all $$$k$$$) for a width of $$$n$$$ is $$$\Omega(n)$$$? We only did some testing of small cases, with a bruteforce BFS solution, and found that the worstcase is around $$$n/2$$$ button presses.
Visualization
Left halve solution for $$$n=15$$$.
Visualization
Solution for middle toy and $$$n=15$$$.
Visualization
Full solution for right halve for $$$n=15$$$.
Solution
#include "bits/stdc++.h"
using namespace std;

int main() {
    int n,k; cin >> n >> k;
    --k;
    int half = (n-3)/2;
    string res = "";
    if(k==half) {
        res = "DL";
    } else {
        while(true) {
            if(k<half) {
                res+="R";
                int need = half-1-k;
                while(need--) {
                    res+="DRUR";
                }
                res+="DL";
                break;
            } else {
                int need = k-half-1;
                while(need--) {
                    res+="LDLU";
                }
                res+="LDR";
                for(int i=0;i<half+1;++i) {
                    res+="DRUR";
                }
                res+="LDRU"; 
                k = half-1;
            }
        }
    }
    cout << res << '\n';
}
--------------------------------------------------
Problem ID: 1817C
Editorial Content:
1817C - Similar Polynomials
Editorial
Tutorial is loading...
Solution
const int mod = 1e9 + 7;

namespace algebra {
    const int maxn = 3e6 + 42;
    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); 

    template<typename T>
    T bpow(T x, size_t n) {
        if(n == 0) {
            return T(1);
        } else {
            auto t = bpow(x, n / 2);
            t = t * t;
            return n % 2 ? x * t : t;
        }
    }

    const int m = mod;
    struct modular {
        int r;
        constexpr modular(): r(0) {}
        constexpr modular(int64_t rr): r(rr % m) {if(r < 0) r += m;}
        modular inv() const {return bpow(*this, m - 2);}
        modular operator - () const {return r ? m - r : 0;}
        modular operator * (const modular &t) const {return (int64_t)r * t.r % m;}
        modular operator / (const modular &t) const {return *this * t.inv();}
        modular operator += (const modular &t) {r += t.r; if(r >= m) r -= m; return *this;}
        modular operator -= (const modular &t) {r -= t.r; if(r < 0) r += m; return *this;}
        modular operator + (const modular &t) const {return modular(*this) += t;}
        modular operator - (const modular &t) const {return modular(*this) -= t;}
        modular operator *= (const modular &t) {return *this = *this * t;}
        modular operator /= (const modular &t) {return *this = *this / t;}
        
        bool operator == (const modular &t) const {return r == t.r;}
        bool operator != (const modular &t) const {return r != t.r;}
        bool operator < (const modular &t) const {return r < t.r;}
        
        explicit operator int() const {return r;}
        int64_t rem() const {return 2 * r > m ? r - m : r;}
    };
    
    istream& operator >> (istream &in, modular &x) {
        return in >> x.r;
    }
    
    ostream& operator << (ostream &out, modular const& x) {
        return out << x.r;
    }
    
    vector<modular> F(maxn), RF(maxn);
    
    template<typename T>
    T fact(int n) {
        static bool init = false;
        if(!init) {
            F[0] = T(1);
            for(int i = 1; i < maxn; i++) {
                F[i] = F[i - 1] * T(i);
            }
            init = true;
        }
        return F[n];
    }
    
    template<typename T>
    T rfact(int n) {
        static bool init = false;
        if(!init) {
            RF[maxn - 1] = T(1) / fact<T>(maxn - 1);
            for(int i = maxn - 2; i >= 0; i--) {
                RF[i] = RF[i + 1] * T(i + 1);
            }
            init = true;
        }
        return RF[n];
    }
}

using namespace algebra;

using base = modular;


void solve() {
    int d;
    cin >> d;
    vector<base> A(d + 1), B(d + 1);
    copy_n(istream_iterator<base>(cin), d + 1, begin(A));
    copy_n(istream_iterator<base>(cin), d + 1, begin(B));
    base s = 0, k2 = 0;
    auto coef = [&](int i) {
        return base((d - i) % 2 ? -1 : 1) * rfact<base>(i) * rfact<base>(d - i);
    };
    for(int i = 0; i <= d; i++) {
        s += (A[i] - B[i]) * coef(i) * (d * (d + 1) / 2 - i);
        k2 += (A[i] + B[i]) * coef(i);
    }
    s *= base(2) / (k2 * d);
    cout << s << "\n";
}
--------------------------------------------------
Problem ID: 1817B
Editorial Content:
1817B - Fish Graph
Hint 1
Can you find a necessary condition for whether a Fish Subgraph exists?
Hint 2
For the Fish Subgraph to exist, the graph must have a cycle with one node in the cycle having degree at least 4.
Hint 3
When the necessary condition is satisfied, actually, you can always find a Fish Subgraph. Try to prove this, and see if your proof can be turned into an algorithm.
Editorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
#define all(x) begin(x),end(x)
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int,int> pi;

void solve() {
    int n,m; cin >> n >> m;
    vvi adj(n);
    while(m--) {
        int u,v; cin >> u >> v;
        --u,--v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    // find cycle and node with big degree.
    for(int u=0;u<n;++u) if(adj[u].size()>=4) for(int v : adj[u]) {
        // find path from u to v, without edge (u,v)
        vi cur;
        vi p;
        vector<bool> vis(n);
        auto dfs = [&](auto&& self, int at) -> void {
            vis[at]=1;
            cur.push_back(at);
            if(at==v) {
                p=cur;
                return;
            }
            for(int to : adj[at]) if(!vis[to]) {
                if(at==u and to==v) continue;
                self(self,to);
                if(!p.empty()) return;
            }
            cur.pop_back();
        };
        dfs(dfs,u);
        if(p.empty()) continue;
        // found cycle, with a node with degree >=4
        vi extra = adj[u];
        extra.resize(4);
        int mn = p.size();
        for(auto i : extra) {
            auto it = find(all(p),i);
            if(it!=p.begin()+1) {
                mn = min(mn,int(it-p.begin())+1);
            }
        }
        p.resize(mn);
        partition(all(extra),[&](int i) {return count(all(p),i)==0;});
        extra.resize(2);

        cout << "YES\n";
        cout << p.size()+2 << '\n';
        auto out = [&](int a, int b) {cout << a+1 << ' ' << b+1 << '\n';};
        int prv=p.back();
        for(auto i : p) {
            out(i,prv);
            prv=i;
        }
        out(u,extra[0]);
        out(u,extra[1]);
        return;
    }

    cout << "NO\n";
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int t; cin >> t;
    while(t--) solve();
}
--------------------------------------------------
Problem ID: 1817A
Editorial Content:
1817A - Almost Increasing Subsequence
Editorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
typedef vector<int> vi;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int n,q; cin >> n >> q;
    vi a(n);
    for(int& i : a) cin >> i;
    vi p(n-1);
    for(int i=1;i<n-1;++i) {
        int downhill = a[i-1]>=a[i] and a[i]>=a[i+1];
        p[i] = p[i-1] + downhill;
    }
    while(q--) {
        int l,r; cin >> l >> r;
        --l,--r;
        if(l==r) {
            cout << "1\n";
        } else {
            int ans = (r-l+1) - p[r-1] + p[l];
            cout << ans << '\n';
        }
    }
}
--------------------------------------------------
Problem ID: 1816B
Editorial Content:
1816B - Grid Reconstruction
Hint
Consider the parity (odd/even) of $$$i+j$$$. What do you observe?
Editorial
Observe that $$$a_{i,j}$$$ will be added if $$$(i+j)$$$ is even, and will be subtracted otherwise. This forms a checkered pattern.
Obviously, it is optimal for all values that will be added to be strictly larger than all values that will be subtracted. Also, the difference between the value of adjacent grids should be
almost
equal (by some definition of
almost
).
We construct array $$$a$$$ as follows:
$$$a_{1,1} = 2n-1$$$ and $$$a_{2,n} = 2n$$$
For $$$2 \leq i \leq n$$$ and $$$i$$$ is even, $$$a_{1,i} = i$$$ and $$$a_{2,i-1} = i - 1$$$
For $$$2 \leq i \leq n$$$ and $$$i$$$ is odd, $$$a_{1,i} = n + i - 1$$$ and $$$a_{2,i-1} = n + (i - 1) - 1$$$
For example, when $$$n=10$$$, the output will be
19 2 12 4 14 6 16 8 18 10
1 11 3 13 5 15 7 17 9 20
Insights on how to find the construction
(This is a very informal proof. See "Proof" below for a formal proof.)
First of all, due to the checkered pattern, $$$a_{1,1}, a_{2,2}, a_{1,3}, \cdots, a_{2,n}$$$ should be filled with $$$n+1, n+2, n+3, \cdots, 2n$$$, and $$$a_{2,1}, a_{1,2}, a_{2,3}, \cdots, a_{1,n}$$$ should be filled with $$$1, 2, 3, \cdots, n$$$. In particular, $$$a_{1,1}$$$ and $$$a_{2,n}$$$ should be $$$2n-1$$$ and $$$2n$$$.
Next, as we are trying to maximise the minimum, the difference between paths shouldn't be large (since the minimum path will be smaller if the difference is larger). Notice that a path consists of a prefix of $$$a_1$$$ and a suffix of $$$a_2$$$, and the difference between $$$2$$$ adjacent paths is
Unable to parse markup [type=CF_MATHJAX]
(depending on the parity of $$$k$$$). It is optimal for the difference to be as small as possible (which is $$$1$$$).
Finally, it is optimal that $$$a_{1,k} - a_{2,k-1}$$$ stays constant in the whole array. If they are different, the difference between $$$2$$$ paths (not adjacent) will be larger than $$$1$$$, which is suboptimal.
Proof
Consider the cost of the top right path and bottom left path.
The cost of the top right path is $$$a_{1,1} - a_{1,2} + a_{1,3} - \cdots - a_{1,n} + a_{2,n}$$$.
The cost of the bottom right path is $$$a_{1,1} - a_{2,1} + a_{2,2} - a_{2,3} + ... + a_{2,n}$$$.
Summing both values, we get
$$$a_{1,1} + a_{2,n} + ((a_{1,1} - a_{1,2} + a_{1,3} - a_{1,4} + ... - a_{1,n}) + (-a_{2,1} + a_{2,2} - a_{2,3} + ... + a_{2,n}))$$$
which is equal to
$$$a_{1,1} + a_{2,n} + ((a_{1,1} + a_{2,2} + a_{1,3} + a_{2,4} + \cdots + a_{2,n}) - (a_{2,1} + a_{1,2} + a_{2,3} + a_{1,4} + \cdots + a_{1,n}))$$$
This value attains maximum when $$$a_{1,1} = 2n$$$, $$$a_{2,n} = 2n-1$$$, $$$(a_{1,1} + a_{2,2} + a_{1,3} + a_{2,4} + \cdots + a_{2,n}) = ((n+1) + (n+2) + (n+3) + \cdots + 2n)$$$ and $$$(a_{2,1} + a_{1,2} + a_{2,3} + a_{1,4} + \cdots + a_{1,n}) = (1 + 2 + 3 + \cdots + n)$$$, which is $$$(2n + (2n - 1) + (\frac{(n)((n+1)+2n)}{2}) - (\frac{(n)(1+n)}{2})) = (n^2 + 4n - 1)$$$.
Therefore, the upper bound for the maximum cost is $$$\lfloor \frac{n^2 + 4n - 1}{2} \rfloor = \frac{1}{2}n^2 + 2n - 1$$$. We will now show that the construction above meets the upper bound.
Let $$$P_k$$$ be the cost of the path $$$a_{1,1}, a_{1,2}, a_{1,3}, \cdots, a_{1,k}, a_{2,k}, a_{2,k+1}, \cdots, a_{2,n}$$$.
Observe that $$$P_k - P_{k-1} = (-1)^k(a_{1,k} - a_{2,k-1}) = (-1)^k$$$, as the paths differ by exactly $$$2$$$ grids and $$$a_{1,k} - a_{2,k-1} = 1$$$ (from the above construction).
Calculating $$$P$$$,
$$$P_1 = (2n - 1) - 2 + (n + 2) - 4 + (n + 4) - \cdots - (n - 2) + 2n = (2n - 1) + (n)(\frac{n}{2} - 1) - n + 2n = \frac{1}{2}n^2 + 2n - 1$$$
$$$P_2 = P_1 + (-1)^2 = \frac{1}{2}n^2 + 2n$$$
$$$P_3 = P_2 + (-1)^3 = \frac{1}{2}n^2 + 2n - 1$$$
$$$\cdots$$$
Therefore, $$$min(P) = \frac{1}{2}n^2 + 2n - 1$$$, which achieves the upper bound.
Insights on how to find the construction
(This is a very informal proof. See "Proof" below for a formal proof.)
First of all, due to the checkered pattern, $$$a_{1,1}, a_{2,2}, a_{1,3}, \cdots, a_{2,n}$$$ should be filled with $$$n+1, n+2, n+3, \cdots, 2n$$$, and $$$a_{2,1}, a_{1,2}, a_{2,3}, \cdots, a_{1,n}$$$ should be filled with $$$1, 2, 3, \cdots, n$$$. In particular, $$$a_{1,1}$$$ and $$$a_{2,n}$$$ should be $$$2n-1$$$ and $$$2n$$$.
Next, as we are trying to maximise the minimum, the difference between paths shouldn't be large (since the minimum path will be smaller if the difference is larger). Notice that a path consists of a prefix of $$$a_1$$$ and a suffix of $$$a_2$$$, and the difference between $$$2$$$ adjacent paths is
Unable to parse markup [type=CF_MATHJAX]
(depending on the parity of $$$k$$$). It is optimal for the difference to be as small as possible (which is $$$1$$$).
Finally, it is optimal that $$$a_{1,k} - a_{2,k-1}$$$ stays constant in the whole array. If they are different, the difference between $$$2$$$ paths (not adjacent) will be larger than $$$1$$$, which is suboptimal.
Proof
Consider the cost of the top right path and bottom left path.
The cost of the top right path is $$$a_{1,1} - a_{1,2} + a_{1,3} - \cdots - a_{1,n} + a_{2,n}$$$.
The cost of the bottom right path is $$$a_{1,1} - a_{2,1} + a_{2,2} - a_{2,3} + ... + a_{2,n}$$$.
Summing both values, we get
$$$a_{1,1} + a_{2,n} + ((a_{1,1} - a_{1,2} + a_{1,3} - a_{1,4} + ... - a_{1,n}) + (-a_{2,1} + a_{2,2} - a_{2,3} + ... + a_{2,n}))$$$
which is equal to
$$$a_{1,1} + a_{2,n} + ((a_{1,1} + a_{2,2} + a_{1,3} + a_{2,4} + \cdots + a_{2,n}) - (a_{2,1} + a_{1,2} + a_{2,3} + a_{1,4} + \cdots + a_{1,n}))$$$
This value attains maximum when $$$a_{1,1} = 2n$$$, $$$a_{2,n} = 2n-1$$$, $$$(a_{1,1} + a_{2,2} + a_{1,3} + a_{2,4} + \cdots + a_{2,n}) = ((n+1) + (n+2) + (n+3) + \cdots + 2n)$$$ and $$$(a_{2,1} + a_{1,2} + a_{2,3} + a_{1,4} + \cdots + a_{1,n}) = (1 + 2 + 3 + \cdots + n)$$$, which is $$$(2n + (2n - 1) + (\frac{(n)((n+1)+2n)}{2}) - (\frac{(n)(1+n)}{2})) = (n^2 + 4n - 1)$$$.
Therefore, the upper bound for the maximum cost is $$$\lfloor \frac{n^2 + 4n - 1}{2} \rfloor = \frac{1}{2}n^2 + 2n - 1$$$. We will now show that the construction above meets the upper bound.
Let $$$P_k$$$ be the cost of the path $$$a_{1,1}, a_{1,2}, a_{1,3}, \cdots, a_{1,k}, a_{2,k}, a_{2,k+1}, \cdots, a_{2,n}$$$.
Observe that $$$P_k - P_{k-1} = (-1)^k(a_{1,k} - a_{2,k-1}) = (-1)^k$$$, as the paths differ by exactly $$$2$$$ grids and $$$a_{1,k} - a_{2,k-1} = 1$$$ (from the above construction).
Calculating $$$P$$$,
$$$P_1 = (2n - 1) - 2 + (n + 2) - 4 + (n + 4) - \cdots - (n - 2) + 2n = (2n - 1) + (n)(\frac{n}{2} - 1) - n + 2n = \frac{1}{2}n^2 + 2n - 1$$$
$$$P_2 = P_1 + (-1)^2 = \frac{1}{2}n^2 + 2n$$$
$$$P_3 = P_2 + (-1)^3 = \frac{1}{2}n^2 + 2n - 1$$$
$$$\cdots$$$
Therefore, $$$min(P) = \frac{1}{2}n^2 + 2n - 1$$$, which achieves the upper bound.
Implementation
#include <bits/stdc++.h>
using namespace std;
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        
        int ans[3][n + 1];
        
        ans[1][1] = 2 * n - 1;
        ans[2][n] = 2 * n;

        for (int i = 2; i <= n; i++) {
            if (i % 2 == 0) {
                ans[1][i] = i;
                ans[2][i - 1] = i - 1;
            } else {
                ans[1][i] = n + (i - 1);
                ans[2][i - 1] = n + (i - 1) - 1;
            }
        }

        for (int i = 1; i <= 2; i++) {
            for (int j = 1; j <= n; j++) {
                cout << ans[i][j] << (j == n ? '\n' : ' ');
            }
        }
    }
}
Question
Can you find a construction for a $$$n \times n$$$ grid (and give a formal proof)? (We don't have a solution)
--------------------------------------------------
Problem ID: 1816A
Editorial Content:
1816A - Ian Visits Mary
Editorial
Let us show that Ian can get to Mary within two moves. Indeed, consider $$$(x_1,y_1)$$$ and $$$(x_2,y_2)$$$ where $$$x_2-x_1=1$$$, since the value of the $$$x$$$-coordinates of a point lying on the segment joining $$$(x_1,y_1)$$$ and $$$(x_2,y_2)$$$, and is not at the endpoints, is strictly between $$$x_1$$$ and $$$x_2$$$, but there are no integers strictly between $$$x_1$$$ and $$$x_2$$$, the point must not be a lattice point. Similarly, no lattice points lie on the segment joining $$$(x_1,y_1)$$$ and $$$(x_2,y_2)$$$ with $$$y_2-y_1=1$$$ except for the endpoints. Therefore, Ian can jump from $$$(0,0)$$$ to $$$(x-1,1)$$$ to $$$(x,y)$$$.
Implementation
#include<bits/stdc++.h>
using namespace std;
 
void solve(){
    int a,b;
    cin >> a >> b;
    cout << 2 << "\n" << a-1 << ' ' << 1 << "\n" << a << ' ' << b << "\n";
}
 
int main(){
    int t;
    cin >> t;
    while(t--){
        solve();
    }
}
Remark
Originally, the problem asks you for the minimal amount of steps, which requires gcd. Since it would be too hard, we had a quite last-minute change to the current statement.
--------------------------------------------------
Problem ID: 1815F
Editorial Content:
1815F - OH NO1 (-2-3-4)
Key Idea 1
Go through from vertex $$$1$$$ through $$$n$$$ and decided their final weights in this order. When deciding the weights for $$$v$$$ , make sure it is different from $$$w$$$ if $$$w < v$$$ and $$$v$$$ is adjacent to $$$w$$$. Ignore vertices $$$x$$$ where $$$x$$$ is adjacent to $$$v$$$ but have $$$x > v$$$.
Key Idea 2
If there are at least $$$d+1$$$ options to take from, and $$$d$$$ of them are not available, then there is still some option to take.
Editorial
Let's try to decide the final weights of $$$1$$$ through $$$n$$$ in this order. For a triangle $$$a<b<c$$$, we call $$$a$$$ the first vertex, $$$b$$$ the second vertex, $$$c$$$ the third vertex. Consider each triangle individually, if we can achieve the following task then we are done: By only adjusting edges of this triangle:
There is at least one option for the first vertex
After fixing a particular option for the first vertex, there are at least two options for the the second vertex
After fixing particular options for the first two vertices, there are at least three options for the third vertex
To see this is enough: Suppose a vertex $$$v$$$ is in $$$A$$$ triangles as the first vertex, $$$B$$$ triangles as the second vertex, and $$$C$$$ triangles as the third vertex. It is not difficult to see $$$v$$$ have exactly $$$B + 2 \times C$$$ neighbours that are of smaller index, and there are at least $$$B+ 2\times C+ 1$$$ options.
Finally, by using the following specific edge weights, the goal can be achieved:
$$$1,4,4$$$ gives weights $$$5,5,8$$$
$$$2,3,3$$$ gives weights $$$5,5,6$$$
$$$3,2,2$$$ gives weights $$$5,5,4$$$
$$$1,4,3$$$ gives weights $$$5,4,7$$$
$$$2,3,2$$$ gives weights $$$5,4,5$$$
$$$3,2,1$$$ gives weights $$$5,4,3$$$
These numbers aren't exactly just completely random. You can see that they are composed of two components: A $$$(+1,-1,-1)$$$ part and a $$$(0,0,-1)$$$ part. Upto two copies of the first option and upto one copy of the second option have been used.
There is also a simple solution in this specific case where $$$G$$$ consists of triangles and use only weights 1,2,3.
This is a special case of 1-2-3 conjecture, which states that the above statement holds for arbitrary graph and using only the weights 1,2,3 (and no 4). Recently (March 2023) it has a claimed proof. The claimed algorithm is far from a linear time algorithm however.
Implementation (Tester: gamegame)
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define fi first
#define se second
const ll mod=998244353;
const int N=2e6+1;
ll n,m;
vector<pair<int,int> >adj[N];
array<int,3>e[N];
array<int,3>f[N];
ll a[N],b[N];
pair<int,int>vis[10000005];
void solve(){
    cin >> n >> m;
    for(int i=1; i<=n ;i++){
        adj[i].clear();
    }
    for(int i=1; i<=n ;i++){
        cin >> a[i];
    }
    for(int i=1; i<=m ;i++){
        for(int j=0; j<3 ;j++){
        cin >> e[i][j];
        adj[e[i][j]].push_back({i,j});
    }
        f[i][0]=3;
        f[i][1]=1;
        f[i][2]=1;
        a[e[i][0]]+=f[i][0]+f[i][2];
        a[e[i][1]]+=f[i][1]+f[i][0];
        a[e[i][2]]+=f[i][2]+f[i][1];
    }
    for(int i=1; i<=n ;i++){
        for(auto c:adj[i]){
        for(int d=0; d<c.se ;d++){
        vis[a[e[c.fi][d]]]={c.fi,d};
    }
    }
        while(vis[a[i]].fi!=0){
            int ed=vis[a[i]].fi;
            if(i==e[ed][1]){
                a[i]++;
                a[e[ed][2]]++;
                f[ed][1]++;
            }
            else{
                a[i]+=2;

                f[ed][0]--;
                f[ed][1]++;
                f[ed][2]++;
            }
        }

        for(auto c:adj[i]){
        for(int d=0; d<c.se ;d++){
        vis[a[e[c.fi][d]]]={0,0};
    }
    }
    }
    for(int i=1; i<=m ;i++){
        cout << f[i][0] << ' ' << f[i][1] << ' ' << f[i][2] << '\n';
    }
}
int main(){
    ios::sync_with_stdio(false);cin.tie(0);
    int t;cin >> t;while(t--) solve();
}
--------------------------------------------------
Problem ID: 1815E
Editorial Content:
1815E - Bosco and Particle
Hint 1
If the oscillator string is periodic, what should we do?
Hint 2
Use the case when $$$n=1$$$ to help you calculate the answer.
Observation 1
Observe that whole process is periodic.
Note that the process is reversible. If you are in some state $$$s$$$, consisting of position of the particle and the current state position of each oscillator, you can decide the next state and the previous state. This implies the state transition graph is a permutation, so it decomposes into cycles.
Editorial
Firstly, we can easily see that removing cycles for the oscillator strings does not affect the answer. To help us calculating the answer easier, we have to remove cycle. You can remove cycle using any fast enough string algorithm such as KMP.
It is not difficult to see that if all strings are non-periodic, then being periodic with respect to the particle position $$$x$$$ is the same as being periodic with respect to both $$$x$$$ and all oscillator states.
Let $$$a_i$$$ be the number of times the particle hits oscillator $$$i$$$ when moving downwards and $$$b_i$$$ be the number of times the particle hits oscillator i when moving upwards in each cycle.
For each oscillator $$$i$$$, consider the case when $$$n=1$$$ and oscillator $$$i$$$ is the only oscillator. Let $$$a'_i$$$ be the number of times the particle hits oscillator $$$i$$$ when moving downwards and $$$b'_i$$$ be the number of times the particle hits the oscillator $$$i$$$ when moving upwards in each cycle.
Then we must have $$$a_i=ka'_i$$$ and $$$b_i=kb'_i$$$ for some positive integer k. Also, we must have $$$a_i=b_{i-1}$$$ as the number of times the particle goes from oscillator $$$i-1$$$ to oscillator $$$i$$$ is same as the number of times the particle goes from oscillator $$$i$$$ to oscillator $$$i-1$$$. It can be shown that the smallest integers $$$a_i$$$ and $$$b_i$$$ satisfying the above constraints must be the period.
We can calculate the the smallest such integers, by factoring each $$$k$$$ and maintain the primes. In other words, we can separately consider the $$$p$$$-adic valuation of the $$$a'_i$$$'s and $$$b'_i$$$'s to get the $$$p$$$-adic valuation of $$$a_i$$$'s and $$$b_i$$$'s for each prime. Below is a visualisation:
Notice the answer is $$$2(a_1+a_2+...+a_n+b_n)$$$, which can be easily calculated. So we are done.
Implementation
#include<bits/stdc++.h>
using namespace std;
 
vector <int> prime;
bool p[1000001];
 
const long long int mod=998244353;
 
void init(){
    p[1]=0;
    for(int i=2;i<=1000000;i++){
        p[i]=1;
    }
    for(int i=2;i<=1000000;i++){
        if(p[i]){
            prime.push_back(i);
        }
        for(int j=i;j<=1000000;j+=i){
            p[j]=0;
        }
    }
    return;
}
 
long long int bigmod(long long int n,long long int k){
    long long int pown=n,ans=1;
    while(k>0){
        if(k%2){
            ans*=pown;
            ans%=mod;
        }
        pown*=pown;
        pown%=mod;
        k/=2;
    }
    return ans;
}
 
int vp(long long int n,int p){
    int ans=0;
    if(n==0){
        return 10000000;
    }
    while(n%p==0){
        n/=p;
        ans++;
    }
    return ans;
}
 
string rpc(string str){
    int i=0;
    int len=str.length();
    int j=-1;
    int nextval[len];
    nextval[i]=-1;
    while (i<len){
        if (j==-1||str[i]==str[j]){
            i++;
            j++;
            nextval[i]=j;
        }
        else
        j=nextval[j];
    }
    if ((len)%(len-nextval[len])==0) return str.substr(0,len-nextval[len]);
    else return str;
}
 
int main(){
    init();
    int n;
    cin >> n;
    int lim=n;
    pair<int,int> arr[n];
    for(int i=0;i<n;i++){
        string s;
        cin >> s;
        s=rpc(s);
        int x=0,y=0,ptr=0;
        bool b=true;
        do{
            if(b){
                x++;
            }
            else{
                y++;
            }
            if(s[ptr]=='0'){
                b=1-b;
            }
            ptr++;
            ptr%=s.length();
        }while(!b||(ptr!=0));
        arr[i]={x,y};
        if(y==0&&lim==n){
            lim=i;
        }
    }
    long long int times[n+1];
    for(int i=0;i<=n;i++){
        times[i]=1;
    }
    for(int i=0;i<prime.size();i++){
        int p=prime[i],curl=0,curr=0,difp[lim+1]={0};
        for(int j=1;j<=lim;j++){
            int l=vp(arr[j-1].first,p);
            int r=vp(arr[j-1].second,p);
            if(curr<l){
                curl+=(l-curr);
                curr=r;
            }
            else{
                curr+=(r-l);
            }
            difp[j]=r-l;
        }
        int cur=curl;
        for(int j=0;j<=lim;j++){
            cur+=difp[j];
            times[j]*=bigmod(p,cur);
            times[j]%=mod;
        }
    }
    long long int ans=0;
    for(int i=0;i<=lim;i++){
        ans+=times[i];
        ans%=mod;
    }
    cout << (2*ans)%mod << endl;
}
--------------------------------------------------
Problem ID: 1815D
Editorial Content:
1815D - XOR Counting
Hint 1
The cases when $$$m=1$$$ and $$$m\ge3$$$ are relatively much easier than when $$$m=2$$$.
Hint 2
When $$$m=2$$$, perform an $$$O(\log n)$$$ DP on answer. Notice we have to DP another thing as well. What is it?
Editorial
If $$$m=1$$$, it is clear that we only can have $$$a_1=n$$$ so the answer is $$$n$$$.
If $$$m\ge3$$$, $$$\left[x,\frac{n-x}2,\frac{n-x}2,0,0,...\right]$$$ gives a xor of $$$x$$$, so all $$$x$$$ with the same parity as $$$n$$$ and at most $$$n$$$ can be achieved. Notice xor and sum are identical in terms of parity, and $$$a\oplus b\le a+b$$$. So these restrict that only values of $$$x$$$ that has same parity with $$$n$$$ and is at most $$$n$$$ is possible as a result of the xor. Therefore, we can use $$$O(1)$$$ to calculate the sum of all non-negative integers at most $$$n$$$ and have same parity as $$$n$$$.
It remains to handle the case when $$$m=2$$$. We create the functions $$$f(n)$$$ and $$$g(n)$$$, where $$$f(n)$$$ is the sum of all possible values of the xor and $$$g(n)$$$ counts the number of all possible values of the xor. We then consider the following:
If $$$n$$$ is odd, then one of $$$a_1,a_2$$$ is even and the other is odd. WLOG assume $$$a_1$$$ is even and $$$a_2$$$ is odd. Then we let $$$a_1'=\frac{a_1}2$$$ and $$$a_2'=\frac{a_2-1}2$$$. We can see that $$$a_1'+a_2'=\frac{n-1}2$$$ and $$$a_1\oplus a_2=2(a_1'\oplus a_2')+1$$$. Hence we know that $$$g(n)=g\left(\frac{n-1}2\right)$$$, and $$$f(n)=2f\left(\frac{n-1}2\right)+g\left(\frac{n-1}2\right)$$$.
If $$$n$$$ is even, there are two cases. If $$$a_1$$$ and $$$a_2$$$ are both even, we let $$$a_1'=\frac{a_1}2$$$ and $$$a_2'=\frac{a_2}2$$$. We can see that $$$a_1'+a_2'=\frac{n}2$$$ and $$$a_1\oplus a_2=2(a_1'\oplus a_2')$$$. If $$$a_1$$$ and $$$a_2$$$ are both odd, we let $$$a_1'=\frac{a_1-1}2$$$ and $$$a_2'=\frac{a_2-1}2$$$. We can see that $$$a_1'+a_2'=\frac{n}2-1$$$ and $$$a_1\oplus a_2=2(a_1'\oplus a_2')$$$. Hence we know that $$$f(n)=2f\left(\frac{n}2\right)+2f\left(\frac{n}2-1\right)$$$, and $$$g(n)=g\left(\frac{n}2\right)+g\left(\frac{n}2-1\right)$$$.
So we can simply DP. It can be seen that the time complexity is $$$O(\log n)$$$ per test case, so we are done.
Implementation
#include<bits/stdc++.h>
using namespace std;

unordered_map <long long int,long long int> npos,spos;

const int MOD=998244353;

long long int solve(long long int n){
    if(npos[n]!=0){
        return spos[n];
    }
    if(n%2==1){
        solve(n/2);
        npos[n]=npos[n/2];
        spos[n]=spos[n/2]*2+npos[n/2];
        spos[n]%=MOD;
    }
    else{
        solve(n/2); solve(n/2-1);
        npos[n]=npos[n/2]+npos[n/2-1];
        spos[n]=(spos[n/2]+spos[n/2-1])*2;
        spos[n]%=MOD;
    }
    return spos[n];
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    npos[0]=1;
    spos[0]=0;
    int t;
    cin >> t;
    while(t--){
        long long int n,m;
        cin >> n >> m;
        if(m==2){
            cout << solve(n) << endl;
        }
        else if(m==1){
            cout << n%MOD << endl;
        }
        else if(n%2==0){
            cout << (((n/2)%MOD)*((n/2+1)%MOD))%MOD << endl;
        }
        else{
            cout << (((n/2+1)%MOD)*((n/2+1)%MOD))%MOD << endl;
        }
    }
}
--------------------------------------------------
Problem ID: 1815C
Editorial Content:
1815C - Between
Editorial
Construct a graph with $$$n$$$ vertices and add a directed edge $$$a \rightarrow b$$$ if between every two $$$a$$$ there must be a $$$b$$$.
Let $$$v_a$$$ be the number of occurrences of $$$a$$$. The key observation is that if $$$a \rightarrow b$$$, then $$$v_{a} \leq v_{b} + 1$$$.
Suppose $$$a_k \rightarrow a_{k-1} \rightarrow \cdots a_1$$$ is a directed path, where $$$a_1 = 1$$$. Then since $$$v_1 = 1$$$, we must have $$$v_{a_i} \leq i$$$. In other words, $$$v_s \leq d_s $$$. where $$$d_s$$$ is one plus the length of the shortest directed path from $$$s$$$ to $$$1$$$.
Therefore, the total array length does not exceed $$$\sum_{i=1}^{n} d_i$$$. We claim that we can achieve this.
It is easy to calculate the $$$d_s$$$ by a BFS. Let $$$T_i$$$ consists of vertices $$$x$$$ such that $$$v_x = s$$$. Let $$$M$$$ the largest value of $$$d_i$$$ among all $$$i \in {1,2\cdots n}$$$. Consider
$$$ [T_M] , [T_{M-1}][T_M] , [T_{M-2}][T_{M-1}][T_{M}],\cdots [T_1][T_2][T_3]\cdots [T_m]$$$
where for each $$$i$$$, vertices in various occurrences of $$$T_i$$$ must be arranged in the same order.
It is easy to check that this construction satisfies all the constraints and achieve the upper bound $$$\sum_{i=1}^{n} d_i$$$. Thus, this output is correct.
The sequence can be arbitrarily long if and only if there is some $$$v$$$ that does not have a path directed to $$$1$$$. To see this, let $$$S$$$ be the set of vertices that do not have path directed to $$$1$$$, then the following construction gives an arbitrarily long output that satisfy all constraints:
$$$ 1 [S][S][S]\cdots $$$
Implementation
#include<bits/stdc++.h>
using namespace std;

void solve(){
    int n,m;
    cin >> n >> m;
    vector <int> adj[n+1];
    int occ[n+1];
    occ[1]=1;
    for(int i=0;i<m;i++){
        int x,y;
        cin >> x >> y;
        adj[y].push_back(x);
    }
    for(int i=2;i<=n;i++){
        occ[i]=0;
    }
    queue <int> bfs;
    bfs.push(1);
    while(bfs.size()>0){
        int f=bfs.front();
        bfs.pop();
        for(int i=0;i<adj[f].size();i++){
            if(occ[adj[f][i]]==0){
                occ[adj[f][i]]=occ[f]+1;
                bfs.push(adj[f][i]);
            }
        }
    }
    vector <int> v[n+1];
    int ans=0;
    for(int i=1;i<=n;i++){
        if(occ[i]==0){
            cout << "INFINITE\n";
            return;
        }
        v[occ[i]].push_back(i);
        ans+=occ[i];
    }
    cout << "FINITE\n" << ans << endl;
    for(int i=n;i>=1;i--){
        for(int j=n;j>=i;j--){
        if(i%2!=j%2){
            continue;
        }
        for(int k=0;k<v[j].size();k++){
        cout << v[j][k] << ' ';
    }
    }
    }
    for(int i=2;i<=n;i++){
        for(int j=n;j>=i;j--){
        if(i%2!=j%2){
            continue;
        }
        for(int k=0;k<v[j].size();k++){
        cout << v[j][k] << ' ';
    }
    }
    }
    cout << endl;
    return;
}

int main(){
    int t;
    cin >> t;
    while(t--){
        solve();
    }
}
--------------------------------------------------
Problem ID: 1815B
Editorial Content:
1815B - Sum Graph
Hint 1
Consider using a type 1 operation on $$$x=n+1$$$ and $$$x=n+2$$$. What do you notice?
Hint 2
The resulting graph, after performing type 1 operations according to hint 1, will be a chain (e.g. when $$$n=6$$$, it should look like $$$1 - 6 - 2 - 5 - 3 - 4$$$). Now, try to figure out a position $$$k$$$ such that node $$$p_k$$$ is one of the endpoints of the chain. Once you figure that out, how can you make use of this to solve the full problem?
Editorial
There are many ways to solve this problem. My original solution is rather difficult to implement correctly, and a bit complicated. During round testing, tester
rsj
found an alternative solution, which is, in my opinion, one that's a lot easier to understand and implement.
Firstly, use a type 1 operation on $$$x=n+1$$$ and $$$x=n+2$$$ (or you can do $$$x=n$$$ and $$$x=n+1$$$). Then, the graph should look like a chain (e.g. when $$$n=6$$$, it should look like $$$1 - 6 - 2 - 5 - 3 - 4$$$). Note that there are actually two edges between each pair of directly connected nodes, but it is irrelevant to the task.
Next, use a type 2 query on all pairs of $$$(1,i)$$$ where $$$2 \le i \le n$$$. Take the maximum of the query results. Let $$$k$$$ be one of the values such that the query result of $$$(1,k)$$$ is maximum among all $$$(1,i)$$$. It is easy to see that, node $$$p_k$$$ is one of the endpoints of the chain.
Afterwards, use a type 2 query on all pairs of $$$(k,i)$$$ where $$$1 \le i \le n$$$ and $$$i \ne k$$$. Since node $$$p_k$$$ is an endpoint of the chain, all the query results are distinct and you can recover the exact node that each query result corresponds to.
A problem arises that it is unclear about which endpoint node $$$p_k$$$ actually is. But this issue can be solved easily: since the problem allows outputting two permutations that can be $$$p$$$, just try both endpoints and output the corresponding permutations.
In total, $$$2$$$ type 1 operations and $$$2n-2$$$ type 2 operations are used, which sums up to $$$2n$$$ operations. As stated in the sample description, you don't even need any operations when $$$n=2$$$. It is also easy to see that the actual number of operations required is $$$2n-1$$$ since there is a pair of duplicate type 2 operations, but we allow duplicating the operation anyway.
Implementation
#include <bits/stdc++.h>
using namespace std;
void solve(int tc) {
  int n; cin >> n;
  cout << "+ " << n+1 << endl;
  cout << "+ " << n+2 << endl;
  int l = 1, r = n;
  int ord[n+1];
  for(int i=1; i<=n; i++) {
    if(i & 1) ord[i] = l++;
    else ord[i] = r--;
  }
  int dist1[n+1];
  dist1[1] = 0;
  int ma = 0, id;
  for(int i=2; i<=n; i++) {
    cout << "? 1 " << i << endl;
    cin >> dist1[i];
    if(dist1[i] > ma) {
      ma = dist1[i];
      id= i;
    }
  }
  int p[n+1], q[n+1];
  p[id] = ord[1];
  q[id] = ord[n];
  for(int i=1; i<=n; i++) {
    if(i != id) {
      cout << "? " << id << " " << i << endl;
      int x;
      cin >> x;
      p[i] = ord[x+1];
      q[i] = ord[n-x];
    }
  }
  cout << "!";
  for(int i=1; i<=n; i++) cout << " " << p[i];
  for(int i=1; i<=n; i++) cout << " " << q[i];
  cout << endl;

}
int32_t main() {
  int t = 1; cin >> t;
  for(int i=1; i<=t; i++) solve(i);
}
Harder version
Try to solve the problem using at most $$$n + \left \lfloor \frac{n}{2} \right \rfloor + 2$$$ queries.
Solution to harder version
Refer to this
comment
. Thanks to
-1e11
and
FatihSolak
for the solution. (To pass this problem using this solution, optimizations for $$$n=2$$$ are needed, as mentioned in the editorial section.)
Another way of solving the harder version provided by
sysia
: refer to this
comment
.
--------------------------------------------------
Problem ID: 1815A
Editorial Content:
1815A - Ian and Array Sorting
Hint 1
Consider difference array $$$[a_2-a_1,a_3-a_2,...,a_n-a_{n-1}]$$$. If the original array is non-decreasing, what properties does the difference array have?
Hint 2
Operations to the original array correspond to what operations in the difference array?
Editorial
We consider the difference array $$$b_i=a_{i+1}-a_i$$$ ($$$1\le i\le n-1$$$). Then the original array is non-decreasing if and only if all elements of the difference array is non-negative. We can see that either $$$b_i$$$ is increased by $$$1$$$ and $$$b_{i+2}$$$ is decreased by $$$1$$$ or vice versa for $$$1\le i\le n-3$$$, $$$b_2$$$ is increased or decreased by $$$1$$$ or $$$b_{n-2}$$$ is increased or decreased by $$$1$$$.
If $$$n$$$ is odd, then $$$n-2$$$ is odd. What we can do is to increase $$$b_2$$$ and $$$b_{n-2}$$$ enough number of times, and then do $$$b_i$$$ increase by $$$1$$$ and $$$b_{i+2}$$$ decrease by $$$1$$$ or vice versa enough times to distribute the values to other elements of $$$b$$$. Doing this, we can make all of the elements of $$$b$$$ non-negative, which is what we want. So we output 'YES' no matter what for odd $$$n$$$.
For even $$$n$$$, $$$n-2$$$ is even. So by increasing $$$b_2$$$ and $$$b_{n-2}$$$ enough number of times, then distributing, we can only ensure that the elements of $$$b$$$ with even indices are non-negative. Since the only operation that affects odd indices is increasing $$$b_i$$$ by $$$1$$$ and decreasing $$$b_{i+2}$$$ by $$$1$$$ or vice versa, we can see that the sum of the elements of $$$b$$$ with odd indices will not change. If the sum of the elements of $$$b$$$ with odd indices is at least $$$0$$$, we can distribute the values such that in the end, all of them are non-negative, so we should output 'YES'. But if the sum of elements of $$$b$$$ with odd indices is negative, there must exist a negative $$$b_i$$$ in the end, and we should output 'NO'.
Implementation
#include<bits/stdc++.h>
using namespace std;

void solve(){
    int n;
    cin >> n;
    int arr[n];
    long long int altsum=0;
    for(int i=0;i<n;i++){
        cin >> arr[i];
        if(i%2==0){
            altsum-=arr[i];
        }
        else{
            altsum+=arr[i];
        }
    }
    if(n%2==1||altsum>=0){
        cout << "YES\n";
    }
    else{
        cout << "NO\n";
    }
    return;
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    int t;
    cin >> t;
    while(t--){
        solve();
    }
}
--------------------------------------------------
Problem ID: 1814F
Editorial Content:
1814F - Communication Towers
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

#define sz(a) int((a).size())

const int N = 200002;
const int V = 50 * N;

using pt = pair<int, int>;

int n, m;
pt a[N];
vector<pt> t[4 * N];
int p[N], rk[N], vs[N];
int cntV;
pt g[V];
bool ans[V];

void upd(int v, int l, int r, int L, int R, pt e) {
  if (L >= R) return;
  if (l == L && r == R) {
    t[v].push_back(e);
    return;
  }
  int m = (l + r) / 2;
  upd(v * 2 + 1, l, m, L, min(m, R), e);
  upd(v * 2 + 2, m, r, max(m, L), R, e);
}

int k;
int* ptr[V];
int val[V];

void upd(int &a, int b) {
  ptr[k] = &a;
  val[k] = a;
  k += 1;
  a = b;
}

int getp(int v) {
  return p[v] == v ? v : getp(p[v]);
}

void unite(int v, int u) {
  v = getp(v), u = getp(u);
  if (v == u) return;
  if (rk[v] > rk[u]) swap(v, u);
  upd(p[v], u);
  g[cntV] = {vs[v], vs[u]};
  upd(vs[u], cntV++);
  if (rk[v] == rk[u])
    upd(rk[u], rk[u] + 1);
}

void solve(int v, int l, int r) {
  int cur = k;
  for (auto& [v, u] : t[v]) 
    unite(v, u);
  if (l + 1 == r) {
    ans[vs[getp(0)]] = 1;
  } else {
    int m = (l + r) / 2;
    solve(v * 2 + 1, l, m);
    solve(v * 2 + 2, m, r);
  }
  while (k > cur) {
    k -= 1;
    (*ptr[k]) = val[k];
  }
}

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  
  cin >> n >> m;
  for (int i = 0; i < n; ++i)
    cin >> a[i].first >> a[i].second;
  for (int i = 0; i < m; ++i) {
    int x, y;
    cin >> x >> y;
    --x; --y;
    int L = max(a[x].first, a[y].first);
    int R = min(a[x].second, a[y].second);
    upd(0, 0, N, L, R + 1, {x, y});
  }
  
  for (int i = 0; i < n; ++i) {
    p[i] = i;
    rk[i] = 1;
    vs[i] = i;
    g[i] = {-1, -1};
  }
  
  cntV = n;
  solve(0, 0, N);
  
  queue<int> q;
  for (int i = 0; i < cntV; ++i) if (ans[i]) 
    q.push(i);
  
  while (!q.empty()) {
    int v = q.front(); q.pop();
    for (int u : {g[v].first, g[v].second}) {
      if (u != -1 && !ans[u]) {
        ans[u] = true;
        q.push(u);
      }
    }
  }
  
  for (int i = 0; i < n; ++i) if (ans[i])
    cout << i + 1 << ' ';
}
--------------------------------------------------
Problem ID: 1814E
Editorial Content:
1814E - Chain Chips
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

typedef long long li;

const li INF = (li)(1e18);
const int N = 200043;

struct data
{
	array<array<long long, 2>, 2> d;
	data() {
	    for(int i = 0; i < 2; i++)
			for(int j = 0; j < 2; j++)
				d[i][j] = INF;
	};
	data(li x)
	{
		for(int i = 0; i < 2; i++)
			for(int j = 0; j < 2; j++)
				d[i][j] = INF;
		d[0][0] = 0;
		d[1][1] = x;
	};
	data(data l, data r)
	{
		for(int i = 0; i < 2; i++)
			for(int j = 0; j < 2; j++)
				d[i][j] = INF;
		for(int i = 0; i < 2; i++)
			for(int j = 0; j < 2; j++)
				for(int k = 0; k < 2; k++)
					for(int x = 0; x < 2; x++)
					{
						if(j == 0 && k == 0) continue;
						d[i][x] = min(d[i][x], l.d[i][j] + r.d[k][x]);
					}
	};
};

data T[4 * N];
li a[N];

void recalc(int v)
{
	T[v] = data(T[v * 2 + 1], T[v * 2 + 2]);
}

void build(int v, int l, int r)
{
	if(l == r - 1) T[v] = data(a[l]);
	else
	{
		int m = (l + r) / 2;
		build(v * 2 + 1, l, m);
		build(v * 2 + 2, m, r);
		recalc(v);
	}
}

void upd(int v, int l, int r, int pos, li val)
{
	if(l == r - 1)
	{
		a[l] = val;
		T[v] = data(a[l]);
	}
	else
	{
		int m = (l + r) / 2;
		if(pos < m)
			upd(v * 2 + 1, l, m, pos, val);
		else
			upd(v * 2 + 2, m, r, pos, val);
		recalc(v);
	}
}

int main()
{
	int n;
	scanf("%d", &n);
	for(int i = 0; i < n - 1; i++)
	{
		scanf("%lld", &a[i]);
	}
	build(0, 0, n - 1);
	int q;
	scanf("%d", &q);
	for(int i = 0; i < q; i++)
	{
		int x;
		li k;
		scanf("%d %lld", &x, &k);
		upd(0, 0, n - 1, x - 1, k);
		printf("%lld\n", T[0].d[1][1] * 2);
	}
}
--------------------------------------------------
Problem ID: 1814D
Editorial Content:
1814D - Balancing Weapons
Tutorial
Tutorial is loading...
Solution (adedalic)
fun main() {
    repeat(readln().toInt()) {
        val (n, k) = readln().split(' ').map { it.toInt() }
        val f = readln().split(' ').map { it.toLong() }
        val d = readln().split(' ').map { it.toLong() }

        fun checkAround(pos : Long) : Int {
            val qs = Array(2 * k + 1) { MutableList(0) { 0 } }

            fun inside(x : Long, pos: Long) = (pos - k <= x) && (x <= pos + k)
            for (i in f.indices) {
                var newD = maxOf(1L, pos / f[i])
                if (newD != d[i] && newD + 1 != d[i] && inside(d[i] * f[i], pos)) {
                    val id = (i + 1)
                    qs[(d[i] * f[i] - pos + k).toInt()].add(id)
                }
                repeat(2) {
                    if (inside(newD * f[i], pos)) {
                        val id = if (newD == d[i]) (i + 1) else -(i + 1)
                        qs[(newD * f[i] - pos + k).toInt()].add(id)
                    }
                    newD++
                }
                
            }

            val cntPerId = IntArray(n) { 0 }
            var cntDistinct = 0
            var cntGood = 0

            fun addToSeg(cid : Int) {
                val id = -1 + if (cid > 0) cid else -cid
                val c = if (cid > 0) 1 else 0

                if (cntPerId[id] == 0)
                    cntDistinct++
                cntPerId[id]++

                cntGood += c
            }
            fun eraseFromSeg(cid : Int) {
                val id = -1 + if (cid > 0) cid else -cid
                val c = if (cid > 0) 1 else 0

                cntPerId[id]--
                if (cntPerId[id] == 0)
                    cntDistinct--

                cntGood -= c
            }
            var ans = 0
            for (p in 0 until k)
                qs[p].forEach { addToSeg(it) }
            for (p in 0..k) {
                qs[p + k].forEach { addToSeg(it) }
                if (cntDistinct == n)
                    ans = maxOf(ans, cntGood)
                qs[p].forEach { eraseFromSeg(it) }
            }
            return n - ans
        }

        var ans = n
        for (i in f.indices) {
            ans = minOf(ans, checkAround(d[i] * f[i]))
        }
        println(ans)
    }
}
--------------------------------------------------
Problem ID: 1814C
Editorial Content:
1814C - Search in Parallel
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

int main()
{
	int t;
	scanf("%d", &t);
	for(int i = 0; i < t; i++)
	{
		int n;
		scanf("%d", &n);
		vector<int> s(2);
		for(int j = 0; j < 2; j++)
			scanf("%d", &s[j]);
		vector<pair<int, int>> a(n);
		for(int j = 0; j < n; j++)
		{
			scanf("%d", &a[j].first);
			a[j].second = j + 1;
		}
		sort(a.begin(), a.end());
		reverse(a.begin(), a.end());
		vector<vector<int>> lists(2);
		for(int j = 0; j < n; j++)
		{
			int cost1 = s[0] * (lists[0].size() + 1);
			int cost2 = s[1] * (lists[1].size() + 1);
			if(cost1 < cost2)
				lists[0].push_back(a[j].second);
			else
				lists[1].push_back(a[j].second);
		}
		for(int j = 0; j < 2; j++)
		{
		    cout << lists[j].size();
		    for(auto x : lists[j]) cout << " " << x;
		    cout << endl;
		}
	}
}
--------------------------------------------------
Problem ID: 1814B
Editorial Content:
1814B - Long Legs
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	a, b = map(int, input().split())
	ans = a + b
	for m in range(1, 100000):
		ans = min(ans, (a + m - 1) // m + (b + m - 1) // m + (m - 1))
	print(ans)
--------------------------------------------------
Problem ID: 1814A
Editorial Content:
1814A - Coins
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	n, k = map(int, input().split())
	for x in range(2):
		if n - x * k >= 0 and (n - x * k) % 2 == 0:
			print("YES")
			break
	else:
		print("NO")
--------------------------------------------------
Problem ID: 1812J
Editorial Content:
1812J - Unmysterious Language
Hint
Think of unmysterious languages.
Even Bigger Hint
We literally told you.
Solution
Tutorial is loading...
Feedback
Amazing problem
Amazing problem
Amazing problem
--------------------------------------------------
Problem ID: 1812I
Editorial Content:
1812I - Mountain Climber
Hint
How do mountains and the "YES"-words relate to each other?
Solution
Tutorial is loading...
Feedback
Amazing problem
Amazing problem
Amazing problem
--------------------------------------------------
Problem ID: 1812H
Editorial Content:
1812H - Expected Twist
Hint 1
Some details are suspiciously specific.
Hint 2
624 is a weird number. Google (or DuckDuckGo, Bing, etc.) the suspicious keywords like "624 random", "random number 624", "random twist" or something similar.
Solution
Tutorial is loading...
Feedback
Amazing problem
Amazing problem
Amazing problem
--------------------------------------------------
Problem ID: 1812G
Editorial Content:
1812G - Colour Vision
Hint 1
Besides the sample, which doesn't provide much information, we have to continue based off of the image. How can we extract information from an image, given that we only have three rectangles in a shade of green?
Hint 2
Hex?
Solution
Tutorial is loading...
Feedback
Amazing problem
Amazing problem
Amazing problem
--------------------------------------------------
Problem ID: 1812F
Editorial Content:
1812F - Factorization
Hint
Factor the first number. What do you notice?
Solution
Tutorial is loading...
Feedback
Amazing problem
Amazing problem
Amazing problem
--------------------------------------------------
Problem ID: 1812E
Editorial Content:
1812E - Not a Geometry Problem
Hint
Read the output constraint carefully!
Solution
Tutorial is loading...
Feedback
Amazing problem
Amazing problem
Amazing problem
--------------------------------------------------
Problem ID: 1812D
Editorial Content:
1812D - Trivial Conjecture
Hint 1
What is a conjecture? Is this problem really a conjecture?
Hint 2
The problem name is "Trivial Conjecture". Is it really trivial?
Hint 3
What are the most used words in the statement?
Solution
Tutorial is loading...
Feedback
Amazing problem
Amazing problem
Amazing problem
--------------------------------------------------
Problem ID: 1812C
Editorial Content:
1812C - Digits
Hint 1
$$$8$$$, $$$7$$$, and $$$30$$$ all seem to be products of some numbers in the input.
Hint 2
The answer is to print the product of all numbers in a test case, but we don't know $$$n$$$.
Solution
Tutorial is loading...
Feedback
Amazing problem
Amazing problem
Amazing problem
--------------------------------------------------
Problem ID: 1812B
Editorial Content:
1812B - Was it Rated?
Hint
Was
it rated?
Solution
Tutorial is loading...
Feedback
Amazing problem
Amazing problem
Amazing problem
--------------------------------------------------
Problem ID: 1812A
Editorial Content:
1812A - Are You a Robot?
Hint
Have you seen the "are you a robot" boxes on websites?
Solution
Tutorial is loading...
Video Editorial
Video Editorial
Feedback
Amazing problem
Amazing problem
Amazing problem
--------------------------------------------------
Problem ID: 1811G2
Editorial Content:
1811G2 - Vlad and the Nice Paths (hard version)
Tutorial
Tutorial is loading...
Solution
from sys import stdin
input = lambda: stdin.readline().strip()


M = 10 ** 9 + 7
cnk = [[0] * (5000 + 1) for i in range(5000 + 1)]


def solve():
    n, k = map(int, input().split())
    c = [-1] + [int(x) for x in input().split()]
    if k == 1:
        print(1)
        return
    dp = [[0, 0] for i in range(n + 1)]  # dp[i] = [number, max] for i prefix
    dp[0][0] = 1
    for i in range(1, n + 1):
        sz = 1
        for s in range(i - 1, - 1, -1):
            if c[s] == c[i]:
                sz += 1
                if sz == k:
                    dp[i][1] = dp[s - 1][1] + 1
                if sz >= k:
                    if dp[s - 1][1] < dp[i][1] - 1:
                        break
                    dp[i][0] += dp[s - 1][0] * cnk[sz - 2][k - 2] % M
                    dp[i][0] %= M
        if dp[i][1] < dp[i - 1][1]:
            dp[i] = [0, dp[i - 1][1]]
        if dp[i][1] == dp[i - 1][1]:
            dp[i][0] += dp[i - 1][0]
            dp[i][0] %= M
    print(dp[n][0])


for i in range(5000 + 1):
    cnk[i][0] = 1
for i in range(1, 5000 + 1):
    for j in range(1, i + 1):
        cnk[i][j] = (cnk[i - 1][j] + cnk[i - 1][j - 1]) % M

t = int(input())
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 1811G1
Editorial Content:
1811G1 - Vlad and the Nice Paths (easy version)
Tutorial
Tutorial is loading...
Solution
M = 10 ** 9 + 7


def pw(a, n):
    if n == 0:
        return 1
    b = pw(a, n // 2)
    return b * b % M * (a if n % 2 == 1 else 1) % M


def obr(x):
    return pw(x, M - 2)


def cnk(n, k):
    return fact[n] * obr(fact[k]) % M * obr(fact[n - k]) % M


def solve():
    n, k = map(int, input().split())
    c = [-1] + [int(x) for x in input().split()]
    if k == 1:
        print(1)
        return
    dp = [[0] * (n // k + 1) for i in range(n + 1)]  # dp[i][j] = number for i prefix with j blocks
    dp[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, n // k + 1):
            if j > 0:
                sz = 1
                for s in range(i - 1, - 1, -1):
                    if c[s] == c[i]:
                        sz += 1
                        if sz >= k:
                            dp[i][j] += dp[s - 1][j - 1] * cnk(sz - 2, k - 2) % M
                            dp[i][j] %= M
            dp[i][j] += dp[i - 1][j]
            dp[i][j] %= M
    for j in range(n // k, -1, -1):
        if dp[n][j] > 0:
            print(dp[n][j])
            return


t = int(input())
fact = [1] * 101
for i in range(1, 101):
    fact[i] = fact[i - 1] * i % M
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 1811F
Editorial Content:
1811F - Is It Flower?
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

int sz(int v, vector<vector<int>> &g, vector<bool> &used){
    used[v] = true;
    int s = 1;
    for(int u: g[v]){
        if(!used[u]) s += sz(u, g, used);
    }
    return s;
}

void remove(vector<int> &from, int x){
    for(int &e: from){
        if(e == x){
            swap(e, from.back());
            from.pop_back();
            return;
        }
    }
}

void solve(int tc) {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> sl(n);
    for(int i = 0; i < m; ++i){
        int u, v;
        cin >> u >> v;
        sl[--u].emplace_back(--v);
        sl[v].emplace_back(u);
    }
    int k = sqrt(n);
    if(n != k * k || m != n + k){
        cout << "NO";
        return;
    }
    for(int i = 0; i < n; ++i){
        if(sl[i].size() != 2 && sl[i].size() != 4){
            cout << "NO";
            return;
        }
    }
    vector<bool> used(n);
    if(sz(0, sl, used) != n){
        cout << "NO";
        return;
    }
    for(int i = 0; i < n; ++i){
        if(sl[i].size() == 2) continue;
        for(int j = 0; j < sl[i].size();){
            int u = sl[i][j];
            if(sl[u].size() > 2){
                remove(sl[i], u);
                remove(sl[u], i);
            }
            else{
                j++;
            }
        }
    }
    used = vector<bool>(n);
    for(int i = 0; i < n; ++i){
        if(!used[i] && sz(i, sl, used) != k){
            cout << "NO";
            return;
        }
    }
    cout << "YES";
}

bool multi = true;

signed main() {
    cout.tie(nullptr);
    int t = 1;
    if (multi)cin >> t;
    for (int i = 1; i <= t; ++i) {
        solve(i);
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1811E
Editorial Content:
1811E - Living Sequence
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <cmath>
#include <cctype>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <deque>
#include <stack>
#include <unordered_set>
#include <sstream>
#include <cstring>
#include <iomanip>
#include <queue>
#include <unordered_map>
#include <random>
#include <cfloat>
#include <chrono>
#include <bitset>
#include <complex>
#include <immintrin.h>

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);

    int32_t num_tests;
    std::cin >> num_tests;

    for(int32_t t = 0; t < num_tests; t++) {
        int64_t k;
        std::cin >> k;

        std::vector<int32_t> digits;
        while(k > 0) {
            digits.push_back(k % 9);
            k /= 9;
        }
        std::reverse(digits.begin(), digits.end());

        for(int32_t i = 0; i < digits.size(); i++)
            std::cout << (char)(digits[i] < 4 ? (digits[i] + '0') : (digits[i] + '1'));
        std::cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1811D
Editorial Content:
1811D - Umka and a Long Flight
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 50;

int fib[MAXN];

void build() {
	fib[0] = fib[1] = 1;
	for (int i = 2; i < MAXN; ++i)
		fib[i] = fib[i - 2] + fib[i - 1];
}

bool solve(int n, int x, int y) {
	if (n == 1) return true;
	if (fib[n - 1] <= y && y < fib[n])
		return false;
	if (fib[n] <= y)
		y -= fib[n];
	return solve(n - 1, y, x);
}

int main() {
	int t; cin >> t;
	build();
	while (t--) {
		int n, x, y; cin >> n >> x >> y;
		cout << (solve(n, --x, --y) ? "YES" : "NO") << '\n';
	}
}
--------------------------------------------------
Problem ID: 1811C
Editorial Content:
1811C - Restore the Array
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;

void solve(){
    int n;
    cin >> n;
    vector<int>b(n-1), a;
    for(int i = 0; i < n - 1; i++) cin >> b[i];
    a.emplace_back(b[0]);
    for(int i = 0; i < n - 2; i++){
        a.emplace_back(min(b[i], b[i + 1]));
    }
    a.emplace_back(b[n - 2]);
    for(auto &i : a) cout << i << ' ';
    cout << "\n";
}
int main(){
    int t;
    cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1811B
Editorial Content:
1811B - Conveyor Belts
Tutorial
Tutorial is loading...
Solution
def layer(n, x, y):
    return min([x, y, n + 1 - x, n + 1 - y])


def solve():
    n, x1, y1, x2, y2 = map(int, input().split())
    print(abs(layer(n, x1, y1) - layer(n, x2, y2)))


t = int(input())
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 1811A
Editorial Content:
1811A - Insert Digit
Tutorial
Tutorial is loading...
Solution
#include <iostream>

using namespace std;

void solve() {
    int n, d;
    cin >> n >> d;
    string s;
    cin >> s;
    for (int i = 0; i < n; ++i) {
        if (s[i] - '0' >= d) {
            cout << s[i];
        } else {
            cout << d;
            for (int j = i; j < n; ++j) {
                cout << s[j];
            }
            cout << '\n';
            return;
        }
    }
    cout << d << '\n';
}

int main() {
    int t;
    cin >> t;
    for (int _ = 0; _ < t; ++_) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1810H
Editorial Content:

--------------------------------------------------
Problem ID: 1810G
Editorial Content:

--------------------------------------------------
Problem ID: 1810F
Editorial Content:

--------------------------------------------------
Problem ID: 1810E
Editorial Content:

--------------------------------------------------
Problem ID: 1810D
Editorial Content:

--------------------------------------------------
Problem ID: 1810C
Editorial Content:

--------------------------------------------------
Problem ID: 1810B
Editorial Content:

--------------------------------------------------
Problem ID: 1810A
Editorial Content:

--------------------------------------------------
Problem ID: 1809G
Editorial Content:
1809G - Prediction
Tutorial
Tutorial is loading...
Solution (BledDest)
#include <bits/stdc++.h>
 
using namespace std;

const int MOD = 998244353;

int add(int x, int y)
{
    return ((x + y) % MOD + MOD) % MOD;
}

int mul(int x, int y)
{
    return x * 1ll * y % MOD;   
}

int binpow(int x, int y)
{
    int z = 1;
    while(y)
    {
        if(y % 2 == 1) z = mul(z, x);
        x = mul(x, x);
        y /= 2;
    }
    return z;
}

int inv(int x)
{
    return binpow(x, MOD - 2);    
}

int divide(int x, int y)
{
    return mul(x, inv(y));
}

int main()
{
    int n, k;
    scanf("%d %d", &n, &k);
    vector<int> a(n);
    for(int i = 0; i < n; i++)    
        scanf("%d", &a[i]);
    
    reverse(a.begin(), a.end());

    vector<int> fact(n + 1);
    fact[0] = 1;
    for(int i = 1; i <= n; i++)
        fact[i] = mul(fact[i - 1], i);

    // for each player, we find the first player which doesn't conflict with them
    vector<int> first_no_conflict(n);
    for(int i = 0; i < n; i++)
    {
        if(i) first_no_conflict[i] = first_no_conflict[i - 1];
        while(first_no_conflict[i] < n && a[first_no_conflict[i]] >= a[i] - k)
            first_no_conflict[i]++;
    }

    vector<int> dp(n + 1);
    if(a[0] - a[1] > k) dp[1] = 1;
    for(int i = 1; i < n; i++)
    {
        // first choice: put a[i] on the first position
        // then we put all which conflict with a[i] on any position other than 1
        int no_of_conflicting = first_no_conflict[i] - i - 1;
        // put all conflicting with a[i] on any position other than 1
        // the first one chooses from i positions, the second - from i+1 positions, and so on
        // so the number of ways is fact[i + no_of_conflicting - 1] / fact[i - 1]
        dp[i + no_of_conflicting + 1] = add(dp[i + no_of_conflicting + 1], mul(dp[i], divide(fact[i + no_of_conflicting - 1], fact[i - 1])));

        // second choice: put a[i] on any other position
        dp[i + 1] = add(dp[i + 1], mul(dp[i], i));
    }

    printf("%d\n", dp[n]);
}
--------------------------------------------------
Problem ID: 1809F
Editorial Content:
1809F - Traveling in Berland
Tutorial (Neon)
Tutorial is loading...
Solution (awoo)
#include<bits/stdc++.h>

using namespace std;

#define forn(i, n) for (int i = 0; i < int(n); ++i)

void solve(){
	int n, k;
	scanf("%d%d", &n, &k);
	vector<int> a(n);
	forn(i, n) scanf("%d", &a[i]);
	vector<int> b(n);
	forn(i, n) scanf("%d", &b[i]);
	
	vector<long long> pr(2 * n + 1);
	forn(i, 2 * n) pr[i + 1] = pr[i] + a[i % n];
	
	vector<long long> dist(n);
	vector<long long> cost(n);
	int cnt = 0;
	for (int i = 2 * n - 1; i >= 0; --i){
		if (i < n){
			if (b[i] == 2){
				dist[i] = 1;
				cost[i] = a[i] * 2;
			}
			else if (cnt == 0){
				dist[i] = 1;
				cost[i] = a[i];
			}
			else{
				int j = lower_bound(pr.begin() + i, pr.begin() + i + cnt + 1, pr[i] + k) - pr.begin();
				assert(j > i);
				dist[i] = j - i;
				if (pr[j] - pr[i] <= k)
					cost[i] = pr[j] - pr[i];
				else
					cost[i] = 2 * (pr[j] - pr[i]) - k;
			}
		}
		if (b[i % n] == 2) ++cnt;
		else cnt = 0;
	}
	
	int pw = 0;
	while ((1 << pw) <= n) ++pw;
	
	vector<vector<long long>> distk(pw, dist);
	vector<vector<long long>> costk(pw, cost);
	for (int j = 1; j < pw; ++j) forn(i, n){
		distk[j][i] = distk[j - 1][i] + distk[j - 1][(i + distk[j - 1][i]) % n];
		costk[j][i] = costk[j - 1][i] + costk[j - 1][(i + distk[j - 1][i]) % n];
	}
	
	forn(i, n){
		int pos = i;
		long long tot = 0;
		long long ans = 0;
		for (int j = pw - 1; j >= 0; --j) if (tot + distk[j][pos] <= n){
			tot += distk[j][pos];
			ans += costk[j][pos];
			pos = (pos + distk[j][pos]) % n;
		}
		if (tot < n) ans += pr[i + n] - pr[i + tot];
		printf("%lld ", ans);
	}
	puts("");
}

int main(){
	int tc;
	scanf("%d", &tc);
	while (tc--) solve();
}
--------------------------------------------------
Problem ID: 1809E
Editorial Content:
1809E - Two Tanks
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

int main() {
	int n, a, b;
	scanf("%d%d%d", &n, &a, &b);
	vector<int> v(n);
	forn(i, n) scanf("%d", &v[i]);
	vector<vector<int>> ans(a + 1, vector<int>(b + 1));
	forn(cd, a + b + 1){
		int l = max(0, cd - b), r = min(a, cd);
		int sum = 0;
		for (int x : v){
			sum += x;
			l = max({l, sum, cd + sum - b});
			r = min({r, a + sum, sum + cd});
		}
		if (l > r) l = r = max(0, cd - b);
		int res = l;
		for (int x : v){
			if (x > 0)
				res -= min({res, x, b - (cd - res)});
			else
				res += min({cd - res, -x, a - res});
		}
		forn(c, cd + 1) if (c <= a && cd - c <= b){
			ans[c][cd - c] = (c < l ? res : (c > r ? res + r - l : res + c - l));
		}
	}
	forn(i, a + 1){
		forn(j, b + 1)
			printf("%d ", ans[i][j]);
		puts("");
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1809D
Editorial Content:
1809D - Binary String Sorting
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

const long long pw10 = 1e12;

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int tc;
  cin >> tc;
  while (tc--) {
    string s;
    cin >> s;
    int n = s.size();
    int cnt0 = 0, cnt1 = count(s.begin(), s.end(), '1');
    long long ans = 1e18;
    if (n == 1) ans = 0;
    for (int i = 0; i < n - 1; ++i) {
      cnt0 += s[i] == '0';
      cnt1 -= s[i] == '1';
      int k = cnt0 + cnt1 + (s[i] == '1') + (s[i + 1] == '0');
      long long cur = (n - k) * (pw10 + 1);
      if (s[i] > s[i + 1]) cur += pw10;
      ans = min(ans, cur); 
    }
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1809C
Editorial Content:
1809C - Sum on Subarrays
Tutorial
Tutorial is loading...
Solution (BledDest)
def solve(n, k):
    if n == 0:
        return []
    if k < n:
        a = [-1 for i in range(n)]
        if k > 0:
            a[k - 1] = 200
        a[k] = -400
    else:
        a = solve(n - 1, k - n)
        a.append(1000)
    return a

t = int(input())
for i in range(t):
    n, k = map(int, input().split())
    b = solve(n, k)
    print(*b)
--------------------------------------------------
Problem ID: 1809B
Editorial Content:
1809B - Points on Plane
Tutorial
Tutorial is loading...
Solution 1 (adedalic)
fun main() {
    repeat(readln().toInt()) {
        val n = readln().toLong()
        var l = (-1).toLong()
        var r = 1e9.toLong()
        while (r - l > 1) {
            val mid = (l + r) / 2
            if (mid * mid >= n)
                r = mid
            else
                l = mid
        }
        println(r - 1)
    }
}
Solution 2 (adedalic)
import kotlin.math.sqrt

fun main() {
    repeat(readln().toInt()) {
        val n = readln().toLong()
        var ans = sqrt(n.toDouble()).toLong()
        while (ans * ans > n)
            ans--
        while (ans * ans < n)
            ans++
        println(ans - 1)
    }
}
--------------------------------------------------
Problem ID: 1809A
Editorial Content:
1809A - Garland
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int tc;
  cin >> tc;
  while (tc--) {
    string s;
    cin >> s;
    vector<int> cnt(10);
    for (auto c : s) ++cnt[c - '0'];
    int mx = *max_element(cnt.begin(), cnt.end());
    if (mx == 4) cout << -1;
    else if (mx == 3) cout << 6;
    else cout << 4;
    cout << '\n';
  }
}
--------------------------------------------------
Problem ID: 1808E3
Editorial Content:
1808E3 - Minibuses on Venus (hard version)
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1808E2
Editorial Content:
1808E2 - Minibuses on Venus (medium version)
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1808E1
Editorial Content:
1808E1 - Minibuses on Venus (easy version)
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1808D
Editorial Content:
1808D - Petya, Petya, Petr, and Palindromes
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1808C
Editorial Content:
1808C - Unlucky Numbers
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1808B
Editorial Content:
1808B - Playing in a Casino
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1808A
Editorial Content:
1808A - Lucky Numbers
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1807G2
Editorial Content:
1807G2 - Subsequence Addition (Hard Version)
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
#define ll long long
 
#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()
 
void solve() {
    int n; cin >> n;
    vector<int> a(n);
    for(int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    sort(all(a));
    if(a[0] != 1) {
        cout << "NO\n";
        return;
    }
    long long sum = a[0];
    for(int i = 1; i < n; ++i) {
        if(sum < a[i]) {
            cout << "NO\n";
            return;
        }
        sum += a[i];
    }
    cout << "YES\n";
}
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1807G1
Editorial Content:
1807G1 - Subsequence Addition (Easy Version)
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
#define ll long long
 
#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()
 
void solve() {
    int n; cin >> n;
    vector<int> a(n);
    for(int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    sort(all(a));
    if(a[0] != 1) {
        cout << "NO\n";
        return;
    }
    vector<int> dp(5005, 0);
    dp[1] = 1;
    for(int i = 1; i < n; ++i) {
        if(!dp[a[i]]) {
            cout << "NO\n";
            return;
        }
        for(int j = 5000; j >= a[i]; --j) {
            dp[j] |= dp[j - a[i]];
        }
    }
    cout << "YES\n";
}
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1807F
Editorial Content:
1807F - Bouncy Ball
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
 
void solve()
{
    int n, m, x1, y1, x2, y2;
    string d_string;
    cin >> n >> m >> x1 >> y1 >> x2 >> y2;
    x1--;x2--;y1--;y2--;
    cin >> d_string;
    int d = (d_string[0] == 'U' ? 1+(d_string[1] == 'R' ? 2 : 0) : 0+(d_string[1] == 'R' ? 2 : 0));
    bool vis[n][m][4];
    memset(vis, false, sizeof(vis));
    int i = x1, j = y1;
    int bounces = 0;
    while(!vis[i][j][d])
    {
        if(i == x2 && j == y2){cout << bounces << endl; return;}
        int na = 0;
        if(d%2 == 1 && i == 0){d-=1;na++;}
        if(d%2 == 0 && i == n-1){d+=1;na++;}
        if(d >= 2 && j == m-1){d-=2;na++;}
        if(d < 2 && j == 0){d+=2;na++;}
        bounces+=min(1, na);
        if(vis[i][j][d])
        {
            break;
        }
        vis[i][j][d] = true;
        if(d%2 == 1){i--;}else{i++;}
        if(d >= 2){j++;}else{j--;}
    }
    cout << -1 << endl;
}
 
int32_t main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1807E
Editorial Content:
1807E - Interview
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using ll=long long;
using ld=long double;
int const INF=1000000005;
ll const LINF=1000000000000000005;
ll const mod=1000000007;
ld const PI=3.14159265359;
ll const MAX_N=3e5+5;
ld const EPS=0.00000001;
#pragma GCC optimize("O3")
#pragma GCC optimize("Ofast")
#define f first
#define s second
#define pb push_back
#define mp make_pair
#define endl '\n'
#define sz(a) (int)a.size()
#define CODE_START  ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
ll t,n,a[2000005],pref[2000005];
int32_t main(){
//CODE_START;
#ifdef LOCAL
//ifstream cin("input.txt");
#endif
cin>>t;
while(t--){
    cin>>n;
    for(ll i=1;i<=n;i++)
    {
        cin>>a[i];
        pref[i]=pref[i-1]+a[i];
    }
    ll l=1,r=n,ans=0;
    while(l<=r){
            ll mid=(l+r)/2;
        cout<<"? "<<(mid-l+1)<<' ';
        for(ll i=l;i<=mid;i++)
        {
            cout<<i<<' ';
        }
        cout<<endl<<flush;
        ll x=0;
        cin>>x;
        if(x==pref[mid]-pref[l-1]){
            l=mid+1;
        }else {
            r=mid-1;
            ans=mid;
        }
    }
    cout<<"! "<<ans<<endl<<flush;
}
}
--------------------------------------------------
Problem ID: 1807D
Editorial Content:
1807D - Odd Queries
Tutorial
Tutorial is loading...
Solution
#include <iostream>
 
using namespace std;
long long n,a[200005],q,sum=0,pref[200005],t;
int main() {
    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    cin>>t;
    while(t--)
    {
        sum = 0;
        cin >> n >> q;
        for(int i=1;i<=n;i++){
            cin >> a[i];
            sum+=a[i];
            pref[i]=pref[i-1];
            pref[i]+=a[i];
        }
        for(int i = 0; i < q; i++){
            long long l,r,k;
            cin >> l >> r >> k;
            long long ans = pref[n]-(pref[r]-pref[l-1])+k*(r-l+1);
            if(ans%2==1){
                cout<<"YES"<<endl;
            }
            else
            {
                cout<<"NO"<<endl;
            }
        }
    }
}
--------------------------------------------------
Problem ID: 1807C
Editorial Content:
1807C - Find and Replace
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200007;
const int MOD = 1000000007;
 
void solve() {
	int n;
	cin >> n;
	string s;
	cin >> s;
	int mp[26];
	for (int i = 0; i < 26; i++) {
		mp[i] = -1;
	}
	for (int i = 0; i < n; i++) {
		int curr = (s[i] - 'a');
		if (mp[curr] == -1) {
			mp[curr] = (i % 2);
		}
		else {
			if (mp[curr] != (i % 2)) {cout << "NO\n"; return;}
		}
	}
	cout << "YES\n";
}
 
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1807B
Editorial Content:
1807B - Grab the Candies
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
 
void solve()
{
    int n;
    cin >> n;
    int x, odd = 0, even = 0;
    for(int i = 0; i < n; i++)
    {
        cin >> x;
        if(x%2 == 0)
        {
            even+=x;
        }
        else
        {
            odd+=x;
        }
    }
    if(even > odd)
    {
        cout << "YES" << endl;
    }
    else
    {
        cout << "NO" << endl;
    }
}
 
int32_t main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1807A
Editorial Content:
1807A - Plus or Minus
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
using namespace std;
 
const int MAX = 200007;
const int MOD = 1000000007;
 
void solve() {
	int a, b, c;
	cin >> a >> b >> c;
	if (a + b == c) {cout << "+\n";}
	else {cout << "-\n";}	
}
 
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1806F2
Editorial Content:
1806F2 - Мастер НОД (сложная версия)
Solution
Tutorial is loading...
Code
#include<bits/stdc++.h>
#define ll long long
#define int128 __int128
#define fir first
#define sec second
#define pii pair<int,int>
using namespace std;

const int maxn=1000005;
const ll inf=9e18;
const int128 inf128=(int128)(inf)*(int128)(inf);

ll a[maxn];
ll b[maxn];
ll g[maxn];
ll ra[maxn];
int128 suma[maxn];
int128 sumb[maxn];
int128 ans[maxn];

ll gcd(ll x,ll y) {
	return !y?x:gcd(y,x%y);
}

void print(int128 x) {
	if(!x) {
		return ;
	}
	print(x/10);
	cout<<(int)(x%10);
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;
	cin>>T;
	while(T--) {
		int n,k;
		ll m;
		cin>>n>>m>>k;
		for(int i=1;i<=n;i++) {
			cin>>a[i];
		}
		sort(a+1,a+n+1);
		int t=0,r=0;
		for(int i=1;i<=n;i++) {
			if(i>1&&a[i]==a[i-1]) {
				b[++r]=a[i];
			} else {
				ra[++t]=a[i];
			}
		}
		n=t;
		for(int i=1;i<=n;i++) {
			a[i]=ra[i];
			g[i]=gcd(g[i-1],a[i]);
			suma[i]=suma[i-1]+a[i];
		}
		for(int i=0;i<=k;i++) {
			ans[i]=-inf128;
		}
		for(int l=1;l<=n;) {
			int r=l;
			while(r<=n&&g[r]==g[l]) {
				r++;
			}
			r--;
			ll Max=-inf;
			for(int i=r+1;i<=n;i++) {
				a[i]=gcd(a[i],g[l]);
				Max=max(Max,a[i]-ra[i]);
			}
			for(int i=r;i>=l;i--) {
				ans[i]=suma[n]-suma[i]+Max;	
				a[i]=gcd(a[i],g[l]);
				Max=max(Max,a[i]-ra[i]);
			}
			l=r+1;
		}
		for(int i=1;i<=r;i++) {
			sumb[i]=sumb[i-1]+b[i];
		}
		int128 final=-inf128;
		if(k<=r) {
			final=suma[n]+sumb[r]-sumb[k];
		}
		for(int i=0;i<=r&&i<=k;i++) {
			final=max(final,sumb[r]-sumb[i]+ans[k-i]);
		}
		print(final);
		cout<<"\n";
	}
}
--------------------------------------------------
Problem ID: 1806F1
Editorial Content:

--------------------------------------------------
Problem ID: 1806E
Editorial Content:
1806E - Мастер деревьев
Solution
Tutorial is loading...
Code
#include<bits/stdc++.h>
#define ll long long
#define fir first
#define sec second
#define pii pair<int,int>
using namespace std;

const int maxn=100005;
const int sqrtn=325;
const int B=320;
const int inf=0x3f3f3f3f;

int n,q;
int a[maxn];
int h[maxn];
int fa[maxn];
int cnt[maxn];
int depth[maxn];
ll f[maxn][sqrtn];
vector<int> tree[maxn]; 

void dfs(int x,int d) {
	h[x]=++cnt[d],depth[x]=d;
	for(int to:tree[x]) {
		dfs(to,d+1);
	}
}

ll ask(int x,int y) {
	if(!x&&!y) {
		return 0;
	}
	if(cnt[depth[y]]<=B&&f[x][h[y]]) {
		return f[x][h[y]];
	}
	ll ans=ask(fa[x],fa[y])+1ll*a[x]*a[y];
	if(cnt[depth[y]]<=B) {
		f[x][h[y]]=ans;
	}
	return ans;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++) {
		cin>>a[i];
	}
	for(int i=2;i<=n;i++) {
		cin>>fa[i];
		tree[fa[i]].push_back(i);
	}
	dfs(1,0);
	while(q--) {
		int x,y;
		cin>>x>>y;
		cout<<ask(x,y)<<"\n";
	}
}
--------------------------------------------------
Problem ID: 1806D
Editorial Content:
1806D - Мастер СНМ
Solution
Tutorial is loading...
Code
#include<bits/stdc++.h>
#define ll long long
#define fir first
#define sec second
#define pii pair<int,int>
using namespace std;
 
const int maxn=500005;
const int inf=0x3f3f3f3f;
const int mod=998244353;

int a[maxn];
int f[maxn];

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;
	cin>>T;
	while(T--) {
		int n;
		cin>>n;
		for(int i=1;i<=n-1;i++) {
			cin>>a[i];
		}
		f[1]=1;
		for(int i=1;i<=n-1;i++) {
			f[i+1]=1ll*f[i]*(i-a[i])%mod;
		}
		int ans=0;
		for(int i=1;i<=n-1;i++) {
			ans=(1ll*ans*i+(!a[i])*f[i])%mod;
			cout<<ans<<" ";
		}
		cout<<"\n";
	}
}
--------------------------------------------------
Problem ID: 1806C
Editorial Content:
1806C - Мастер последовательностей
Solution
Tutorial is loading...
Code
#include<bits/stdc++.h>
#define ll long long
#define fir first
#define sec second
#define pii pair<int,int>
using namespace std;

const int maxn=400005;
const ll inf=0x3f3f3f3f3f3f3f3f;

ll a[maxn];

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;
	cin>>T;
	while(T--) {
		int n;
		cin>>n;
		ll ans=0,sum=0;
		for(int i=1;i<=n*2;i++) {
			cin>>a[i];
			ans+=abs(a[i]);
			sum+=abs(a[i]-(-1));
		}
		if(n==1) {
			ans=min(ans,abs(a[1]-a[2]));
		}
		if(n==2) {
			ans=min(ans,abs(a[1]-2)+abs(a[2]-2)+abs(a[3]-2)+abs(a[4]-2));
		}
		if(n%2==0) {
			for(int i=1;i<=n*2;i++) {
				ans=min(ans,sum-abs(a[i]-(-1))+abs(a[i]-n));
			}
		}
		cout<<ans<<"\n";
	}
}
--------------------------------------------------
Problem ID: 1806B
Editorial Content:
1806B - Мастер Mex-ов
Solution
Tutorial is loading...
Code
#include<bits/stdc++.h>
#define ll long long
#define fir first
#define sec second
#define pii pair<int,int>
using namespace std;

const int maxn=200005;
const int inf=0x3f3f3f3f;

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;
	cin>>T;
	while(T--) {
		int n;
		cin>>n;
		int sum0=0;
		bool f=false;
		for(int i=1;i<=n;i++) {
			int x;
			cin>>x;
			if(x==0) {
				sum0++;
			} else if(x>=2) {
				f=true;
			}
		}
		if(sum0<=(n+1)/2) {
			cout<<"0\n";
		} else if(f||sum0==n) {
			cout<<"1\n";
		} else {
			cout<<"2\n";
		}
	}
}
--------------------------------------------------
Problem ID: 1806A
Editorial Content:
1806A - Мастер перемещений
Solution
Tutorial is loading...
Code
#include<bits/stdc++.h>
#define ll long long
#define fir first
#define sec second
#define pii pair<int,int>
using namespace std;

const int maxn=500005;
const int inf=0x3f3f3f3f;

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;
	cin>>T;
	while(T--) {
		int a,b,c,d;
		cin>>a>>b>>c>>d;
		if(b<=d&&c<=a+d-b) {
			cout<<(d-b)+(a+d-b-c)<<"\n";
		} else {
			cout<<"-1\n";
		}
	}
}
--------------------------------------------------
Problem ID: 1805F2
Editorial Content:
1805F2 - Survival of the Weakest (hard version)
Hint 1
Figure out how to implement the function $$$F$$$ in $$$O(n log n)$$$
Hint 1.1
You'll need $$$std::priority\_queue$$$ or $$$std::set$$$
Hint 2
If you run $$$F$$$ for $$$O(n log n)$$$ $$$n - 1$$$ times, we'll get the solution in $$$O(n^2 log n)$$$. However, the numbers in the array can grow very fast. Can you somehow modify the numbers in the array so that $$$F$$$ changes in a predictable way?
Hint 2.2
$$$F([a_1, a_2, \ldots, a_n]) = F([a_1 - x, a_2 - x, \ldots, a_n - x]) + x \cdot 2^{n-1}$$$
Hint 3
How to solve the problem if $$$a_i \leq 1$$$? $$$\leq 2$$$? Can you notice anything about these solutions?
Hint 4
If $$$n$$$ is large enough, then $$$F(F(\ldots F([a_1, a_2, \ldots, a_n])\ldots)) = F(F( \ldots F([a_1, a_2, \ldots, a_{n-1}, X])\ldots))$$$ where $$$X$$$ any number $$$\geq a_{n-1}$$$, in other words: the largest element is useless for the final answer
Hint 5
Only a small number of the smallest elements of the original array will affect the answer
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
#define all(x) x.begin(), (x).end()

using namespace std;

const int M = 1000000007;
long long ans = 0;
int real_len = 0;


long long binpow(long long a, int x) {
    long long ans0 = 1;
    while (x) {
        if (x % 2) {
            ans0 *= a;
            ans0 %= M;
        }
        a *= a;
        a %= M;
        x /= 2;
    }
    return ans0;
}


void chill(vector<int> &b) {
    int mn = b[0];
    ans += (int) ((long long) mn * binpow(2, real_len - 1) % M);
    if (ans >= M) {
        ans -= M;
    }
    for (auto &x : b) {
        x -= mn;
    }
}


void F(vector<int> &b, int sub = 0) {
    --real_len;
    vector<int> cnd;
    for (int i = 0; i < b.size(); i++) {
        for (int j = i + 1; j < b.size(); j++) {
            if (i * j >= b.size()) break;
            cnd.push_back(b[i] + b[j]);
        }
    }
    sort(all(cnd));
    vector<int> b2((int) b.size() - sub);
    for (int i = 0; i < (int) b.size() - sub; i++) {
        b2[i] = cnd[i];
    }
    chill(b2);
    b = b2;
}


signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    sort(all(a));
    int L = 64;
    vector<int> b(min(n, L));
    for (int i = 0; i < min(n, L); i++) {
        b[i] = a[i];
    }
    real_len = n;
    chill(b);
    while (b.size() < real_len) {
        if (b[1] + b[2] > b.back()) {
            F(b, 1);
            F(b, 1);
        } else {
            F(b);
        }
    }
    while (real_len > 1) {
        F(b, 1);
    }
    ans += b[0];
    ans %= M;
    cout << ans << '\n';
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1805F1
Editorial Content:

--------------------------------------------------
Problem ID: 1805E
Editorial Content:
1805E - There Should Be a Lot of Maximums
Hint 1
Let $$$M$$$ — $$$MAD$$$ of the whole tree. What is the answer if there are many vertices with value $$$M$$$ in the tree?
Hint 2
Note that for many edges the answer is $$$M$$$. And for which edges is it not so?
Hint 3
Let the tree have only two vertices with value $$$M$$$. Then for the edges not on the path between them we know the answer. What about the path between two vertices of $$$M$$$? Can we walk along it by calculating the answer for all vertices?
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;


const int N = 2e5 + 100;
vector <pair <int, int>> g[N];
int val[N];

vector <int> ans;
map <int, int> cnt1, cnt2;
set <int> mad1, mad2;

vector <int> path, path_ind;
bool used[N];


bool dfs(int v, int tar) {
    used[v] = true;
    path.push_back(v);
    if (v == tar) {
        return true;
    }
    for (auto [i, ind] : g[v]) {
        if (!used[i]) {
            path_ind.push_back(ind);
            if (dfs(i, tar)) {
                return true;
            }
            path_ind.pop_back();
        }
    }
    path.pop_back();
    return false;
}


int mad() {
    int mx = 0;
    if (!mad1.empty()) {
        mx = max(mx, *mad1.rbegin());
    }
    if (!mad2.empty()) {
        mx = max(mx, *mad2.rbegin());
    }
    return mx;
}


void recalc(int v, int ban1, int ban2) {
    cnt1[val[v]]++;
    if (cnt1[val[v]] == 2) {
        mad1.insert(val[v]);
    }
    cnt2[val[v]]--;
    if (cnt2[val[v]] == 1) {
        mad2.erase(val[v]);
    }
    for (auto [i, _] : g[v]) {
        if (i != ban1 && i != ban2) {
            recalc(i, v, -1);
        }
    }
}


signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    for (int i = 0; i < n - 1; i++) {
        int a, b;
        cin >> a >> b;
        a--, b--;
        g[a].emplace_back(b, i);
        g[b].emplace_back(a, i);
    }

    map <int, vector <int>> ind;
    for (int i = 0; i < n; i++) {
        cin >> val[i];
        ind[val[i]].push_back(i);
        cnt2[val[i]]++;
        if (cnt2[val[i]] == 2) {
            mad2.insert(val[i]);
        }
    }

    while (!ind.empty() && ind.rbegin() -> second.size() == 1) {
        ind.erase(prev(ind.end()));
    }
    if (ind.empty()) {
        for (int i = 0; i < n - 1; i++) {
            cout << "0\n";
        }
        return 0;
    } else if (ind.rbegin()->second.size() > 2) {
        for (int i = 0; i < n - 1; i++) {
            cout << ind.rbegin() -> first << "\n";
        }
        return 0;
    }

    int a = ind.rbegin()->second[0], b = ind.rbegin()->second[1];
    dfs(a, b);

    ans.assign(n - 1, ind.rbegin() -> first);
    recalc(path[0], path[1], -1);
    ans[path_ind[0]] = mad();

    for (int i = 1; i + 1 < path.size(); i++) {
        recalc(path[i], path[i - 1], path[i + 1]);
        ans[path_ind[i]] = mad();
    }

    for (int i : ans) {
        cout << i << "\n";
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1805D
Editorial Content:
1805D - A Wide, Wide Graph
Hint 1
At what maximal $$$k$$$ does the graph $$$G_k$$$ not decompose into single components? What happens if we decrease $$$k$$$ by $$$1$$$?
Hint 2
Consider some diameter of a tree (the path of the longest length). If in the graph $$$G_k$$$ a vertex has a neighbor, then it is also connected by an edge to one of the ends of the diameter. How can we use this fact to find the answer for $$$k$$$ if we know the components of graph $$$G_{k+1}$$$?
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()

using namespace std;

const int N = 1e5 + 228;

vector<int> G[N];

void dfs(int v, int par, int h, vector<int> &d) {
    d[v] = h;
    for (int i : G[v]) {
        if (i != par) {
            dfs(i, v, h + 1, d);
        }
    }
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    int n;
    cin >> n;
    for (int i = 0; i < n - 1; ++i) {
        int a, b;
        cin >> a >> b;
        G[a - 1].push_back(b - 1);
        G[b - 1].push_back(a - 1);
    }

    vector<int> d1(n), d2(n);
    dfs(0, -1, 0, d1);
    int a = max_element(all(d1)) - d1.begin();
    dfs(a, -1, 0, d1);
    int b = max_element(all(d1)) - d1.begin();
    dfs(b, -1, 0, d2);
    for (int i = 0; i < n; ++i) {
        d2[i] = max(d2[i], d1[i]);
    }
    sort(all(d2));
    int ans = 0;
    for (int i = 1; i <= n; ++i) {
        while (ans < n && d2[ans] < i) {
            ++ans;
        }
        cout << min(n, ans + 1) << ' ';
    }
    cout << '\n';
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1805C
Editorial Content:
1805C - Place for a Selfie
Hint 1
Note that the distance between the line and the parabola will also be a parabola. Then what is the condition that the line and the parabola have no common points?
Hint 2
Recall the discriminant formula from school: If a parabola $$$ax^2 + bx + c$$$ is given, then calculate $$$D=b^2 - 4ac$$$ (discriminant). Then, if $$$D > 0$$$, the parabola has $$$2$$$ roots, if $$$D=0$$$, it has one root, if $$$D<0$$$, it has no roots.
Hint 3
If we choose the parabola $$$ax^2 + bx + c$$$, then the lines with such coefficient $$$k$$$ that $$$(b-k)^2<4ac$$$ have no common points with it. How can we find such $$$k$$$ among the given lines?
Editorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
#define int long long

using namespace std;


void solve() {
    int n, m;
    cin >> n >> m;
    vector <int> lines(n);
    for (int i = 0; i < n; i++) {
        cin >> lines[i];
    }
    sort(lines.begin(), lines.end());

    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;

        int ind = lower_bound(lines.begin(), lines.end(), b) - lines.begin();
        if (ind < n && (lines[ind] - b) * (lines[ind] - b) < 4 * a * c) {
            cout << "YES\n" << lines[ind] << "\n";
            continue;
        }
        if (ind > 0 && (lines[ind - 1] - b) * (lines[ind - 1] - b) < 4 * a * c) {
            cout << "YES\n" << lines[ind - 1] << "\n";
            continue;
        }
        cout << "NO\n";
    }
}


signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int q = 1;
    cin >> q;
    while (q--) {
        solve();
    }
    return 0;
}
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1805B
Editorial Content:
1805B - The String Has a Target
Hint 1
What should be the first character if we are trying to make the string lexicographically minimal?
Hint 2
Consider the string «
baba
». If you choose $$$i=2$$$, you get the string «
abba
», and if you choose $$$i=4$$$ you get «
abab
». Try to generalize this reasoning to any string.
Editorial
Tutorial is loading...
Solution
for _ in range(int(input())):
    n = int(input())
    s = input()
    ind = s.rfind(min(s))  # Find the last ind such that s[ind] = min(s)
    print(s[ind] + s[:ind] + s[ind + 1:])
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1805A
Editorial Content:
1805A - We Need the Zero
Hint 1
Recall the basic properties of the $$$\oplus$$$ operation: $$$A \oplus 0 = A$$$, $$$A \oplus A = 0$$$, $$$A \oplus B = B \oplus A$$$.
Hint 2
Consider the cases of even and odd array lengths.
Editorial
Tutorial is loading...
Solution
for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    xor = 0
    for x in a:
        xor ^= x
    if xor == 0:
        print(0)
    else:
        if n % 2 == 1:
            print(xor)
        else:
            print(-1)
Rate the problem
Didn't solve
Good task
Average task
Bad task
--------------------------------------------------
Problem ID: 1804H
Editorial Content:

--------------------------------------------------
Problem ID: 1804G
Editorial Content:

--------------------------------------------------
Problem ID: 1804F
Editorial Content:

--------------------------------------------------
Problem ID: 1804E
Editorial Content:

--------------------------------------------------
Problem ID: 1804D
Editorial Content:

--------------------------------------------------
Problem ID: 1804C
Editorial Content:

--------------------------------------------------
Problem ID: 1804B
Editorial Content:

--------------------------------------------------
Problem ID: 1804A
Editorial Content:

--------------------------------------------------
Problem ID: 1802B
Editorial Content:
1802B - Settlement of Guinea Pigs
Solution
Todo
Code
#include<bits/stdc++.h>

using namespace std;

void solve() {
    int n;
    cin >> n;
    int known = 0, unknown = 0;
    int need = 0;
    for (int i = 0; i < n; ++i) {
        int x;
        cin >> x;
        if (x == 1) ++unknown;
        else {
            known += unknown;
            unknown = 0;
        }
        need = max(need, unknown + (known ? known / 2 + 1 : 0));
    }
    cout << need << endl;
}

signed main() {
    int t = 1;
    cin >> t;
    for (int i = 0; i < t; ++i) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1802A
Editorial Content:
1802A - Likes
Solution
Let's show a construction that maximizes the number of likes. We need to first leave all the likes that we can put, and only then delete them.
To minimize the number of likes, we need to delete the like (if we can) immediately after we post it.
The code below implements these constructs.
Code
#include "bits/stdc++.h"

using namespace std;

void solve() {
    int n;
    cin >> n;
    int likes = 0, dislikes = 0;
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        if (x > 0) likes++;
        else dislikes++;
    }
    for (int i = 1; i <= n; ++i) {
        if (i <= likes) cout << i << ' ';
        else cout << likes * 2 - i << ' ';
    }
    cout << '\n';

    for (int i = 1; i <= n; ++i) {
        if (i <= dislikes * 2) cout << i % 2 << ' ';
        else cout << (i - dislikes * 2) << ' ';
    }
    cout << '\n';
}

signed main() {
    int t = 1;
    cin >> t;
    for (int i = 1; i <= t; ++i) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1801G
Editorial Content:
1801G - A task for substrings
Solution
Let's use the Aho-Korasik structure to store strings from $$$S$$$. Let's build compressed suffix links on it. This way it is a little more optimal to find all the lines from $$$S$$$ ending in this position $$$t$$$.
Denote by $$$pref[i]$$$ the number of substrings of $$$S$$$ in the prefix $$$t$$$ of length $$$i$$$.
Denote by $$$suf[i]$$$ the number of substrings of $$$S$$$ in the suffix $$$t$$$ starting from the position $$$i$$$.
Note that $$$pref[r] + suf[l] - priv[|T|]$$$ is equal to the number of substrings of the string for $$$t$$$ from $$$S$$$ on the segment $$$[l, p]$$$ minus the number of substrings of $$$t$$$ from $$$S$$$ that begin before $$$l$$$ and end later than $$$r$$$.
For each query, we will find a substring $$$t$$$ that matches $$$s_i$$$, which covers the string $$$t[l, r]$$$ and ends as close as possible to $$$r$$$. If there is no such thing, then the answer can be calculated using the previous formula. Otherwise, $$$t[l, r]$$$ is invested in $$$s_i[l', r']$$$. At the same time, there are no substrings of $$$S$$$ in the string $$$s_i$$$ that begin before $$$l'$$$ and end later than $$$r'$$$. To get the answer, we apply the previous formula with the string $$$s_i$$$ and the sub-section $$$[l', r']$$$.
Asymptotics: $$$O(S+ t +m \log m)$$$
Code
#include <bits/stdc++.h>

#define x first
#define y second

using namespace std;

struct node {
	int nx[26];
	int p;
	int pp;
	int len;
	int id;
	int cnt;
	bool term;

	node() : p(-1), pp(-1), len(0), id(-1), term(false), cnt(0) {
		for (int i = 0; i < 26; i++) {
			nx[i] = -1;
		}
	}
};

vector<node> g;

vector<string> s[2];

string t[2];

vector<vector<long long>> c[2], pid[2];

vector<long long> tc[2];

int add(int a, char c) {
	c -= 'a';
	if (g[a].nx[c] == -1) {
		g[a].nx[c] = g.size();
		g.emplace_back();
		g.back().len = g[a].len + 1;
	}
	return g[a].nx[c];
}

void build_aho(int a) {
	vector<pair<int, int>> q;
	for (int i = 0; i < 26; i++) {
		if (g[a].nx[i] == -1) {
			g[a].nx[i] = a;
		} else {
			q.emplace_back(a, i);
		}
	}

	int qb = 0;
	while (qb < q.size()) {
		int b = q[qb].x;
		int i = q[qb].y;
		qb++;
		int v = g[b].nx[i];
		int c = g[b].p;

		if (g[v].term) { // bug in c != -1
			g[v].cnt = 1;
		}

		if (c == -1) {
			g[v].p = a;
			g[b].pp = -1;
		} else {
			g[v].p = g[c].nx[i];
			if (g[v].term) {
				g[v].pp = v;
			} else {
				g[v].pp = g[g[v].p].pp;
			}
			g[v].cnt += g[g[v].p].cnt;
		}

		for (int i = 0; i < 26; i++) {
			if (g[v].nx[i] == -1) {
				g[v].nx[i] = g[g[v].p].nx[i];
			} else {
				q.emplace_back(v, i);
			}
		}
	}
}

vector<vector<pair<int, int>>> ts;
vector<int> qlen;
priority_queue<pair<int, int>> h;
vector<long long> ans;

long long get_ans(int rdst, int len, vector<long long>& a, vector<long long>& b, bool substr) {
	int l = a.size() - 1 - rdst;
	int r = l + len;
	long long cnt = a[r] + b[a.size() - 1 - l] - a.back();
	if (substr && l == 0 && r == a.size() - 1) {
		cnt++;
	}

	return cnt;
}

int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;
	g.emplace_back(); g.emplace_back();
	s[0].resize(n); s[1].resize(n);
	c[0].resize(n); c[1].resize(n);
	pid[0].resize(n); pid[1].resize(n);
	ans.resize(m);

	cin >> t[0];
	t[1] = t[0];
	reverse(t[1].begin(), t[1].end());
	ts.resize(t[0].size());

	for (int i = 0; i < n; i++) {
		cin >> s[0][i];
	}
	sort(s[0].begin(), s[0].end(), \ 
	[](const string& a, const string& b) { return a.size() < b.size(); });

	for (int i = 0; i < n; i++) {
		s[1][i] = s[0][i];
		reverse(s[1][i].begin(), s[1][i].end());

		for (int e = 0; e < 2; e++) {
			int a = e;
			for (auto j : s[e][i]) {
				a = add(a, j);
			}
			g[a].term = true;
			g[a].id = i;
		}
	}

	build_aho(0); build_aho(1);

	for (int e = 0; e < 2; e++) {
		tc[e].resize(t[0].size() + 1);

		int a = e;
		for (int i = 0; i < t[0].size(); i++) {
			a = g[a].nx[t[e][i] - 'a'];
			tc[e][i + 1] = tc[e][i] + g[a].cnt;
		}
		for (int i = 0; i < n; i++) {;
			c[e][i].resize(s[0][i].size() + 1);
			pid[e][i].resize(s[0][i].size() + 1, -1);

			int a = e;
			for (int j = 0; j < s[e][i].size(); j++) {
				a = g[a].nx[s[e][i][j] - 'a'];
				c[e][i][j + 1] = c[e][i][j] + g[a].cnt;
				
				if (g[a].term) { // bug always
					pid[e][i][j + 1] = g[a].id;
				}
			}

			for (int j = (int)s[e][i].size() - 1; j >= 0; j--) { // bug forget
				if (pid[e][i][j] == -1) {
					pid[e][i][j] = pid[e][i][j + 1];
				}
			}
			c[e][i].back()--; // bug forget string itself
			
		}
	}

	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		a--;
		ts[b - 1].emplace_back(a, i);
		qlen.emplace_back(b - a);
	}

	int a = 0;
	for (int i = 0; i < t[0].size(); i++) {
		// cout << i << ' ' << t[0][i] << '\n';
		for (auto j : ts[i]) {
			h.emplace(j);
		}

		a = g[a].nx[t[0][i] - 'a'];

		if (g[a].pp != -1) { // bug ignore
			int id = g[g[a].pp].id;
			int bg = i + 1 - (int)s[0][id].size();
			while (h.size() > 0 && h.top().x >= bg) {
				int rdst = i - h.top().x + 1;
				int nid = pid[1][id][rdst]; // bug forget

				// cout << h.top().x << ' ' << h.top().y << ' ' << rdst << ' ' << nid << '\n';

				ans[h.top().y] = get_ans(rdst, qlen[h.top().y], 
				    c[0][nid], c[1][nid], true);
				h.pop();
			}
		}
	}

	while (h.size() > 0) {
		// cout << h.top().x << ' ' << h.top().y << '\n';
		ans[h.top().y] = get_ans(t[0].size() - h.top().x, qlen[h.top().y], tc[0], tc[1], false);
		h.pop();
	}

	for (auto i : ans) {
		cout << i << ' ';
	}
	cout << '\n';
}
--------------------------------------------------
Problem ID: 1801F
Editorial Content:
1801F - Another n-dimensional chocolate bar
Solution
For $$$A$$$ we denote the maximum value of $$$a_i$$$
To begin with, let's solve the problem for $$$O(n\cdot k\cdot f(k, A))$$$ using dynamic programming.
Let's put $$$dp[i][j]$$$— the maximum possible volume of the smallest piece, if by the first $$$i$$$ measurements we divided the chocolate into $$$j$$$ parts. If we have divided into more than $$$k$$$ parts, we will also put the result in $$$dp[i][k]$$$. In terms of calculation, we need to decide how many hours to divide the chocolate bar along the next dimension. Let's look at several ways to do this.
It is possible for $$$O(k)$$$ to sort out the state to which we are moving, and from this calculate how many parts you need to divide the chocolate bar along the next dimension. — We get $$$O(n\cdot k^2)$$$
It is possible for $$$O(A)$$$ to sort out how many parts we divide the chocolate bar along the next dimension.
Being in the state of $$$dp[i][j]$$$, you can iterate over $$$b_i$$$ — into how many parts to divide the chocolate until $$$j\cdot b_i\le k$$$. It can be shown that such a solution will work for $$$O(n\cdot k\cdot\ln{k})$$$
The key idea
suppose we need to divide a chocolate bar into $$$10$$$ parts, and along the first measurements we have already divided it into $$$5$$$ parts, or $$$6$$$ parts, or $$$7, 8$$$ or $$$9$$$ parts. All these states are not distinguishable for us, because in all these cases we need to divide the chocolate bar into at least $$$2$$$ parts. It remains to understand how many such <> states there are and learn how to store them. There are several approaches for this, let's analyze one of them:
we are interested in all the values of $$$\lceil\frac{k}{i}\rceil$$$ for $$$i = 1, 2, \ldots k$$$— this is how many parts the chocolate bar may still need to be divided into. Among them, only $$$O(\sqrt{k})$$$different, since either $$$i\le\sqrt{k}$$$, or the value of $$$\lceil\frac{k}{i}\rceil\le\sqrt{k}$$$ itself. If we make all these numbers states, and recalculate, iterating over the state to which to go, we get $$$O(n\cdot\sqrt{k} \cdot\sqrt{k}) = O(n\cdot k)$$$— this is still not enough to solve the hollow problem.
Last observation
If we are in the state of $$$dp[i][remain]$$$ where $$$remain = \lceil\frac{k}{i}\rceil$$$ for some $$$i$$$, we will apply the same idea to it. From it, we are interested in transitions to the states $$$\lceil \frac{remain}{j} \rceil$$$ for $$$j = 1, 2, \ldots remain$$$. What kind of asymptotics will be obtained if we iterate over only interesting transitions?
$$$n \cdot (\sum\limits_{r=1}^{\sqrt{k}}{ 2 \cdot \sqrt{r} + 2 \cdot \sqrt{\lceil \frac{k}{r} \rceil}})$$$
it can be shown that this is $$$O(n\cdot k^{3/4})$$$— which solves the problem
Code
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 200;
int a[MAXN];

const int MAXK = 1e7 + 100, MAXH = 1e4;
int hsh[MAXK];
int rev[MAXH];

double dp[MAXN][MAXH];

vector<array<int, 2>> go[MAXH];

main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int n, k;
    cin >> n >> k;
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    int id = 0;
    for (int c = 1;; ++id) {
        rev[id] = (k + c - 1) / c;
        hsh[(k + c - 1) / c] = id;
        int t = (k + c - 1) / c - 1;
        if (t == 0) break;
        c = (k + t - 1) / t;
    }
    ++id;
    dp[0][hsh[k]] = k;

    for (int i = 0; i < id; ++i) {
        int k = rev[i];
        for (int c = 1;;) {
            go[i].push_back({c, hsh[(k + c - 1) / c]});
            int t = (k + c - 1) / c - 1;
            if (t == 0) break;
            c = (k + t - 1) / t;
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < id; ++j) {
            double val = dp[i][j];
            if (val == 0) continue;
            for (auto elem : go[j]) {
                int c = elem[0], k1 = elem[1];
                if (c > a[i]) break;
                int cur = a[i] / c;
                dp[i + 1][k1] = max(dp[i + 1][k1], val * cur / a[i]);
            }
        }
    }
    cout << fixed << setprecision(20);
    cout << dp[n][hsh[1]] << '\n';
    return 0;
}
--------------------------------------------------
Problem ID: 1801E
Editorial Content:
1801E - Gasoline prices
Solution
To begin with, let's understand what is required of us. A tree is given, in each vertex of which the price range for this vertex is recorded. A query is a pair of paths of equal length, the prices at the $$$i$$$-th vertices along these paths should be equal for all $$$i$$$. We need to find the number of ways to place prices at the vertices for each prefix of restrictions
Let's start with a slow solution of the problem. We will store the connectivity components (in each vertex prices should be equal). For each of them, we store an acceptable price range. The answer will be the product of the lengths of the ranges over all components. We will go along the paths and combine 2 vertices into one component using DSU. It is clear that to speed up this solution, it is necessary to search faster for the moments when two vertices are combined into one component.
First, let's analyze the long solution. Let's make a heavy-light decomposition, with which we will hash the paths in the tree, taking the root number of its components as a symbol for the vertex. Now, with the help of bin search, we will look for the first moment when the hashes on the path prefixes differ, that is, two vertices are combined into one component. With the help of transfusions, we will update the roots of their components for vertices and the tree of segments for hld. We will get $$$n$$$ unions, we will find each one for $$$O(log^2(n))$$$ using hld. There will also be $$$O(n\cdot log(n))$$$ updates in the segment tree due to overflows. For each request there will be $$$O(log^2(n))$$$ from hld. The final asymptotic $$$O((n+q)\cdot log^2(n))$$$
Now let's give a beautiful solution to this problem. Let's start with bamboo.
Replace the equality of prices on a pair of paths with two pairs of paths with lengths equal to the maximum power of two, less than the length of the original path (as in sparse table). Now the path lengths of all constraints have become powers of two. We will iterate over the powers of two in descending order $$$2^k$$$, for each path of length $$$2^k$$$ we will get a vertex in the graph, we will also get a vertex for each such path in reverse order. Now the constraints define edges in such a graph. Let's spend them, select the spanning tree. For each edge from the backbone, we divide the constraints into 2 constraints with path lengths half as long and continue the process. On a layer with lengths 1, we will get the spanning tree we need, which will be responsible for the first moments when some pairs of vertices were combined into components. Note that no more than $$$2n$$$ edges will be added down from each layer, as well as no more than $$$2q$$$ edges from queries. That is, each layer will work for $$$O((n + q)\cdot\alpha(n))$$$, where $$$\alpha(n)$$$ is the average operating time in DSU, the inverse of the Ackerman function. We got the solution in $$$O((n + q) \cdot\alpha(n)\cdot log(n))$$$
For a complete solution on the tree, first we divide a pair of paths into three pairs of corresponding vertical paths (take from the 4 end vertices of these paths the pair of vertices closest to the lca on its path, then we pair this path with a vertical path (part of another path), now we get one vertical path and an arbitrary path in the tree, let's split the second path by lca and the first by the corresponding lengths). Next, we will proceed similarly to bamboo, only the place of the vertex responsible for the segment, we will get the vertex responsible for the binary ascent in the tree to a height equal to the power of two.
Code
#include "bits/stdc++.h"

using namespace std;

const int mod = (int) 1e9 + 7;

int inv(int x) {
    int res = 1, n = mod - 2;
    while (n) {
        if (n & 1) {
            res = res * 1ll * x % mod;
        }
        x = x * 1ll * x % mod;
        n /= 2;
    }
    return res;
}

const int N = (int) 2e5 + 22, K = 18;
vector<int> g[N];
pair<int, int> a[N];
int n, q, ans = 1;
int h[N], up[N][K], lg[N];
vector<array<int, 3>> graph[K]; // lower vertex1, lower vertex2, time, vertex with direction
vector<array<int, 3>> gr[N];
vector<array<int, 3>> edges;

struct dsu {
    vector<int> p, sz;

    void build(int n) {
        p.resize(n);
        sz.resize(n);
        for (int i = 0; i < n; i++) {
            p[i] = i;
            sz[i] = 1;
        }
    }

    int get(int v) {
        return (v == p[v] ? v : p[v] = get(p[v]));
    }

    bool merge(int v, int u) {
        v = get(v), u = get(u);
        if (v != u) {
            if (sz[v] > sz[u]) {
                swap(v, u);
            }
            p[v] = u;
            sz[u] += sz[v];
            return true;
        }
        return false;
    }
} G, dsu[K];

void dfs(int v, int pr, int d) {
    h[v] = d;
    up[v][0] = pr;
    for (int j = 1; j < K; j++) {
        up[v][j] = up[up[v][j - 1]][j - 1];
    }
    for (auto u : g[v]) {
        dfs(u, v, d + 1);
    }
}

int la(int v, int x) {
    for (int j = 0; j < K; j++) {
        if (x >> j & 1) {
            v = up[v][j];
        }
    }
    return v;
}

int lca(int v, int u) {
    if (h[v] > h[u]) {
        swap(v, u);
    }
    u = la(u, h[u] - h[v]);
    if (v == u) {
        return v;
    }
    for (int j = K - 1; j >= 0; j--) {
        if (up[v][j] != up[u][j]) {
            v = up[v][j], u = up[u][j];
        }
    }
    return up[v][0];
}

int id(int v) {
    return (v > 0 ? v : -v + n);
}

int sgn(int v) {
    return (v > 0 ? 1 : -1);
}

void add_edge(int j, int v, int u, int t) {
    if (dsu[j].merge(id(v), id(u))) {
        if (j > 0) {
            if (sgn(v) == sgn(u)) {
                add_edge(j - 1, v, u, t);
                add_edge(j - 1, sgn(v) * up[abs(v)][j - 1], sgn(u) * up[abs(u)][j - 1], t);
            } else {
                if (sgn(v) == -1) {
                    swap(v, u);
                }
                add_edge(j - 1, v, sgn(u) * up[abs(u)][j - 1], t);
                add_edge(j - 1, sgn(v) * up[abs(v)][j - 1], u, t);
            }
        } else {
            edges.push_back({abs(v), abs(u), t});
        }
    }
}

void add(int v, int u, int x, int y, int t, int type1, int type2) {
    if (h[v] < h[u]) {
        swap(v, u);
    }
    if (h[x] < h[y]) {
        swap(x, y);
    }
    assert(h[v] - h[u] == h[x] - h[y]);
    int g = lg[h[v] - h[u]];
    if (type1 == type2) {
        add_edge(g, type1 * v, type2 * x, t);
        add_edge(g, type1 * la(v, h[v] - h[u] - (1 << g) + 1), type2 * la(x, h[x] - h[y] - (1 << g) + 1), t);
    } else {
        add_edge(g, type1 * v, type2 * la(x, h[x] - h[y] - (1 << g) + 1), t);
        add_edge(g, type1 * la(v, h[v] - h[u] - (1 << g) + 1), type2 * x, t);
    }
}

void merge(int v, int u) {
    v = G.get(v), u = G.get(u);
    if (v != u) {
        G.merge(v, u);
        if (G.sz[v] > G.sz[u]) {
            swap(v, u);
        }
        if (a[v].first <= a[v].second) {
            ans = ans * 1ll * inv(a[v].second - a[v].first + 1) % mod;
        }
        if (a[u].first <= a[u].second) {
            ans = ans * 1ll * inv(a[u].second - a[u].first + 1) % mod;
        }
        a[u].first = max(a[u].first, a[v].first);
        a[u].second = min(a[u].second, a[v].second);
        if (a[u].first > a[u].second) {
            ans = 0;
        } else {
            ans = ans * 1ll * (a[u].second - a[u].first + 1) % mod;
        }
    }
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    for (int j = 2; j < N; j++) {
        lg[j] = lg[j / 2] + 1;
    }
    cin >> n;
    for (int i = 2; i <= n; i++) {
        int v;
        cin >> v;
        g[v].push_back(i);
    }
    for (int i = 1; i <= n; i++) {
        cin >> a[i].first >> a[i].second;
        ans = ans * 1ll * (a[i].second - a[i].first + 1) % mod;
    }
    dfs(1, 1, 0);
    cin >> q;
    for (int j = 0; j < K; j++) {
        dsu[j].build(2 * n + 1);
    }
    for (int i = 0; i < q; i++) {
        int v, u, x, y;
        cin >> v >> u >> x >> y;
        int w = lca(v, u);
        int z = lca(x, y);
        if (h[v] - h[w] > h[x] - h[z]) {
            swap(v, x);
            swap(u, y);
            swap(w, z);
        }
        if (v != w) {
            int d = h[v] - h[w];
            int v2 = la(v, d - 1);
            int x2 = la(x, d - 1);
            add(v, v2, x, x2, i, 1, 1);
            v = up[v2][0];
            x = up[x2][0];
        }
        if (x != z) {
            int d = h[x] - h[z];
            int v2 = la(u, (h[u] - h[v]) - d);
            int x2 = la(x, d - 1);
            add(v, up[v2][0], x, x2, i, -1, 1);
            v = v2;
            x = up[x2][0];
        }
        add(v, u, x, y, i, (h[v] > h[u] ? 1 : -1), (h[x] > h[y] ? 1 : -1));
    }
    G.build(n + 1);
    int j = 0;
    for (int i = 0; i < q; i++) {
        while (j < (int) edges.size() && edges[j][2] == i) {
            merge(edges[j][0], edges[j][1]);
            j++;
        }
        cout << ans << '\n';
    }
}
--------------------------------------------------
Problem ID: 1801D
Editorial Content:
1801D - The way home
Solution
Note that the show can be done "postponed". As soon as we don't have enough money to walk along the edge, we can do several shows in advance among the peaks that we have already passed, so as to earn the maximum amount of money.
For the general case, you can write $$$dp[v][best] = (\textit{min show}, \textit{max money})$$$, where $$$v$$$ is the number of the vertex where we are, and $$$best$$$ is the vertex with max. $$$w_i$$$, which we have already passed through. It can be shown that it is optimal to minimize the number of shows first, and then maximize the amount of money. This dynamics can be recalculated using Dijkstra's algorithm. Asymptotics of $$$O(mn\log n)$$$
Code
#include "bits/stdc++.h"

#define rep(i, n) for (int i = 0; i < (n); ++i)
#define pb push_back
#define all(a) (a).begin(), (a).end()
#define ar array
#define vec vector

using namespace std;

using ll = long long;
using pi = pair<int, int>;

using vi = vector<int>;
using vpi = vector<pair<int, int>>;

const ll INF = 2e18;
const int maxN = 3e5 + 10;

struct PathParams {
    ll num_show;
    int money;
};

bool operator==(const PathParams &a, const PathParams &b) {
    return tie(a.num_show, a.money) == tie(b.num_show, b.money);
}

bool operator!=(const PathParams &a, const PathParams &b) {
    return !(a == b);
}

struct State {
    PathParams params;
    int v;
    int best;
};

bool operator<(const PathParams &a, const PathParams &b) {
    if (a.num_show != b.num_show) return a.num_show < b.num_show;
    return a.money > b.money;
}

bool operator<(const State &a, const State &b) {
    return tie(a.params, a.v, a.best) < tie(b.params, b.v, b.best);
}

bool operator>(const State &a, const State &b) {
    return !(a < b);
}

void solve() {
    int n, m, p, group;
    cin >> n >> m >> p;
    vector dp(n, vector<PathParams>(n, {INF, 0}));
    vector<vpi> g(n);
    vi w(n);
    rep(i, n) cin >> w[i];
    rep(i, m) {
        int a, b, s;
        cin >> a >> b >> s;
        a--;
        b--;
        g[a].emplace_back(b, s);
    }
    dp[0][0] = {0, p};
    priority_queue<State, vector<State>, greater<>> pq;
    pq.push({.params = {.num_show=0, .money=p}, .v = 0, .best=0});
    while (!pq.empty()) {
        auto current = pq.top();
        pq.pop();
        int v = current.v;
        int best = current.best;
        if (dp[v][best] != current.params) continue;
        for (auto &[u, s]: g[v]) {
            auto state2 = current;
            PathParams &path = state2.params;
            if (path.money < s) {
                ll need = (s - path.money + w[best] - 1) / w[best];
                path.num_show += need;
                path.money += need * w[best];
                assert(path.money < s + w[best]);
            }
            path.money -= s;
            state2.v = u;
            if (w[u] > w[state2.best]) state2.best = u;
            if (path < dp[u][state2.best]) {
                dp[u][state2.best] = path;
                pq.push(state2);
            }
        }
    }
    ll ans = INF;
    rep(i, n) {
        ans = min(ans, dp[n - 1][i].num_show);
    }
    cout << (ans == INF ? -1 : ans) << '\n';
}

signed main() {
    int t = 1;
    cin >> t;
    rep(_, t) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1801C
Editorial Content:
1801C - Music Festival
Solution
Let's introduce the concept of a compressed album for an album, which is obtained from the original one by removing all elements except those that are the first maxima on their corresponding prefixes.
For example:
For the album $$$[\textbf{1}, \textbf{4}, 4, 3, \textbf{6}, 5, 6]$$$ the album will be compressed $$$[1, 4, 6]$$$.
Now we note that the solution of the original problem is reduced to solving the same problem, but on compressed albums. Indeed, the answer to them will not be different, because if some element increased the impression on ordinary albums, then it will increase if you compress albums and vice versa. Next, it will be assumed that all albums have been compressed beforehand.
Let's introduce $$$dp_c$$$ — the maximum impression that can be obtained if there were no albums such that they have elements larger than $$$c$$$. Then, $$$dp_c$$$ is equal to $$$dp_{c-1}$$$, or you can add another element or two if $$$c$$$ is the maximum element for some album. Then for all compressed albums, it can be recalculated through the value of $$$dp$$$ at the point before the first element of the album, or through $$$c - 1$$$. Thus, for recalculation, it is enough to know for each $$$c$$$ which albums ended in this index, as well as for each album its first element. Solution for $$$O(K)$$$
Let's now solve the complete problem. For each value of $$$c$$$, let's remember the indexes of albums that contain an element equal to $$$c$$$. We go in order of increasing $$$c$$$, we maintain for each album the value of $$$dp_i$$$ — the maximum impression that can be obtained if there were no elements of large $$$c$$$ and Masha listened to the last $$$i$$$ album. Suppose for the next $$$c$$$ there is an album $$$i$$$, that there is a song with the coolness of $$$c$$$ in it. Then $$$dp_i$$$ should be taken as the maximum of $$$dp_i + 1$$$ and the values for all $$$dp_j + 1$$$, such that the maximum element in the $$$j$$$th album is less than the maximum element of $$$i$$$th, since she could listen to this track, either next in this album, or after listening to some other album completely. Note that you can store the value of $$$mx$$$ — maximum for all albums for which the maximum value in them is less than $$$c$$$ and recalculate it when moving to $$$c + 1$$$, storing those albums that have ended, then you will get a solution for $$$O(K + C)$$$.
Code
#include "bits/stdc++.h"
#include <algorithm>
#include <locale>
#include <random>
#include <unordered_map>
#include <vector>

using namespace std;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
typedef long long ll;
typedef long double db;
typedef unsigned long long ull;

vector<int> shrink(vector<int> &a) {
  vector<int> a1;
  int n = a.size();
  int mx = 0;
  for (int i = 0; i < n; ++i) {
    if (a[i] > mx) {
      a1.emplace_back(a[i]);
      mx = a[i];
    }
  }
  return a1;
}

void solve() {
  int n;
  cin >> n;
  vector<vector<int>> a(n);
  int k;
  for (int i = 0; i < n; ++i) {
    int k;
    cin >> k;
    a[i].resize(k);
    for (auto &j : a[i]) {
      cin >> j;
    }
  }
  vector<vector<int>> a1(n);
  for (int i = 0; i < n; ++i) {
    a1[i] = shrink(a[i]);
  }
  map<int, vector<int>> b;
  for (int i = 0; i < n; ++i) {
    for (auto &j : a1[i]) {
      b[j].emplace_back(i);
    }
  }
  vector<int> dp(n);
  int closed = 0;
  for (auto &it : b) {
    int c = it.first;
    int newclosed = 0;
    for (auto &i : it.second) {
      if (c == a1[i].back()) {
        dp[i] = max(dp[i] + 1, closed + 1);
        newclosed = max(newclosed, dp[i]);
        continue;
      }
      if (c == a1[i].front()) {
        dp[i] = closed + 1;
        continue;
      }
      dp[i] = max(dp[i] + 1, closed + 1);
    }
    closed = max(closed, newclosed);
  }
  cout << *max_element(all(dp));
}

signed main() {
  int t = 0;
  cin >> t;
  while (t --> 0) {
      solve();
      cout << '\n';
  }
  return 0;
}
--------------------------------------------------
Problem ID: 1801B
Editorial Content:
1801B - Buying gifts
Solution
To begin with, let's sort all departments in descending order $$$b_i$$$ (and if ~--- is equal, in ascending order $$$a_i$$$). Now let's go through the $$$i$$$ department, in which the most expensive gift for the second girlfriend will be bought. Note that in all departments with numbers $$$j < i$$$, Sasha must buy a gift for the first girlfriend, otherwise the gift $$$i$$$ will not have the maximum value among the gifts bought for the second girlfriend. Therefore, we will immediately find the value of $$$m = \max \limits_{j < i} a_j$$$. Thus, we can already get the answer $$$\lvert m - b_i\rvert$$$.
In all departments with numbers $$$j > i$$$, for which $$$a_j \le m$$$, Sasha can buy a gift for any of her friends, and this will not affect the answer in any way. Now consider all departments with numbers $$$j > i$$$ for which $$$a_j > m$$$. If you buy a gift for your first girlfriend in some of these departments, the value of $$$m$$$ will increase, which means the answer may improve. Therefore, let's iterate through all these departments and update the response with the value $$$\lvert a_j - b_i\rvert$$$.
Time $$$O(n^2)$$$.
Let's optimize this solution. To begin with, instead of calculating the value of $$$m$$$ anew at each iteration, we will maintain its value in some variable. Then, when moving from department $$$i - 1$$$ to department $$$i$$$, we will update the value of $$$m$$$ as follows: $$$m:= \max(m, a_i)$$$.
It remains to learn how to quickly find the optimal department number $$$j$$$, such that $$$j > i$$$, $$$a_j > m$$$, as well as $$$\lvert a_j - b_i\rvert$$$ is minimal. Let's choose on the suffix of the array the minimum $$$a_j$$$, such that $$$a_j\ge b_i$$$, and also the maximum $$$a_j$$$, such that $$$a_j \le b_i$$$. You can notice that the optimal $$$a_j$$$ is one of the two selected numbers (you also need to remember to check the condition $$$a_j > m$$$). Therefore, it is enough to update the answer only with the help of them.
You can search for these two elements using the \texttt{set} data structure. We will support in the set all $$$a_j$$$ located on the suffix. Then you can find the necessary two elements for $$$O(\log n)$$$. When moving from department $$$i - 1$$$ to department $$$i$$$, you need to remove the value $$$a_{i - 1}$$$ from the data structure.
Time $$$O(n\log n)$$$
Code
#include <bits/stdc++.h>

using namespace std;

template<typename T>
bool smin(T& a, const T& b) {
    if (b < a) {
        a = b;
        return true;
    }
    return false;
}

template<typename T>
bool smax(T& a, const T& b) {
    if (a < b) {
        a = b;
        return true;
    }
    return false;
}

const int INF = 0x3f3f3f3f;
const int N = 500100;

std::pair<int, int> a[N];

void run() {
    int n;
    scanf("%d", &n);

    for (int i = 0; i < n; ++i) {
        scanf("%d%d", &a[i].first, &a[i].second);
    }

    sort(a, a + n, [&](const pair<int, int>& p1, 
                            const pair<int, int>& p2) {
        return p1.second > p2.second || (p1.second == p2.second && p1.first < p2.first);
    });

    multiset<int> setik;
    for (int i = 0; i < n; ++i) {
        setik.insert(a[i].first);
    }

    int mx = -INF;
    int ans = INF;
    
    for (int i = 1; i < n; ++i) {
        smin(ans, abs(a[i].first - a[0].second));
    }
    
    for (int i = 0; i < n; ++i) {
        setik.erase(setik.find(a[i].first));
        if (i == 0) {
            mx = a[i].first;
            continue;
        }

        smin(ans, abs(mx - a[i].second));
        auto it = setik.lower_bound(a[i].second);
        if (it != setik.end() && *it >= mx) {
            smin(ans, abs(*it - a[i].second));
        }
        if (it != setik.begin() && *std::prev(it) >= mx) {
            smin(ans, abs(*prev(it) - a[i].second));
        }

        smax(mx, a[i].first);
    }

    printf("%d\n", ans);
}

int main(void) {
    int t;
    scanf("%d", &t);
    while (t--) {
        run();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1801A
Editorial Content:
1801A - The Very Beautiful Blanket
Solution
The maximum number of different numbers we can type is always $$$n\cdot m$$$. Let's show how you can build an example for any $$$n$$$ and $$$m$$$.
Note that if we were able to construct a correct matrix, then any of its submatrix is also a correct matrix of a smaller size. Therefore, let's build a correct matrix for some $$$N$$$ and $$$M$$$, and as an answer we will output the upper left corner of this matrix of the desired size.
Take $$$N = M = 2^8$$$ and construct the matrix using the following algorithm. Let's break it into blocks of size $$$2 \times 2$$$. Let's number the blocks from left to right and from top to bottom in order, starting from zero. The $i$th block will have the form
$$$4i + 0$$$ $$$4i + 1$$$
$$$4i + 2$$$ $$$4i + 3$$$
With this construction, the bitwise exclusive OR any submatrix of size $$$2\times 2$$$ will be zero. You can verify this as follows. Let's look at the upper left corner of $$$(i,\,j)$$$ of an arbitrary submatrix of size $$$2\times 2$$$. There are 4 cases:
both coordinates are even;
$$$i$$$ is even, $$$j$$$ is odd;
$$$i$$$ odd, $$$j$$$ even;
both coordinates are odd.
Immediately note that $$$i, \, j < 200 < 2^8$$$
Consider the most unpleasant case — the last one. The remaining cases are treated in a similar way. In this case, the submatrix will have the form:
$$$4i + 3$$$ $$$4(i + 1) + 2$$$
$$$4(i + 2^8) + 1$$$ $$$4(i + 2^8 + 1) + 0$$$
Note that the second part of each term is less than 4, and the first part of each term is greater than or equal to 4. Therefore, they can be considered independently.
$$$3 \oplus 2 \oplus 1 \oplus 0$$$ $$$=$$$ $$$0$$$.
If $$$i$$$$$$=$$$$$$1$$$, then
$$$4i \oplus 4(i + 1)$$$ $$$=$$$ $$$12$$$,
$$$4(1 + 2^8) \oplus 4(2 + 2^8)$$$ $$$=$$$ $$$12$$$.
If $$$i\neq 1$$$, then
$$$4i \oplus 4(i + 1)$$$ $$$=$$$ $$$4$$$
$$$4(i + 2^8) \oplus 4(i + 2^8 + 1)$$$$$$=$$$$$$4$$$ (for $$$i=0$$$, you can check with your hands, for $$$1 < i <2^8$$$ $$$4(i+ 2^8)$$$ will be reduced and $$$4$$$ will remain from the second term).
$$$4 \oplus 4 \oplus 0$$$ $$$=$$$ $$$0$$$. Thus, in the selected submatrix, the bitwise exclusive OR is zero.
Code
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int SZ = 256;

int v[SZ][SZ];

void Solve(){
    int n, m;
    cin >> n >> m;

    cout << n * m << '\n';

    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            cout << v[i][j] << " \n"[j + 1 == m];
}

signed main(){
    ios_base::sync_with_stdio(NULL);
    cin.tie(NULL);
    cout.tie(NULL);

    {
        int now = 0;
        int n = 256;
        int m = 256;

        for(int i = 0; i < n; i += 2)
            for(int j = 0; j < m; j += 2){
                v[i][j] = now;
                v[i][j + 1] = now + 1;
                v[i + 1][j] = now + 2;
                v[i + 1][j + 1] = now + 3;
                now += 4;
            }
    }

    int num_test = 1;
    cin >> num_test;

    for(int i = 1; i <= num_test; i++){
        Solve();
    }
}
--------------------------------------------------
Problem ID: 1800G
Editorial Content:
1800G - Symmetree
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define int long long
#define pb emplace_back
#define mp make_pair
#define x first
#define y second
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()

typedef long double ld;
typedef long long ll;

using namespace std;

mt19937 rnd(time(nullptr));

const int inf = 2e18;
const ll M = 1e9;
const ld pi = atan2(0, -1);
const ld eps = 1e-6;

int last;
map<vector<int>, int> eq;
map<int, bool> symmetrical;

int dfs(int v, int p, vector<vector<int>> &sl){
    vector<int> children;
    for(int u: sl[v]){
        if(u == p) continue;
        children.emplace_back(dfs(u, v, sl));
    }
    sort(all(children));
    if(!eq.count(children)){
        map<int, int> cnt;
        for(int e: children){
            cnt[e]++;
        }
        int odd = 0, bad = 0;
        for(auto e: cnt){
            if(e.y & 1){
                odd++;
                bad += !symmetrical[e.x];
            }
        }
        eq[children] = last;
        symmetrical[last] = odd < 2 && bad == 0;
        last++;
    }
    return eq[children];
}

void solve(int tc){
    int n;
    cin >> n;
    eq.clear();
    symmetrical.clear();
    eq[vector<int>(0)] = 0;
    symmetrical[0] = true;
    last = 1;
    vector<vector<int>> sl(n);
    for(int i = 1; i < n; ++i){
        int u, v;
        cin >> u >> v;
        sl[--u].emplace_back(--v);
        sl[v].emplace_back(u);
    }
    cout << (symmetrical[dfs(0, 0, sl)]? "YES" : "NO");
}

bool multi = true;

signed main() {
    int t = 1;
    if (multi)cin >> t;
    for (int i = 1; i <= t; ++i) {
        solve(i);
        cout << "\n";
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1800F
Editorial Content:
1800F - Dasha and Nightmares
Tutorial
Tutorial is loading...
Solution
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("avx2,avx,fma,bmi2")

#include <bits/stdc++.h>
#include <immintrin.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;

#define endl '\n'
//#define int long long
#define all(arr) arr.begin(), arr.end()
#define multitest() int _gorilla_silverback; cin >> _gorilla_silverback; while (_gorilla_silverback --> 0)
#define pikachu push_back
#define ls(id) (id << 1 | 1)
#define rs(id) ((id << 1) + 2)
#define sqr(x) ((x) * (x))
#define dlg(x) (31 - __builtin_clz(x))
#define ulg(x) (32 - __builtin_clz(x))

typedef pair<int, int> ipair;
typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> treap;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

const int MAXN = 200200;
const int L = 26;

int n;
string srr[MAXN];
int arr[MAXN], brr[MAXN], crr[MAXN];

void build() {
	for (int i = 0; i < n; ++i) {
		for (char c: srr[i]) {
			arr[i] ^= (1 << (c - 'a'));
			brr[i] |= (1 << (c - 'a'));
		}
	}
}

long long calc(int c) {
	int k = 0;
	for (int i = 0; i < n; ++i)
		if (brr[i] >> c & 1 ^ 1) crr[k++] = arr[i];
	sort(crr, crr + k);
	int mask = -1 & ((1 << L) - 1) ^ (1 << c);
	long long ans = 0;
	for (int i = 0; i < k; ++i) {
		auto itl = lower_bound(crr, crr + k, crr[i] ^ mask);
		auto itr = upper_bound(crr, crr + k, crr[i] ^ mask);
		ans += itr - itl;
	}
	return ans >> 1LL;
}

long long solve() {
	long long ans = 0;
	for (int c = 0; c < L; ++c)
		ans += calc(c);
	return ans;
}

signed main() {
	ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
	cin >> n;
	for (int i = 0; i < n; ++i)
		cin >> srr[i];
	build();
	cout << solve() << endl;
}
--------------------------------------------------
Problem ID: 1800E2
Editorial Content:
1800E2 - Unforgivable Curse (hard version)
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

#define sz(v) (int)v.size()
#define all(v) v.begin(),v.end()
#define eb emplace_back

void solve() {
    int n, k; cin >> n >> k;
    string s; cin >> s;
    string t; cin >> t;
    vector<int> cnt(26, 0);

    bool ok = true;
    for (int i = 0; i < n; ++i) {
        if (i >= k || i+k < n){
            cnt[s[i] - 'a']++;
            cnt[t[i] - 'a']--;
        } else {
            ok &= s[i] == t[i];
        }
    }

    cout << (ok && count(all(cnt), 0) == 26 ? "YES" : "NO") << '\n';
}

int main() {
    int t;
    cin >> t;

    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1800E1
Editorial Content:
1800E1 - Unforgivable Curse (easy version)
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

#define sz(v) (int)v.size()
#define all(v) v.begin(),v.end()
#define eb emplace_back


void slow_solve(int n, int k, string s, string t) {
    set<string> was;

    queue<string> q;
    q.push(s);
    was.insert(s);

    auto add = [&](string& s, int i, int j) {
        if (i >= 0 && i < j && j < n) {
            swap(s[i], s[j]);
            if (!was.count(s)) {
                was.insert(s);
                q.push(s);
            }
            swap(s[i], s[j]);
        }

    };

    while (!q.empty()) {
        s = q.front(); q.pop();
        for (int i = 0; i < n; ++i) {
            add(s, i, i+k);
            add(s, i, i+k+1);
            add(s, i-k, i);
            add(s, i-k-1, i);
        }
    }
    cout << (was.count(t) ? "Yes" : "No") << '\n';
}

void solve() {
    int n,k; cin >> n >> k;
    string s; cin >> s;
    string t; cin >> t;

    if (n <= 5) {
        slow_solve(n, k, s, t);
        return;
    }
    map<char, int> cnt;
    for (char c : s) {
        cnt[c]++;
    }

    for (char c : t) {
        cnt[c]--;
    }

    bool ok = true;
    for (auto [c, x] : cnt) {
        ok &= x == 0;
    }
    cout << (ok ? "Yes" : "No") << '\n';
}

int main() {
    int t;
    cin >> t;

    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1800D
Editorial Content:
1800D - Remove Two Letters
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <queue>
#include <map>
#include <set>

using namespace std;

void solve() {
    int n;
    cin >> n;
    string s;
    cin >> s;
    int res = n - 1;
    for (int i = 1; i + 1 < n; ++i) {
        if (s[i - 1] == s[i + 1]) {
            res--;
        }
    }
    cout << res << '\n';
}

int main(int argc, char* argv[]) {
    int t;
    cin >> t;
    for (int i = 0; i < t; ++i) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1800C2
Editorial Content:
1800C2 - Powering the Hero (hard version)
Tutorial
Tutorial is loading...
Solution
from queue import PriorityQueue


def solve():
    n = int(input())
    s = [int(x) for x in input().split()]
    ans = 0
    buffs = PriorityQueue()
    for e in s:
        if e > 0:
            buffs.put(-e)
        elif not buffs.empty():
            ans -= buffs.get()
    print(ans)


t = int(input())
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 1800C1
Editorial Content:
1800C1 - Powering the Hero (easy version)
Tutorial
Tutorial is loading...
Solution
def solve():
    n = int(input())
    s = [int(x) for x in input().split()]
    ans = 0
    buffs = [0] * n
    for e in s:
        if e > 0:
            buffs += [e]
            j = len(buffs) - 1
            while buffs[j] < buffs[j - 1]:
                buffs[j], buffs[j - 1] = buffs[j - 1], buffs[j]
                j -= 1
        else:
            ans += buffs.pop()
    print(ans)


t = int(input())
for _ in range(t):
    solve()
--------------------------------------------------
Problem ID: 1800B
Editorial Content:
1800B - Count the Number of Pairs
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
const int N = 26;

void solve(){
    int n, k;
    cin >> n >> k;
    string s;
    cin >> s;
    vector<int>big(N, 0), small(N, 0);
    for(auto &i : s){
        if('A' <= i && 'Z' >= i) big[i - 'A']++;
        else small[i - 'a']++;
    }
    int answer = 0;
    for(int i = 0; i < N; i++){
        int pairs = min(small[i], big[i]);
        answer += pairs;
        small[i] -=pairs; big[i] -= pairs;
        int add = min(k, max(small[i], big[i]) / 2);
        k -= add; answer += add;
    }
    cout << answer << endl;
}
int main(){
    int t;
    cin >> t;
    while(t--) solve();
    return 0;
}
--------------------------------------------------
Problem ID: 1800A
Editorial Content:
1800A - Is It a Cat?
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;

void solve(){
    int n;
    cin >> n;
    string s;
    cin >> s;
    transform(s.begin(), s.end(), s.begin(), [] (char c) {
        return tolower(c);
    });
    s.erase(unique(s.begin(), s.end()), s.end());
    cout << (s == "meow" ? "YES" : "NO") << "\n";
}

int main(){
    int t;
    cin >> t;
    while(t--) solve();
}
--------------------------------------------------
Problem ID: 1799H
Editorial Content:

--------------------------------------------------
Problem ID: 1799G
Editorial Content:

--------------------------------------------------
Problem ID: 1799F
Editorial Content:

--------------------------------------------------
Problem ID: 1799E
Editorial Content:

--------------------------------------------------
Problem ID: 1799D2
Editorial Content:

--------------------------------------------------
Problem ID: 1799D1
Editorial Content:

--------------------------------------------------
Problem ID: 1799C
Editorial Content:

--------------------------------------------------
Problem ID: 1799B
Editorial Content:

--------------------------------------------------
Problem ID: 1799A
Editorial Content:

--------------------------------------------------
Problem ID: 1798F
Editorial Content:
1798F - Gifts from Grandfather Ahmed
Hint 1
Let's say the box you selected will be sent to the largest class. Then if this class has a size of $$$s$$$, you can send any $$$s-1$$$ from the available boxes there. So you can not worry about this class, and pick boxes for the rest, always having as potential options $$$s-1$$$ additional boxes. Plenty of room for maneuver.
Hint 2
The solution exists for any valid input
Hint 3
After Hint2 think about some specific inputs. You know, they always have a solution. This should inspire you.
Hint 3.1
$$$k = 2, s_1 = s_2$$$.
Hint 4
Erdős--Ginzburg--Ziv theorem
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
 
#define pb push_back
// #define int long long
#define all(x) x.begin(), x.end()
#define ld long double
using namespace std;
const int N = 210;
bool dp[N][N][N];
bool take[N][N][N];
 
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n, k;
    cin >> n >> k;
    vector<int> a(n), s(k);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    for (int i = 0; i < k; i++) {
        cin >> s[i];
    }
    vector<pair<int, int>> s2;
    for (int i = 0; i < k; i++) {
        s2.pb({s[i], i});
    }
    sort(all(s2));
    vector<vector<int>> ans(k);
    for (int i = 0; i < k - 1; i++) {
        int class_size = s2[i].first;
        vector<int> boxes;
        for (int _ = 0; _ < 2 * class_size - 1; _++) {
            boxes.pb(a.back());
            a.pop_back();
        }
        for (int sz = 0; sz <= class_size; sz++) {
            for (int r = 0; r < class_size; r++) {
                dp[0][sz][r] = false;
                take[0][sz][r] = false;
            }
        }
        dp[0][0][0] = true;
        dp[0][1][boxes[0] % class_size] = true;
        take[0][1][boxes[0] % class_size] = true;
        for (int j = 1; j < (int) boxes.size(); j++) {
            for (int sz = 0; sz <= class_size; sz++) {
                for (int r = 0; r < class_size; r++) {
                    dp[j][sz][r] = dp[j - 1][sz][r];
                    if (sz > 0 && dp[j - 1][sz - 1][(class_size + r - boxes[j] % class_size) % class_size]) {
                        dp[j][sz][r] = true;
                        take[j][sz][r] = true;
                    } else {
                        take[j][sz][r] = false;
                    }
                }
            }
        }
        vector<bool> used(2 * class_size - 1);
        int sz = class_size, r = 0;
        for (int j = (int) boxes.size() - 1; j >= 0; j--) {
            if (take[j][sz][r]) {
                used[j] = true;
                sz--;
                r += (class_size - boxes[j] % class_size);
                r %= class_size;
            } else {
                used[j] = false;
            }
        }
        vector<int> to_class;
        for (int j = 0; j < (int) boxes.size(); j++) {
            if (!used[j]) {
                a.pb(boxes[j]);
            } else {
                to_class.pb(boxes[j]);
            }
        }
        ans[s2[i].second] = to_class;
    }
 
    int sum = 0;
    for (auto x : a) {
        sum += x;
        sum %= (int) (a.size() + 1);
    }
    int add = (int) (a.size() + 1) - sum;
    ans[s2[k - 1].second] = a;
    ans[s2[k - 1].second].pb(add);
 
    cout << add << '\n';
    for (auto arr : ans) {
        for (auto x : arr) {
            cout << x << ' ';
        }
        cout << '\n';
    }
}
Rate the problem
Didnt solve
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1798E
Editorial Content:
1798E - Multitest Generator
Hint 1
Estimate from above the number of changes for which you can make a multitest from an arbitrary array.
Hint 2
How to check for each suffix whether it is a multitest by itself (without changes)?
Hint 2.1
This is done using one-dimensional dynamic programming by suffixes.
Hint 3
Let's say you want to check if an array can turn into a multitest for $$$1$$$ change. Find all the elements that could potentially be changed (all the elements are such that changing them could lead to the array becoming a multitest without being it initially). For each of them, you need to determine whether it is possible to make a change that turns array into multitest. One-dimensional dynamic programming by suffixes will help to take into account all these variants of change.
Tutorial
Tutorial is loading...
Solution
N = 300777
a = [0] * N
go = [0] * N
good_chain = [0] * N
chain_depth = [0] * N
suf_max_chain_depth = [0] * N

ans = ""
for _ in range(int(input())):
    n = int(input())
    a = [0] + list(map(int, input().split()))
    chain_depth[n + 1] = 0
    suf_max_chain_depth[n + 1] = 0
    curr_max_chain_depth = 0
    for i in range(n, 0, -1):
        go[i] = i + a[i] + 1
        if go[i] == n + 1 or (go[i] <= n and good_chain[go[i]]):
            good_chain[i] = True
        else:
            good_chain[i] = False
        chain_depth[i] = 1 + chain_depth[min(go[i], n + 1)]
        suf_max_chain_depth[i] = 1 + curr_max_chain_depth
        if go[i] <= n + 1:
            suf_max_chain_depth[i] = max(suf_max_chain_depth[i], 1 + suf_max_chain_depth[go[i]])
        if good_chain[i]:
            curr_max_chain_depth = max(curr_max_chain_depth, chain_depth[i])
    for i in range(1, n):
        if good_chain[i + 1] and chain_depth[i + 1] == a[i]:
            ans += "0 "
        elif good_chain[i + 1] or suf_max_chain_depth[i + 1] >= a[i]:
            ans += "1 "
        else:
            ans += "2 "
    ans += '\n'
print(ans)
Rate the problem
Didnt solve
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1798D
Editorial Content:
1798D - Shocking Arrangement
Hint 1
Express $$$\max\limits_{1 \leq l \leq r \leq n} \lvert a_l+a_{l+1}+\ldots+a_r\rvert$$$ in a simpler way.
Hint 1.1
Use the prefix sums of the array $$$a$$$.
Hint 2
Build the answer starting from an empty array. If you add numbers to the response so that the prefix sum is always in the half-interval $$$(\min(a), \max(a)]$$$, the resulting array will fit the condition. How to do it? Remember that the sum of the array is $$$0$$$.
Tutorial
Tutorial is loading...
Solution
for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    if max(a) == 0:
        print("No")
    else:
        print("Yes")
        prefix_sum = 0
        pos = []
        neg = []
        for x in a:
            if x >= 0:
                pos.append(x)
            else:
                neg.append(x)
        ans = []
        for _ in range(n):
            if prefix_sum <= 0:
                ans.append(pos[-1])
                pos.pop()
            else:
                ans.append(neg[-1])
                neg.pop()
            prefix_sum += ans[-1]
        print(' '.join(list(map(str, ans))))
Rate the problem
Didnt solve
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1798C
Editorial Content:
1798C - Candy Store
Hint 1
In which case 1 price tag is enough?
Hint 1.1
For any positive integers $$$x, y, z$$$, the statement ``$$$x$$$ is divisible by $$$y$$$'' equivalent to the statement ``$$$xz$$$ is divisible by $$$yz$$$'
Hint 1.2
Let's denote the total cost of all packs of candies for $$$cost$$$. Rewrite all the conditions given in the problem so that they become conditions only for the number $$$cost$$$. Hint1.1 will help in this.
Hint 2
If one price tag is enough for a set of candies, then if you remove any type of candy from this set, one price tag will still be enough. This is a reason to think about greedy.
Tutorial
Tutorial is loading...
Solution
from math import gcd
 
def lcm(a, b):
  return a * b // gcd(a, b)
 
for _ in range(int(input())):
    n = int(input())
    a = []
    b = []
    for i in range(n):
       ai, bi = map(int, input().split())
       a.append(ai)
       b.append(bi)
    g = 0
    l = 1
    ans = 1
    for i in range(n):
        g = gcd(g, a[i] * b[i])
        l = lcm(l, b[i])
        if g % l:
            ans += 1
            g = a[i] * b[i]
            l = b[i]
    print(ans)
Rate the problem
Didnt solve
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1798B
Editorial Content:
1798B - Three Sevens
Hint 1
Let the participant with the number $$$X$$$ participate in the lottery in days $$$i_1 < i_2 < \ldots < i_k$$$. On what days could the participant $$$X$$$ be chosen as the winner so as not to break the conditions?
Hint 2
If there are several candidates for the lottery winner on the day of $$$i$$$ (who did not participate in the days from $$$i+1$$$ to $$$m$$$), does it matter which of them we choose as a winner?
Tutorial
Tutorial is loading...
Solution
MAX = 50000
last = [0] * (MAX + 777)
for _ in range(int(input())):
    m = int(input())
    a_ = []
    for day in range(m):
        n = int(input())
        a = list(map(int, input().split()))
        for x in a:
            last[x] = day
        a_.append(a)
    ans = [-1] * m
    for day in range(m):
        for x in a_[day]:
            if last[x] == day:
                ans[day] = x
        if ans[day] == -1:
            print(-1)
            break
    else:
        print(*ans)
Rate the problem
Didnt solve
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1798A
Editorial Content:
1798A - Showstopper
Hint 1
For each index $$$i$$$, it makes no sense to perform the operation $$$\ge 2$$$ once, since applying the operation with the same index twice does not change anything.
Hint 2
Condition $$$a_n = \max(a_1, a_2, \ldots, a_n)$$$ is equivalent to $$$a_i \leq a_n$$$ for all $$$i$$$. So for each index $$$i$$$ there are only 2 conditions: $$$a_i \leq a_n$$$ and $$$b_i \leq b_n$$$.
Tutorial
Tutorial is loading...
Solution
for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    for i in range(n):
        if a[i] > b[i]:
            a[i], b[i] = b[i], a[i]
    if a[-1] == max(a) and b[-1] == max(b):
        print("YES")
    else:
        print("NO")
Rate the problem
Didnt solve
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1797F
Editorial Content:
1797F - Li Hua и путь
Tutorial
Tutorial is loading...
Solution (Celtic, centroid decomposition)
// Celtic
#include<bits/stdc++.h> 
#define N 501001
#define MAX 2005
using namespace std;
typedef long long ll;
typedef long double db;
const ll inf=1e18,mod=998244353,inv3=(mod+1)/3;
inline void read(ll &ret)
{
	ret=0;char c=getchar();bool pd=false;
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
	ret=pd?-ret:ret;
	return;
}
ll n,m,x,y,siz[N],son[N],minn=inf,num=0,f[N],sum,root;
vector<ll>v[N];
bool vis[N];
inline void find(ll ver,ll fa)
{
	siz[ver]=1;
	ll maxn=0;
	for(int i=0;i<v[ver].size();i++)
	{
		ll to=v[ver][i];
		if(to==fa||vis[to])
			continue;
		find(to,ver);
		siz[ver]+=siz[to];
		maxn=max(maxn,siz[to]);
	}
	maxn=max(maxn,num-siz[ver]);
	if(maxn<minn)
	{
		minn=maxn;
		root=ver;
	}
	return;
}
ll valmx[N],valmn[N],sz[N],now,fat[N];
struct node
{
	ll x,y,ver;
}a[N];
inline bool cmp1(node a,node b)
{
	return a.x<b.x;
}
inline bool cmp2(node a,node b)
{
	return a.y<b.y;
}
ll cnt;
vector<ll>g[N];
inline void dfs(ll ver,ll fa,ll d)
{
	valmx[ver]=max(valmx[fa],ver);
	valmn[ver]=min(valmn[fa],ver);
	if(ver!=now)
	{
		if(valmx[ver]==ver||valmx[ver]==now)
			sum++;
		if(valmn[ver]==ver||valmn[ver]==now)
			sum++;
		if(valmx[ver]==ver&&valmn[ver]==now)
			sum-=2;
		if(valmx[ver]==now&&valmn[ver]==ver)
			sum-=2;
		if(valmn[ver]==ver)
			f[now]++;
		if(valmn[ver]==now)
			f[ver]++;
		g[d].push_back(ver);
		a[++cnt]=node{valmx[ver],valmn[ver],ver};
	}
	sz[ver]=1;
	fat[ver]=d;
//	cout<<"dfs"<<ver<<" "<<fa<<" "<<d<<endl;
	for(int i=0;i<v[ver].size();i++)
	{
		ll to=v[ver][i];
		if(to==fa||vis[to])
			continue;
		if(ver==now)
			dfs(to,ver,to);
		else
			dfs(to,ver,d);
		sz[ver]+=sz[to];
	}
	return;
}
ll tree[N];
inline void update(ll pos,ll num)
{
	pos++;
	while(pos<N)
	{
		tree[pos]+=num;
		pos+=pos&-pos;
	}
	return;
}
inline ll query(ll pos)
{
	pos++;
	ll ret=0;
	while(pos)
	{
		ret+=tree[pos];
		pos-=pos&-pos; 
	}
	return ret;
}
inline void calc()
{
	sort(a+1,a+cnt+1,cmp1);
	for(int i=1;i<=cnt;i++)
	{
		ll j=i;
		for(;j<=cnt&&a[j].x==a[i].x;j++);
		j--;
		for(int k=i;k<=j;k++)
		{
			if(a[k].x==a[k].ver)
				sum+=i-1,sum-=2*query(a[k].y)/*,cout<<"del "<<a[k].ver<<" "<<i-1<<" "<<query(a[k].y)<<endl*/;
		}
		for(int k=i;k<=j;k++)
		{
			if(a[k].y==a[k].ver)
				update(a[k].y,1);
		}
		i=j;
	}
	for(int i=1;i<=cnt;i++)
	{
		ll j=i;
		for(;j<=cnt&&a[j].x==a[i].x;j++);
		j--;
		for(int k=i;k<=j;k++)
		{
			if(a[k].y==a[k].ver)
				update(a[k].y,-1);
		}
		i=j;
	}
	sort(a+1,a+cnt+1,cmp2);
	for(int i=cnt;i;i--)
	{
		ll j=i;
		for(;j&&a[j].y==a[i].y;j--);
		j++;
		for(int k=j;k<=i;k++)
		{
			if(a[k].y==a[k].ver)
				sum+=cnt-i;
		}
		i=j;
	}
	ll tmp=0;
	for(int i=1;i<=cnt;i++)
	{
		ll j=i;
		for(;j<=cnt&&a[j].y==a[i].y;j++);
		j--;
		for(int k=i;k<=j;k++)
			f[a[k].ver]+=tmp;
		for(int k=i;k<=j;k++)
			if(a[k].ver==a[k].y)
				tmp++;
		i=j;
	}
	return;
}
inline void decalc()
{
	sort(a+1,a+cnt+1,cmp1);
	for(int i=1;i<=cnt;i++)
	{
		ll j=i;
		for(;j<=cnt&&a[j].x==a[i].x;j++);
		j--;
		for(int k=i;k<=j;k++)
		{
			if(a[k].x==a[k].ver)
				sum-=i-1,sum+=2*query(a[k].y)/*,cout<<"back"<<a[k].ver<<" "<<i-1<<" "<<query(a[k].y)<<endl*/;
		}
		for(int k=i;k<=j;k++)
		{
			if(a[k].y==a[k].ver)
				update(a[k].y,1);
		}
		i=j;
	}
	for(int i=1;i<=cnt;i++)
	{
		ll j=i;
		for(;j<=cnt&&a[j].x==a[i].x;j++);
		j--;
		for(int k=i;k<=j;k++)
		{
			if(a[k].y==a[k].ver)
				update(a[k].y,-1);
		}
		i=j;
	}
	sort(a+1,a+cnt+1,cmp2);
	for(int i=cnt;i;i--)
	{
		ll j=i;
		for(;j&&a[j].y==a[i].y;j--);
		j++;
		for(int k=j;k<=i;k++)
		{
			if(a[k].y==a[k].ver)
				sum-=cnt-i;
		}
		i=j;
	}
	ll tmp=0;
	for(int i=1;i<=cnt;i++)
	{
		ll j=i;
		for(;j<=cnt&&a[j].y==a[i].y;j++);
		j--;
		for(int k=i;k<=j;k++)
			f[a[k].ver]-=tmp;
		for(int k=i;k<=j;k++)
			if(a[k].ver==a[k].y)
				tmp++;
		i=j;
	}
	return;
}
inline void divide(ll ver)
{
	vis[ver]=true;
	now=ver;
	cnt=0;
	valmn[0]=inf;
	dfs(ver,0,0);
//	cout<<"??"<<ver<<" "<<sum<<endl;
/*	cout<<ver<<endl;
	for(int i=1;i<=cnt;i++)
		cout<<a[i].x<<" "<<a[i].y<<endl;*/
	calc();
//	cout<<ver<<" "<<cnt<<endl;
	for(int i=0;i<v[ver].size();i++)
	{
		ll to=v[ver][i];
		if(vis[to])
			continue;
		cnt=0;
		for(auto x:g[to])
			a[++cnt]=node{valmx[x],valmn[x],x}/*,cout<<ver<<" "<<to<<" "<<x<<endl*/;
		g[to].clear();
	//	cout<<ver<<" "<<to<<" "<<cnt<<endl;
		decalc();
	}
//	cout<<"result::"<<ver<<" "<<sum<<endl;
	for(int i=0;i<v[ver].size();i++)
	{
		ll to=v[ver][i];
		if(vis[to])
			continue;
		num=siz[to];
		minn=inf;
		find(to,ver);
	//	cout<<ver<<" "<<to<<" "<<root<<endl;
		divide(root);
	}
	return;
}
signed main()
{
	read(n);
	for(int i=1;i<n;i++)
	{
		read(x);
		read(y);
		v[x].push_back(y);
		v[y].push_back(x);
	}
	num=n;
	find(1,0);
	divide(root);
	printf("%lld\n",sum);
/*	for(int i=1;i<=n;i++)
		cout<<f[i]<<" ";
	cout<<endl;*/
	read(m);
	for(int i=1;i<=m;i++)
	{
		ll x;
		read(x);
		n++;
		f[n]=f[x]+1;
		sum+=(n-1)-f[n];
		printf("%lld\n",sum);
	}
	exit(0);
}
Solution (rui_er, reconstruction trees)
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x,y,z) for(ll x=(y);x<=(z);x++)
#define per(x,y,z) for(ll x=(y);x>=(z);x--)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;
const ll N = 4e5+5;
 
ll n, m, k, faMx[N], faMn[N], disMx[N], disMn[N], dfn[N], sz[N], tms;
ll A, B, C, ans;
vector<ll> eMx[N], eMn[N], reMx[N], reMn[N];
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
struct Dsu {
	ll fa[N];
	void init(ll x) {rep(i, 1, x) fa[i] = i;}
	ll find(ll x) {return x == fa[x] ? x : fa[x] = find(fa[x]);}
	bool merge(ll x, ll y) {
		ll u = find(x), v = find(y);
		if(u == v) return 0;
		fa[u] = v;
		return 1;
	}
}dsu;
struct BIT {
	ll c[N], sz;
	void init(ll x) {sz = x; rep(i, 1, x) c[i] = 0;}
	ll lowbit(ll x) {return x & (-x);}
	void add(ll x, ll k) {for(; x <= sz; x += lowbit(x)) c[x] += k;}
	ll ask(ll x) {ll k = 0; for(; x; x -= lowbit(x)) k += c[x]; return k;}
	ll Ask(ll x, ll y) {return ask(y) - ask(x - 1);}
}bit;
void dfs1(ll u) {
	dfn[u] = ++tms;
	sz[u] = 1;
	disMx[u] = disMx[faMx[u]] + 1;
	B += disMx[u] - 1;
	for(ll v : reMx[u]) {
		dfs1(v);
		sz[u] += sz[v];
	}
}
void dfs2(ll u) {
	disMn[u] = disMn[faMn[u]] + 1;
	A += disMn[u] - 1;
	C += bit.Ask(dfn[u], dfn[u] + sz[u] - 1);
	bit.add(dfn[u], 1);
	for(ll v : reMn[u]) dfs2(v);
	bit.add(dfn[u], -1);
}
 
int main() {
	scanf("%lld", &n);
	rep(i, 1, n-1) {
		ll u, v;
		scanf("%lld%lld", &u, &v);
		if(u < v) swap(u, v);
		eMx[u].push_back(v);
		eMn[v].push_back(u);
	}
	dsu.init(n);
	rep(i, 1, n) {
		for(ll j : eMx[i]) {
			j = dsu.find(j);
			dsu.merge(j, i);
			faMx[j] = i;
			reMx[i].push_back(j);
		}
	}
	dsu.init(n);
	per(i, n, 1) {
		for(ll j : eMn[i]) {
			j = dsu.find(j);
			dsu.merge(j, i);
			faMn[j] = i;
			reMn[i].push_back(j);
		}
	}
	bit.init(n);
	dfs1(n);
	dfs2(1);
	ans = A + B - 2 * C;
	// printf("%lld + %lld - 2 * %lld = %lld\n", A, B, C, ans);
	printf("%lld\n", ans);
	for(scanf("%lld", &m); m; m--) {
		scanf("%lld", &k);
		disMn[++n] = disMn[k] + 1;
		ans += n - disMn[n];
		printf("%lld\n", ans);
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1797E
Editorial Content:
1797E - Li Hua и массив
Tutorial
Tutorial is loading...
Solution (rui_er)
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;
const int N = 1e5 + 5, P = 4e5 + 5, K = 5e6 + 5, W = 5e6; 
 
int n, m, a[N], tab[K], phi[K], p[P], pcnt, dis[K], fa[K][6];
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
void sieve(int lim) {
	phi[1] = 1;
	rep(i, 2, lim) {
		if(!tab[i]) {
			p[++pcnt] = i;
			phi[i] = i - 1;
		}
		for(int j=1;j<=pcnt&&1LL*i*p[j]<=lim;j++) {
			tab[i*p[j]] = 1;
			if(i % p[j]) phi[i*p[j]] = phi[i] * phi[p[j]];
			else {
				phi[i*p[j]] = phi[i] * p[j];
				break;
			}
		}
	}
}
void initTree(int lim) {
	dis[1] = 1;
	rep(j, 0, 5) fa[1][j] = 1;
	rep(i, 2, lim) {
		dis[i] = dis[phi[i]] + 1;
		fa[i][0] = phi[i];
		rep(j, 1, 5) fa[i][j] = fa[fa[i][j-1]][j-1];
	}
}
int LCA(int u, int v) {
	if(dis[u] < dis[v]) swap(u, v);
	per(i, 5, 0) if(dis[fa[u][i]] >= dis[v]) u = fa[u][i];
	if(u == v) return u;
	per(i, 5, 0) if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
	return fa[u][0];
}
struct Node {
	int lca, ans, mndis, allrt;
};
struct SegTree {
	Node t[N<<2];
	#define lc(u) (u<<1)
	#define rc(u) (u<<1|1)
	void pushup(int u, int l, int r) {
		int mid = (l + r) >> 1;
		t[u].lca = LCA(t[lc(u)].lca, t[rc(u)].lca);
		t[u].ans = t[lc(u)].ans + t[rc(u)].ans
				 + (mid - l + 1) * (dis[t[lc(u)].lca] - dis[t[u].lca])
				 + (r - mid) * (dis[t[rc(u)].lca] - dis[t[u].lca]);
		t[u].mndis = min(t[lc(u)].mndis, t[rc(u)].mndis);
		t[u].allrt = t[lc(u)].allrt && t[rc(u)].allrt;
	}
	void build(int u, int l, int r) {
		if(l == r) {
			t[u].lca = a[l];
			t[u].ans = 0;
			t[u].mndis = dis[a[l]];
			t[u].allrt = a[l] == 1;
			return;
		}
		int mid = (l + r) >> 1;
		build(lc(u), l, mid);
		build(rc(u), mid+1, r);
		pushup(u, l, r);
	}
	void modify(int u, int l, int r, int ql, int qr) {
		if(t[u].allrt) return;
		if(l == r) {
			t[u].lca = fa[t[u].lca][0];
			--t[u].mndis;
			t[u].allrt = t[u].lca == 1;
			return;
		}
		int mid = (l + r) >> 1;
		if(ql <= mid) modify(lc(u), l, mid, ql, qr);
		if(qr > mid) modify(rc(u), mid+1, r, ql, qr);
		pushup(u, l, r);
	}
	int queryLCA(int u, int l, int r, int ql, int qr) {
		if(ql <= l && r <= qr) return t[u].lca;
		int mid = (l + r) >> 1;
		if(qr <= mid) return queryLCA(lc(u), l, mid, ql, qr);
		if(ql > mid) return queryLCA(rc(u), mid+1, r, ql, qr);
		int ans = queryLCA(lc(u), l, mid, ql, qr);
		if(ans == 1) return 1;
		return LCA(ans, queryLCA(rc(u), mid+1, r, ql, qr));
	}
	int queryAns(int u, int l, int r, int ql, int qr, int lca) {
		if(ql <= l && r <= qr) {
			return t[u].ans + (r - l + 1) * (dis[t[u].lca] - dis[lca]);
		}
		int mid = (l + r) >> 1, ans = 0;
		if(ql <= mid) ans += queryAns(lc(u), l, mid, ql, qr, lca);
		if(qr > mid) ans += queryAns(rc(u), mid+1, r, ql, qr, lca);
		return ans;
	}
	#undef lc
	#undef rc
}sgt;
 
int main() {
	sieve(W);
	initTree(W);
	scanf("%d%d", &n, &m);
	rep(i, 1, n) scanf("%d", &a[i]);
	sgt.build(1, 1, n);
	while(m --> 0) {
		int op, l, r;
		scanf("%d%d%d", &op, &l, &r);
		if(op == 1) sgt.modify(1, 1, n, l, r);
		else {
			int lca = sgt.queryLCA(1, 1, n, l, r);
			printf("%d\n", sgt.queryAns(1, 1, n, l, r, lca));
		}
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1797D
Editorial Content:
1797D - Li Hua и дерево
Tutorial
Tutorial is loading...
Solution (rui_er)
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
#define rep(x,y,z) for(ll x=y;x<=z;x++)
#define per(x,y,z) for(ll x=y;x>=z;x--)
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;
const ll N = 1e5+5; 
 
ll n, m, a[N], sz[N], son[N], fa[N], sum[N];
vector<ll> e[N];
set<tuple<ll, ll> > sons[N]; 
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
void dfs(ll u, ll f) {
	sz[u] = 1;
	sum[u] = a[u];
	fa[u] = f;
	for(auto v : e[u]) {
		if(v == f) continue;
		dfs(v, u);
		sz[u] += sz[v];
		sum[u] += sum[v];
		sons[u].insert(make_tuple(-sz[v], v));
		if(sz[v] > sz[son[u]] || sz[v] == sz[son[u]] && v < son[u]) son[u] = v;
	}
}
 
int main() {
	scanf("%lld%lld", &n, &m);
	rep(i, 1, n) scanf("%lld", &a[i]);
	rep(i, 1, n-1) {
		ll u, v;
		scanf("%lld%lld", &u, &v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1, 0);
	while(m --> 0) {
		ll op, u;
		scanf("%lld%lld", &op, &u);
		if(op == 1) printf("%lld\n", sum[u]);
		else {
			ll v = son[u];
			if(!v) continue;
			ll p = fa[u];
			sz[u] -= sz[v];
			sum[u] -= sum[v];
			sons[u].erase(make_tuple(-sz[v], v));
			son[u] = sons[u].empty() ? 0 : get<1>(*sons[u].begin());
			fa[u] = v;
			sz[v] += sz[u];
			sum[v] += sum[u];
			sons[v].insert(make_tuple(-sz[u], u));
			son[v] = get<1>(*sons[v].begin());
			fa[v] = p;
			sons[p].erase(make_tuple(-sz[v], u));
			sons[p].insert(make_tuple(-sz[v], v));
			son[p] = get<1>(*sons[p].begin());
		}
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1797C
Editorial Content:
1797C - Li Hua и шахматы
Tutorial
Tutorial is loading...
Solution (rui_er)
#include <bits/stdc++.h>
using namespace std;
 
int T, n, m;
 
int ask(int x, int y) {
	printf("? %d %d\n", x, y);
	fflush(stdout);
	scanf("%d", &x);
	return x;
}
 
void give(int x, int y) {
	printf("! %d %d\n", x, y);
	fflush(stdout);
}
 
int main() {
	for(scanf("%d", &T);T;T--) {
		scanf("%d%d", &n, &m);
		int T1 = ask(1, 1);
		if(T1 >= n) {
			int T2 = ask(1, T1+1);
			give(T2+1, T1+1);
		}
		else if(T1 >= m) {
			int T2 = ask(T1+1, 1);
			give(T1+1, T2+1);
		}
		else {
			int T2 = ask(T1+1, 1);
			int T3 = ask(1, T1+1);
			if(T2 == T1 && T3 == T1) give(T1+1, T1+1);
			else if(T3 == T1) give(T1+1, T2+1);
			else give(T3+1, T1+1);
		}
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1797B
Editorial Content:
1797B - Li Hua и узор
Tutorial
Tutorial is loading...
Solution (rui_er)
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;
const int N = 1e3+5;
 
int T, n, k, a[N][N];
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
 
int main() {
	for(scanf("%d", &T);T;T--) {
		scanf("%d%d", &n, &k);
		rep(i, 1, n) rep(j, 1, n) scanf("%d", &a[i][j]);
		int diff = 0;
		rep(i, 1, n) rep(j, 1, n) if(a[i][j] != a[n+1-i][n+1-j]) ++diff;
		diff /= 2;
		if(diff > k) puts("NO");
		else {
			k -= diff;
			if(n & 1) puts("YES");
			else if(k & 1) puts("NO");
			else puts("YES");
		}
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1797A
Editorial Content:
1797A - Li Hua и лабиринт
Tutorial
Tutorial is loading...
Solution (rui_er)
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;
 
#define y1 y114514
int T, n, m, x1, y1, x2, y2;
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
int f(int x, int y) {
	if((x == 1 || x == n) && (y == 1 || y == m)) return 2;
	if(x == 1 || x == n || y == 1 || y == m) return 3;
	return 4;
}
 
int main() {
	for(scanf("%d", &T);T;T--) {
		scanf("%d%d%d%d%d%d", &n, &m, &x1, &y1, &x2, &y2);
		printf("%d\n", min(f(x1, y1), f(x2, y2)));
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1796F
Editorial Content:
1796F - Strange Triples
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>
 
using namespace std;

#define sz(a) int((a).size())

using li = long long;

const int MAXLEN = 5;

vector<int> divs(int x) {
  vector<int> res;
  for (int i = 1; i * i <= x; ++i) {
    if (x % i == 0) {
      res.push_back(i);
      if (i * i != x)
        res.push_back(x / i);
    }
  }
  return res;
}

int main() {
  int A, B, N;
  cin >> A >> B >> N;

  vector<int> pw(10);
  pw[0] = 1;
  for (int i = 1; i < 10; ++i) pw[i] = pw[i - 1] * 10;
  
  int PW = pw[MAXLEN];
  set<array<int, 3>> used;
  
  vector<int> len(PW);
  for (int i = 0; i < PW; ++i)
    len[i] = sz(to_string(i));
  
  for (int lenn = 1; lenn <= 9; ++lenn) {
    int x = pw[lenn] - 1;
    for (int k2 : divs(x)) {
      int r = x / k2;
      for (int d = 1; d < PW; ++d) {
        for (int lenb = len[d]; lenb <= MAXLEN; ++lenb) {
          int bg = pw[lenb] - d * li(r) % pw[lenb];
          int dd = d / __gcd(d, bg);
          int lb = (pw[lenb - 1] + bg - 1) / bg;
          int rb = (pw[lenb] - 1) / bg;
          for (int g = (lb + dd - 1) / dd * dd; g <= rb; g += dd) {
            int b = bg * g;
            assert(b % d == 0);
            if (b >= B || __gcd(b / d, r) != 1) continue;
            int ag = (d * li(r) + bg) / pw[lenb];
            li n = b / d * li(k2) * ag;
            if (n < N && ag * g < A && __gcd(ag, bg) == 1 && sz(to_string(n)) == lenn) 
              used.insert({ag * g, b, n});
          }
        }
      }
    }
  }
  
  int res = 0;
  for (auto it : used) {
    li a = it[0], b = it[1], n = it[2];
    int lenn = sz(to_string(n));
    int lenb = sz(to_string(b));
    res += a * b * pw[lenn] + n * b == a * n * pw[lenb] + a * b;
  }
  
  cout << res << endl;
}
--------------------------------------------------
Problem ID: 1796E
Editorial Content:
1796E - Colored Subgraphs
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
using namespace std;
 
#define forn(i, n) for(int i = 0; i < int(n); i++) 

vector<vector<int>> g;
vector<multiset<int>> len;
multiset<int> all;

int getlen(int v){
    return len[v].empty() ? 1 : *len[v].begin() + 1;
}

void init(int v, int p = -1){
    for (int u : g[v]) if (u != p){
        init(u, v);
        len[v].insert(getlen(u));
    }
    if (int(len[v].size()) > 1){
        all.insert(*(++len[v].begin()));
    }
}

int ans;

void dfs(int v, int p = -1){
    ans = max(ans, min(*len[v].begin() + 1, *all.begin()));
    
    for (int u : g[v]) if (u != p){
        if (int(len[v].size()) > 1) all.erase(all.find(*(++len[v].begin())));
        len[v].erase(len[v].find(getlen(u)));
        if (int(len[v].size()) > 1) all.insert(*(++len[v].begin()));
        
        if (int(len[u].size()) > 1) all.erase(all.find(*(++len[u].begin())));
        len[u].insert(getlen(v));
        if (int(len[u].size()) > 1) all.insert(*(++len[u].begin()));
        
        dfs(u, v);
        
        if (int(len[u].size()) > 1) all.erase(all.find(*(++len[u].begin())));
        len[u].erase(len[u].find(getlen(v)));
        if (int(len[u].size()) > 1) all.insert(*(++len[u].begin()));
        
        if (int(len[v].size()) > 1) all.erase(all.find(*(++len[v].begin())));
        len[v].insert(getlen(u));
        if (int(len[v].size()) > 1) all.insert(*(++len[v].begin()));
    }
}

int main(){
    int t;
    scanf("%d", &t);
    while (t--){
        int n;
        scanf("%d", &n);
        g.assign(n, {});
        forn(i, n - 1){
            int v, u;
            scanf("%d%d", &v, &u);
            --v, --u;
            g[v].push_back(u);
            g[u].push_back(v);
        }
        len.assign(n, {});
        all.clear();
        all.insert(n);
        init(0);
        ans = 0;
        dfs(0);
        printf("%d\n", ans);
    }
}
--------------------------------------------------
Problem ID: 1796D
Editorial Content:
1796D - Maximum Subarray
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

using li = long long;

const int N = 222222;
const int K = 22;
const li INF = 1e18;

int n, k, x;
int a[N];
li dp[N][K][3];

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int tc;
  cin >> tc;
  while (tc--) {
    cin >> n >> k >> x;
    for (int i = 0; i < n; ++i) cin >> a[i];
    for (int i = 0; i <= n; ++i) {
      for (int j = 0; j <= k; ++j) { 
        for (int t = 0; t < 3; ++t) {
          dp[i][j][t] = -INF;
        }
      }
    }
    dp[0][0][0] = 0;
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j <= k; ++j) {
        for (int t = 0; t < 3; ++t) {
          if (dp[i][j][t] == -INF) continue;
          for (int jj = j; jj <= min(k, j + 1); ++jj) {
            li add = a[i] + (j == jj ? -x : x);
            for (int tt = t; tt < 3; ++tt) {
              dp[i + 1][jj][tt] = max(dp[i + 1][jj][tt], dp[i][j][t] + (tt == 1 ? add : 0));
            }
          }
        }
      }
    }
    cout << max(dp[n][k][1], dp[n][k][2]) << '\n';
  }
}
--------------------------------------------------
Problem ID: 1796C
Editorial Content:
1796C - Maximum Set
Tutorial
Tutorial is loading...
Solution (BledDest)
#include <bits/stdc++.h>
 
using namespace std;

int main()
{
    int t;
    cin >> t;
    for(int i = 0; i < t; i++)
    {
        int l, r;
        cin >> l >> r;
        int max_size = 1;
        while((l << max_size) <= r)
            max_size++;
        int ans2 = (r / (1 << (max_size - 1)) - l + 1);
        if(max_size > 1)
            ans2 += (max_size - 1) * max(0, (r / (1 << (max_size - 2)) / 3 - l + 1));
        cout << max_size << " " << ans2 << endl;
    }
}
--------------------------------------------------
Problem ID: 1796B
Editorial Content:
1796B - Asterisk-Minor Template
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
    a = input()
    b = input()
    if a[0] == b[0]:
        print("YES")
        print(a[0] + "*")
        continue
    if a[-1] == b[-1]:
        print("YES")
        print("*" + a[-1])
        continue
    for i in range(len(b) - 1):
        if (b[i] + b[i + 1]) in a:
            print("YES")
            print("*" + b[i] + b[i + 1] + "*")
            break
    else:
        print("NO")
--------------------------------------------------
Problem ID: 1796A
Editorial Content:
1796A - Typical Interview Problem
Tutorial
Tutorial is loading...
Solution (BledDest)
#include <bits/stdc++.h>
 
using namespace std;

int main()
{
    string fb;
    int cur = 1;
    while(fb.size() < 100)
    {
        if(cur % 3 == 0) fb += "F";
        if(cur % 5 == 0) fb += "B";
        cur++;
    }
    int t;
    cin >> t;
    for(int i = 0; i < t; i++)
    {
        int k;
        cin >> k;
        string s;
        cin >> s;
        cout << (fb.find(s) != string::npos ? "YES" : "NO") << endl;
    }
}
--------------------------------------------------
Problem ID: 1795G
Editorial Content:
1795G - Removal Sequences
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
using namespace std;
 
#define forn(i, n) for(int i = 0; i < int(n); i++) 

typedef unsigned long long uli;

int main(){
    int t;
    scanf("%d", &t);
    while (t--){
        int n, m;
        scanf("%d%d", &n, &m);
        vector<int> a(n);
        forn(i, n) scanf("%d", &a[i]);
        vector<vector<int>> g(n);
        forn(i, m){
            int v, u;
            scanf("%d%d", &v, &u);
            --v, --u;
            g[v].push_back(u);
            g[u].push_back(v);
        }
        vector<char> rem(n);
        vector<int> d(n);
        forn(i, n) d[i] = g[i].size();
        queue<int> q;
        forn(i, n) if (a[i] == d[i]) q.push(i);
        vector<pair<int, int>> ord;
        while (!q.empty()){
            int v = q.front();
            q.pop();
            rem[v] = true;
            for (int u : g[v]) if (!rem[u]){
                --d[u];
                ord.push_back({v, u});
                if (d[u] == a[u])
                    q.push(u);
            }
        }
        reverse(ord.begin(), ord.end());
        vector<uli> mask(n);
        long long ans = n * 1ll * (n + 1) / 2;
        for (int l = 0; l < n; l += 64){
            int r = min(n, l + 64);
            for (int i = l; i < r; ++i)
                mask[i] = 1ull << (i - l);
            for (const pair<int, int> &it : ord)
                mask[it.first] |= mask[it.second];
            forn(i, n){
                ans -= __builtin_popcountll(mask[i]);
                mask[i] = 0;
            }
        }
        printf("%lld\n", ans);
    }
}
--------------------------------------------------
Problem ID: 1795F
Editorial Content:
1795F - Blocking Chips
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
using namespace std;
 
#define forn(i, n) for(int i = 0; i < int(n); i++) 

vector<vector<int>> g;
vector<int> req;
vector<char> used;

vector<int> d;

bool dfs(int v, int p = -1){
    d[v] = 0;
    for (int u : g[v]) if (u != p){
        if (!dfs(u, v)) return false;
        if (!used[u]) d[v] = max(d[v], d[u] + 1);
    }
    if (req[v] == 0 || d[v] >= req[v]) return true;
    if (p == -1 || used[p]) return false;
    used[p] = true;
    req[p] = req[v] - 1;
    return true;
}

int main(){
    int t;
    scanf("%d", &t);
    while (t--){
        int n;
        scanf("%d", &n);
        g.assign(n, {});
        d.resize(n);
        forn(i, n - 1){
            int v, u;
            scanf("%d%d", &v, &u);
            --v, --u;
            g[v].push_back(u);
            g[u].push_back(v);
        }
        int k;
        scanf("%d", &k);
        vector<int> a(k);
        forn(i, k){
            scanf("%d", &a[i]);
            --a[i];
        }
        int l = 1, r = n;
        int res = 0;
        while (l <= r){
            int m = (l + r) / 2;
            used.assign(n, 0);
            req.assign(n, 0);
            forn(i, k){
                used[a[i]] = true;
                req[a[i]] = m / k + (i < m % k);
            }
            if (dfs(0)){
                res = m;
                l = m + 1;
            }
            else{
                r = m - 1;
            }
        }
        printf("%d\n", res);
    }
}
--------------------------------------------------
Problem ID: 1795E
Editorial Content:
1795E - Explosions?
Tutorial
Tutorial is loading...
Solution (adedalic)
import java.util.*

fun main() {
    repeat(readln().toInt()) {
        val n = readln().toInt()
        var h = readln().split(' ').map { it.toInt() }

        val d = Array(2) { LongArray(n) { 0 } }
        for (tp in 0..1) {
            val s = Stack<Pair<Int, Int>>()

            for (i in h.indices) {
                while (s.isNotEmpty() && s.peek().first > h[i] - i)
                    s.pop()
                var j = maxOf(-1, i - h[i])
                if (s.isNotEmpty())
                    j = maxOf(j, s.peek().second)

                val len = (i - j).toLong()
                d[tp][i] = len * h[i] - len * (len - 1) / 2
                if (j >= 0 && len < h[i])
                    d[tp][i] += d[tp][j]

                s.push(Pair(h[i] - i, i))
            }
            h = h.reversed()
        }
        d[1] = d[1].reversedArray()

        var ans = 1e18.toLong()
        val sum = h.fold(0L) { total, it -> total + it }
        for (i in h.indices) {
            val cur = sum - d[0][i] - d[1][i] + 2 * h[i]
            ans = minOf(ans, cur)
        }
        println(ans)
    }
}
--------------------------------------------------
Problem ID: 1795D
Editorial Content:
1795D - Triangle Coloring
Tutorial
Tutorial is loading...
Solution (BledDest)
#include <bits/stdc++.h>
 
using namespace std;

const int MOD = 998244353;

int add(int x, int y)
{
    return ((x + y) % MOD + MOD) % MOD;
}

int mul(int x, int y)
{
    return x * 1ll * y % MOD;   
}

int binpow(int x, int y)
{
    int z = 1;
    while(y)
    {
        if(y % 2 == 1) z = mul(z, x);
        x = mul(x, x);
        y /= 2;
    }
    return z;
}

int inv(int x)
{
    return binpow(x, MOD - 2);    
}

int divide(int x, int y)
{
    return mul(x, inv(y));
}

int main()
{
    int n;
    cin >> n;
    int ans = 1;
    for(int i = 1; i <= n / 6; i++)
        ans = mul(ans, divide(i + n / 6, i));
    for(int i = 0; i < n / 3; i++)
    {
        vector<int> a(3);
        for(int j = 0; j < 3; j++)
            cin >> a[j];
        int mn = *min_element(a.begin(), a.end());
        int cnt_min = count(a.begin(), a.end(), mn);
        ans = mul(ans, cnt_min);
    }
    cout << ans << endl;
}
--------------------------------------------------
Problem ID: 1795C
Editorial Content:
1795C - Tea Tasting
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

using li = long long;

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<li> a(n), b(n);
    for (auto& x : a) cin >> x;
    for (auto& x : b) cin >> x;
    vector<li> sum(n + 1);
    for (int i = 0; i < n; ++i) sum[i + 1] = sum[i] + b[i];
    vector<li> cnt(n + 1), add(n + 1);
    for (int i = 0; i < n; ++i) {
      int j = upper_bound(sum.begin(), sum.end(), a[i] + sum[i]) - sum.begin() - 1;
      cnt[i] += 1;
      cnt[j] -= 1;
      add[j] += a[i] - sum[j] + sum[i];
    }
    for (int i = 0; i < n; ++i) {
      cout << cnt[i] * b[i] + add[i] << ' ';
      cnt[i + 1] += cnt[i];   
    }
    cout << '\n';
  }
}
--------------------------------------------------
Problem ID: 1795B
Editorial Content:
1795B - Ideal Point
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n, k;
    cin >> n >> k;
    int L = 0, R = 55;
    while (n--) {
      int l, r;
      cin >> l >> r;
      if (l <= k && k <= r)
        L = max(L, l), R = min(R, r);
    }
    cout << (L == R ? "YES\n" : "NO\n");
  }
}
--------------------------------------------------
Problem ID: 1795A
Editorial Content:
1795A - Two Towers
Tutorial
Tutorial is loading...
Solution (Neon) 1
#include <bits/stdc++.h>

using namespace std;

int main() {
  auto ok = [](string s) {
    for (int i = 1; i < (int)s.size(); ++i)
      if (s[i - 1] == s[i]) return false;
    return true;    
  };
  
  int t;
  cin >> t;
  while (t--) {
    int n, m;
    string s, t;
    cin >> n >> m >> s >> t;
    bool f = false;
    for (int x = 0; x < 2; ++x) {
      string cs = s, ct = t;
      for (int i = 0; i < n; ++i) {
        f |= ok(cs) && ok(ct);
        ct.push_back(cs.back());
        cs.pop_back();
      }
      swap(n, m);
      swap(s, t);   
    }
    cout << (f ? "YES\n" : "NO\n");
  }
}
Solution (Neon) 2
#include <bits/stdc++.h>

using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n, m;
    string s, t;
    cin >> n >> m >> s >> t;
    reverse(t.begin(), t.end());
    s += t;
    int cnt = 0;
    for (int i = 1; i < n + m; ++i) cnt += s[i - 1] == s[i];
    cout << (cnt <= 1 ? "YES\n" : "NO\n");
  }
}
--------------------------------------------------
Problem ID: 1794E
Editorial Content:
1794E - Labeling the Tree with Distances
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
 
const int MAXN = 200005;
mt19937_64 rng(chrono::system_clock::now().time_since_epoch().count());
 
//Hashing stuff
const ll MOD[3] = {999727999, 1070777777, 1000000007};
ll B[3];
 
vector<ll> shift(vector<ll> h, ll val = 0){
	for(int k = 0; k < 3; k++){
		h[k] = (h[k] * B[k] + val) % MOD[k];
	}
	return h;
}
 
vector<ll> add(vector<ll> a, vector<ll> b){
	vector<ll> res(3);
	for(int k = 0; k < 3; k++){
		res[k] = (a[k] + b[k]) % MOD[k];
	}
	return res;
}
 
vector<ll> sub(vector<ll> a, vector<ll> b){
	vector<ll> res(3);
	for(int k = 0; k < 3; k++){
		res[k] = (a[k] - b[k] + MOD[k]) % MOD[k];
	}
	return res;
}
 
//Tree stuff
vector<int> g[MAXN];
 
bool vis[MAXN];
int parent[MAXN];
vector<ll> dp[MAXN], dp2[MAXN];
 
void dfs(int x){
	vis[x] = true;
	for(auto i : g[x]){
		if(!vis[i]){
			parent[i] = x;
			dfs(i);
			dp[x] = add(dp[x], shift(dp[i]));
		}
	}
	dp[x] = add(dp[x], {1, 1, 1});
}
 
void dfs2(int x){
	if(x != 0){
		dp2[x] = sub(dp[parent[x]], shift(dp[x]));
		dp2[x] = add(dp2[x], shift(dp2[parent[x]]));
	}
	for(auto i : g[x]){
		if(i != parent[x]){
			dfs2(i);
		}
	}
}
 
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	for(int k = 0; k < 3; k++){
		B[k] = rng() % MOD[k];
	}
	//reading the input
	int n; cin >> n;
	vector<int> occurrences(n);
	for(int i = 0; i < n - 1; i++){
		int a; cin >> a;
		occurrences[a]++;
	}
	for(int i = 0; i < n - 1; i++){
		int u, v; cin >> u >> v;
		u--; v--;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	//calculating possible list hashes
	vector<vector<ll>> list_hashes;
	vector<ll> h = {0, 0, 0};
	for(int i = n - 1; i >= 0; i--){
		h = shift(h, occurrences[i]);
	}
	vector<ll> extra = {1, 1, 1};
	for(int i = 0; i < n; i++){
		list_hashes.push_back(add(h, extra));
		extra = shift(extra);
	}
	//calculating possible tree hashes
	for(int i = 0; i < n; i++){
		dp[i] = {0, 0, 0};
		dp2[i] = {0, 0, 0};
	}
	parent[0] = -1;
	dfs(0);
	dfs2(0);
	vector<pair<vector<ll>, int>> tree_hashes;
	for(int i = 0; i < n; i++){
		if(i == 0){
			tree_hashes.push_back({dp[i], i});
		}else{
			tree_hashes.push_back({add(dp[i], shift(dp2[i])), i});
		}
	}
	//calculting the answer
	sort(list_hashes.begin(), list_hashes.end());
	sort(tree_hashes.begin(), tree_hashes.end());
	vector<int> res;
	int pos = 0;
	for(auto lh : list_hashes){
		while(pos < n && tree_hashes[pos].first < lh){
			pos++;
		}
		while(pos < n && tree_hashes[pos].first == lh){
			res.push_back(tree_hashes[pos].second);
			pos++;
		}
	}
	sort(res.begin(), res.end());
	cout << res.size() << "\n";
	for(auto i : res){
		cout << i + 1 << " ";
	}
	cout << "\n";
	return 0;
}
Feedback
Amazing problem:
Good problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1794D
Editorial Content:
1794D - Counting Factorizations
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
 
const ll MOD = 998244353;
 
//checks if n is prime
bool is_prime(ll n){
	if(n == 1){
		return false;
	}
	for(ll i = 2; i * i <= n; i++){
		if(n %i == 0){
			return false;
		}
	}
	return true;
}
 
//computes b ** e % MOD
ll fast_pow(ll b, ll e){
	ll res = 1;
	while(e > 0){
		if(e % 2 == 1){
			res = res * b % MOD;
		}
		b = b * b % MOD;
		e /= 2;
	}
	return res;
}
 
vector<pair<ll, ll>> primes;
 
const int MAXN = 5050;
 
ll dp[MAXN][MAXN];
 
ll fact[MAXN], fact_inv[MAXN];
 
ll f(ll x, ll y){
	ll &res = dp[x][y];
	if(res >= 0){
		return res;
	}
	if(x == (int)primes.size()){
		return res = (y == 0);
	}
	res = fact_inv[primes[x].second] * f(x + 1, y) % MOD;
	if(y > 0){
		res = (res + fact_inv[primes[x].second - 1] * f(x + 1, y - 1)) % MOD;	
	}
	return res;
}
 
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	//reading the input
	int n; cin >> n;
	vector<ll> a(2 * n);
	for(int i = 0; i < 2 * n; i++){
		cin >> a[i];
	}
	sort(a.begin(), a.end());
	//compressed version of a, pairs {value, #occurrences}
	vector<pair<ll, ll>> a_comp;
	for(int i = 0; i < 2 * n; i++){
		if(a_comp.size() == 0u || a_comp.back().first != a[i]){
			a_comp.push_back({a[i], 1});
		}else{
			a_comp.back().second++;
		}
	}
	//computing factorials and inverses
	fact[0] = 1;
	for(ll i = 1; i < MAXN; i++){
		fact[i] = fact[i-1] * i % MOD;
	}
	fact_inv[0] = 1;
	for(ll i = 0; i < MAXN; i++){
		fact_inv[i] = fast_pow(fact[i], MOD - 2);
	}
	//adding only primes for the dp
	for(auto i : a_comp){
		if(is_prime(i.first)){
			primes.push_back(i);
		}
	}
	memset(dp, -1, sizeof(dp));
	ll res = f(0, n);
	//we have to consider the contribution of non-primes too!
	for(auto i : a_comp){
		if(!is_prime(i.first)){
			res = res * fact_inv[i.second] % MOD;
		}
	}
	res = res * fact[n] % MOD;
	cout << res << "\n";
	return 0;
}
Additional comment
It is possible to solve the problem with greater constraints, like $$$n \leq 10^5$$$. Try to solve it with this new constraint!
Feedback
Amazing problem:
Good problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1794C
Editorial Content:
1794C - Scoring Subsequences
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
 
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int t; cin >> t;
	for(int test_number = 0; test_number < t; test_number++){
		int n; cin >> n;
		vector <int> a(n);
		for(int i = 0; i < n; i++){
			cin >> a[i];
		}
		vector<int> res;
		for(int i = 0; i < n; i++){
			int l = 1, r = i + 1;
			while(l <= r){
				int m = (l + r) / 2;
				if(a[i - m + 1] >= m){
					l = m + 1;
				}else{
					r = m - 1;
				}
			}
			res.push_back(r);
		}
		for(auto i : res){
			cout << i << " ";
		}
		cout<<"\n";
	}
	return 0;
}
Feedback
Amazing problem:
Good problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1794B
Editorial Content:
1794B - Not Dividing
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
 
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int t; cin >> t;
	for(int test_number = 0; test_number < t; test_number++){
		int n; cin >> n;
		vector <int> a(n);
		for(int i = 0; i < n; i++){
			cin >> a[i];
		}
		for(int i = 0; i < n; i++){
			if(a[i] == 1){
				a[i]++;
			}
		}
		for(int i = 1; i < n; i++){
			if(a[i] % a[i - 1] == 0){
				a[i]++;
			}
		}
		for(auto i : a){
			cout << i << " ";
		}
		cout << "\n";
	}
	return 0;
}
Additional comment
Actually, the maximum number of operations performed by this algorithm is $$$\frac{3}{2}n$$$. Try to prove it!
Feedback
Amazing problem:
Good problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1794A
Editorial Content:
1794A - Prefix and Suffix Array
Solution
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
 
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int t; cin >> t;
	for(int test_number = 0; test_number < t; test_number++){
		int n; cin >> n;
		vector <string> long_subs;
		for(int i = 0; i < 2 * n - 2; i++){
			string s; 
			cin >> s;
			if((int)s.size() == n - 1){
				long_subs.push_back(s);
			}
		}
		reverse(long_subs[1].begin(), long_subs[1].end());
		if(long_subs[0] == long_subs[1]){
			cout<<"YES\n";
		}else{
			cout<<"NO\n";
		}
	}
	
	return 0;
}
Feedback
Amazing problem:
Good problem:
Bad problem:
Didn't solve:
--------------------------------------------------
Problem ID: 1793F
Editorial Content:
1793F - Rebrending
1793F - Rebrending
Code
#include <bits/stdc++.h>

using namespace std;

const int inf = 1e9 + 228;

template<class T, class Fun = function<T(const T &, const T &)>>
struct SegTree {
    Fun f;
    vector<T> t;
    int n;

    SegTree(int sz, const Fun &g, T default_value = T()) : f(g) {
        n = 1;
        while (n < sz) n <<= 1;
        t.resize(n * 2, default_value);
    }

    SegTree(vector<T> &a, const Fun &g, T default_value = T()) : SegTree(a.size(), g, default_value) {
        for (int i = 0; i < n; ++i) t[i + n] = a[i];
        for (int i = n - 1; i >= 1; --i) t[i] = f(t[i << 1], t[i << 1 | 1]);
    }

    void upd(int i, T x) {
        i += n;
        t[i] = f(t[i], x);
        for (i >>= 1; i > 1; i >>= 1) t[i] = f(t[i << 1], t[i << 1 | 1]);
    }

    T get(int l, int r) {
        T resL = t[0], resR = t[0];
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if (l & 1) resL = f(resL, t[l++]);
            if (r & 1) resR = f(t[--r], resR);
        }
        return f(resL, resR);
    }
};

signed main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    int n, q;
    cin >> n >> q;
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    vector<vector<pair<int, int>>> posts(n);
    for (int i = 0; i < q; i++) {
        int l, r;
        cin >> l >> r;
        l--, r--;
        posts[r].push_back({l, i});
    }
    SegTree<int> ind(n + 1, [](int x, int y) { return max(x, y); }, -1);
    SegTree<int> dp(n + 1, [](int x, int y) { return min(x, y); }, inf);
    vector<int> answer(q);
    for (int i = 0; i < n; i++) {
        {
            int limit = n + 1;
            while (true) {
                int j = ind.get(a[i], limit);
                if (j == -1)
                    break;
                dp.upd(j, abs(a[j] - a[i]));
                limit = a[i] + (a[j] - a[i] + 1) / 2;
            }
        }
        {
            int limit = 0;
            while (true) {
                int j = ind.get(limit, a[i]);
                if (j == -1)
                    break;
                dp.upd(j, abs(a[j] - a[i]));
                limit = a[i] - (a[i] - a[j] + 1) / 2 + 1;
            }
        }
        ind.upd(a[i], i);
        for (pair<int, int> j: posts[i]) {
            answer[j.second] = dp.get(j.first, i);
        }
    }
    for (int i: answer) {
        cout << i << "\n";
    }

    return 0;
}
--------------------------------------------------
Problem ID: 1793E
Editorial Content:
1793E - Velepin and Marketing
1793E - Velepin and Marketing
Code
#include<bits/stdc++.h>

using namespace std;
#define ll long long
#define pii pair<int, int>
#define ld long double
#define all(a) (a).begin(), (a).end()

const int inf = 1e9 + 7;

signed main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;
    vector<int> c(n);
    for (int i = 0; i < n; ++i) cin >> c[i];
    sort(all(c));
    vector<int> ans(n + 1); 
    vector<int> dp(n + 1, -inf);
    dp[0] = 0;

    for (int i = 1; i <= n; ++i) {
        if (c[i-1] <= i) {
            dp[i] = dp[i - c[i-1]] + 1;
            ans[dp[i] + n - i] = max(ans[dp[i] + n - i], i);
        } else {
            if (c[i-1] <= n) {
                ans[1 + n - c[i-1]] = max(ans[1 + n - c[i-1]], i);
            }
        }
        dp[i] = max(dp[i], dp[i-1]);
    }

    for (int i = n - 1; i >= 0; i--) {
        ans[i] = max(ans[i], ans[i + 1]);
    }

    int q;
    cin >> q;
    for (int i = 0; i < q; ++i) {
        int x;
        cin >> x;
        cout << ans[x] << '\n';
    }

    return 0;
}
--------------------------------------------------
Problem ID: 1793D
Editorial Content:
1793D - Moscow Gorillas
1793D - Moscow Gorillas
Code
#include <bits/stdc++.h>
#define int long long

using namespace std;

void solve() {
    int n;
    cin >> n;
    vector<int> pos_a(n + 1);
    vector<int> pos_b(n + 1);
    for (int i = 0; i < n; i++) {
        int a;
        cin >> a;
        pos_a[a] = i + 1;
    }
    for (int i = 0; i < n; i++) {
        int b;
        cin >> b;
        pos_b[b] = i + 1;
    }
    int la = n, ra = 1, lb = n, rb = 1, ans = 0;
    for (int i = 1; i + 1 <= n; i++) {
        la = min(la, pos_a[i]);
        ra = max(ra, pos_a[i]);
        lb = min(lb, pos_b[i]);
        rb = max(rb, pos_b[i]);
        int min_la, max_ra, min_lb, max_rb;
        if (pos_a[i + 1] < la) {
            min_la = pos_a[i + 1] + 1;
            max_ra = n;
        } else {
            min_la = 1;
            max_ra = pos_a[i + 1] - 1;
        }
        if (pos_b[i + 1] < lb) {
            min_lb = pos_b[i + 1] + 1;
            max_rb = n;
        } else {
            min_lb = 1;
            max_rb = pos_b[i + 1] - 1;
        }
        ans += max(min(la, lb) - max(min_la, min_lb) + 1, 0ll) * max(min(max_ra, max_rb) - max(ra, rb) + 1, 0ll);
    }
    ans += min(pos_a[1], pos_b[1]) * (min(pos_a[1], pos_b[1]) - 1) / 2;
    ans += (n - max(pos_a[1], pos_b[1])) * (n - max(pos_a[1], pos_b[1]) + 1) / 2;
    ans += abs(pos_a[1] - pos_b[1]) * (abs(pos_a[1] - pos_b[1]) - 1) / 2;
    ans++;
    cout << ans << endl;
}

signed main() {
    int q = 1;
    while (q--)
        solve();
    return 0;
}
--------------------------------------------------
Problem ID: 1793C
Editorial Content:
1793C - Dora and Search
1793C - Dora and Search
Code
#include <bits/stdc++.h>

using namespace std;

typedef vector<int> vi;

void solve() {
    int n;
    cin >> n;
    vi a(n);
    for (int &i: a)
        cin >> i;
    int l = 0, r = n - 1;
    int mn = 1, mx = n;
    while (l <= r) {
        if (a[l] == mn) {
            l++;
            mn++;
        } else if (a[l] == mx) {
            l++;
            mx--;
        } else if (a[r] == mn) {
            r--;
            mn++;
        } else if (a[r] == mx) {
            r--;
            mx--;
        } else {
            break;
        }
    }
    if(l <= r){
        cout << l + 1 << " " << r + 1 << endl;
    } else{
        cout << -1 << endl;
    }
}

signed main() {
    int q = 1;
    cin >> q;
    while (q--)
        solve();
    return 0;
}
--------------------------------------------------
Problem ID: 1793B
Editorial Content:
1793B - Fedya and Array
1793B - Fedya and Array
Code
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

void solve() {
    ll a, b;
    cin >> a >> b;
    ll n = 2 * (a - b);
    cout << n << '\n';
    vector<ll> arr(n);
    int ptr = 0;
    for (ll c = b; c <= a; ++c) {
        arr[ptr++] = c;
    }
    for (ll c = a - 1; c > b; --c) {
        arr[ptr++] = c;
    }
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " \n"[i == n - 1];
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1793A
Editorial Content:
1793A - Yet Another Promotion
1793A - Yet Another Promotion
Code
t = int(input())

for i in range(t):
    a, b = map(int, input().split(" "))
    n, m = map(int, input().split(" "))

    q = n // (m + 1)
    r = n - q * (m + 1)
    print(q * min(a * m, b * (m + 1))+ r*min(a,b))
--------------------------------------------------
Problem ID: 1792F2
Editorial Content:
1792F2 - Graph Coloring (hard version)
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

const int LOGN = 18;
const int N = (1 << LOGN);
const int MOD = 998244353;
const int g = 3;

#define forn(i, n) for(int i = 0; i < int(n); i++)

inline int mul(int a, int b)
{
    return (a * 1ll * b) % MOD;
}

inline int norm(int a) 
{
    while(a >= MOD)
        a -= MOD;
    while(a < 0)
        a += MOD;
    return a;
}

inline int binPow(int a, int k) 
{
    int ans = 1;
    while(k > 0) 
    {
        if(k & 1)
            ans = mul(ans, a);
        a = mul(a, a);
        k >>= 1;
    }
    return ans;
}

inline int inv(int a) 
{
    return binPow(a, MOD - 2);
}

vector<int> w[LOGN];
vector<int> iw[LOGN];
vector<int> rv[LOGN];

void precalc() 
{
    int wb = binPow(g, (MOD - 1) / (1 << LOGN));
    
    for(int st = 0; st < LOGN; st++) 
    {
        w[st].assign(1 << st, 1);
        iw[st].assign(1 << st, 1);
        
        int bw = binPow(wb, 1 << (LOGN - st - 1));
        int ibw = inv(bw);
        
        int cw = 1;
        int icw = 1;
        
        for(int k = 0; k < (1 << st); k++) 
        {
            w[st][k] = cw;
            iw[st][k] = icw;
            
            cw = mul(cw, bw);
            icw = mul(icw, ibw);
        }
        
        rv[st].assign(1 << st, 0);
        
        if(st == 0) 
        {
            rv[st][0] = 0;
            continue;
        }
        int h = (1 << (st - 1));
        for(int k = 0; k < (1 << st); k++)
            rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);
    }
}

inline void fft(int a[N], int n, int ln, bool inverse) 
{   
    for(int i = 0; i < n; i++) 
    {
        int ni = rv[ln][i];
        if(i < ni)
            swap(a[i], a[ni]);
    }
    
    for(int st = 0; (1 << st) < n; st++) 
    {
        int len = (1 << st);
        for(int k = 0; k < n; k += (len << 1)) 
        {
            for(int pos = k; pos < k + len; pos++) 
            {
                int l = a[pos];
                int r = mul(a[pos + len], (inverse ? iw[st][pos - k] : w[st][pos - k]));
                
                a[pos] = norm(l + r);
                a[pos + len] = norm(l - r);
            }
        }
    }
    
    if(inverse) 
    {
        int in = inv(n);
        for(int i = 0; i < n; i++)
            a[i] = mul(a[i], in);
    }
}

int aa[N], bb[N], cc[N];

vector<int> multiply(vector<int> a, vector<int> b) 
{
    int sza = a.size();
    int szb = b.size();
    int n = 1, ln = 0;
    while(n < (sza + szb))
        n <<= 1, ln++;
    for(int i = 0; i < n; i++)
        aa[i] = (i < sza ? a[i] : 0);
    for(int i = 0; i < n; i++)
        bb[i] = (i < szb ? b[i] : 0);
        
    fft(aa, n, ln, false);
    fft(bb, n, ln, false);
    
    for(int i = 0; i < n; i++)
        cc[i] = mul(aa[i], bb[i]);
        
    fft(cc, n, ln, true);
    
    int szc = n;
    vector<int> c(szc);
    szc = n;
    for(int i = 0; i < n; i++)
        c[i] = cc[i];
    return c;
}                    

int main()
{
    int n;
    cin >> n;
    vector<int> fact(n + 1);
    fact[0] = 1;
    for(int i = 0; i < n; i++)
        fact[i + 1] = mul(fact[i], i + 1);
    precalc();
    vector<int> A = {0, 1, 2};
    vector<int> B = {0, 1, 1};
    vector<int> C = {0, 1, 1};
    vector<int> D = {0, 1, 1};
    vector<int> conv;
    const int K = 2000;
    int last_conv = -1e9;
    while(A.size() <= n)
    {
        int cur = A.size();
        if(cur - last_conv >= K)
        {
            last_conv = cur - 1;
            conv = multiply(C, D);
        }
        /*for(auto x : conv) cerr << x << " ";
        cerr << endl;*/
        int val_A;
        if(last_conv * 2 >= cur)
        {
            val_A = conv[cur];
            // [cur - last_conv, last_conv] are already used
            for(int i = 1; i < (cur - last_conv); i++)
            {
                val_A = norm(val_A + mul(C[i], D[cur - i]));
            }
            for(int i = last_conv + 1; i < cur; i++)
            {
                val_A = norm(val_A + mul(C[i], D[cur - i]));
            }
        }
        else
        {
            val_A = 0;
            for(int i = 1; i <= cur - 1; i++)
            {
                val_A = norm(val_A + mul(C[i], D[cur - i]));
            }
        }
        val_A = mul(val_A, fact[cur - 1]);
        val_A = mul(val_A, 2);
        A.push_back(val_A);
        B.push_back(mul(val_A, inv(2)));
        C.push_back(mul(val_A, inv(fact[cur])));
        D.push_back(mul(B.back(), inv(fact[cur - 1])));
    }
    cout << norm(A[n] - 2) << endl;
}
--------------------------------------------------
Problem ID: 1792F1
Editorial Content:
1792F1 - Graph Coloring (easy version)
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

const int MOD = 998244353;

int add(int x, int y)
{
    x += y;
    while(x >= MOD) x -= MOD;
    while(x < 0) x += MOD;
    return x;
}

int mul(int x, int y)
{
    return (x * 1ll * y) % MOD;
}

int varMul(int x)
{
    return x;
}

template<typename... Args>
int varMul(int x, Args... args)
{
    return mul(x, varMul(args...));
}

int binpow(int x, int y)
{
    int z = 1;
    while(y)
    {
        if(y & 1) z = mul(z, x);
        x = mul(x, x);
        y /= 2;
    }
    return z;
}

vector<int> fact, rfact;
vector<int> dp;
int n;

void precalc()
{
    fact.resize(n + 1);
    rfact.resize(n + 1);
    fact[0] = 1;
    for(int i = 1; i <= n; i++)
        fact[i] = mul(i, fact[i - 1]);
    for(int i = 0; i <= n; i++)
        rfact[i] = binpow(fact[i], MOD - 2);
    dp.resize(n + 1, -1);
}

int C(int n, int k)
{
    if(n < 0 || n < k || k < 0) return 0;
    return varMul(fact[n], rfact[k], rfact[n - k]);
}

int calc(int x)
{
    if(dp[x] != -1) return dp[x];
    if(x == 1) return dp[x] = 1;
    if(x == 2) return dp[x] = 1;
    dp[x] = 0;
    int& d = dp[x];
    for(int i = 1; i < x; i++)
    {
        d = add(d, varMul(calc(i), (i == x - 1 ? (MOD + 1) / 2 : calc(x - i)), 2, C(x - 1, i - 1)));
    }   
    return d;
}

int main()
{
    cin >> n;
    precalc();
    cout << add(mul(calc(n), 2), -2) << endl;
}
--------------------------------------------------
Problem ID: 1792E
Editorial Content:
1792E - Divisors and Table
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>

using namespace std;

#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define sz(a) int((a).size())

#define x first
#define y second

typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;

template<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {
	return out << "(" << p.x << ", " << p.y << ")";
}
template<class A> ostream& operator <<(ostream& out, const vector<A> &v) {
	fore(i, 0, sz(v)) {
		if(i) out << " ";
		out << v[i];
	}
	return out;
}

const int INF = int(1e9);
const li INF64 = li(1e18);
const ld EPS = 1e-9;

int n;
li m1, m2;

inline bool read() {
	if(!(cin >> n >> m1 >> m2))
		return false;
	return true;
}

vector<pt> mFact;
vector<li> divs;

void factM(li m1, li m2) {
	mFact.clear();

	for (int d = 2; d * d <= m1 || d * d <= m2; d++) {
		int cnt = 0;
		while (m1 % d == 0) {
			m1 /= d;
			cnt++;
		}
		while (m2 % d == 0) {
			m2 /= d;
			cnt++;
		}
		if (cnt > 0)
			mFact.push_back({d, cnt});
	}
	if (m1 > m2)
		swap(m1, m2);
	if (m1 > 1)
		mFact.push_back({m1, 1});
	if (m2 > 1) {
		if (m2 == m1)
			mFact.back().y++;
		else
			mFact.push_back({m2, 1});
	}
}

void genDivisors(int pos, li val) {
	if (pos >= sz(mFact)) {
		divs.push_back(val);
		return;
	}
	li cur = val;
	fore (pw, 0, mFact[pos].y + 1) {
		genDivisors(pos + 1, cur);
		if (pw < mFact[pos].y)
			cur *= mFact[pos].x;
	}
}

inline void solve() {
	factM(m1, m2);

	divs.clear();
	genDivisors(0, 1);
	sort(divs.begin(), divs.end());

	vector<int> ans(sz(divs), 0);

	vector<li> dp(sz(divs), -1);
	fore (id, 0, sz(divs)) {
		if (divs[id] <= n)
			dp[id] = divs[id];
		for (auto [p, pw] : mFact) {
			if (divs[id] % p != 0)
				continue;
			
			int pos = int(lower_bound(divs.begin(), divs.end(), divs[id] / p) - divs.begin());
			dp[id] = max(dp[id], dp[pos]);
		}

		if (divs[id] / dp[id] <= n)
			ans[id] = divs[id] / dp[id];
	}

	int cnt = 0;
	int xorSum = 0;
	fore (i, 0, sz(ans)) {
		cnt += ans[i] > 0;
		xorSum ^= ans[i];
	}
	
//	cout << sz(ans) << endl;
//	cout << ans << endl;
	cout << cnt << " " << xorSum << endl;
}

int main() {
#ifdef _DEBUG
	freopen("input.txt", "r", stdin);
	int tt = clock();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(15);

	int t; cin >> t;
	
	while (t--) {
		
		read();
		solve();
		
#ifdef _DEBUG
		cerr << "TIME = " << clock() - tt << endl;
		tt = clock();
#endif
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1792D
Editorial Content:
1792D - Fixed Prefix Permutations
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
using namespace std;
 
#define forn(i, n) for(int i = 0; i < int(n); i++) 

int get(const vector<int> &a, const vector<int> &b){
	int res = 0;
	while (res < int(a.size()) && a[res] == b[res])
		++res;
	return res;
}

int main(){
	int t;
	scanf("%d", &t);
	while (t--){
		int n, m;
		scanf("%d%d", &n, &m);
		vector<vector<int>> a(n, vector<int>(m));
		forn(i, n) forn(j, m){
			scanf("%d", &a[i][j]);
			--a[i][j];
		}
		vector<vector<int>> b(n, vector<int>(m));
		forn(i, n) forn(j, m) b[i][a[i][j]] = j;
		sort(b.begin(), b.end());
		forn(i, n){
			int j = lower_bound(b.begin(), b.end(), a[i]) - b.begin();
			int ans = 0;
			if (j > 0) ans = max(ans, get(a[i], b[j - 1]));
			if (j < n) ans = max(ans, get(a[i], b[j]));
			printf("%d ", ans);
		}
		puts("");
	}
}
--------------------------------------------------
Problem ID: 1792C
Editorial Content:
1792C - Min Max Sort
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<int> pos(n + 1);
    for (int i = 0; i < n; ++i) {
      int x;
      cin >> x;
      pos[x] = i;
    }
    int l = (n + 1) / 2, r = (n + 2) / 2;
    while (l > 0 && (l == r || (pos[l] < pos[l + 1] && pos[r - 1] < pos[r]))) {
      --l;
      ++r;
    }
    cout << (n - r + l + 1) / 2 << '\n';
  }
}
--------------------------------------------------
Problem ID: 1792B
Editorial Content:
1792B - Stand-up Comedian
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
    a1, a2, a3, a4 = map(int, input().split())
    if a1 == 0:
        print(1)
    else:
        print(a1 + min(a2, a3) * 2 + min(a1 + 1, abs(a2 - a3) + a4))
--------------------------------------------------
Problem ID: 1792A
Editorial Content:
1792A - GamingForces
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    int cnt1 = 0;
    for (int i = 0; i < n; ++i) {
      int x;
      cin >> x;
      cnt1 += (x == 1);
    }
    cout << n - cnt1 / 2 << '\n';
  }
}
--------------------------------------------------
Problem ID: 1791G2
Editorial Content:
1791G2 - Teleporters (Hard Version)
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
#define startt ios_base::sync_with_stdio(false);cin.tie(0);
typedef long long  ll;
using namespace std;
#define vint vector<int>
#define all(v) v.begin(), v.end()
#define MOD 1000000007
#define MOD2 998244353
#define MX 1000000000
#define MXL 1000000000000000000
#define PI (ld)2*acos(0.0)
#define pb push_back
#define sc second
#define fr first
#define int long long
#define endl '\n'
#define ld long double
#define NO cout << "NO" << endl
#define YES cout << "YES" << endl
int ceildiv(int one, int two) {if (one % two == 0) {return one / two;}else {return one / two + 1;}} int power(int n, int pow, int m) {if (pow == 0) return 1;if (pow % 2 == 0) {ll x = power(n, pow / 2, m);return (x * x) % m;}else return (power(n, pow - 1, m) * n) % m;} int gcd(int a, int b) { if (!b)return a; return gcd(b, a % b);} int factorial(int n, int mod) {if (n > 1)return (n * factorial(n - 1, mod)) % mod; else return 1;} int lcm(int a, int b) {return (a * b) / gcd(a, b);} vector<int> read(int n) {vector<int> a; for (int i = 0; i < n; i++) { int x; cin >> x; a.pb(x);} return a;}struct prefix_sum{vint pref;void build(vint a){pref.pb(0);for(int i = 0; i < a.size(); i++){pref.pb(pref.back()+a[i]);}}int get(int l, int r){return pref[r]-pref[l-1];}};//mesanu

void solve()
{
    int n, c;
    cin >> n >> c;
    vector<pair<int, int>> a;
    for(int i = 0; i < n; i++)
    {
        int x;
        cin >> x;
        a.pb({x+min(i+1, n-i), x+i+1});
    }
    sort(all(a));
    vector<int> pref;
    pref.pb(0);
    for(int i = 0; i < n; i++)
    {
        pref.pb(pref.back()+a[i].fr);
    }
    int ans = 0;
    for(int i = 0; i < n; i++)
    {
        int new_c = c-a[i].sc;
        int l = 0, r = n;
        int mx = 0;
        while(l <= r)
        {
            int mid = l+r>>1;
            // Calculate price
            int price = pref[mid];
            int now = mid+1;
            if(mid > i)
            {
                price-=a[i].fr;
                now--;
            }
            if(price <= new_c)
            {
                mx = max(now, mx);
                l = mid+1;
            }
            else
            {
                r = mid-1;
            }
        }
        ans = max(ans, mx);
    }
    cout << ans << endl;
}

int32_t main(){
    startt
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1791G1
Editorial Content:
1791G1 - Teleporters (Easy Version)
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
#define ll long long

#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()

void solve() {
    int n, c, ans = 0; cin >> n >> c;
    priority_queue<int> q;
    for(int i = 1, x; i <= n; ++i) {
        cin >> x;
        q.push(-x - i);
    }
    while(!q.empty()) {
        int x = -q.top(); q.pop();
        if(x > c) break;
        ++ans;
        c -= x;
    }
    cout << ans << "\n";
}   
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1791F
Editorial Content:
1791F - Range Update Point Query
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;

int digit_sum(int n) {
    int ret = 0;
    while(n) {
        ret += n % 10;
        n /= 10;
    }
    return ret;
}
void solve() {
    int n, q; cin >> n >> q;
    vector<int> a(n);
    set<int> s;
    for(int i = 0; i < n; ++i) {
        cin >> a[i];
        if(a[i] > 9) s.insert(i);
    }
    while(q--) {
        int type; cin >> type;
        if(type == 1) {
            int l, r; cin >> l >> r; --l, --r;
            int lst = l;
            while(!s.empty()) {
                auto it = s.lower_bound(lst);
                if(it == s.end() || *it > r) break;
                a[*it] = digit_sum(a[*it]);
                int paiu = *it;
                s.erase(it);
                if(a[paiu] > 9) s.insert(paiu);
                lst = paiu + 1;
            }
        } else {
            int x; cin >> x; --x;
            cout << a[x] << "\n";
        }
    }
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(0);
	int t; cin >> t;
	while(t--) {
	    solve();
	}
}
--------------------------------------------------
Problem ID: 1791E
Editorial Content:
1791E - Negatives and Positives
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t; cin >> t;
    while(t--) {
        int n; cin >> n;
        vector<int> a(n);
        long long sum = 0;
        int negs = 0;
        for(int i = 0; i < n; ++i) {
            cin >> a[i];
            if(a[i] < 0) {
                ++negs;
                a[i] = -a[i];
            }
            sum += a[i];
        }
        sort(a.begin(), a.end());
        if(negs & 1) sum -= 2 * a[0];
        cout << sum << "\n";
    }
}
--------------------------------------------------
Problem ID: 1791D
Editorial Content:
1791D - Distinct Split
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
#define ll long long

#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()

void solve() {
    int n; string s; cin >> n >> s;
    vector<int> cnt(26, 0), p(26, 0);
    for(auto x: s) cnt[x - 'a']++;
    int ans = 0;
    for(auto x: s) {
        --cnt[x - 'a'];
        ++p[x - 'a'];
        int cur = 0;
        for(int i = 0; i < 26; ++i) {
            cur += min(1, cnt[i]) + min(1, p[i]);
        }
        ans = max(ans, cur);
    }
    cout << ans << "\n";
}   
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1791C
Editorial Content:
1791C - Prepend and Append
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

const int MAX = 200007;
const int MOD = 1000000007;

void solve() {
	int n;
	cin >> n;
	string s;
	cin >> s;
	int l = 0, r = n - 1, ans = n;
	while (s[l] != s[r] && ans > 0) {l++; r--; ans -= 2;}
	cout << ans << '\n';
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1791B
Editorial Content:
1791B - Following Directions
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

const int MAX = 200007;
const int MOD = 1000000007;

void solve() {
	int n;
	cin >> n;
	string s;
	cin >> s;
	int x = 0, y = 0;
	for (int i = 0; i < n; i++) {
		if (s[i] == 'L') {x--;}
		if (s[i] == 'R') {x++;}
		if (s[i] == 'D') {y--;}
		if (s[i] == 'U') {y++;}
		if (x == 1 && y == 1) {cout << "YES\n"; return;}
	}	
	cout << "NO\n";
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1791A
Editorial Content:
1791A - Codeforces Checking
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

const string s = "codeforces";

void solve() {
	char c;
	cin >> c;
	for (char i : s) {
		if (i == c) {cout << "YES\n"; return;}
	}
	cout << "NO\n";
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1790G
Editorial Content:
1790G - Tokens on Graph
Tutorial
Tutorial is loading...
Solution
#include<bits/stdc++.h>

using namespace std;

void solve()
{
    int n;
    cin >> n;
    vector<int> token(n), boni(n);
    vector<vector<int>> g(n);
    vector<int> good(n);
    int m;
    cin >> m;
    int p, b;
    cin >> p >> b;
    for(int i = 0; i < p; i++)
    {
        int x;
        cin >> x;
        --x;
        token[x] = 1;
    }
    for(int i = 0; i < b; i++)
    {
        int x;
        cin >> x;
        --x;
        boni[x] = 1;
    }
    for(int i = 0; i < m; i++)
    {
        int x, y;
        cin >> x >> y;
        --x;
        --y;
        g[x].push_back(y);
        g[y].push_back(x);
    }
    for(int i = 0; i < n; i++)
        for(auto x : g[i])
            if(boni[i] && boni[x]) good[i] = 1;
    set<int> good_tokens;
    set<int> not_so_good_tokens;
    for(int i = 0; i < n; i++)
        for(auto x : g[i])
        {
            if(token[i] && good[x]) good_tokens.insert(i);
            else if(token[i] && boni[x]) not_so_good_tokens.insert(i);
        }
    vector<int> d(n, int(1e9));
    queue<int> q;
    d[0] = 0;
    q.push(0);
    while(!q.empty())
    {
        int k = q.front();
        q.pop();
        for(auto x : g[k])
        {
            if(d[x] > d[k] + 1)
            {
                d[x] = d[k] + 1;
                if(boni[x]) q.push(x);
            }
        }
    }
    bool has_ans = false;
    for(int i = 0; i < n; i++)
    {
        if(!token[i] || d[i] > n) continue;
        has_ans |= (!good_tokens.empty() && (*good_tokens.begin() != i || *good_tokens.rbegin() != i));
        int cnt = not_so_good_tokens.size();
        if(not_so_good_tokens.count(i)) cnt--;
        has_ans |= d[i] <= 1 + cnt;
    }
    cout << (has_ans ? "YES" : "NO") << endl;
}

int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
#ifdef _DEBUG
    freopen("input.txt", "r", stdin);
#endif
    int tc = 1;
    cin >> tc;
    for(int i = 0; i < tc; i++)
    {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1790F
Editorial Content:
1790F - Timofey and Black-White Tree
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 200200;
const int INF = 1e9;

int n, ANS = INF;
int crr[MAXN], dist[MAXN], res[MAXN];
bool clr[MAXN];
vector<int> gr[MAXN];

void init() {
	ANS = INF;
	for (int v = 0; v < n; ++v)
		gr[v].clear();
	fill(dist, dist + n, INF);
	memset(clr, 0, n);
}

void dfs(int v, int p) {
	if (dist[v] >= ANS) return;
	if (clr[v]) ANS = min(ANS, dist[v]);
	for (int u: gr[v]) {
		if (u == p) continue;
		if (dist[v] + 1 < dist[u]) {
			dist[u] = dist[v] + 1;
			dfs(u, v);
		} else ANS = min(ANS, dist[v] + 1 + dist[u]);
	}
}

void solve() {
	dist[*crr] = 0;
	dfs(*crr, -1);
	clr[*crr] = true;
	for (int i = 1; i < n; ++i) {
		dist[crr[i]] = 0;
		dfs(crr[i], -1);
		clr[crr[i]] = true;
		res[i] = ANS;
	}
}

int main() {
	int gorilla; cin >> gorilla;
	while (gorilla--) {
		cin >> n >> *crr, --(*crr);
		init();
		for (int i = 1; i < n; ++i)
			cin >> crr[i], --crr[i];
		for (int i = 1; i < n; ++i) {
			int v, u; cin >> v >> u, --v, --u;
			gr[v].push_back(u);
			gr[u].push_back(v);
		}
		solve();
		for (int i = 1; i < n; ++i)
			cout << res[i] << ' ';
		cout << '\n';
	}
}
--------------------------------------------------
Problem ID: 1790E
Editorial Content:
1790E - Vlad and a Pair of Numbers
Tutorial
Tutorial is loading...
Solution
t = int(input())
for _ in range(t):
    x = int(input())
    a = x
    b = 0
    for i in range(32, -1, -1):
        if x & (1 << i) > 0:
            continue
        if 2 * x - a - b >= (2 << i):
            a += 1 << i
            b += 1 << i
    if a + b == 2 * x and a ^ b == x:
        print(a, b)
    else:
        print(-1)
--------------------------------------------------
Problem ID: 1790D
Editorial Content:
1790D - Matryoshkas
Tutorial
Tutorial is loading...
Solution
#include <iostream>
#include <vector>
#include <queue>
#include <map>
#include <set>

using namespace std;

void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    map<int, int> cnt;
    set<int> b;
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        cnt[a[i]]++;
        b.insert(a[i]);
        b.insert(a[i] + 1);
    }
    int last = 0;
    int res = 0;
    for (auto x: b) {
        int c = cnt[x];
        res += max(0, c - last);
        last = c;
    }
    cout << res << '\n';
}

int main(int argc, char* argv[]) {
    int t;
    cin >> t;
    for (int i = 0; i < t; ++i) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1790C
Editorial Content:
1790C - Premutation
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
int n;

void solve(){
    cin >> n;
    vector<vector<int>>perm(n, vector<int>(n - 1));
    vector<int>p(n, 0);
    vector<int>cnt(n + 1, 0);
    for(int i = 0; i < n; i++){
        p[i] = i + 1;
        for(int j = 0; j < n - 1; j++){
            cin >> perm[i][j];
            if(j == 0) cnt[perm[i][j]]++;
        }
    }
    for(int i = 1; i <= n; i++){
        if(cnt[i] == n - 1){
            p[0] = i;
            break;
        }
    }
    for(int i = 0; i < n; i++){
        if(perm[i][0] != p[0]){
            for(int j = 0; j < n - 1; j++){
                p[j + 1] = perm[i][j];
            }
        }
    }
    for(int i = 0; i < n; i++) cout << p[i] << ' ';
    cout << endl;

}

int main(){
    int t;
    cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1790B
Editorial Content:
1790B - Taisia and Dice
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 55;

int n, s1, s2;
vector<int> res;

void solve() {
	res.clear();
	int d = s1 - s2;
	for (; s2 >= d; s2 -= d)
		res.push_back(d);
	if (s2) res.push_back(s2);
	for (int i = 0; i < res.size() && res.size() + 1 < n;) {
		if (res[i] == 1) {
		    ++i;
		    continue;
		}
		--res[i];
		res.push_back(1);
	}
	res.push_back(d);
}

int main() {
	int t; cin >> t;
	while (t--) {
		cin >> n >> s1 >> s2;
		solve();
		sort(res.begin(), res.end());
		for (int x: res)
			cout << x << ' ';
		cout << endl;
	}
}
--------------------------------------------------
Problem ID: 1790A
Editorial Content:
1790A - Polycarp and the Day of Pi
Tutorial
Tutorial is loading...
Solution
t = int(input())
pi = '31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679'
for _ in range(t):
    n = input() + '#'
    for i in range(len(n)):
        if pi[i] != n[i]:
            print(i)
            break
--------------------------------------------------
Problem ID: 1789F
Editorial Content:
1789F - Serval and Brain Power
Tutorial
Assume that the longest powerful subsequence of the given string $$$S$$$ is $$$T$$$, which can be obtained by concatenating $$$k$$$ copies of string $$$T'$$$. Noticing that $$$|S|\leq 80$$$, we have the observation that $$$k\cdot |T'| \leq |S| \leq 80$$$, so it is impossible that both $$$k$$$ and $$$|T'|$$$ is large.
When $$$k < 5$$$, we only need to consider the $$$k = 2$$$ case and the $$$k = 3$$$ case. The $$$k = 4$$$ case is covered by $$$k = 2$$$ case, since $$$T = T'+T'+T'+T' = (T'+T') + (T'+T')$$$.
For the $$$k = 2$$$ case, we split $$$S$$$ into two parts $$$S=S_1+S_2$$$, then calculate the maximal length of $$$\operatorname{LCS}(S_1, S_2)$$$ by dynamic programming over all the possible splits. This case can be solved in $$$O(w_2\cdot|S|^3)$$$ time, where $$$w_2$$$ is a small constant.
It is similar to solve the $$$k = 3$$$ case. We split $$$S$$$ into three parts $$$S = S_1 + S_2 + S_3$$$, then calculate the maximal length of $$$\operatorname{LCS}(S_1, S_2, S_3)$$$ over all the possible splits. This case can be solved in $$$O(w_3\cdot|S|^5)$$$ time, where $$$w_3$$$ is a small constant. We will estimate $$$w_3$$$ later.
When $$$k \geq 5$$$, we have $$$|T'|\leq {|S|\over k}\leq {|S|\over 5}$$$. It can be shown that, if we split $$$S$$$ into $$$5$$$ parts, $$$T'$$$ will be the subsequence of at least one of them. We can split $$$S$$$ into equal lengths, then enumerate all the subsequences of these substrings as the possible $$$T'$$$. For a possible $$$T'$$$, we can find out corresponding $$$k$$$ by matching $$$T'$$$ and $$$S$$$ greedily. This case can be solved in $$$O(5\cdot 2^{|S|/5}|S|)$$$.
Now let us roughly estimate how small $$$w_3$$$ could be. The time that dynamic programming consumed for certain $$$S_1, S_2, S_3$$$ is $$$|S_1|\cdot|S_2|\cdot|S_3|$$$. Since $$$|S_1|+|S_2|+|S_3|=|S|$$$, we have $$$|S_1|\cdot|S_2|\cdot|S_3|\leq {1\over 27}|S|^3$$$. Recall that there are $$${|S|-1 \choose 2} \leq {1\over 2}|S|^2$$$ possible splits, then $$$w_3\leq {1\over 54}$$$ holds.
Time complexity: $$$O(w_3\cdot|S|^5 + 5\cdot 2^{|S|/5}|S|)$$$.
--------------------------------------------------
Problem ID: 1789E
Editorial Content:
1789E - Serval and Music Game
Tutorial
Consider the following two cases:
Case 1
: $$$x$$$ is not a factor of $$$s_n$$$.
In this case we have $$$\left\lfloor{s_n\over x}\right\rfloor + 1 = \left\lceil{s_n\over x}\right\rceil$$$. Let $$$k = \left\lfloor{s_n\over x}\right\rfloor$$$. It can be shown that there are at most $$$2\sqrt{s_n}$$$ different values of $$$k$$$. The constraint of $$$s_i$$$ can be written in the following form:
$$$ s_i = p_i \cdot k + q_i \cdot (k+1) = (p_i+q_i)\cdot k + q_i $$$
For a certain $$$k$$$, such $$$p_i$$$ and $$$q_i$$$ do not exist if and only if $$$s_i\bmod k > \left\lfloor{s_i\over k}\right\rfloor$$$. To prove it, we show the contradiction that $$$q_i\bmod k = s_i\bmod k > \left\lfloor{s_i\over k}\right\rfloor \geq q_i$$$, and we can give a construction of $$$p_i$$$ and $$$q_i$$$ when $$$s_i\bmod k\leq \left\lfloor{s_i\over k}\right\rfloor$$$ that $$$q_i = s_i\bmod k$$$ and $$$p_i=\left\lfloor{s_i\over k}\right\rfloor - q_i$$$.
By observation, these $$$s_i$$$ are in one of the following $$$k-2$$$ intervals:
$$$ [1, k-1], [k+2, 2k-1],\dots, [(i-1)k+i, ik-1],\dots, [(k-2)k+(k-1), (k-1)k-1] $$$
We can count the number of these $$$s_i$$$ by pre-calculating the prefix sums to calculate $$$f(x)$$$.
This case can be solved in $$$O(s_n)$$$ time, and we will show this fact:
When $$$k\leq \sqrt{s_n}$$$, there are $$$k - 2$$$ intervals that need to be considered for a certain $$$k$$$. Since $$$\sum_{k\leq \sqrt{s_n}} k \leq s_n$$$, this part can be solved in $$$O(s_n)$$$ time.
When $$$k>\sqrt{s_n}$$$, notice that there are at most $$$\left\lceil s_n\over k\right\rceil \leq \sqrt{s_n}$$$ intervals that need to be considered for a certain $$$k$$$. Recall that there are at most $$$\sqrt{s_n}$$$ different values of $$$k$$$ in this part, so it can be solved in $$$O(s_n)$$$ time.
Case 2
: $$$x$$$ is a factor of $$$s_n$$$.
In this case we have $$$\left\lfloor{s_n\over x}\right\rfloor = \left\lceil{s_n\over x}\right\rceil$$$. Let $$$k = {s_n\over x}$$$. The constraint of $$$s_i$$$ becomes:
$$$ s_i = (p_i + q_i) \cdot k $$$
To calculate $$$f(x)$$$, we only need to count the number of multiples of $$$x$$$. To do this, we can first calculate $$$s'_i = \gcd(s_i, s_n)$$$ for all $$$1\leq i\leq n$$$ in $$$O(n\log s_n)$$$ time. It is obvious that $$$s_i'$$$ is a factor of $$$s_n$$$. For a certain $$$x$$$, we can enumerate all the factors of $$$s_n$$$, find out the multiples of $$$x$$$ among them, and sum up the times that they occurred in $$$s'$$$. Recall that $$$s_n$$$ has at most $$$2\sqrt{s_n}$$$ factors, so this takes $$$O(s_n)$$$ time.
This case can be solved in $$$O(n\log s_n + s_n)$$$ time in total.
Time complexity: $$$O(n\log s_n + s_n)$$$.
$$$O(s_n + \sigma(s_n))$$$ solutions can pass all the tests, where $$$\sigma(n)$$$ denotes the sum of all the factors of $$$n$$$. A well-implemented $$$O(s_n\log s_n)$$$ solutions may pass the tests, too.
Bonus
: Solve this problem in $$$O(n + s_n)$$$ time.
--------------------------------------------------
Problem ID: 1789D
Editorial Content:
1789D - Serval and Shift-Shift-Shift
Tutorial
First of all, it could be proven that the answer exists if and only if $$$a$$$ and $$$b$$$ are both zero or $$$a$$$ and $$$b$$$ are both non-zero.
If $$$a$$$ is zero, it remains zero after any operations. Therefore it cannot become $$$b$$$ if $$$b$$$ is non-zero. If $$$a$$$ is non-zero, logical left shift it will definitely increase its lowest bit or make it zero, thus changing it into a different number. The same applies to logical right shift. Therefore, the xor result must be non-zero and there are no possible operations if $$$b$$$ is zero.
We will show that it is always possible to change $$$a$$$ into $$$b$$$ in the other cases. We denote $$$\text{lb}(a)$$$ as the lowest bit of $$$a$$$ and $$$\text{hb}(a)$$$ as the highest bit of $$$a$$$. If $$$a$$$ and $$$b$$$ are both zero, no operations are needed. If they are both non-zero, the construction consists of four steps:
If $$$\text{hb}(a)<\text{lb}(b)$$$, logical left shift $$$a$$$ by $$$\text{lb}(b)-\text{hb}(a)$$$ bits. Then $$$\text{hb}(a)$$$ must be equal or greater than $$$\text{lb}(b)$$$.
For each bit $$$i$$$ of $$$\text{lb}(b)-1,\text{lb}(b)-2,\dots,1$$$, if $$$a_{i}=1$$$, we may logical right shift $$$a$$$ by $$$\text{hb}(a)-i$$$ bits to erase it. After that, we have $$$\text{lb}(a)\ge\text{lb}(b)$$$.
If $$$\text{lb}(a)>\text{lb}(b)$$$, logical right shift $$$a$$$ by $$$\text{lb}(a)-\text{lb}(b)$$$ bits. Now it is guaranteed that $$$\text{lb}(a)=\text{lb}(b)$$$.
For each bit $$$i$$$ of $$$\text{lb}(b)+1,\text{lb}(b)+2,\dots,n$$$, if $$$a_{i}\neq b_{i}$$$, we may logical left shift $$$a$$$ by $$$i-\text{lb}(a)$$$ bits to erase it. After that, we must have $$$a=b$$$.
Step 2 and step 4 require at most $$$n-1$$$ operations. We may also note that step 1 and step 3 never appear simultaneously. If step 1 is operated, then $$$\text{lb}(a)=\text{lb}(b)$$$ is guaranteed after step 2. Thus, we need not operate step 3 in this case. In conclusion, we may use no more than $$$n$$$ operations to change $$$a$$$ into $$$b$$$ if they are both non-zero.
Time Complexity: $$$O(n^{2})$$$ or $$$O(\frac{n^{2}}{w})$$$ by using
std::bitset
.
--------------------------------------------------
Problem ID: 1789C
Editorial Content:
1789C - Serval and Toxel's Arrays
Tutorial
Consider the contribution of each value. We only need to count the number of concatenated arrays each value appears in, and sum all those counts up. The answer to this problem only depends on the number of appearances of this value. Notice that the appearance of each value forms some intervals. Each interval starts when it modifies another element (or in the initial array), and ends when it is modified (or in the $$$m$$$-th array). As there are no duplicate elements, the intervals do not intersect, so we can simply sum their lengths up.
Let's use an array $$$\text{appear}$$$ to track the appearance of each value. We first set the appearance of the initial elements to $$$0$$$, and other elements to $$$-1$$$, which means the value does not appear. Then, in the $$$i$$$-th modification, suppose we modified some elements from $$$x$$$ to $$$y$$$, then we should add $$$i-\text{appear}_{x}$$$ to $$$\text{count}_{x}$$$, and set $$$\text{appear}_{x}$$$ to $$$-1$$$. We should also set $$$\text{appear}_{y}$$$ to $$$i$$$. After all operations, for all $$$x$$$, add $$$m+1-\text{appear}_{x}$$$ to $$$\text{count}_{x}$$$ if $$$\text{appear}_{x}$$$ is not $$$-1$$$.
Value $$$x$$$ appears in $$$\frac{m(m+1)}{2}-\frac{(m-\text{count}_{x})(m-\text{count}_{x}+1)}{2}$$$ concatenated arrays.
Time complexity: $$$O(n+m)$$$.
--------------------------------------------------
Problem ID: 1789B
Editorial Content:
1789B - Serval and Inversion Magic
Tutorial
If $$$s$$$ is palindromic initially, we can operate on the interval $$$[1,n]$$$, the answer is
Yes
.
Let's consider the other case. In a palindrome $$$s$$$, for each $$$i$$$ in $$$[1,\lfloor n/2\rfloor]$$$, $$$s_{i}=s_{n-i+1}$$$ must hold. For those $$$i$$$, we may check whether $$$s_{i}=s_{n-i+1}$$$ is true in the initial string. For all the illegal positions $$$i$$$, the operation must contain either $$$i$$$ or $$$n+1-i$$$, but not both. For the legal positions, the operation must contain neither of $$$i$$$ nor $$$n+1-i$$$, or both of them.
If the illegal positions is continuous (which means that they are $$$l,l+1,\dots,r-1,r$$$ for some $$$l$$$ and $$$r$$$), we may operate on the interval $$$[l,r]$$$ (or $$$[n+1-r,n+1-l]$$$), making the string palindromic. The answer is
Yes
.
Otherwise, there must be some legal positions that lie between the illegal ones. Suppose the illegal positions range between $$$[l,r]$$$ (but not continuous), and the operation is $$$[o_{1},o_{2}]$$$. Without loss of generality, let the operation lies in the left part of the string. Then $$$o_{1}\le l,r\le o_{2}<n+1-r$$$ must hold to correct all the illegal positions. This interval covers all the legal positions that lie between the illegal ones but does not cover their symmetrical positions. Thus, such kind of operation will produce new illegal positions. In other words, there are no valid operations in this situation. The answer is
No
.
Time complexity: $$$O(n)$$$.
--------------------------------------------------
Problem ID: 1789A
Editorial Content:
1789A - Serval and Mocha's Array
Tutorial
Considering an array $$$a$$$ of $$$n$$$ ($$$n\geq 2$$$) positive integers, the following inequality holds for $$$2\leq i\leq n$$$:
$$$ \gcd(a_1,a_2,\cdots,a_i) \leq \gcd(a_1,a_2) \leq 2 $$$
Therefore, when the prefix $$$[a_1,a_2]$$$ of $$$a$$$ is good, we can show that all the prefixes of $$$a$$$ whose length is no less than $$$2$$$ are good, then $$$a$$$ is beautiful. It is obvious that $$$[a_1, a_2]$$$ is good when $$$a$$$ is beautiful. So we get the conclusion that $$$a$$$ is beautiful if and only if the prefix $$$[a_1, a_2]$$$ is good.
We can check if there exist $$$a_i, a_j$$$ ($$$i\neq j$$$) such that $$$\gcd(a_i, a_j)\leq 2$$$. If so, we can move $$$a_i,a_j$$$ to the front of $$$a$$$ to make it beautiful, then the answer is
Yes
. If not, the answer is
No
.
Time complexity: $$$O(n^2\log 10^6)$$$.
--------------------------------------------------
Problem ID: 1788F
Editorial Content:
1788F - XOR, Tree, and Queries
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1788E
Editorial Content:
1788E - Sum Over Zero
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1788D
Editorial Content:
1788D - Moving Dots
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1788C
Editorial Content:
1788C - Matching Numbers
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1788B
Editorial Content:
1788B - Sum of Two Numbers
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1788A
Editorial Content:
1788A - One and Two
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1787I
Editorial Content:
1787I - Treasure Hunt
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1787H
Editorial Content:
1787H - Codeforces Scoreboard
Something To Say
Have to declare that we built up Problem H from zero. ;)
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1787G
Editorial Content:
1787G - Colorful Tree Again
Tutorial
Tutorial is loading...
UPD:
An alternative implementation using segment tree
comment link
.
--------------------------------------------------
Problem ID: 1787F
Editorial Content:
1787F - Inverse Transformation
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
const int N = 200005;
int dest[N], visit[N], ans[N], mp[N], ansinv[N], sp;
int pow2(int y, int M) {
	long long x = 2, ans = 1;
	while (y) {
		if (y & 1) ans = ans * x % M;
		x = x * x % M, y >>= 1;
	}
	return ans % M;
}
vector<int> cyc[N];
void get() {
	sp = 0;
	int n, i, j, m, z, o;
	cin >> n >> m;
	for (i = 1; i <= n; i++) cyc[i].clear();
	for (i = 1; i <= n; i++) visit[i] = 0, cin >> dest[i];
	for (i = 1; i <= n; i++) {
		if (visit[i]) continue;
		j = i, z = 0; do { ++z, visit[j] = 1, j = dest[j]; } while (j != i);
		cyc[z].push_back(i);
	}
	int lim = pow2(min(m, 20), 1e9), s = 0, d, t, num, cp;
	for (i = 1; i <= n; i++) {
		if (!cyc[i].size()) continue;
		int siz = cyc[i].size();
		if (i % 2 == 0 && siz % lim) {
			cout << "NO" << endl; return;
		} else {
			cp = -1;
			for (j = lim; j > 0; j /= 2) {
				while (siz >= j) {
					siz -= j, d = s + j * i, t = j;
					while (t--) {
						++s, ++cp, num = s, o = cyc[i][cp];
						do {
						    ans[num] = o, num += pow2(m, i * j);
						    if (num > d) num -= j * i;
						    o = dest[o];
						} while (o != cyc[i][cp]);
					}
					for (int k = sp + 1; k < sp + j * i; k++) mp[k] = k + 1;
					mp[sp + j * i] = sp + 1, sp += j * i, s = d;
				}
			}
		}
	}
	cout << "YES" << endl;
	for (i = 1; i <= n; i++) ansinv[ans[i]] = i;
	for (i = 1; i <= n; i++) cout << ans[mp[ansinv[i]]] << " \n"[i == n];
}
int main() {
	ios::sync_with_stdio(0), cin.tie(0);
	int T;
	cin >> T;
	while (T--) get();
	return 0;
}
--------------------------------------------------
Problem ID: 1787E
Editorial Content:
1787E - The Harmonization of XOR
Tutorial
Tutorial is loading...
Bonus Problem
Bonus Problem:
What if $$$x=0$$$?
--------------------------------------------------
Problem ID: 1787D
Editorial Content:
1787D - Game on Axis
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
const int N = 200005;
int a[N];
int v[N]; //= 1 -> in the tree with the end node
int s[N]; //subtree size
struct E {
	int to;
	E *nex;
} *h[N];
void add(int u, int v) {
	E *cur = new E;
	cur->to = v, cur->nex = h[u], h[u] = cur;
}
void dfs(int u) {
	s[u] = v[u] = 1;
	for (E *cur = h[u]; cur; cur = cur->nex)
		dfs(cur->to), s[u] += s[cur->to];
}
void get() {
	int i, j, n;
	cin >> n;
	for (i = 1; i <= n + 1; i++)
		s[i] = v[i] = 0, h[i] = 0;
	for (i = 1; i <= n; i++) {
		cin >> a[i], a[i] = min(i + a[i], n + 1);
		if (a[i] <= 0) a[i] = n + 1;
		add(a[i], i);
	}
	dfs(n + 1); //start with the end point, dfs the tree
	long long ans = 0;
	if (v[1] == 1) {
		j = 1; do { ans -= s[j] + (n - s[n + 1] + 1), j = a[j]; }
		while (j != n + 1);
		ans += 1ll * n * (2 * n + 1);
	} else {
		j = 1; do { ans += (n + s[n + 1]), v[j] = 2, j = a[j]; }
		while (v[j] != 2);
	}
	cout << ans << endl;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int T;
	cin >> T;
	while (T--) get();
	return 0;
}
--------------------------------------------------
Problem ID: 1787C
Editorial Content:
1787C - Remove the Bracket
Fact
This is the reason why the problem was named as
Remove the Bracket
.
$$$ \begin{aligned} \text{Product} &= a_1 \cdot a_2 \cdot a_3 \cdot \ldots \cdot a_n = \\ &= a_1 \cdot (x_2+y_2) \cdot (x_3+y_3) \cdot \ldots \cdot (x_{n-1}+y_{n-1}) \cdot a_n = \\ &\overset{\text{?}}{=} a_1 \cdot x_2+y_2 \cdot x_3+y_3 \cdot \ldots \cdot x_{n-1}+y_{n-1} \cdot a_n. \end{aligned} $$$
However, We discussed to remove it on 28th Jan in the statement. Really sorry for inconvenience of the statement!
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
const int N = 200005;
long long f[N][2],x[N],y[N];
void get() {
	int i,n,s,j;
	cin>>n>>s;
	for(i=1; i<=n; i++) {
		cin>>j;
		if(i==1||i==n) x[i]=y[i]=j;
		else if(j<=s) x[i]=0,y[i]=j;
		else x[i]=s,y[i]=j-s;
	}
	f[1][0]=f[1][1]=0;
	for(i=2; i<=n; i++) {
		f[i][0]=min(f[i-1][0]+y[i-1]*x[i],f[i-1][1]+x[i-1]*x[i]);
		f[i][1]=min(f[i-1][0]+y[i-1]*y[i],f[i-1][1]+x[i-1]*y[i]);
	}
	cout<<f[n][0]<<endl;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int T; cin>>T;
	while(T--) get();
	return 0;
}
--------------------------------------------------
Problem ID: 1787B
Editorial Content:
1787B - Number Factorization
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
#define mp make_pair
pair<int, int> s[110];
int d[110];
void get() {
	int n, l = 0, i, c;
	cin >> n;
	for (i = 2; i * i <= n; i++) {
		if (n % i == 0) {
			c = 0;
			while (n % i == 0) c++, n /= i;
			s[++l] = make_pair(c, i);
		}
	}
	if (n != 1) s[++l] = make_pair(1, n);
	sort(s + 1, s + l + 1), d[l + 1] = 1;
	for (i = l; i >= 1; i--) d[i] = d[i + 1] * s[i].second;
	int ans = 0;
	for (i = 1; i <= l; i++) if (s[i].first != s[i - 1].first) ans += d[i] * (s[i].first - s[i - 1].first);
	cout << ans << endl;
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int T;
	cin >> T;
	while (T--) get();
	return 0;
}
--------------------------------------------------
Problem ID: 1787A
Editorial Content:
1787A - Exponential Equation
Tutorial
Tutorial is loading...
--------------------------------------------------
Problem ID: 1786B
Editorial Content:
1786B - Cake Assembly Line
Explanation
Tutorial is loading...
Code by KAN
#include <bits/stdc++.h>

using namespace std;

const int inf = 1000000000;

int main() {
  int tt;
  cin >> tt;
  while (tt--) {
    int n, w, h;
    cin >> n >> w >> h;
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
      cin >> a[i];
    }
    vector<int> b(n);
    for (int i = 0; i < n; i++) {
      cin >> b[i];
    }
    int minshift = -inf;
    int maxshift = inf;
    for (int i = 0; i < n; i++) {
      minshift = max(minshift, (b[i] + h) - (a[i] + w));
      maxshift = min(maxshift, (b[i] - h) - (a[i] - w));
    }
    if (minshift <= maxshift) {
      cout << "YES" << '\n';
    } else {
      cout << "NO" << '\n';
    }
  }
  return 0;
}
--------------------------------------------------
Problem ID: 1786A2
Editorial Content:
1786A2 - Alternating Deck (hard version)
Explanation
Tutorial is loading...
Code by KAN
NT = int(input())
 
for T in range(NT):
	n = int(input())
	answer = [0, 0, 0, 0]
	first_card = 1
	for it in range(1, 20000):
		who = 0 if it % 4 == 1 or it % 4 == 0 else 1
		cnt = it
		if n < cnt:
			cnt = n
		cnt_white = (cnt + first_card % 2) // 2
		cnt_black = cnt - cnt_white
		answer[who * 2 + 0] += cnt_white
		answer[who * 2 + 1] += cnt_black
		first_card += cnt
		n -= cnt
		if n == 0:
			break
	assert(n == 0)
	print(*answer)
--------------------------------------------------
Problem ID: 1786A1
Editorial Content:

--------------------------------------------------
Problem ID: 1784F
Editorial Content:

--------------------------------------------------
Problem ID: 1784E
Editorial Content:

--------------------------------------------------
Problem ID: 1784D
Editorial Content:

--------------------------------------------------
Problem ID: 1784C
Editorial Content:

--------------------------------------------------
Problem ID: 1784B
Editorial Content:

--------------------------------------------------
Problem ID: 1784A
Editorial Content:

--------------------------------------------------
Problem ID: 1783G
Editorial Content:
1783G - Weighed Tree Radius
Tutorial
Tutorial is loading...
Solution 1 (adedalic)
#include<bits/stdc++.h>

using namespace std;

#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define sz(a) int((a).size())

#define x first
#define y second

typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;

template<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {
	return out << "(" << p.x << ", " << p.y << ")";
}
template<class A> ostream& operator <<(ostream& out, const vector<A> &v) {
	fore(i, 0, sz(v)) {
		if(i) out << " ";
		out << v[i];
	}
	return out;
}

const int INF = int(1e9);
const li INF64 = li(1e18);
const ld EPS = 1e-9;

const int LOG = 18;
const int N = int(2e5) + 55;

int n;
vector<int> a;
vector<int> g[N];

inline bool read() {
	if(!(cin >> n))
		return false;
	a.resize(n);
	fore (i, 0, n)
		cin >> a[i];
	fore (i, 0, n - 1) {
		int u, v;
		cin >> u >> v;
		u--, v--;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	return true;
}

int p[LOG][N];
int h[N], tin[N], tout[N], T = 0;

void precalcLca(int v, int pr) {
	tin[v] = T++;
	h[v] = 0;
	if (pr != v)
		h[v] = h[pr] + 1;
	p[0][v] = pr;
	fore (pw, 0, LOG - 1)
		p[pw + 1][v] = p[pw][p[pw][v]];

	for (int to : g[v]) {
		if (to == pr)
			continue;
		precalcLca(to, v);
	}
	tout[v] = T;
}

bool isParent(int l, int v) {
	return tin[l] <= tin[v] && tout[v] <= tout[l];
}

int lca(int u, int v) {
	if (isParent(u, v))
		return u;
	if (isParent(v, u))
		return v;
	
	for (int pw = LOG - 1; pw >= 0; pw--) 
		if (!isParent(p[pw][v], u))
			v = p[pw][v];
	assert(!isParent(v, u));
	assert(isParent(p[0][v], u));
	return p[0][v];
}

int getFarthest(int s) {
	vector<int> used(n, 0);
	queue<int> q;

	used[s] = 1;
	q.push(s);
	int v;
	while (!q.empty()) {
		v = q.front(); 
		q.pop();
		for (int to : g[v]) {
			if (used[to])
				continue;
			used[to] = 1;
			q.push(to);
		}
	}
	return v;
}

int getDist(int u, int v) {
	return h[u] + h[v] - 2 * h[lca(u, v)];
}

const int M = int(2e5);
vector<pt> ops[4 * M];

void setOp(int v, int l, int r, int lf, int rg, const pt &op) {
	if (l >= r || lf >= rg) return;
	if (l == lf && r == rg) {
		ops[v].push_back(op);
		return;
	}
	int mid = (l + r) / 2;
	if (lf < mid)
		setOp(2 * v + 1, l, mid, lf, min(mid, rg), op);
	if (rg > mid)
		setOp(2 * v + 2, mid, r, max(lf, mid), rg, op);
}

void updDiam(int &s, int &t, int &curD, const pt &op) {
	int v = op.x;
	a[v] = op.y;

	int ns = s, nt = t, nD = curD;

	vector<pt> cds = {{s, v}, {v, t}, {v, v}};
	for (auto &c : cds) {
		int d1 = getDist(c.x, c.y);
		if (nD < a[c.x] + d1 + a[c.y]) {
			nD = a[c.x] + d1 + a[c.y];
			ns = c.x, nt = c.y;
		}
	}
	s = ns;
	t = nt;
	curD = nD;
}

vector<int> ans;

void calcDiams(int v, int l, int r, int s, int t, int curD) {
	for (auto &op : ops[v])
		updDiam(s, t, curD, op);
	if (r - l > 1) {
		int mid = (l + r) / 2;
		calcDiams(2 * v + 1, l, mid, s, t, curD);
		calcDiams(2 * v + 2, mid, r, s, t, curD);
	}
	else
		ans[l] = (curD + 1) / 2;
	
	for (auto &op : ops[v])
		a[op.first] = 0;
}

inline void solve() {
	precalcLca(0, 0);
	int s = getFarthest(0);
	int t = getFarthest(s);

	int m;
	cin >> m;
	vector<int> lst(n, 0);
	fore (i, 0, m) {
		int v, x;
		cin >> v >> x;
		v--;

		setOp(0, 0, m, lst[v], i, {v, a[v]});
		lst[v] = i;
		a[v] = x;
	}
	fore (v, 0, n)
		setOp(0, 0, m, lst[v], m, {v, a[v]});

	ans.resize(m, -1);
	a.assign(n, 0);
	calcDiams(0, 0, m, s, t, getDist(s, t));

	fore (i, 0, m)
		cout << ans[i] << '\n';
}

int main() {
#ifdef _DEBUG
	freopen("input.txt", "r", stdin);
	int tt = clock();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(15);
	
	if(read()) {
		solve();
		
#ifdef _DEBUG
		cerr << "TIME = " << clock() - tt << endl;
		tt = clock();
#endif
	}
	return 0;
}
Solution 2 (adedalic)
#include<bits/stdc++.h>

using namespace std;

#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define sz(a) int((a).size())

#define x first
#define y second

typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;

template<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {
	return out << "(" << p.x << ", " << p.y << ")";
}
template<class A> ostream& operator <<(ostream& out, const vector<A> &v) {
	fore(i, 0, sz(v)) {
		if(i) out << " ";
		out << v[i];
	}
	return out;
}

const int INF = int(1e9);
const li INF64 = li(1e18);
const ld EPS = 1e-9;

const int LOG = 18;
const int N = int(2e5) + 55;

int n;
vector<int> a;
vector<int> g[N];

inline bool read() {
	if(!(cin >> n))
		return false;
	a.resize(n);
	fore (i, 0, n)
		cin >> a[i];
	fore (i, 0, n - 1) {
		int u, v;
		cin >> u >> v;
		u--, v--;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	return true;
}

struct Lca {
	vector<int> log2, tin;
	vector< vector<int> > hs;
	int T = 0;

	void dfs(int v, int p, int cdepth) {
		tin[v] = T++;
		hs[0][tin[v]] = cdepth;
		for (int to : g[v]) {
			if (to == p)
				continue;
			dfs(to, v, cdepth + 1);
			hs[0][T++] = cdepth;
		}
	}

	void init() {
		log2.assign(2 * n, 0);
		fore (i, 2, sz(log2))
			log2[i] = log2[i / 2] + 1;
		hs.assign(log2.back() + 1, vector<int>(2 * n, INF));

		tin.assign(n, 0);
		T = 0;

		dfs(0, -1, 0);
		assert(T < 2 * n);

		fore (pw, 0, sz(hs) - 1) {
			fore (i, 0, T - (1 << pw))
				hs[pw + 1][i] = min(hs[pw][i], hs[pw][i + (1 << pw)]);
		}
	}

	int getMin(int u, int v) {
		if (tin[u] > tin[v])
			swap(u, v);
		int len = log2[tin[v] + 1 - tin[u]];
		int d = min(hs[len][tin[u]], hs[len][tin[v] + 1 - (1 << len)]);
//		cerr << u << " " << v << ": " << d << endl;
		return d;
	}
	inline int getH(int v) {
		return hs[0][tin[v]];
	}
} lcaST;

int getFarthest(int s) {
	vector<int> used(n, 0);
	queue<int> q;

	used[s] = 1;
	q.push(s);
	int v;
	while (!q.empty()) {
		v = q.front(); 
		q.pop();
		for (int to : g[v]) {
			if (used[to])
				continue;
			used[to] = 1;
			q.push(to);
		}
	}
	return v;
}

int getDist(int u, int v) {
	return lcaST.getH(u) + lcaST.getH(v) - 2 * lcaST.getMin(u, v);
}

const int M = int(2e5);
vector<pt> ops[4 * M];

void setOp(int v, int l, int r, int lf, int rg, const pt &op) {
	if (l >= r || lf >= rg) return;
	if (l == lf && r == rg) {
		ops[v].push_back(op);
		return;
	}
	int mid = (l + r) / 2;
	if (lf < mid)
		setOp(2 * v + 1, l, mid, lf, min(mid, rg), op);
	if (rg > mid)
		setOp(2 * v + 2, mid, r, max(lf, mid), rg, op);
}

void updDiam(int &s, int &t, int &curD, const pt &op) {
	int v = op.x;
	a[v] = op.y;

	int ns = s, nt = t, nD = curD;

	vector<pt> cds = {{s, v}, {v, t}, {v, v}};
	for (auto &c : cds) {
		int d1 = getDist(c.x, c.y);
		if (nD < a[c.x] + d1 + a[c.y]) {
			nD = a[c.x] + d1 + a[c.y];
			ns = c.x, nt = c.y;
		}
	}
	s = ns;
	t = nt;
	curD = nD;
}

vector<int> ans;

void calcDiams(int v, int l, int r, int s, int t, int curD) {
	for (auto &op : ops[v])
		updDiam(s, t, curD, op);
	if (r - l > 1) {
		int mid = (l + r) / 2;
		calcDiams(2 * v + 1, l, mid, s, t, curD);
		calcDiams(2 * v + 2, mid, r, s, t, curD);
	}
	else
		ans[l] = (curD + 1) / 2;
	
	for (auto &op : ops[v])
		a[op.first] = 0;
}

inline void solve() {
	lcaST.init();
	int s = getFarthest(0);
	int t = getFarthest(s);

	int m;
	cin >> m;
	vector<int> lst(n, 0);
	fore (i, 0, m) {
		int v, x;
		cin >> v >> x;
		v--;

		setOp(0, 0, m, lst[v], i, {v, a[v]});
		lst[v] = i;
		a[v] = x;
	}
	fore (v, 0, n)
		setOp(0, 0, m, lst[v], m, {v, a[v]});

	ans.resize(m, -1);
	a.assign(n, 0);
	calcDiams(0, 0, m, s, t, getDist(s, t));

	fore (i, 0, m)
		cout << ans[i] << '\n';
}

int main() {
#ifdef _DEBUG
	freopen("input.txt", "r", stdin);
	int tt = clock();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(15);
	
	if(read()) {
		solve();
		
#ifdef _DEBUG
		cerr << "TIME = " << clock() - tt << endl;
		tt = clock();
#endif
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1783F
Editorial Content:
1783F - Double Sort II
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

const int N = 5043;

vector<int> g[N];
int mt[N];
int u[N];
vector<vector<int>> cycle[2];
vector<int> a[2];
int n;
int vs[2];
vector<vector<int>> inter;

bool kuhn(int x)
{
    if(u[x]) return false;
    u[x] = true;
    for(auto y : g[x])
    {
        if(mt[y] == x) continue;
        if(mt[y] == -1 || kuhn(mt[y]))
        {
            mt[y] = x;
            return true;
        }
    }
    return false;
}

int find_intersection(const vector<int>& x, const vector<int>& y)
{
    for(auto i : x)
        for(auto j : y)
            if(i == j)
                return i;
    return -1;
}

int main()
{
    scanf("%d", &n);
    for(int k = 0; k < 2; k++)
    {
        a[k].resize(n);
        for(int j = 0; j < n; j++)
        {
            scanf("%d", &a[k][j]);
            a[k][j]--;
        }    
    }

    for(int k = 0; k < 2; k++)
    {
        vector<bool> used(n);
        for(int i = 0; i < n; i++)
        {
            if(used[i]) continue;
            vector<int> cur;
            int j = i;
            while(!used[j])
            {
                cur.push_back(j);
                used[j] = true;
                j = a[k][j];            
            }
            cycle[k].push_back(cur);
        }
        vs[k] = cycle[k].size();
    }

    inter.resize(vs[0], vector<int>(vs[1]));

    for(int i = 0; i < vs[0]; i++)
        for(int j = 0; j < vs[1]; j++)
        {
            inter[i][j] = find_intersection(cycle[0][i], cycle[1][j]);
            if(inter[i][j] != -1)
                g[i].push_back(j);
        }

    for(int i = 0; i < vs[1]; i++)
        mt[i] = -1;
    for(int i = 0; i < vs[0]; i++)
    {
        for(int j = 0; j < vs[0]; j++)
            u[j] = false;
        kuhn(i);
    }
    
    set<int> res;
    for(int i = 0; i < n; i++) res.insert(i);
    for(int i = 0; i < vs[1]; i++)
        if(mt[i] != -1)
            res.erase(inter[mt[i]][i]);

    printf("%d\n", res.size());
    for(auto x : res) printf("%d ", x + 1);
    puts("");
}
--------------------------------------------------
Problem ID: 1783E
Editorial Content:
1783E - Game of the Year
Tutorial
Tutorial is loading...
Solution (BledDest)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;


int main() {
	int t;
	scanf("%d", &t);
	while (t--){
		int n;
		scanf("%d", &n);
		vector<int> a(n), b(n);
		forn(i, n) scanf("%d", &a[i]);
		forn(i, n) scanf("%d", &b[i]);
		vector<int> dx(n + 1);
		forn(i, n) if (b[i] < a[i]){
			++dx[b[i]];
			--dx[a[i]];
		}
		forn(i, n) dx[i + 1] += dx[i];
		vector<int> ans;
		for (int k = 1; k <= n; ++k){
			bool ok = true;
			for (int nk = k; nk <= n; nk += k)
				ok &= dx[nk] == 0;
			if (ok)
				ans.push_back(k);
		}
		printf("%d\n", int(ans.size()));
		for (int k : ans) printf("%d ", k);
		puts("");
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1783D
Editorial Content:
1783D - Different Arrays
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

const int MOD = 998244353;

int add(int x, int y)
{
    x += y;
    while(x >= MOD) x -= MOD;
    while(x < 0) x += MOD;
    return x;
}   

const int ZERO = 100000;

int dp[2][ZERO * 2];

void recalc(int x)
{
    for(int i = 0; i < ZERO * 2; i++)
        dp[1][i] = 0;

    for(int i = 0; i < ZERO * 2; i++)
    {
        if(dp[0][i] == 0) continue;
        int nx = x + i;
        dp[1][nx] = add(dp[1][nx], dp[0][i]);
        if(nx != ZERO)
            dp[1][2 * ZERO - nx] = add(dp[1][2 * ZERO - nx], dp[0][i]);
    }

    for(int i = 0; i < ZERO * 2; i++)
        dp[0][i] = dp[1][i];
}

int main()
{
    int n;
    cin >> n;
    vector<int> a(n);
    for(int i = 0; i < n; i++)
        cin >> a[i];
    dp[0][ZERO] = 1;
    for(int i = 1; i + 1 < n; i++)
        recalc(a[i]);
    int ans = 0;
    for(int i = 0; i < ZERO * 2; i++)
        ans = add(ans, dp[0][i]);
    cout << ans << endl;
}
--------------------------------------------------
Problem ID: 1783C
Editorial Content:
1783C - Yet Another Tournament
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int t;
  cin >> t;
  while (t--) {
    int n, m;
    cin >> n >> m;
    vector<int> a(n);
    for (auto &x : a) cin >> x;
    auto b = a;
    sort(b.begin(), b.end());
    int ans = 0;
    for (int i = 0; i < n && b[i] <= m; ++i) {
      m -= b[i];
      ++ans;
    }
    if (ans != 0 && ans != n && m + b[ans - 1] >= a[ans]) ++ans;
    cout << n + 1 - ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1783B
Editorial Content:
1783B - Matrix of Differences
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

#define forn(i, n) for (int i = 0; i < int(n); ++i)

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    vector<vector<int>> a(n, vector<int>(n));
    int l = 1, r = n * n, t = 0;
    forn(i, n) {
      forn(j, n) {
        if (t) a[i][j] = l++;
        else a[i][j] = r--;
        t ^= 1;
      }
      if (i & 1) reverse(a[i].begin(), a[i].end());
    }
    forn(i, n) forn(j, n) cout << a[i][j] << " \n"[j == n - 1];
  }
}
--------------------------------------------------
Problem ID: 1783A
Editorial Content:
1783A - Make it Beautiful
Tutorial
Tutorial is loading...
Solution (BledDest)
t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if a[0] == a[n - 1]:
        print('NO')
    else:
        print('YES')
        print(a[n - 1], end = ' ')
        print(*(a[0:n-1]))
--------------------------------------------------
Problem ID: 1781H2
Editorial Content:

--------------------------------------------------
Problem ID: 1781H1
Editorial Content:

--------------------------------------------------
Problem ID: 1781G
Editorial Content:

--------------------------------------------------
Problem ID: 1781F
Editorial Content:

--------------------------------------------------
Problem ID: 1781E
Editorial Content:

--------------------------------------------------
Problem ID: 1781D
Editorial Content:

--------------------------------------------------
Problem ID: 1781C
Editorial Content:

--------------------------------------------------
Problem ID: 1781B
Editorial Content:

--------------------------------------------------
Problem ID: 1781A
Editorial Content:

--------------------------------------------------
Problem ID: 1780G
Editorial Content:
1780G - Delicious Dessert
Tutorial
This problem has several solutions using different suffix structures. We will tell two of them — using suffix array, and using suffix automaton.
Suffix array (t4m0fey)
Let's build suffix array $$$suf$$$ and array $$$lcp$$$ (largest common prefixes) on the string $$$s$$$. Fix some $$$k > 1$$$ и consider about all substring $$$s$$$ length $$$k$$$. Match $$$1$$$ to positions $$$i$$$ array $$$lcp$$$, such that $$$lcp_i \geq k$$$, and match $$$0$$$ to other positions. One in position $$$i$$$ means that the substrings length $$$k$$$ starting at $$$suf_i$$$ and $$$suf_{i + 1}$$$ are equal. Consider any block of units length $$$len$$$, then for $$$len + 1$$$ substrings length $$$k$$$ number of occurrences in $$$s$$$ — $$$len + 1$$$, then in order for the substrings in this block to be delicious, it is necessary that $$$len + 1$$$ divided by $$$k$$$.
Let's brute $$$k$$$ from $$$n$$$ to $$$2$$$ и sustain all sizes blocks. Then, when shift to a new $$$k$$$ should events — change $$$0$$$ to $$$1$$$, for all $$$i$$$, such that $$$lcp_i = k$$$. To do this you can sustain DSU (Disjoint set union). Then for each block size we know the number of blocks with this size. Then it is enough to consider all blocks of length $$$len$$$, such as $$$len + 1$$$ — divider $$$k$$$. It can be done explicitly, just brute $$$k$$$, $$$2 \cdot k$$$, ..., as $$$len + 1$$$. And this works in sum of harmonic series: $$${\sum_{k = 2}^{n} \lfloor \frac{n}{k} \rfloor}$$$ $$$= O(n \cdot log(n))$$$.
For $$$k = 1$$$, obviously, any substring length $$$1$$$ satisfies, so you can just add $$$n$$$ to the answer.
Overall time complexity is $$$O(n \cdot log(n))$$$.
Suffix automaton (AndreyPavlov)
The solution with the suffix automaton is as follows: let's build the suffix automaton itself, now we calculate for each vertex of the suffix automaton the dynamics $$$dp_v$$$ — this is the number of paths from the vertex $$$v$$$ to the terminal vertices. This dynamics means the number of occurrences of the substring corresponding to this vertex in the entire string. Let's introduce the function $$$f(v)$$$ — the length of the longest substring leading to the vertex $$$v$$$. We know that all substrings of length from $$$l_v$$$ to $$$r_v$$$ lead to the vertex $$$v$$$ of the suffix automaton — each once. Where $$$r_v = f(v)$$$ and $$$l_v = f(suff_v) + 1$$$, where $$$suff_v$$$ is the suffix link of $$$v$$$. Why is it so? All substrings of the form $$$s[x:k], s[x+1:k], ..., s[y:k]$$$ lead to the vertex $$$v$$$ of the suffix automaton, and there is a suffix link $$$suff_v$$$ to which lead all substrings of the form $$$s[x + 1:k], s[y + 2:k], ..., s[t: k]$$$.
In order to solve the problem, let's go through the $$$v$$$ vertex and look at the number of occurrences of any substring that leads to the $$$v$$$ — $$$dp_v$$$ vertex, then fix $$$c$$$ — the number of such $$$l_v \le x \le r_v$$$, that $$$dp_v$$$ is evenly divisible by $$$x$$$. Therefore, $$$dp_v \cdot c$$$ must be added to the answer. All divisors can be stored in $$$O(n \cdot log(n))$$$ and each time find the number of such $$$x$$$ by binsearch.
Asymptotics $$$O(n \cdot log(n))$$$
Suffix array (t4m0fey)
Let's build suffix array $$$suf$$$ and array $$$lcp$$$ (largest common prefixes) on the string $$$s$$$. Fix some $$$k > 1$$$ и consider about all substring $$$s$$$ length $$$k$$$. Match $$$1$$$ to positions $$$i$$$ array $$$lcp$$$, such that $$$lcp_i \geq k$$$, and match $$$0$$$ to other positions. One in position $$$i$$$ means that the substrings length $$$k$$$ starting at $$$suf_i$$$ and $$$suf_{i + 1}$$$ are equal. Consider any block of units length $$$len$$$, then for $$$len + 1$$$ substrings length $$$k$$$ number of occurrences in $$$s$$$ — $$$len + 1$$$, then in order for the substrings in this block to be delicious, it is necessary that $$$len + 1$$$ divided by $$$k$$$.
Let's brute $$$k$$$ from $$$n$$$ to $$$2$$$ и sustain all sizes blocks. Then, when shift to a new $$$k$$$ should events — change $$$0$$$ to $$$1$$$, for all $$$i$$$, such that $$$lcp_i = k$$$. To do this you can sustain DSU (Disjoint set union). Then for each block size we know the number of blocks with this size. Then it is enough to consider all blocks of length $$$len$$$, such as $$$len + 1$$$ — divider $$$k$$$. It can be done explicitly, just brute $$$k$$$, $$$2 \cdot k$$$, ..., as $$$len + 1$$$. And this works in sum of harmonic series: $$${\sum_{k = 2}^{n} \lfloor \frac{n}{k} \rfloor}$$$ $$$= O(n \cdot log(n))$$$.
For $$$k = 1$$$, obviously, any substring length $$$1$$$ satisfies, so you can just add $$$n$$$ to the answer.
Overall time complexity is $$$O(n \cdot log(n))$$$.
Suffix automaton (AndreyPavlov)
The solution with the suffix automaton is as follows: let's build the suffix automaton itself, now we calculate for each vertex of the suffix automaton the dynamics $$$dp_v$$$ — this is the number of paths from the vertex $$$v$$$ to the terminal vertices. This dynamics means the number of occurrences of the substring corresponding to this vertex in the entire string. Let's introduce the function $$$f(v)$$$ — the length of the longest substring leading to the vertex $$$v$$$. We know that all substrings of length from $$$l_v$$$ to $$$r_v$$$ lead to the vertex $$$v$$$ of the suffix automaton — each once. Where $$$r_v = f(v)$$$ and $$$l_v = f(suff_v) + 1$$$, where $$$suff_v$$$ is the suffix link of $$$v$$$. Why is it so? All substrings of the form $$$s[x:k], s[x+1:k], ..., s[y:k]$$$ lead to the vertex $$$v$$$ of the suffix automaton, and there is a suffix link $$$suff_v$$$ to which lead all substrings of the form $$$s[x + 1:k], s[y + 2:k], ..., s[t: k]$$$.
In order to solve the problem, let's go through the $$$v$$$ vertex and look at the number of occurrences of any substring that leads to the $$$v$$$ — $$$dp_v$$$ vertex, then fix $$$c$$$ — the number of such $$$l_v \le x \le r_v$$$, that $$$dp_v$$$ is evenly divisible by $$$x$$$. Therefore, $$$dp_v \cdot c$$$ must be added to the answer. All divisors can be stored in $$$O(n \cdot log(n))$$$ and each time find the number of such $$$x$$$ by binsearch.
Asymptotics $$$O(n \cdot log(n))$$$
Implementation (t4m0fey)
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

vector<int> suffix_array(string s){
    int n = s.size();
    vector<int> a(n), c(n), h(n);
    vector<pair<char, int>> t;
    for (int i = 0; i < n; i++) t.push_back({s[i], i});
    sort(t.begin(), t.end());
    int cur = -1;
    for (int i = 0; i < n; i++){
        if (i == 0 || t[i].first != t[i - 1].first){
            cur++;
            h[cur] = i;
        }
        a[i] = t[i].second;
        c[a[i]] = cur;
    }
    vector<int> a1(n), c1(n);
    for (int len = 1; len < n; len *= 2){
        for (int i = 0; i < n; i++){
            int j = (n + a[i] - len) % n;
            a1[h[c[j]]++] = j;
        }
        a = a1;
        cur = -1;
        for (int i = 0; i < n; i++){
            if (i == 0 || c[a[i]] != c[a[i - 1]] || c[(a[i] + len) % n] != c[(a[i - 1] + len) % n]){
                cur++;
                h[cur] = i;
            }
            c1[a[i]] = cur;
        }
        c = c1;
    }
    return a;
}
vector<int> build_lcp(string s, vector<int> suf){
    int n = s.size();
    vector<int> rsuf(n), lcp(n);
    for (int i = 0; i < n; i++) rsuf[suf[i]] = i;
    int cur = 0;
    for (int i = 0; i < n; i++){
        int j = rsuf[i];
        if (j != n - 1){
            while (s[suf[j] + cur] == s[suf[j + 1] + cur]) cur++;
            lcp[j] = cur;
        }
        if (cur > 0) cur--;
    }
    return lcp;
}
const int N = 1e6 + 1;
int r[N], l[N], us[N], cnt[N];
vector<int> pos[N];

int main() {
    ios::sync_with_stdio(false), cin.tie(0);
    int n;
    cin >> n;
    string s;
    cin >> s;
    s += '$';
    vector<int> suf = suffix_array(s);
    vector<int> lcp = build_lcp(s, suf);
    for (int i = 0; i < lcp.size(); i++) {
        pos[lcp[i]].push_back(i);
    }
    ll ans = n;
    for (int k = n; k >= 2; k--) {
        for (int i : pos[k]) {
            // add i
            us[i] = true;
            cnt[1]++;
            l[i] = r[i] = i;
            if (i != 0 && us[i - 1]) {
                cnt[i - l[i - 1]]--;
                cnt[1]--;
                cnt[i - l[i - 1] + 1]++;
                l[i] = l[i - 1];
                r[l[i - 1]] = i;
            }
            if (i + 1 < lcp.size() && us[i + 1]) {
                cnt[r[i + 1] - i]--;
                cnt[i - l[i] + 1]--;
                cnt[r[i + 1] - l[i] + 1]++;
                l[r[i + 1]] = l[i];
                r[l[i]] = r[i + 1];
            }
        }
        for (int x = k; x <= n; x += k) {
            ans += 1ll * x * cnt[x - 1];
        }
    }
    cout << ans << "\n";
}
Implementation (AndreyPavlov)
/* Includes */
#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>

/* Using libraries */
using namespace std;

/* Defines */
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define ld long double
#define pb push_back
#define vc vector
#define sz(a) (int)a.size()
#define forn(i, n) for (int i = 0; i < n; ++i)
#define pii pair <int, int>
#define vec pt
#define all(a) a.begin(), a.end()

const int K = 26;
const int N = 1e6 + 1;

struct node {
    int next[K];
    int suf = -1, pr = -1, dp = 0, len = 0, ch = -1;
    node () {
        forn (i, K) next[i] = -1;
    }
};

int get (char c) {
    if (c >= 'a')
        return c - 'a';
    return c - 'A';
}

int lst = 0, sz = 1;
node t[N * 2];
int used[N * 2];

int add (int a, int x) {
    int b = sz++;
    t[b].pr = a;
    t[b].suf = 0;
    t[b].ch = x;
    for (; a != -1; a = t[a].suf) {
        if (t[a].next[x] == -1) {
            t[a].next[x] = b;
            t[b].len = max(t[b].len, t[a].len + 1);
            continue;
        }
        int c = t[a].next[x];
        if (t[c].pr == a) {
            t[b].suf = c;
            break;
        }
        int d = sz++;
        forn (i, K) t[d].next[i] = t[c].next[i];
        t[d].suf = t[c].suf;
        t[c].suf = t[b].suf = d;
        t[d].pr = a;
        t[d].ch = x;
        for (; a != -1 && t[a].next[x] == c; a = t[a].suf) {
            t[a].next[x] = d;
            t[d].len = max(t[d].len, t[a].len + 1);
        }
        break;
    }
    return b;
}

void add (char c) {
    lst = add(lst, get(c));
}

void dfs (int u) {
    used[u] = 1;
    for (int i = 0; i < K; ++i) {
        if (t[u].next[i] == -1) continue;
        int v = t[u].next[i];
        if (!used[v])
            dfs(v);
        t[u].dp += t[v].dp;
    }
}

vc <int> p[N], pr;
int dr[N];
vc <pii> d;
int l, r, cur = 0;

int cnt_log (int x, int y) {
    int z = 1, res = 0;
    while (y >= z) {
        z *= x;
        ++res;
    }
    return res - 1;
}

void rec (int i, int x) {
    if (i == sz(d)) {
        cur += l <= x;
        return;
    }
    rec(i + 1, x);
    for (int j = 1; j <= d[i].second; ++j) {
        x *= d[i].first;
        if (x > r)
            break;
        rec(i + 1, x);
    }
}

void solve () {
    int n;
    cin >> n;
    string s;
    cin >> s;
    for (char c : s)
        add(c);
    for (int a = lst; a != -1; a = t[a].suf)
        t[a].dp = 1;
    dfs(0);
    for (int i = 2; i <= n; ++i) {
        if (dr[i] == 0) {
            dr[i] = i;
            pr.pb(i);
        }
        for (int j = 0; j < sz(pr) && pr[j] <= dr[i] && i * pr[j] <= n; ++j)
            dr[i * pr[j]] = pr[j];
    }
    long long ans = 0;
    forn (i, sz) {
        if (t[i].len == 0) continue;
        l = t[t[i].suf].len + 1;
        r = t[i].len;
        int x = t[i].dp;
        d.clear();
        while (x > 1) {
            int y = dr[x];
            if (d.empty() || d.back().first != y)
                d.pb({y, 1});
            else
                d.back().second++;
            x /= y;
        }
        rec(0, 1);
        ans += t[i].dp * cur;
        cur = 0;
    }
    cout << ans << '\n';
}

/* Starting and precalcing */
signed main() {
    /* freopen("input.txt","r",stdin);freopen("output.txt","w",stdout); */
    fast;
    int t = 1;
    // cin >> t;
    while (t--) solve();
    return 0;
}
--------------------------------------------------
Problem ID: 1780F
Editorial Content:
1780F - Three Chairs
Tutorial
Let's sort the array and process the triples $$$i, j, k$$$, assuming that $$$i < j < k$$$ and $$$a_i < a_j < a_k$$$. Now if $$$\gcd(a_i, a_k) = 1$$$, then the number of ways to take the index $$$j$$$ is $$$k - i - 1$$$.
We will consider the answer to the problem for each $$$k$$$ from $$$1$$$ to $$$n$$$, assuming that $$$a_k$$$ is the maximum number in the triple. Now let $$$c$$$ be the number of numbers that are mutually prime with $$$a_k$$$ on the prefix from $$$1$$$ to $$$k - 1$$$, and $$$sum$$$ is the sum of their indices. Then you need to add $$$c\cdot i - sum - c$$$ to the answer.
It remains to find out the number of numbers that are mutually prime with $$$a_k$$$ and the sum of their indices. This can be done using the inclusion and exclusion method. Let $$$cnt_i$$$ be the number of numbers $$$a_j$$$ that are divisible by $$$i$$$, $$$s_i$$$ be the sum of the indices $$$j$$$ of numbers $$$a_j$$$ that are divisible by $$$i$$$. Let's look at the prime numbers $$$p_1, p_2, ..., p_m$$$ included in the factorization of the number $$$a_k$$$.
Then let $$$c$$$ initially be equal to the number of numbers on the prefix, and $$$sum$$$ to the sum of the indices on the prefix. Note that then we took into account the extra elements — numbers that are divisible by $$$p_1, p_2, ..., p_m$$$, since they will not be mutually simple with $$$a_k$$$, we subtract them from $$$c$$$ and $$$sum$$$. But having done this, we again took into account the extra elements that are multiples of the numbers of the form $$$p_i * p_j$$$, where $$$i \neq j$$$, add them back, etc. So we can iterate over the mask $$$mask$$$ of the primes $$$p_1, p_2, ..., p_m$$$. And depending on the parity of the bits in the mask, we will subtract or add elements that are multiples of $$$d$$$, where $$$d$$$ is the product of the primes included in $$$mask$$$. Having received $$$c$$$ and $$$sum$$$, we can recalculate the answer for the position $$$i$$$.
To move from position $$$i$$$ to position $$$i+1$$$, update the values of $$$cnt$$$ and $$$s$$$ by adding the element $$$a_{i-1}$$$ by iterating over the mask of the simple element $$$a_{i-1}$$$.
Implementation (С++)
#include "bits/stdc++.h"
 
using namespace std;
 
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
 
#define sz(v) ((int)(v).size())
#define all(a) (a).begin(),  (a).end()
#define rall(a) a.rbegin(), a.rend()
#define F first
#define S second
#define pb push_back
#define ppb pop_back
#define eb emplace_back
#define time ((double)clock() / (double)CLOCKS_PER_SEC)
 
using pii = pair<int, int>;
using ll = long long;
using int64 = long long;
using ld = double;
 
const ll infll = (ll) 1e18 + 27;
const ll inf = (ll) 1e9;
 
#define dbg(x) cout << #x << " = " << (x) << endl
 
template<class T>
using pq = priority_queue<T, vector<T>, less<T>>;
template<class T>
using pqr = priority_queue<T, vector<T>, greater<T>>;
 
template<typename T, typename T2>
istream &operator>>(istream &in, pair<T, T2> &b) {
    in >> b.first >> b.second;
    return in;
}
 
template<typename T, typename T2>
ostream &operator<<(ostream &out, const pair<T, T2> &b) {
    out << "{" << b.first << ", " << b.second << "}";
    return out;
}
 
template<typename T>
istream &operator>>(istream &in, vector<T> &b) {
    for (auto &v : b) {
        in >> v;
    }
    return in;
}
 
template<typename T>
ostream &operator<<(ostream &out, vector<T> &b) {
    for (auto &v : b) {
        out << v << ' ';
    }
    return out;
}
 
template<typename T>
ostream &operator<<(ostream &out, deque<T> &b) {
    for (auto &v : b) {
        out << v << ' ';
    }
    return out;
}
 
template<typename T>
void print(T x, string end = "\n") {
    cout << x << end;
}
 
 
template<typename T1, typename T2>
bool chkmin(T1 &x, const T2 &y) { return x > y && (x = y, true); }
 
template<typename T1, typename T2>
bool chkmax(T1 &x, const T2 &y) { return x < y && (x = y, true); }
 
mt19937_64 rng(chrono::high_resolution_clock::now().time_since_epoch().count());
 
const int N = 3e5 + 10;
 
ll s[N];
ll cnt[N];
 
ll d[N][20];
int ptr[N];
bool u[N];
 
ll Cnt = 0;
ll Sum = 0;
 
ll Ans = 0;
 
void Answer (int x, int pos) {
	ll C = Cnt;
	ll X = Sum;
	int K = (1ll << ptr[x]);
	for (int mask = 1; mask < K; mask++) {
		ll k = 1;
		for (int j = 0; j < ptr[x]; j++) {
			if ((mask >> j) & 1) {
				k *= d[x][j];
			}
		}
		int bits = __builtin_popcount(mask);
		int D = k;
		if (bits % 2 == 1) {
			C -= cnt[D];
			X -= s[D];
		} else {
			C += cnt[D];
			X += s[D];
		}
	}
	Ans += C * pos - X;
}
 
void add (int x, int pos) {
	Cnt += 1;
	Sum += pos + 1;
	auto v = d[x];
	int K = (1ll << ptr[x]);
	for (int mask = 1; mask < K; mask++) {
		ll k = 1;
		for (int j = 0; j < ptr[x]; j++) {
			if ((mask >> j) & 1) {
				k *= d[x][j];
			}
		}
		int D = k;
		s[D] += pos + 1;
		cnt[D] += 1;
	}
}
 
void solve() {
	for (int i = 2; i < N; i++) {
		if (!u[i]) {
			for (int j = i; j < N; j += i) {
				u[j] = true;
				d[j][ptr[j]] = i;
				ptr[j]++;
			}
		}
	}
	int n;
	cin >> n;
	vector<int> a(n);
	cin >> a;
	sort(all(a));
	for (int i = 0; i < n; i++) {
		Answer(a[i], i);
		if (i > 0) {
			add(a[i - 1], i - 1);
		}
	}
	cout << Ans << "\n";
}
 
int32_t main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    solve();
    return 0;
}
--------------------------------------------------
Problem ID: 1780E
Editorial Content:
1780E - Josuke and Complete Graph
Tutorial
Let’s fix $$$g$$$ and check that the $$$g$$$ weight edge exists in $$$G'$$$. The first number, which is divided into $$$g$$$, starting with $$$L$$$ — $$$\lceil \frac{L}{g} \rceil \cdot g$$$, and the second — $$$(\lceil \frac{L}{g} \rceil + 1) \cdot g$$$, note that their $$$\gcd$$$ is $$$g$$$, so the edge between these vertices weighs $$$g$$$. If the second number is greater $$$R$$$, the edge with weight $$$g$$$ in the $$$G'$$$ doesn't exist, because on the segment from $$$L$$$ to $$$R$$$ at most one vertex, which is divided by $$$g$$$. That is, we should calculate the number of such $$$g$$$, which is $$$(\lceil \frac{L}{g} \rceil + 1) \cdot g \leq R$$$.
For $$$g \geq L$$$: $$$(\lceil \frac{L}{g} \rceil + 1) \cdot g = 2 \cdot g$$$. Get the upper limit on the $$$g \leq \lfloor \frac{R}{2} \rfloor$$$. That is, all $$$g$$$ on segment from $$$L$$$ to $$$\lfloor \frac{R}{2} \rfloor$$$ occur in the $$$G'$$$ as weight some edge. Add them to the answer.
Look at $$$g < L$$$.
Note that $$$\lceil \frac{L}{g} \rceil$$$ takes a $$$O(\sqrt{L})$$$ of different values. Let's fix some $$$f = \lceil \frac{L}{g} \rceil$$$. Note that $$$f$$$ corresponds to a consecutive segment $$$l \leq g \leq r$$$. Let's brute this segments in ascending order $$$f$$$. Then, if there is a left border $$$l$$$ of the segment, you can find $$$r$$$ either by binary search or by writing the formula. The next left border is $$$r + 1$$$. Then note, if $$$f$$$ is fixed, then $$$(f + 1) \cdot g \leq R$$$ is equivalent to $$$g \leq \lfloor \frac{R}{f + 1} \rfloor$$$. That is, with a fixed segment from $$$l$$$ to $$$r$$$, $$$g$$$ occurs in the $$$G'$$$ as weight some edge if $$$l \leq g \leq min(r, \lfloor \frac{R}{f + 1} \rfloor)$$$. Then brute all these segments and sum up of all good $$$g$$$.
Overall time complexity is $$$O(\sqrt{L})$$$ or $$$O(\sqrt{L} \cdot log(L))$$$.
Implementation (Python)
def solve():
    L, R = map(int, input().split())
    ans = max(0, R // 2 - L + 1)
    left = 1
    while left < L:
        C = (L + left - 1) // left
        right = (L + C - 2) // (C - 1) - 1
        ans += max(0, min(right, R // (C + 1)) - left + 1)
        left = right + 1
    print(ans)
t = int(input())
for test in range(t):
    solve()
Implementation (С++)
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int t;
    cin >> t;
    for (int test_case = 0; test_case < t; test_case++){
        ll L, R;
        cin >> L >> R;
        ll ans = max(0ll, R / 2 - L + 1);
        for (ll left = 1, right; left < L; left = right + 1){
            ll C = (L + left - 1) / left;
            right = (L + C - 2) / (C - 1) - 1;
            ans += max(0ll, min(right, R / (C + 1)) - left + 1);
        }
        cout << ans << '\n';
    }
}
--------------------------------------------------
Problem ID: 1780D
Editorial Content:
1780D - Bit Guessing Game
Tutorial
There are two similar solutions to this problem, we will tell you both.
Tutorial (AndreyPavlov)
Subtract $$$1$$$. What can we say now about the number of units at the beginning of the binary notation of a number? There are exactly $$$cnt - cnt_w + 1$$$, where $$$cnt$$$ is the number of unit bits after subtracting the unit, and $$$cnt_w$$$ is — before subtracting. Now we subtract them, for this we need to subtract the number $$$2^{cnt - cnt_w + 1} - 1$$$ and continue the algorithm. But such an algorithm makes at worst $$$60$$$ requests. To save queries, note that we know the number of units after we remove the units from the beginning, therefore it is useless to make another request for this. Then at the same time, as we remove the units from the beginning, we will immediately subtract the unit. As a result, there will be absolutely no more than $$$cnt$$$ operations, where $$$cnt$$$ is the initial number of single bits in the record of the number $$$n$$$. This number does not exceed $$$O(log_2(n))$$$, in turn, $$$log_2(n)$$$ does not exceed 30, which fits into the restrictions.
Tutorial (qualdoom)
Let $$$ans$$$ be the desired number $$$n$$$, and $$$was$$$ be the initial number of bits in the number $$$n$$$. Let's subtract the powers of two : $$$2^0, 2^1, 2^2, ... 2^ k$$$, while $$$was$$$ it will not become 0. We will support the $$$Shift$$$ flag — whether there was a bit transfer to $$$n$$$ when subtracting any power of two. Suppose we subtracted $$$2^k$$$ at the $$$k$$$th step and the number of bits became equal to $$$cnt_{new}$$$, and before the subtraction was $$$cnt$$$, then consider two cases.
1) $$$cnt - cnt_{new} = 1$$$, then bit $$$k$$$ was included in $$$n$$$ at the $$$k$$$th step, and if $$$Shift = false$$$, then we add to $$$ans$$$ — $$$2^k$$$, since there was no bit transfer, which means bit k is also in the original number, and subtract from $$$was$$$ — $$$1$$$. If $$$Shift = true$$$, then we added this bit during previous operations, and it does not need to be taken into account.
2) $$$cnt - cnt_{new} \neq 1$$$, then we know that the number of bits has not decreased, also that in the number $$$n$$$ there was such a bit $$$m$$$ that $$$2^m > 2^k$$$, and at the same time the bit $$$m$$$ is in $$$n$$$. Moreover, $$$m - k - 1 = cnt_{new} - cnt$$$. So $$$m = k + 1 + cnt_{new} - cnt$$$. Let's add $$$2^m$$$ to the answer, subtract from $$$was$$$ — $$$1$$$ and assign the $$$Shift$$$ flag the value $$$true$$$, since there was a bit transfer.
Thus, we found the initial number $$$n$$$, which is equal to $$$ans$$$, and also made no more than $$$O(log_2(n))$$$ queries, since $$$k\le log_2(n)$$$.
Thus, the solution spends no more than 30 requests, which fits into the limitations of the task.
Tutorial (AndreyPavlov)
Subtract $$$1$$$. What can we say now about the number of units at the beginning of the binary notation of a number? There are exactly $$$cnt - cnt_w + 1$$$, where $$$cnt$$$ is the number of unit bits after subtracting the unit, and $$$cnt_w$$$ is — before subtracting. Now we subtract them, for this we need to subtract the number $$$2^{cnt - cnt_w + 1} - 1$$$ and continue the algorithm. But such an algorithm makes at worst $$$60$$$ requests. To save queries, note that we know the number of units after we remove the units from the beginning, therefore it is useless to make another request for this. Then at the same time, as we remove the units from the beginning, we will immediately subtract the unit. As a result, there will be absolutely no more than $$$cnt$$$ operations, where $$$cnt$$$ is the initial number of single bits in the record of the number $$$n$$$. This number does not exceed $$$O(log_2(n))$$$, in turn, $$$log_2(n)$$$ does not exceed 30, which fits into the restrictions.
Tutorial (qualdoom)
Let $$$ans$$$ be the desired number $$$n$$$, and $$$was$$$ be the initial number of bits in the number $$$n$$$. Let's subtract the powers of two : $$$2^0, 2^1, 2^2, ... 2^ k$$$, while $$$was$$$ it will not become 0. We will support the $$$Shift$$$ flag — whether there was a bit transfer to $$$n$$$ when subtracting any power of two. Suppose we subtracted $$$2^k$$$ at the $$$k$$$th step and the number of bits became equal to $$$cnt_{new}$$$, and before the subtraction was $$$cnt$$$, then consider two cases.
1) $$$cnt - cnt_{new} = 1$$$, then bit $$$k$$$ was included in $$$n$$$ at the $$$k$$$th step, and if $$$Shift = false$$$, then we add to $$$ans$$$ — $$$2^k$$$, since there was no bit transfer, which means bit k is also in the original number, and subtract from $$$was$$$ — $$$1$$$. If $$$Shift = true$$$, then we added this bit during previous operations, and it does not need to be taken into account.
2) $$$cnt - cnt_{new} \neq 1$$$, then we know that the number of bits has not decreased, also that in the number $$$n$$$ there was such a bit $$$m$$$ that $$$2^m > 2^k$$$, and at the same time the bit $$$m$$$ is in $$$n$$$. Moreover, $$$m - k - 1 = cnt_{new} - cnt$$$. So $$$m = k + 1 + cnt_{new} - cnt$$$. Let's add $$$2^m$$$ to the answer, subtract from $$$was$$$ — $$$1$$$ and assign the $$$Shift$$$ flag the value $$$true$$$, since there was a bit transfer.
Thus, we found the initial number $$$n$$$, which is equal to $$$ans$$$, and also made no more than $$$O(log_2(n))$$$ queries, since $$$k\le log_2(n)$$$.
Thus, the solution spends no more than 30 requests, which fits into the limitations of the task.
Implementation (Python)
t = int(input())
def ask (x):
	print('-', x)
	return int(input())
for i in range(t):
	cur = int(input())
	add = 0
	ans = 0
	while cur > 0:
		x = ask(add + 1)
		back = x - cur + 1
		add = 2 ** back - 1
		ans += 2 ** back
		cur = x - back
	print('!', ans)
Implementation (С++)
#include <iostream>
 
using namespace std;
 
int ask (int x) {
    cout << "- " << x << endl;
    if (x == -1)
        exit(0);
    cin >> x;
    return x;
}
 
int main() {
    int t;
    cin >> t;
    while (t--) {
        int cnt;
        cin >> cnt;
        int n = 0;
        int was = 0;
        while (cnt > 0) {
            n += 1;
            int nw = ask(1 + was);
            int back = nw - cnt + 1;
            n += (1 << back) - 1;
            was = (1 << back) - 1;
            cnt = nw - back;
        }
        cout << "! " << n << endl;
    }
}
--------------------------------------------------
Problem ID: 1780B
Editorial Content:
1780B - GCD Partition
Tutorial
Let's note that it doesn't make sense for us to divide into more than $$$k = 2$$$ subsegments. Let's prove it.
Let us somehow split the array $$$a$$$ into $$$m > 2$$$ subsegments : $$$b_1, b_2, \ldots, b_m$$$. Note that $$$\gcd(b_1, b_2, \ldots, b_m) \le \gcd(b_1 + b_2, b_3, \ldots, b_m)$$$, since if $$$b_1$$$ and $$$b_2$$$ were multiples of $$$\gcd(b_1, b_2 , \ldots, b_m)$$$, so $$$b_1 + b_2$$$ is also a multiple of $$$\gcd(b_1, b_2, \ldots, b_m)$$$. This means that we can use $$$b_1 + b_2$$$ instead of $$$b_1$$$ and $$$b_2$$$, and the answer will not worsen, thus it is always beneficial to use no more than $$$k = 2$$$ subsegments.
How to find the answer? Let $$$s$$$ be the sum of the array $$$a$$$. Let's say $$$pref_i = {\sum_{j = 1}^{i} a_j}$$$, then the answer is $$$\max\limits_{1 \le i < n}(\gcd(pref_i, s - pref_i)$$$.
Implementation (Python)
from math import gcd
t = int(input())
for test in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    s = 0
    for i in range(n):
        s += a[i]
    ans = 0
    pref = 0
    for i in range(n - 1):
        pref += a[i]
        ans = max(ans, gcd(pref, s - pref))
    print(ans)
Implementation (С++)
#include <bits/stdc++.h>
using namespace std;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int T = 1;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        long long s = accumulate(a.begin(), a.end(), 0ll), cur = 0;
        long long ans = 1;
        for (int i = 0; i < n - 1; i++) {
            cur += a[i], s -= a[i];
            ans = max(ans, __gcd(s, cur));
        }
        cout << ans << "\n";
    }
}
--------------------------------------------------
Problem ID: 1780A
Editorial Content:
1780A - Hayato and School
Tutorial
Note that there are two variants of which numbers to take to make their amount odd: $$$3$$$ odd number; $$$2$$$ even and $$$1$$$ odd. Let’s save all indices of even and odd numbers into two arrays, and check both cases.
Implementation (Python)
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    odd, even = [], []
    for i in range(n):
        if a[i] % 2 == 0:
            even.append(i + 1)
        else:
            odd.append(i + 1)
    if len(odd) >= 1 and len(even) >= 2:
        print("YES")
        print(odd[0], even[0], even[1])
    elif len(odd) >= 3:
        print("YES")
        print(odd[0], odd[1], odd[2])
    else:
        print("NO")
        
t = int(input())
for test in range(t):
    solve()
Implementation (C++)
#include <bits/stdc++.h>

using namespace std;

int main() {
    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        vector<int> odd, even;
        for (int i = 1; i <= n; i++) {
            int x;
            cin >> x;
            if (x % 2 == 0) {
                even.push_back(i);
            } else {
                odd.push_back(i);
            }
        }
        if (odd.size() >= 3) {
            cout << "YES\n";
            cout << odd[0] << " " << odd[1] << " " << odd[2] << '\n';
        } else if (odd.size() >= 1 && even.size() >= 2) {
            cout << "YES\n";
            cout << odd[0] << " " << even[0] << " " << even[1] << '\n';
        } else {
            cout << "NO\n";
        }
    }
}
--------------------------------------------------
Problem ID: 1779H
Editorial Content:
1779H - Олимпийский тимбилдинг
Hint 1
Try reversing the process.
Hint 2
Start with some multiset $$${ x }$$$ containing only $$$1$$$ element. We will try to make $$$x$$$ an
absolute winner
. Extend it by repeatedly adding subsets of equal sizes to it (which have sum less than or equal to the current one).
Fake Solution
A simple greedy solution is to always extend the current subset with the one which has the maximum sum. This, however, gives
WA
as
100 100 101 98 89 103 103 104 111 680 1 1 1 1 1 2
is a counter-example. (see it for yourself!)
Lemma
Statement: If it is possible to extend some multiset $$$A$$$ to the whole array $$$s$$$, we consider it
winning
. If $$$A \leq B$$$ holds for some subset $$$B$$$, then $$$B$$$ is also
winning
. Here, $$$A \leq B$$$ means that there exists a bijection $$$f\colon A\to B$$$ such that $$$x \leq f(x)$$$ for each $$$x \in A$$$.
Proof: Let $$$A, A_1, A_2, \ldots A_k$$$ be a
winning
sequence of extensions. By definition of $$$A \leq B$$$, we can swap each element of $$$A$$$ with some other element. There are three cases:
If we swap some $$$x \in A$$$ with an element which is already in $$$A$$$, nothing happens.
If we swap some $$$x \in A$$$ with an element which is not in any $$$A_i$$$, the sum of $$$A$$$ increases hence it is also
winning
.
If we swap some $$$x \in A$$$ with an element which is contained in some $$$A_i$$$, the sum of $$$A$$$ increases, the sum of $$$A_i$$$ decreases and the sum of sums of $$$A,A_1, \ldots, A_i$$$ stays the same. The sequence remains winning.
Solution
Special cases of the lemma are subsets of size $$$1$$$. We can conclude that if $$$x$$$ is winning and $$$x \leq y$$$, then so is $$$y$$$. The answer is binary-searchable. Let's work with some fixed $$$s_i = x$$$ from now on. The idea is to maintain a list of current possible
winning
subsets. The motivation of lemma is to exclude subsets which cannot produce the answer.
we can see that $$${ s_j, s_i } \leq { s_{i-1},s_i }$$$ for each $$$j < i-1$$$, hence the only
interesting
subset is $$${ s_{i-1}, s_i }$$$ (we excluded others because if one of them is an answer, then so is $$${ s_{i-1}, s_i }$$$. We will use this without explanation later on).
we extend $$${ s_{i-1}, s_{i} }$$$ further to a subset of size $$$4$$$. There will be at most $$$15$$$ new subsets and it can be proved by using the lemma and two pointers.
extend the current subsets to have size $$$8$$$. And, of course, use the lemma again and exclude unnecessary subsets. Implementing it properly should be fast enough. A fact is that there will be
at most
$$$8000$$$ subsets we have to consider. Although, proving it is not trivial. Consider all subsets of size $$$4$$$ and a partial ordering of them. In our algorithm we have excluded all subsets with large sum and then we excluded all subsets which are less than some other included set. So, the max collection of such subsets is less in size than the max antichain of $$$4$$$-subsets with respect to $$$\leq$$$. Following the theory, a max anti-chain can have size at most $$$\max\limits_{k} f(k)$$$, where $$$f(k)$$$ is the number of $$$4$$$-subsets with indices having sum exactly $$$k$$$. Hard-coding this gives us an approximation of $$$519$$$. This value should be multiplied by $$$15$$$, since we had that many $$$4$$$-subsets to begin with. This is less than $$$8000$$$, which is relatively small.
Extending the $$$8$$$-subsets further sounds like an impossible task. But, greedy finally comes in handy. Every $$$8$$$-subset should be extended with another $$$8$$$-subset which maximizes the sum. It is not hard to see that if an answer exists, then this produces a correct answer too. We are left with solving $$$8$$$-sum in an array of size $$$24$$$. As we need to do this around $$$8000$$$ times, we use the
meet in the middle
approach. It can be done in around $$$2^{12}$$$ operations if merge sort is used (it spares us the "$$$12$$$" factor in $$$12 \cdot 2^{12}$$$).
Summary: Solving the task for $$$n\leq 16$$$ is trivial. Let's fix $$$n=32$$$. Calculating the exact complexity does not make much sense as $$$n$$$ is fixed, but we will calculate the rough number of basic arithmetic operations used. Firstly, a binary search is used, which is $$$\log 32 = 5$$$ operations. Then, we generate $$$8$$$-subsets which can be implemented quickly (but is not trivial). The
meet in the middle
part consumes $$$8000 \cdot 2^{12}$$$ operations. The total number of operations is roughly $$$5 \cdot 8000 \cdot 4096 = 163\,840\,000$$$, which gives us a decent upper bound.
Bonus Problem
Try to construct a strong test against fake greedy solutions :)
--------------------------------------------------
Problem ID: 1779G
Editorial Content:
1779G - Игра века
Hint
Consider the sides of the big triangle. If they have the same orientation (clockwise or counter-clockwise), $$$0$$$ segments have to be inverted since the village is already biconnected.
Solution
If the three sides do not all have the same orientation, inverting some segments is necessary. The following picture represents them (or rather, one case, but every other is analogous).
There are two "major" paths:
$$$A \rightarrow C$$$
$$$A \rightarrow B \rightarrow C$$$
Each road has a "beginning" in one of the paths, hence it is possible to reach every intersection from $$$A$$$. Similarly, $$$C$$$ can be reached from every other intersection. The problem is that $$$C$$$ acts as a tap as it cannot reach anything.
To make the village biconnected, we will make it possible for $$$C$$$ to reach $$$A$$$ by inverting the smallest number of road segments. Intuitively, that will work since for every intersection $$$x$$$ there exists a cycle $$$A \rightarrow x \rightarrow C \rightarrow A$$$. A formal proof is given at the end of this section.
The task is to find a shortest path from $$$C$$$ to $$$A$$$, with edges having weights of $$$0$$$ (its direction is already as desired) and $$$1$$$ (that edge has to be inverted). To implement this in $$$O(n)$$$, one has to notice that we are only interested in the closest road of each direction to the big triangle's side. One can prove that by geometrically looking at the strongly connected components, and maybe some casework is required. But, the implementation is free of boring casework.
Now, it is possible to build a graph with vertices which belong to at least one of the $$$6$$$ roads we take into consideration (there are $$$3$$$ pairs of opposite directions). One can run a $$$0$$$-$$$1$$$ BFS and obtain the shortest path.
This will indeed make the village biconnected as a shortest path does not actually pass through sides $$$A \rightarrow B$$$ and $$$B \rightarrow C$$$ (why would it? it is not optimal making effort to reach it just to invert some unnecessary additional road segments) The shortest path from $$$C$$$ to $$$A$$$ intersects the side $$$A \rightarrow C$$$ though (possibly multiple times), but it can be proved that every intersection on it is reachable from $$$C$$$. Also, sides $$$A \rightarrow B$$$ and $$$B \rightarrow C$$$ are reachable from $$$C$$$ since $$$A$$$ is reachable from $$$C$$$. This means that all sides are reachable by both $$$A$$$ and $$$C$$$, and so is every other intersection.
Bonus Problem
Solve the problem if it is required to process $$$q \leq 10^5$$$ queries: invert a given road (and every segment in it), then print the minimum number of road segments you need to additionally invert to make the village biconnected (and not perform them, they are independent from the queries).
--------------------------------------------------
Problem ID: 1779F
Editorial Content:
1779F - Ксолдовские камни
Hint 1.1
If
XOR
of all stones equals $$$0$$$, then by performing one spell to the root we obtain an answer.
Hint 1.2
Solve the task for
even
$$$n$$$.
Hint 1.3
If $$$n$$$ is
even
, performing a spell to the root guarantees that all nodes will have the same number of stones, meaning that the total
XOR
of the tree is $$$0$$$, thus performing the same spell again makes all nodes have $$$0$$$ stones.
Hint 2.1
Consider
even
and
odd
subtrees. What does a spell do to them?
Hint 2.2
A spell performed to the
odd
subtree does nothing. It does not change the total
XOR
, and it also makes performing a spell to some node in its subtree useless as their
XOR
s would be $$$0$$$ anyway. Thus, we are only interested in
even
subtrees.
Solution
Please refer to the hints as steps. Let's finish the casework:
Let nodes $$$u$$$ and $$$v$$$ have
even
subtrees. And let the spell be performed on $$$u$$$, and then on $$$v$$$ slightly later. Consider the following $$$3$$$ cases:
$$$u$$$ is an ancestor of $$$v$$$; performing a spell on $$$v$$$ does not make sense as its subtree's
XOR
is already $$$0$$$.
$$$v$$$ is an ancestor of $$$u$$$; performing a spell on $$$u$$$ does not make sense either as it will be "eaten" by $$$v$$$ later. More formally, let $$$s_u$$$ be the current
XOR
of $$$u$$$'s subtree. We define $$$s_v$$$ and $$$s_1$$$ analogously. A spell performed on $$$u$$$ sets $$$s_v := s_v \oplus s_u$$$ and $$$s_1 := s_1 \oplus s_u$$$. Later, the spell performed on $$$v$$$ sets $$$s_1 := s_1 \oplus s_v$$$. Notice that the final state of $$$s_1$$$ is the same as if only the spell on $$$v$$$ was performed (since $$$s_u \oplus s_u = 0$$$). This means that the total
XOR
stays the same independent of whether we perform a spell on $$$u$$$ or not.
Neither $$$u$$$ or $$$v$$$ is a parent of the other; this is the only case we are interested in and we will use this as a fact.
We only need to choose some subtrees such that their total
XOR
is equal to the
XOR
of the root. Why? Because after applying the spells to them the total
XOR
becomes $$$0$$$, and that problem has been solved in "Hint 1.1". Of course, each pair of subtrees must satisfy the condition in case $$$3$$$, thus finding the subtrees is possible with dynamic programming and reconstruction. In each node we keep an array of size $$$32$$$ which tells us the possible
XOR
values obtained by performing spells on nodes in its subtree. Transitions are done for each edge, from child to parent, in similar fashion to the knapsack problem, but with
XOR
instead of sums.
Time complexity is $$$O(n A^2)$$$ and memory complexity is $$$O(nA)$$$. It is possible to optimize this, but not necessary.
Bonus Problem
Can you minimize the number of operations?
Bonus Problem Hint
The number of them is $$$\leq 6$$$ (in an optimal case).
--------------------------------------------------
Problem ID: 1779E
Editorial Content:
1779E - Параллельные показательные матчи Ани
Hint
A tournament graph is given. Player $$$i$$$ is a candidate master if for every other player there exists a path from $$$i$$$ to them. Can you find
one
candidate master? (which helps in finding all of them)
Lemma 1
Statement: If player $$$i$$$ has the highest out-degree, then they are a candidate master.
Proof: Let's prove a stronger claim, if player $$$i$$$ has the highest out degree, then they reach every other player in $$$1$$$ or $$$2$$$ edges. Let $$$S_1$$$ be the set of players which are immediately reachable and let $$$S_2$$$ be the set of other players (not including $$$i$$$). Choose some $$$x \in S_2$$$. If $$$x$$$ is not reachable from $$$i$$$, then it has an edge to it as well as to every player in $$$S_1$$$, meaning that the out-degree of $$$x$$$ is at least $$$|S_1|+1$$$. This is a contradiction, since $$$i$$$ has out-degree exactly equal to $$$|S_1|$$$ and the initial condition was for $$$i$$$ to have the highest out-degree. So, every $$$x \in S_2$$$ is reachable by $$$i$$$, which proves the lemma.
Lemma 2
Statement: There exists an integer $$$w$$$ such that player $$$i$$$ is a candidate master if and only if its out-degree is greater than or equal to $$$w$$$.
Proof: Let $$$S_1, S_2, \ldots S_k$$$ represent the strongly connected components (SCC) of the tournament graph, in the topological order ($$$S_1$$$ is the "highest" component, while $$$S_k$$$ is the "lowest"). Since the graph is a tournament, it holds that there exists a directed edge from $$$x$$$ to $$$y$$$ for each $$$x \in S_i$$$, $$$y \in S_j$$$, $$$i<j$$$. We can also conclude that $$$x$$$ has a higher out-degree than $$$y$$$ for each $$$x \in S_i$$$, $$$y \in S_j$$$, $$$i<j$$$. The same holds for $$$i=1$$$, which proves the lemma since $$$S_1$$$ is the set of candidate masters, and also each player in it has
strictly higher
out-degree than every other player not in it.
Solution
For each player, we host a simul which includes every other player (but themselves). This tells us the necessary out-degrees and we can easily find one candidate master (the one with highest out-degree).
The second step is to sort all players by out-degree in non-increasing order and maintain the current $$$w$$$ described in "Lemma 2". Its initial value is the out-degree of player $$$1$$$. As we iterate over players, we host additional simuls: if player $$$i$$$ wins a match against at least one player among $$$1,2, \ldots j$$$ (the set of current candidate masters), then $$$i$$$ is also a candidate master, as well as $$$j+1, j+2, \ldots i-1$$$, we update the set accordingly and eventually decrease $$$w$$$.
The first step requires $$$n$$$ simuls to be hosted, and the same hold for step $$$2$$$. In total, that is $$$2n$$$ simuls (or slightly less, depending on implementation).
Bonus Problem
Solve the task if $$$n-1$$$ simuls are allowed to be hosted.
--------------------------------------------------
Problem ID: 1779D
Editorial Content:
1779D - Борис и его восхитительная прическа
Stupid Hint
If $$$a_i < b_i$$$ for some $$$i$$$, then an answer does
not
exist since a cut cannot make a hair taller.
Hint
If you choose to perform a cut on some segment $$$[l,r]$$$ with a razor of size $$$x$$$, you can "greedily" extend it (decrease $$$l$$$ and increase $$$r$$$) as long as $$$x \geq b_i$$$ for each $$$i$$$ in that segment and still obtain a correct solution.
Solution
There exist some data structures (segment tree, dsu, STL maps and sets, $$$\ldots$$$) ideas, but there is also a simple solution with a STL stack.
Consider $$$a_n$$$ and $$$b_n$$$. If $$$b_n$$$ is greater, the answer is
NO
since it is an impossible case (see "Stupid Hint" section). If $$$a_n$$$ is greater, then a cut on range $$$[l,n]$$$ with a razor of size $$$b_n$$$ has to be performed. Additionally, $$$l$$$ should be as small as possible (see "Hint" section). For each $$$i$$$ in the range, if $$$a_i$$$ becomes exactly equal to $$$b_i$$$, we consider the position $$$i$$$
satisfied
. If $$$a_n$$$ and $$$b_n$$$ are equal, then we simply pop both arrays' ends (we ignore those values as they are already
satisfied
) and we continue our algorithm.
Onto the implementation. We keep track (and count) of each razor size we must use. This can simply be done by putting the corresponding sizes into some container (array or vector) and checking at the end whether it is a subset of $$$x_1,x_2,\ldots x_m$$$ (the input array of allowed razors). To do this, one can use sorting or maps. This part works in $$$O(n \log n + m \log m)$$$ time.
Implementing cuts is more challenging, though. To do this, we keep a monotone stack which represents all cuts which are valid until "now" (more formally, all cuts with their $$$l$$$ being $$$\leq i$$$, and the value of $$$l$$$ will be determined later). The top of the stack will represent the smallest razor, and the size of razors does
not decrease
as we pop it. So, we pop the stack as long as the top is smaller than $$$b_n$$$ (since performing an operation which makes $$$a_i$$$ less than $$$b_i$$$ is not valid). After this, if the new top is exactly equal to $$$b_n$$$ we can conclude that we have satisfied $$$a_n = b_n$$$ with some previous cut and we simply continue our algorithm. Otherwise, we add $$$b_n$$$ to the stack as a cut must be performed. This part works in $$$O(n + m)$$$ time.
Total complexity is $$$O(n \log n + m \log m)$$$ because of sorting/mapping.
Bonus Problem
Solve the task in $$$O(n+m)$$$ total complexity.
--------------------------------------------------
Problem ID: 1779C
Editorial Content:
1779C - Наименьшая префиксная сумма
Hint 1
Try a greedy approach.
Hint 2
What data structure supports inserting an element, finding the maximum and erasing the maximum? That is right, a binary heap, or STL
priority_queue
.
Solution
Let $$$p_i = a_1 + a_2 + \ldots a_i$$$ and suppose that $$$p_x < p_m$$$ for some $$$x < m$$$. Let $$$x$$$ be the greatest such integer. Performing an operation to any element in the segment $$$[1,x]$$$ does nothing since $$$p_m - p_x$$$ stays the same. Similarly, performing an operation to any element in segment $$$[m+1,n]$$$ does not affect it.
A greedy idea is to choose the maximal element in segment $$$[x+1,m]$$$ and perform an operation on it, because it decreases $$$p_m$$$ as much as possible. Repeat this process until $$$p_m$$$ eventually becomes less than or equal to $$$p_x$$$. It might happen that a new $$$p_y$$$ such that $$$p_y < p_m$$$ and $$$y<x$$$ emerges. In that case, simply repeat the algorithm until $$$p_m$$$ is less than or equal to any prefix sum in its "left".
Suppose that $$$p_x < p_m$$$ and $$$x > m$$$ now. The idea is the same, choose a minimal element in segment $$$[m+1,x]$$$ and perform an operation on it as it increases $$$p_x$$$ as much as possible. And repeat the algorithm as long as such $$$x$$$ exists.
To implement this, solve the two cases independently. Let's describe the first case as the second one is analogous. Iterate over $$$i$$$ from $$$m$$$ to $$$1$$$ and maintain a priority queue. If $$$p_i < p_m$$$, pop the queue (possibly multiple times) and decrease $$$p_m$$$ accordingly (we simulate performing the "optimal" operations). Notice that one does not have to update any element other than $$$p_m$$$. Add $$$a_i$$$ to the priority queue afterwards.
The time complexity is $$$O(n \log n)$$$.
Bonus Problem
Solve the task for each $$$m=1,2,\ldots, n$$$ i.e. print $$$n$$$ integers: the minimum number of operations required to make $$$a_1 + a_2 + \ldots a_m$$$ a least prefix sum for each $$$m$$$ (the tasks are independent).
--------------------------------------------------
Problem ID: 1779B
Editorial Content:
1779B - Конструктив от MKnez
Hint 1
There always exists an answer for
even
$$$n$$$. Can you find it?
Hint 2
There always exists an answer for
odd
$$$n \geq 5$$$. Can you find it?
Solution
If $$$n$$$ is
even
, the array $$$[-1,1,-1,1, \ldots ,-1,1]$$$ is a solution. The sum of any two adjacent elements is $$$0$$$, as well as the sum of the whole array.
Suppose that $$$n$$$ is
odd
now. Since $$$s_{i-1} + s_i$$$ and $$$s_i + s_{i+1}$$$ are both equal to the sum of the whole array for each $$$i=2,3,\ldots n-1$$$, it must also hold that $$$s_{i-1} + s_i = s_i + s_{i+1}$$$, which is equivalent to $$$s_{i-1} = s_{i+1}$$$. Let's fix $$$s_1 = a$$$ and $$$s_2 = b$$$. The condition above produces the array $$$s = [a,b,a,b, \ldots a,b,a]$$$ (remember that we consider an
odd
$$$n$$$).
Let $$$k$$$ be a positive integer such that $$$n = 2k+1$$$. The sum of any two adjacent elements is $$$a+b$$$ and the sum of the whole array is $$$(k+1)a + kb$$$. Since the two values are equal, we can conclude that $$$ka + (k-1)b = 0$$$. $$$a=k-1$$$ and $$$b=-k$$$ produces an answer. But, we must be careful with $$$a=0$$$ and $$$b=0$$$ since that is not allowed. If $$$k=1$$$ then $$$ka+(k-1)b=0$$$ implies $$$ka=0$$$ and $$$a=0$$$, so for $$$n=2\cdot 1 + 1 = 3$$$ an answer does not exist. Otherwise, one can see that $$$a=k-1$$$ and $$$b=-k$$$ will be non-zero, which produces a valid answer. So, the array $$$[k-1, -k, k-1, -k, \ldots, k-1, -k, k-1]$$$ is an answer for $$$k \geq 2$$$ ($$$n \geq 5$$$).
Bonus Problem
Solve a generalized task with given $$$m$$$ — find an array $$$a_1,a_2, \ldots a_n$$$ ($$$a_i \neq 0$$$) such that $$$a_i + a_{i+1} + \ldots a_{i+m-1}$$$ is equal to the sum of the whole array for each $$$i=1,2,\ldots n-m+1$$$ (or determine that it is impossible to find such array).
--------------------------------------------------
Problem ID: 1779A
Editorial Content:
1779A - Зал славы
Hint
What happens when $$$\texttt{L}$$$ appears after some $$$\texttt{R}$$$ in the string?
Solution
Suppose that there exists an index $$$i$$$ such that $$$s_i = \texttt{R}$$$ and $$$s_{i+1} = \texttt{L}$$$. Lamp $$$i$$$ illuminates trophies $$$i+1,i+2,\ldots n$$$ and lamp $$$i+1$$$ illuminates $$$1,2,\ldots i$$$. We can conclude that all trophies are illuminated if $$$\texttt{L}$$$ appears right after some $$$\texttt{R}$$$. So, strings $$$\texttt{LLRRLL}, \texttt{LRLRLR}, \texttt{RRRLLL}, \ldots$$$ do not require any operations to be performed on them, since they represent configurations of lamps in which all trophies are already illuminated.
Now, we consider the case when such $$$i$$$ does not exist and think about how we can use the operation
once
. Notice that if $$$\texttt{R}$$$ appears right after some $$$\texttt{L}$$$, an operation can be used to transform $$$\texttt{LR}$$$ into $$$\texttt{RL}$$$, and we have concluded before that all trophies are illuminated in that case. So, if $$$\texttt{LR}$$$ appears in the string, we perform the operation on it.
An edge case is when $$$\texttt{L}$$$ and $$$\texttt{R}$$$ are never adjacent (neither $$$\texttt{LR}$$$ nor $$$\texttt{RL}$$$ appears). Notice that $$$s_i = s_{i+1}$$$ must hold for $$$i=1,2,\ldots n-1$$$ in that case, meaning that $$$\texttt{LL} \ldots \texttt{L}$$$ and $$$\texttt{RR} \ldots \texttt{R}$$$ are the only impossible strings for which the answer is $$$-1$$$.
Bonus Problem
Solve the task in which $$$q \leq 10^5$$$ range queries are given: for each segment $$$[l,r]$$$ print the required index $$$l \leq i < r$$$, $$$0$$$ or $$$-1$$$.
--------------------------------------------------
Problem ID: 1778F
Editorial Content:
1778F - Maximizing Root
Tutorial
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
 
const int N = 100005;
const int mod = 998244353;
 
int val[N];
vector<int> g[N];
vector<int> divisor[N];
int subtree_gcd[N], par[N];
 
int dp[N][1003];
int gcdd[1003][1003];
 
inline long long ___gcd(long long a, long long b){
    if(gcdd[a][b]) return gcdd[a][b];
 
    return gcdd[a][b] = __gcd(a, b);
}
 
inline long long lcm(long long a, long long b){
    return (a/___gcd(a, b))*b;
}
 
void dfs(int u, int p){
    par[u] = p;
    subtree_gcd[u] = val[u];
    for(int v: g[u]){
        if(v==p) continue;
        dfs(v, u);
        subtree_gcd[u] = ___gcd(subtree_gcd[u], subtree_gcd[v]);
    }
}
 
 
int solve(int u, int d, int p){
    if(subtree_gcd[u]%d==0) return 0;
    if((val[u]*val[u])%d) return (1<<30);
 
 
    if(dp[u][d]!=-1) return dp[u][d];
    
    long long req = d/___gcd(d, subtree_gcd[u]);
 
    long long res = (1<<30);
    for(int div: divisor[val[u]]){
        if((val[u]*div)%d==0 && d%div==0){
            long long r = 1;
            for(int v: g[u]){
                if(v==p) continue;
                r += solve(v, lcm(d/div, div), u);
            }
            res = min(res, r);
        }
    }
 
    return dp[u][d] = min(res, (1LL<<30));
}
 
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
 
    for(int i = 2; i < 1001; i++){
        for(int j = i; j < 1001; j+=i){
            divisor[j].push_back(i);
        }
    }
 
    int t;
    cin >> t;
 
    while(t--){
        int n, k;
        cin >> n >> k;
 
        for(int i = 0; i <= n; i++){
            g[i].clear();
        }
 
        for(int i = 1; i <= n; i++){
            cin >> val[i];
        }
        
        for(int i = 0; i <= n; i++){
            for(int d: divisor[val[1]]){
                dp[i][d] = -1;
            }
        }
 
        for(int i = 0; i < n-1; i++){
            int u, v;
            cin >> u >> v;
            g[u].push_back(v);
            g[v].push_back(u);
        }
 
        dfs(1, 0);
 
        int ans = val[1];
 
        for(int d: divisor[val[1]]){
            int req = 0;
            int f = 1;
            for(int v: g[1]){
                int x = solve(v, d, par[v]);
                if(x>n) f = 0;
                req += x;
            }
 
            if(!f) continue;
 
            req++;
            if(req<=k){
                ans = max(ans, val[1]*d);
            }
        }
 
        cout << ans << "\n";
    }
    
    return 0;
}
--------------------------------------------------
Problem ID: 1778E
Editorial Content:
1778E - The Tree Has Fallen!
Tutorial
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
 
#define ll long long
#define pb push_back
#define nn '\n'
#define fastio std::ios_base::sync_with_stdio(false); cin.tie(NULL);
 
const int sz = 2e5 + 10, d = 30;
vector <int> g[sz], Tree[sz];
int a[sz], discover_time[sz], finish_time[sz], nodeOf[sz], tim;
 
struct BASIS {
    int basis[d];
    int sz;
 
    void init() {
        for(int i = 0; i < d; i++) basis[i] = 0;
        sz = 0;
    }
 
    void insertVector(int mask) {
        for (int i = d-1; i >= 0; i--) {
            if (((mask>>i)&1) == 0) continue;
 
            if (!basis[i]) {
                basis[i] = mask;
                ++sz;
                return;
            }
            mask ^= basis[i];
        }
    }
 
    void mergeBasis(const BASIS &from) {
        for(int i = d-1; i >= 0; i--) {
            if(!from.basis[i])
                continue;
 
            insertVector(from.basis[i]);
        }
    }
 
    int findMax()  {
        int ret = 0;
        for(int i = d-1; i >= 0; i--) {
            if(!basis[i] || (ret>>i & 1))
                continue;
 
            ret ^= basis[i];
        }
        return ret;
    }
} in[sz], out, pre[sz], suf[sz];
 
void in_dfs(int u, int p)
{
    in[u].insertVector(a[u]);
    discover_time[u] = ++tim;
    nodeOf[tim] = u;
 
    for(auto &v : g[u]) {
        if(v == p)
            continue;
 
        Tree[u].pb(v);
        in_dfs(v, u);
 
        in[u].mergeBasis(in[v]);
    }
    finish_time[u] = tim;
}
 
inline bool in_subtree(int sub_root, int v)
{
    return discover_time[sub_root] <= discover_time[v]
            && finish_time[sub_root] >= finish_time[v];
}
 
int findChildOnPath(int sub_root, int v)
{
    int lo = 0, hi = (int)Tree[sub_root].size()-1;
 
    while(lo <= hi) {
        int mid = lo+hi>>1, node = Tree[sub_root][mid];
 
        if(finish_time[node] < discover_time[v])
            lo = mid + 1;
        else if(discover_time[node] > discover_time[v])
            hi= mid - 1;
        else
            return node;
    }
}
 
void init(int n) {
 
    for(int i = 0; i <= n+5; i++) {
        g[i].clear(), Tree[i].clear();
        in[i].init();
        pre[i].init(), suf[i].init();
    }
    tim = 0;
}
 
int main()
{
    fastio;
 
    int t;
    cin >> t;
 
    while(t--) {
        int n; cin >> n;
 
        init(n);
 
        for(int i = 1; i <= n; i++) cin >> a[i];
 
        for(int i = 1; i < n; i++) {
            int u, v;
            cin >> u >> v;
            g[u].pb(v); g[v].pb(u);
        }
 
        in_dfs(1, -1);
 
        for(int i = 1; i <= n; i++) {
            pre[i].insertVector(a[ nodeOf[i] ]);
            pre[i].mergeBasis(pre[i-1]);
        }
 
        for(int i = n; i >= 1; i--) {
            suf[i].insertVector(a[ nodeOf[i] ]);
            suf[i].mergeBasis(suf[i+1]);
        }
 
        int q; cin >> q;
 
        while(q--) {
            int root, v;
            cin >> root >> v;
 
            if(root == v) {
                cout << in[1].findMax() << nn;
            }
            else if(in_subtree(v, root)) {
                int child = findChildOnPath(v, root);
 
                out.init();
                out.mergeBasis(pre[discover_time[child]-1]);
                out.mergeBasis(suf[finish_time[child]+1]);
                cout << out.findMax() << nn;
            }
            else
                cout << in[v].findMax() << nn;
        }
    }
 
    return 0;
}
--------------------------------------------------
Problem ID: 1778D
Editorial Content:
1778D - Flexible String Revisit
Tutorial
1778D - Flexible String Revisit
Let $$$k$$$ be the number of indices where the characters between two strings are different and $$$f(x)$$$ be the expected number of moves to make two strings equal given that the strings have $$$x$$$ differences. We have to find the value of $$$f(k)$$$.
For all $$$x$$$ where $$$1 \leq x \leq n-1$$$,
$$$ \begin{align} f(x) = \frac{x}{n} \cdot [1 + f(x-1)] + \frac{n-x}{n} \cdot [1 + f(x+1)]\\ or,~~~ f(x) = 1 + \frac{x}{n}\cdot f(x-1) + \frac{n-x}{n} \cdot f(x+1) \end{align} $$$
Now, $$$f(0) = 0$$$ and $$$f(1) = 1 + \frac{n-1}{n}f(2)$$$.
We can represent any $$$f(i)$$$ in the form $$$f(i) = a_i + b_i \cdot f(i+1)$$$.
Let, $$$a_{1} = 1$$$ and $$$b_{1} = \frac{n-1}{n}$$$. So, we can write $$$f(1) = a_{1} + b_{1}\cdot f(2)$$$.
When $$$1 \lt i \lt n$$$, $$$f(i) = 1 + \frac{i}{n} \cdot f(i-1) + \frac{n-i}{n} \cdot f(i+1)$$$. We can substitute the value of $$$f(i-1)$$$ with $$$a_{i-1} + b_{i-1}\cdot f(i)$$$ and calculate the value of $$$f(i)$$$. Thus we can get the value of $$$a_i$$$ and $$$b_i$$$ using the value of $$$a_{i-1}$$$ and $$$b_{i-1}$$$ by considering $$$a_1$$$ and $$$b_1$$$ as the base case.
We get, $$$a_{i} = \frac{n+i\cdot a_{i-1}}{n-i\cdot b_{i-1}}$$$ and $$$b_{i} = \frac{n-i}{n-i \cdot b_{i-1}}$$$ for $$$2 \leq i \leq n$$$.
Calculation
Substituting $$$f(i-1) = a_{i-1} + b_{i-1}\cdot f(i)$$$,
$$$ \begin{align} f(i) & = 1 + \frac{i}{n} \cdot [a_{i-1} + b_{i-1}\cdot f(i)] + \frac{n-i}{n} \cdot f(i+1)\\ & = 1 + \frac{i}{n}\cdot a_{i-1} + \frac{i}{n} \cdot b_{i-1} \cdot f(i) + \frac{n-i}{n} \cdot f(i+1)\\ & = \frac{1+\frac{i}{n}\cdot a_{i-1}}{1-\frac{i}{n}\cdot b_{i-1}} + \frac{n-i}{n-i \cdot b_{i-1}}f(i+1)\\ & = \frac{n+i\cdot a_{i-1}}{n-i\cdot b_{i-1}} + \frac{n-i}{n-i \cdot b_{i-1}}f(i+1)\\ & = a_{i} + b_{i} \cdot f(i+1) \end{align} $$$
So, $$$a_{i} = \frac{n+i\cdot a_{i-1}}{n-i\cdot b_{i-1}}$$$ and $$$b_{i} = \frac{n-i}{n-i \cdot b_{i-1}}$$$ for $$$2 \leq i \leq n$$$.
Similarly, $$$f(n) = 1+f(n-1)$$$.
We can represent any $$$f(i)$$$ in the form $$$f(i) = c_i + d_i \cdot f(i-1)$$$.
Let, $$$c_{n} = 1$$$ and $$$d_{n} = 1$$$. So, we can write $$$f(n) = c_{n} + d_{n}\cdot f(n-1)$$$.
When $$$1 \lt i \lt n$$$, $$$f(i) = 1 + \frac{i}{n} \cdot f(i-1) + \frac{n-i}{n} \cdot f(i+1)$$$. We can substitute the value of $$$f(i+1)$$$ with $$$c_{i+1} + d_{i+1}\cdot f(i)$$$ and calculate the value of $$$f(i)$$$. Thus we can get the value of $$$c_i$$$ and $$$d_i$$$ using the value of $$$c_{i+1}$$$ and $$$d_{i+1}$$$ by considering $$$c_n$$$ and $$$d_n$$$ as the base case.
We get, $$$c_{i} = \frac{n+(n-i)\cdot c_{i+1}}{n-(n-i)\cdot d_{i+1}}$$$ and $$$d_{i} = \frac{i}{n-(n-i) \cdot d_{i+1}}$$$.
Calculation
Substituting $$$f(i+1) = c_{i+1} + d_{i+1}\cdot f(i)$$$,
$$$ \begin{align} f(i) & = 1 + \frac{i}{n} \cdot f(i-1) + \frac{n-i}{n} \cdot [c_{i+1} + d_{i+1}\cdot f(i)]\\ & = 1 + \frac{i}{n}\cdot f(i-1) + \frac{n-i}{n} \cdot c_{i+1} + \frac{n-i}{n} \cdot d_{i+1} \cdot f(i)\\ & = \frac{1+\frac{n-i}{n}\cdot c_{i+1}}{1-\frac{n-i}{n}\cdot d_{i+1}} + \frac{i}{n-(n-i) \cdot d_{i+1}}f(i-1)\\ & = \frac{n+(n-i)\cdot c_{i+1}}{n-(n-i)\cdot d_{i+1}} + \frac{i}{n-(n-i) \cdot d_{i+1}}f(i-1)\\ & = c_{i} + d_{i} \cdot f(i-1) \end{align} $$$
So, $$$c_{i} = \frac{n+(n-i)\cdot c_{i+1}}{n-(n-i)\cdot d_{i+1}}$$$ and $$$d_{i} = \frac{i}{n-(n-i) \cdot d_{i+1}}$$$.
Now, $$$f(i) = c_i + d_i \cdot f(i-1)$$$ and $$$f(i-1) = a_{i-1} + b_{i-1} \cdot f(i)$$$. By solving these two equations, we find that $$$f(i) = \frac{c_i+d_i \cdot a_{i-1}}{1-d_i \cdot b_{i-1}}$$$.
Time Complexity: $$$\mathcal{O}(n\cdot \log m)$$$.
1778D - Flexible String Revisit
Calculation
Substituting $$$f(i-1) = a_{i-1} + b_{i-1}\cdot f(i)$$$,
$$$ \begin{align} f(i) & = 1 + \frac{i}{n} \cdot [a_{i-1} + b_{i-1}\cdot f(i)] + \frac{n-i}{n} \cdot f(i+1)\\ & = 1 + \frac{i}{n}\cdot a_{i-1} + \frac{i}{n} \cdot b_{i-1} \cdot f(i) + \frac{n-i}{n} \cdot f(i+1)\\ & = \frac{1+\frac{i}{n}\cdot a_{i-1}}{1-\frac{i}{n}\cdot b_{i-1}} + \frac{n-i}{n-i \cdot b_{i-1}}f(i+1)\\ & = \frac{n+i\cdot a_{i-1}}{n-i\cdot b_{i-1}} + \frac{n-i}{n-i \cdot b_{i-1}}f(i+1)\\ & = a_{i} + b_{i} \cdot f(i+1) \end{align} $$$
So, $$$a_{i} = \frac{n+i\cdot a_{i-1}}{n-i\cdot b_{i-1}}$$$ and $$$b_{i} = \frac{n-i}{n-i \cdot b_{i-1}}$$$ for $$$2 \leq i \leq n$$$.
Calculation
Substituting $$$f(i+1) = c_{i+1} + d_{i+1}\cdot f(i)$$$,
$$$ \begin{align} f(i) & = 1 + \frac{i}{n} \cdot f(i-1) + \frac{n-i}{n} \cdot [c_{i+1} + d_{i+1}\cdot f(i)]\\ & = 1 + \frac{i}{n}\cdot f(i-1) + \frac{n-i}{n} \cdot c_{i+1} + \frac{n-i}{n} \cdot d_{i+1} \cdot f(i)\\ & = \frac{1+\frac{n-i}{n}\cdot c_{i+1}}{1-\frac{n-i}{n}\cdot d_{i+1}} + \frac{i}{n-(n-i) \cdot d_{i+1}}f(i-1)\\ & = \frac{n+(n-i)\cdot c_{i+1}}{n-(n-i)\cdot d_{i+1}} + \frac{i}{n-(n-i) \cdot d_{i+1}}f(i-1)\\ & = c_{i} + d_{i} \cdot f(i-1) \end{align} $$$
So, $$$c_{i} = \frac{n+(n-i)\cdot c_{i+1}}{n-(n-i)\cdot d_{i+1}}$$$ and $$$d_{i} = \frac{i}{n-(n-i) \cdot d_{i+1}}$$$.
Alternative Solution
After some calculations, it can be shown that $$$f(1) = 2^n - 1$$$. Now we know $$$f(0) = 0$$$ and $$$f(1) = 2^n - 1$$$.
From the relation between $$$f(i)$$$, $$$f(i-1)$$$ and $$$f(i-2)$$$, we can write $$$f(i) = \frac{n\cdot f(i-1) - i \cdot f(i-2) - n}{n-i+1}$$$.
Code
#include <bits/stdc++.h>
using namespace std;

#define mod 998244353 
#define N 1000005
 
template<int MOD>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(sig) {  }
  ModInt(signed long long sig) : x(sig%MOD) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MOD - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<998244353> mint;
 
mint a[N], b[N], c[N], d[N];
 
 
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
 
    int t;
    cin >> t;
    while(t--){
        int n;
        cin >> n;
 
        string s1, s2;
        cin >> s1 >> s2;
 
        int diff = 0;
        for(int i = 0; i < n; i++){
            diff += s1[i]!=s2[i];
        }
 
        c[n] = 1, d[n] = 1, a[1] = 1, b[1] = ((mint) n-1)/n;
 
        for(int i = 2; i <= n; i++){
            a[i] = ((mint) n + a[i-1]*i)/((mint) n - b[i-1]*i);
            b[i] = ((mint) n-i)/((mint) n - b[i-1]*i);
        }
 
        for(int i = n-1; i >= 1; i--){
            c[i] = ((mint) n + c[i+1]*(n-i))/((mint) n - d[i+1]*(n-i));
            d[i] = (mint) i / ((mint) n - d[i+1]*(n-i));
        }
 
        mint ans = (c[diff]+d[diff]*a[diff-1])/((mint) 1 - d[diff]*b[diff-1]);
 
        cout << ans << endl;
    }
 
    return 0;
}
Alternative Code
#include <bits/stdc++.h>
using namespace std;
 
#define ll long long
 
template<int MOD>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(sig) {  }
  ModInt(signed long long sig) : x(sig%MOD) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MOD - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<998244353> mint;
 
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
 
    mint two = 2;
 
    int t;
    cin >> t;
    while(t--){
        int n;
        cin >> n;
 
        string a, b;
        cin >> a >> b;
 
        int cnt = 0;
        for(int i = 0; i < n; i++){
            if(a[i]!=b[i]) cnt++;
        }
 
        vector<mint> dp(n+2);
        dp[0] = two.pow(n);
        dp[1] = dp[0]-1;
        dp[0] = 0;
 
        for(long long i = 2; i < n; i++){
            mint x = i-1;
            x /= n;
            dp[i] = (dp[i-1]-x*dp[i-2]-1)*n/(n-i+1);
        }
 
        dp[n] = dp[n-1]+1;
 
        cout << dp[cnt] << '\n';
    }
 
    return 0;
}
--------------------------------------------------
Problem ID: 1778C
Editorial Content:
1778C - Flexible String
Tutorial
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
 
#define ll long long
#define pb push_back
#define EL '\n'
#define fastio std::ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
 
string a, b;
string char_list;
bool mark[26];
ll ans, k;
 
ll count_matching_pair()
{
    ll tot_pair = 0, match_count = 0;
 
    for(ll i = 0; i < a.size(); i++) {
        if(a[i] == b[i] || mark[ a[i]-'a' ])
            match_count++;
        else {
            tot_pair += match_count*(match_count+1)/2;
            match_count = 0;
        }
    }
    tot_pair += match_count*(match_count+1)/2;
 
    return tot_pair;
}
 
void solve(ll pos, ll cnt)
{
    if(cnt > k) return;
 
    if(pos == char_list.size()) {
        if(cnt == k) ans = max(ans, count_matching_pair());
        return;
    }
 
    solve(pos+1, cnt);
 
    mark[ char_list[pos]-'a' ] = 1;
    solve(pos+1, cnt+1);
    mark[ char_list[pos]-'a' ] = 0;
}
 
int main()
{
    fastio;
    ll t;
    cin >> t;
 
    while(t--) {
        ll n; cin >> n >> k;
        cin >> a >> b;
 
        unordered_set <char> unq;
        for(auto &ch : a) unq.insert(ch);
 
        char_list.clear();
        for(auto &x : unq) char_list.pb(x);
 
        k = min(k, (ll)unq.size());
        memset(mark, 0, sizeof mark);
        ans = 0;
        solve(0, 0);
 
        cout << ans << EL;
    }
 
    return 0;
}
--------------------------------------------------
Problem ID: 1778B
Editorial Content:
1778B - The Forbidden Permutation
Tutorial
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
 
const int sz = 1e5+10;
int p[sz], a[sz], pos[sz];
 
int main()
{
    int t;
    scanf("%d", &t);
 
    while(t--) {
        int n, m, d;
        scanf("%d %d %d", &n, &m, &d);
 
        for(int i = 1; i <= n; i++) {
            scanf("%d", &p[i]);
            pos[ p[i] ] = i;
        }
 
        for(int i = 1; i <= m; i++) {
            scanf("%d", &a[i]);
        }
 
        int ans = 1e9;
 
        for(int i = 1; i < m; i++) {
            if(pos[a[i+1]] <= pos[a[i]] || pos[a[i+1]]-pos[a[i]] > d) {
                ans = 0;
                break;
            }
 
            ans = min(ans, pos[a[i+1]] - pos[a[i]]);
 
            int dist = pos[a[i+1]]-pos[a[i]];
 
            int swapNeed = d-dist+1;
            int swapPossible = (pos[a[i]]-1) + (n - pos[a[i+1]]);
            if(swapPossible >= swapNeed) ans = min(ans, swapNeed);
        }
 
        printf("%d\n", ans);
    }
 
    return 0;
}
--------------------------------------------------
Problem ID: 1778A
Editorial Content:
1778A - Flip Flop Sum
Tutorial
Tutorial is loading...
Code
#include <bits/stdc++.h>
using namespace std;
 
const int sz = 1e5 + 10;
int ara[sz];
 
int main()
{
    int t;
    scanf("%d", &t);
 
    while(t--) {
        int n;
        scanf("%d", &n);
 
        int sum = 0;
 
        for(int i = 1; i <= n; i++) {
            scanf("%d", &ara[i]);
            sum += ara[i];
        }
 
        int ans = -1e9;
 
        for(int i = 1; i < n; i++) {
            if(ara[i] == ara[i+1]) {
                if(ara[i] == 1) ans = max(ans, sum-4);
                else ans = max(ans, sum+4);
            }
            else
                ans = max(ans, sum);
        }
 
        printf("%d\n", ans);
    }
 
    return 0;
}
--------------------------------------------------
Problem ID: 1777F
Editorial Content:
1777F - Comfortably Numb
Hints
Hint 1
Can we somehow fix the maximum element ?
Hint 2
To calculate the answer over all subarrays with the same maximum element, can we use the trie trick for calculating the maximum xor.
Hint 1
Can we somehow fix the maximum element ?
Hint 2
To calculate the answer over all subarrays with the same maximum element, can we use the trie trick for calculating the maximum xor.
Solution
Tutorial is loading...
Implementation (C++)
#include <bits/stdc++.h>
 
using namespace std;
 
struct Trie{
	struct Trie *child[2]={0};
};
typedef struct Trie trie;
 
void insert(trie *dic, int x)
{
	trie *temp = dic;
	for(int i=30;i>=0;i--) 
	{
		int curr = x>>i&1;
		if(temp->child[curr])
			temp = temp->child[curr];
		else
		{
			temp->child[curr] = new trie;
			temp = temp->child[curr];
		}
	}
}
 
int find_greatest(trie *dic, int x) {
	int res = 0;
	trie *temp = dic;
	for(int i=30;i>=0;i--) {
		int curr = x>>i&1;
		if(temp->child[curr^1]) {
			res ^= 1<<i;
			temp = temp->child[curr^1];
		}
		else {
			temp = temp->child[curr];
		}
	}
	return res;	
}
 
int main() {
	int test_cases;
	cin >> test_cases;
	while(test_cases--)
	{
		int n;
		cin>>n;
		int a[n+1];
		for(int i=1;i<=n;i++) {
			cin>>a[i];
		}
 
		trie *t[n+2];
		int prexor[n+1];
		prexor[0] = 0;
		for(int i=1;i<=n;i++) {
			t[i] = new trie;
			insert(t[i], prexor[i-1]);
			prexor[i] = prexor[i-1]^a[i];
		}
		t[n+1] = new trie;
		insert(t[n+1], prexor[n]);
		
		pair<int,int> asc[n+1];
		for(int i=1;i<=n;i++) {
			asc[i] = make_pair(a[i],i);
		}
		sort(asc+1,asc+n+1);
		
		int left[n+1], right[n+1];
		stack<int> s;
		for(int i=1;i<=n;i++) {
			while(!s.empty() && a[i]>=a[s.top()])
				s.pop();
			if(s.empty())
				left[i] = 0;
			else
				left[i] = s.top();
			s.push(i);
		}
		while(!s.empty()) 
			s.pop();
		for(int i=n;i>0;i--) {
			while(!s.empty() && a[i]>a[s.top()])
				s.pop();
			if(s.empty())
				right[i] = n+1;
			else
				right[i] = s.top();
			s.push(i);
		}
		
		int ans = 0;
		for(int i=1;i<=n;i++) {
			int x = asc[i].second;
			int r = right[x]-1;
			int l = left[x]+1;
			if(x-l < r-x) {
				for(int j=l-1;j<x;j++) {
					ans = max(ans, find_greatest(t[x+1], prexor[j]^a[x]));
				}
				t[l] = t[x+1];
				for(int j=l-1;j<x;j++) {
					insert(t[l], prexor[j]);
				}
			}
			else {
				for(int j=x;j<=r;j++) {
					ans = max(ans, find_greatest(t[l], prexor[j]^a[x]));
				}
				for(int j=x;j<=r;j++) {
					insert(t[l], prexor[j]);
				}
			}
		}
		cout<<ans << endl;
	}
}
Feedback
Good problem:
Average problem:
Bad problem:
Did not solve:
--------------------------------------------------
Problem ID: 1777E
Editorial Content:
1777E - Edge Reverse
Hints
Hint 1
If the cost is c, all edges with weight less than or equal to c are reversible.
Hint 2
If an edge can be reversed, can it be treated as bidirectional?
Hint 3
Let there exist a set of possible starting nodes. If this set is non empty, the highest node h in the topological ordering of nodes will always be present in the set. Think why.
Hint 1
If the cost is c, all edges with weight less than or equal to c are reversible.
Hint 2
If an edge can be reversed, can it be treated as bidirectional?
Hint 3
Let there exist a set of possible starting nodes. If this set is non empty, the highest node h in the topological ordering of nodes will always be present in the set. Think why.
Solution
Tutorial is loading...
Implementation (C++)
#include <bits/stdc++.h>
using namespace std;
 
// Using Kosa Raju, we guarantee the topmost element (indicated by root) of stack is from the root SCC
 
void DFS(int v, bool visited[], int &root, vector<int> edges[])
{
    visited[v] = true;
    for (auto it : edges[v])
        if (!visited[it])
            DFS(it, visited, root, edges);
    root = v;
}
 
int cnt(int v, bool visited[], vector<int> edges[])
{
    int ans = 1;
    visited[v] = true;
    for (auto it : edges[v])
        if (!visited[it])
            ans += cnt(it, visited, edges);
    return ans;
}
 
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int T;
    cin >> T;
    while (T--)
    {
        int i, j, n, m, u, v, w;
        cin >> n >> m;
        vector<pair<int, int>> og_edges[n];
        for (i = 0; i < m; i++)
        {
            cin >> u >> v >> w;
            u--, v--;
 
            og_edges[u].push_back({v, w});
        }
 
        int l = -1, r = 1e9 + 1, mid;
        while (r - l > 1)
        {
            mid = l + (r - l) / 2;
 
            vector<int> edges[n];
            for (i = 0; i < n; i++)
            {
                for (auto it : og_edges[i])
                {
                    edges[i].push_back(it.first);
                    if (it.second <= mid)
                        edges[it.first].push_back(i);
                }
            }
 
            bool visited[n] = {};
            int root;
            for (i = 0; i < n; i++)
            {
                if (!visited[i])
                    DFS(i, visited, root, edges);
            }
 
            memset(visited, false, sizeof(visited));
 
            if (cnt(root, visited, edges) == n)
                r = mid;
            else
                l = mid;
        }
 
        if (r == 1e9 + 1)
            r = -1;
        cout << r << '\n';
    }
    return 0;
}
Feedback
Good problem:
Average problem:
Bad problem:
Did not solve:
--------------------------------------------------
Problem ID: 1777D
Editorial Content:
1777D - Score of a Tree
Hints
Hint 1
What would be the value of a node at time $$$t$$$?
Hint 2
The value of a node $$$u$$$ after time $$$t$$$ would be the xor of the initial values of all nodes in the subtree of $$$u$$$ which are at a distance $$$t$$$ from $$$u$$$.
Hint 3
What is the expected value of xor of $$$k$$$ boolean values?
Hint 1
What would be the value of a node at time $$$t$$$?
Hint 2
The value of a node $$$u$$$ after time $$$t$$$ would be the xor of the initial values of all nodes in the subtree of $$$u$$$ which are at a distance $$$t$$$ from $$$u$$$.
Hint 3
What is the expected value of xor of $$$k$$$ boolean values?
Solution
Tutorial is loading...
Implementation (C++)
#include <bits/stdc++.h>
using namespace std;
 
#define MOD 1000000007
 
long long power(long long a, int b)
{
    long long ans = 1;
    while (b)
    {
        if (b & 1)
        {
            ans *= a;
            ans %= MOD;
        }
        a *= a;
        a %= MOD;
        b >>= 1;
    }
    return ans;
}
 
int DFS(int v, vector<int> edges[], int p, int dep, int ped[])
{
    int mdep = dep;
    for (auto it : edges[v])
        if (it != p)
            mdep = max(DFS(it, edges, v, dep + 1, ped), mdep);
    ped[v] = mdep - dep + 1;
    return mdep;
}
 
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int T, i, j, n, u, v;
    cin >> T;
    while (T--)
    {
        cin >> n;
        vector<int> edges[n];
        for (i = 0; i < n - 1; i++)
        {
            cin >> u >> v;
            u--, v--;
 
            edges[u].push_back(v);
            edges[v].push_back(u);
        }
 
        int ped[n];
        DFS(0, edges, 0, 0, ped);
 
        long long p = power(2, n - 1), ans = 0;
        for (i = 0; i < n; i++)
        {
            ans += p * ped[i] % MOD;
            ans %= MOD;
        }
        cout << ans << "\n";
    }
}
Feedback
Good problem:
Average problem:
Bad problem:
Did not solve:
--------------------------------------------------
Problem ID: 1777C
Editorial Content:
1777C - Quiz Master
Hints
Hint 1
Would sorting the array help?
Hint 2
Would iterating over the factors help?
Hint 3
If the optimal team has students with maximum smartness $$$M$$$ and minimum smartness $$$m$$$, would having students with smartness $$$X$$$ such that $$$m \le X \le M$$$ the answer will not change.
Hint 4
Two pointers?
Hint 1
Would sorting the array help?
Hint 2
Would iterating over the factors help?
Hint 3
If the optimal team has students with maximum smartness $$$M$$$ and minimum smartness $$$m$$$, would having students with smartness $$$X$$$ such that $$$m \le X \le M$$$ the answer will not change.
Hint 4
Two pointers?
Solution
Tutorial is loading...
Implementation (C++)
#include <bits/stdc++.h>
#define all(v) v.begin(), v.end()
#define var(x, y, z) cout << x << " " << y << " " << z << endl;
#define ll long long int
#define pii pair<ll, ll>
#define pb push_back
#define ff first
#define ss second
#define FASTIO                \
    ios ::sync_with_stdio(0); \
    cin.tie(0);               \
    cout.tie(0);

using namespace std;

const ll inf = 1e17;
const ll MAXM = 1e5;
vector<ll> factors[MAXM + 5];

void init()
{
    for (ll i = 1; i <= MAXM; i++)
    {
        for (ll j = i; j <= MAXM; j += i)
        {
            factors[j].pb(i);
        }
    }
}

void solve()
{
    ll n, m;
    cin >> n >> m;
    vector<pii> vec;
    for (ll i = 0; i < n; i++)
    {
        ll value;
        cin >> value;
        vec.pb({value, i});
    }
    sort(all(vec));
    vector<ll> frequency(m + 5, 0);
    ll curr_count = 0;
    ll j = 0;
    ll global_ans = inf;
    for (ll i = 0; i < n; i++)
    {
        for (auto x : factors[vec[i].ff])
        {
            if (x > m)
                break;
            if (!frequency[x]++)
            {
                curr_count++;
            }
        }
        while (curr_count == m)
        {
            ll curr_ans = vec[i].ff - vec[j].ff;
            if (curr_ans < global_ans)
            {
                global_ans = curr_ans;
            }
            for (auto x : factors[vec[j].ff])
            {
                if (x > m)
                    break;
                if (--frequency[x] == 0)
                {
                    curr_count--;
                }
            }
            j++;
        }
    }
    cout << (global_ans >= inf ? -1 : global_ans) << "\n";
}

int main()
{
    FASTIO
    init();
    ll t;
    cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}
Feedback
Good problem:
Average problem:
Bad problem:
Did not solve:
--------------------------------------------------
Problem ID: 1777B
Editorial Content:
1777B - Emordnilap
Hints
Hint 1
Will the answer differ for different permutations?
Hint 2
If you only look at 2 elements, how much will they contribute to the answer?
Hint 1
Will the answer differ for different permutations?
Hint 2
If you only look at 2 elements, how much will they contribute to the answer?
Solution
Tutorial is loading...
Implementation (C++)
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
    const int N = 1e5 + 5;
    const int mod = 1e9 + 7;
    vector<int> fact(N);
    fact[0] = 1;
    for(int i = 1; i < N; i++)
    {
        fact[i] = fact[i - 1] * i;
        fact[i] %= mod;
    }
    int t;
    cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        int ans = n * (n - 1);
        ans %= mod;
        ans = (ans * fact[n]) % mod;
        cout << ans << endl;
    }
    return 0;
}
Implementation (Python)
t = int(input())
for _ in range(t):
    n = int(input())
    nf = 1
    mod = int(1e9 + 7)
    for i in range(n):
        nf = nf * (i + 1)
        nf %= mod
    ans = n * (n - 1) * nf
    ans %= mod
    print(ans)
Feedback
Good problem:
Average problem:
Bad problem:
Did not solve:
--------------------------------------------------
Problem ID: 1777A
Editorial Content:
1777A - Everybody Likes Good Arrays!
Hints
Hint 1
Try to make the problem simpler.
Hint 2
Parity?
Hint 3
Try replacing even numbers with $$$0$$$ and odd numbers with $$$1$$$ in other words consider all numbers modulo $$$2$$$.
Hint 4
Think harder! It works!
Hint 1
Try to make the problem simpler.
Hint 2
Parity?
Hint 3
Try replacing even numbers with $$$0$$$ and odd numbers with $$$1$$$ in other words consider all numbers modulo $$$2$$$.
Hint 4
Think harder! It works!
Solution
Tutorial is loading...
Implementation (C++)
/* Enjoying CP as always!*/
#include <bits/stdc++.h>
using namespace std;
#define int long long

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int t;
    cin>>t;
    while(t--) {
        //Take input
        int n;
        cin>>n;
        int a[n];
        for(int i=0;i<n;i++) {
            cin>>a[i];
        }
        //initialize answer..
        int ans=0;
        for(int i=0;i+1<n;i++) {
            ans+=(!((a[i]^a[i+1])&1));
            /*XOR the two numbers and check 0th bit in the resultant, if it is 1
            then, numbers are of different parity, otherwise both are of same parity*/
        }
        cout<<ans<<"\n";
    }
    return 0;
}
Implementation (Python)
def main():
    T = int(input())
    while T > 0:
        T = T - 1
        n = int(input())
        a = [int(x) for x in input().split()]
        ans = 0
 
        for i in range(1, n):
            ans += 1 - ((a[i] + a[i - 1]) & 1)
 
        print(ans)
 
 
if __name__ == '__main__':
    main()
Feedback
Good problem:
Average problem:
Bad problem:
Did not solve:
--------------------------------------------------
Problem ID: 1776N
Editorial data not available.
--------------------------------------------------
Problem ID: 1776M
Editorial data not available.
--------------------------------------------------
Problem ID: 1776L
Editorial data not available.
--------------------------------------------------
Problem ID: 1776K
Editorial data not available.
--------------------------------------------------
Problem ID: 1776J
Editorial data not available.
--------------------------------------------------
Problem ID: 1776I
Editorial data not available.
--------------------------------------------------
Problem ID: 1776H
Editorial data not available.
--------------------------------------------------
Problem ID: 1776G
Editorial data not available.
--------------------------------------------------
Problem ID: 1776F
Editorial data not available.
--------------------------------------------------
Problem ID: 1776E
Editorial data not available.
--------------------------------------------------
Problem ID: 1776D
Editorial data not available.
--------------------------------------------------
Problem ID: 1776C
Editorial data not available.
--------------------------------------------------
Problem ID: 1776B
Editorial data not available.
--------------------------------------------------
Problem ID: 1776A
Editorial data not available.
--------------------------------------------------
Problem ID: 1775F
Editorial Content:
1775F - Laboratory on Pluto
Solution
Tutorial is loading...
Bonus
Problem A can be solved for $$$O(n)$$$ even if the alphabet consists of all letters. Think about how this can be done.
Bonus answer
The size of the second string is $$$1$$$. You can just go through it.
Code for Problem A (solution for large alphabet)
Link
Code for Problem B
Link
Code for Task C
Link
Code for Task D
Link
Code for Task E
Link
Code for Task F
Link
--------------------------------------------------
Problem ID: 1775E
Editorial Content:
1775E - The Human Equation
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1775D
Editorial Content:
1775D - Friendly Spiders
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1775C
Editorial Content:
1775C - Interesting Sequence
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1775B
Editorial Content:
1775B - Gardener and the Array
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1775A2
Editorial Content:
1775A2 - Gardener and the Capybaras (hard version)
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1775A1
Editorial Content:
1775A1 - Gardener and the Capybaras (easy version)
Solution
Tutorial is loading...
--------------------------------------------------
Problem ID: 1774H
Editorial Content:
1774H - Maximum Permutation
Solution
When it seems to be hard to come up with the whole solution directly, simplified questions can often be a great helper. So first let us consider the case where $$$n$$$ is the multiple of $$$k$$$.
Let $$$t=\frac{n}{k}$$$.
What is the largest value one can obtain theoretically? Pick out $$$t$$$ subsegments $$$a_{[1:k]},a_{[k+1:2k]},\dots,a_{[n-k+1:n]}$$$, and one can see that the answer cannot be greater than the average value of the sum of each subsegment, that is $$$\frac{n(n+1)}{2t}=\frac{k(n+1)}{2}$$$.
Case 1: $$$k$$$ is even
If $$$k$$$ is even, one can construct $$$a=[1,n,2,n-1,3,n-2,\dots,\frac{n}{2},\frac{n}{2}+1]$$$ to reach the maximum value.
Case 2: $$$k$$$ is odd
For easy understanding let us put $$$a_{[1:k]},a_{[k+1:2k]},\dots,a_{[n-k+1:n]}$$$ into a $$$t\times k$$$ table from top to bottom like this:
Note that the difference value between two consecutive subsegments is equal to the difference value between two values in the same column in this table. It inspires us to fill in the last $$$k-3$$$ columns in an S-shaped way like this:
Then our goal is to split the remaining $$$3t$$$ numbers into $$$3$$$ groups and minimize the difference value between the sum of each group.
If $$$n$$$ is odd, the theoretical maximum value mentioned above is an integer, and the sum of each group must be equal to reach that value. Otherwise, the theoretical maximum value mentioned above is not an integer, and the sum of each group cannot be determined. So let us first consider the case where $$$n$$$ is odd. A feasible approach to split the numbers is as follows:
$$$(1,\frac{3t+1}{2},3t),(3,\frac{3t-1}{2},3t-1),\dots,(t,t+1,\frac{5t+1}{2}),(2,2t,\frac{5t-1}{2}),(4,2t-1,\frac{5t-3}{2}),\dots,(t-1,\frac{3t+3}{2},2t+1)$$$
Then fill them into the table:
Similarly, one can come up with an approach when $$$n$$$ is even:
Okay, it's time for us to go back to the original problem.
Let $$$n=qk+r\ (r,q\in \mathbb{N},1\le r<k)$$$.
Split $$$n$$$ elements like this:
As shown in the picture, there are $$$(q+1)$$$ red subsegments with $$$r$$$ elements each, and $$$q$$$ blue subsegments with $$$(k-r)$$$ elements each. What is the largest value one can obtain theoretically now? Pick out $$$q$$$ non-intersecting subsegments consisting of a whole red subsegment and a whole blue segement each, and one can see that the answer cannot be greater than the average value of the sum of each subsegment, that is the sum of $$$1 \thicksim n$$$ subtracted by the sum of any whole red subsegment, then divide by $$$q$$$. Similarly, the answer cannot be greater than the sum of $$$1 \thicksim n$$$ added by the sum of any whole blue subsegment, then divide by $$$(q+1)$$$.
Thus, our goal is to make the maximum sum of each red subsegment the minimum, and make the minimum sum of each blue subsegment the maximum. Now here comes an interesting claim: it can be proved that,
If $$$r\neq 1$$$ and $$$k-r\neq 1$$$, one can fill the red subsegments using the method when $$$n$$$ is the multiple of $$$k$$$ (here $$$n'=(q+1)r,k'=r$$$ ) with $$$1\thicksim (q+1)r$$$, and the blue subsegments (here $$$n'=q(k-r),k'=k-r$$$ ) with the remaining numbers;
If $$$r=1$$$, one can fill the red subsegments with $$$1\thicksim (q+1)$$$ from left to right, and the first element of the blue subsegments with $$$(q+2)\thicksim (2q+1)$$$ from right to left, and the blue subsegments without the first element using the method when $$$n$$$ is the multiple of $$$k$$$ (here $$$n'=q(k-2),k'=k-2$$$ ) with the remaining numbers;
If $$$k-r=1$$$ and $$$q=1$$$, one can let $$$a_k=n$$$, and fill the rest two subsegments using the method when $$$n$$$ is the multiple of $$$k$$$ (here $$$n'=n-1,k'=k-1$$$ ) with the remaining numbers;
If $$$k-r=1$$$ and $$$q>1$$$, one can fill the blue subsegments with $$$(n-q+1)\thicksim n$$$ from right to left, and the first element of the red subsegments with $$$1\thicksim (q+1)$$$ from right to left, and the red subsegments without the first element using the method when $$$n$$$ is the multiple of $$$k$$$ (here $$$n'=(q+1)(r-1),k'=r-1$$$ ) with the remaining numbers,
then the constraints can both be satisfied and the value of the permutation is theoretically maximum. The proof is omitted here.
Time complexity: $$$O(\sum n)$$$
Bonus: solve the problem if $$$k\ge 2$$$.
Code
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
ll t,n,k,seq[100009],ans[100009];
inline ll read(){
  ll s = 0,w = 1;
  char ch = getchar();
  while (ch > '9' || ch < '0'){ if (ch == '-') w = -1; ch = getchar();}
  while (ch <= '9' && ch >= '0') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();
  return s * w;
}

ll f(ll x,ll y,ll k){return (x - 1) * k + y;}
void get(ll n,ll k){
  if (!(k & 1)){
    for (ll i = 1;i <= n >> 1;i += 1) seq[(i << 1) - 1] = i,seq[i << 1] = n + 1 - i;
    return;
  }
  ll m = n / k,cur = 3 * m;
  for (ll i = 4;i <= k;i += 1){
    if (i & 1) for (ll j = m;j >= 1;j -= 1) seq[f(j,i,k)] = ++ cur;
    else for (ll j = 1;j <= m;j += 1) seq[f(j,i,k)] = ++ cur;
  }
  for (ll i = 1;i <= (m + 1 >> 1);i += 1){
    seq[f(i,1,k)] = (i << 1) - 1;
    seq[f(i,2,k)] = ((3 * m + 3) >> 1) - i;
    seq[f(i,3,k)] = 3 * m - i + 1;
  }
  for (ll i = (m + 3 >> 1);i <= m;i += 1){
    ll delta = i - (m + 3 >> 1);
    seq[f(i,1,k)] = ((3 * m + 3) >> 1) + delta;
    seq[f(i,2,k)] = (m << 1) + 1 + delta;
    seq[f(i,3,k)] = m - (m & 1) - (delta << 1);
  }
}
void print(){
  ll res = 0,sum = 0;
  for (ll i = 1;i <= k;i += 1) sum += ans[i];
  res = sum;
  for (ll i = k + 1;i <= n;i += 1) sum += ans[i] - ans[i - k],res = min(res,sum);
  printf("%lld\n",res);
  for (ll i = 1;i <= n;i += 1) printf("%lld ",ans[i]);
  puts("");
}

int main(){
  t = read();
  while (t --){
    n = read(),k = read();
    if (!(n % k)){
      get(n,k);
      for (ll i = 1;i <= n;i += 1) ans[i] = seq[i];
      print();
      continue;
    }
    ll q = n / k,r = n % k;
    if (r == 1){
      ll cur = 0,delta = (q << 1) + 1;
      for (ll i = 1;i <= n;i += k) ans[i] = ++ cur;
      for (ll i = n - k + 1;i >= 2;i -= k) ans[i] = ++ cur;
      get(q * (k - 2),k - 2),cur = 0;
      for (ll i = 3;i <= n;i += k) for (ll j = i;j <= i + k - 3;j += 1) ans[j] = seq[++ cur] + delta;
      print();
      continue;
    }
    if (k - r == 1){
      if (q == 1){
        ll cur = 0;
        ans[k] = n;
        get(n - 1,k - 1);
        for (ll i = 1;i < k;i += 1) ans[i] = seq[++ cur];
        for (ll i = k + 1;i <= n;i += 1) ans[i] = seq[++ cur];
        print();
        continue;
      }
      ll cur = n + 1,delta = q + 1;
      for (ll i = k;i <= n;i += k) ans[i] = -- cur;
      cur = 0;
      for (ll i = 1;i <= n;i += k) ans[i] = ++ cur;
      get((q + 1) * (r - 1),r - 1),cur = 0;
      for (ll i = 2;i <= n;i += k) for (ll j = i;j <= i + r - 2;j += 1) ans[j] = seq[++ cur] + delta;
      print();
      continue;
    }
    ll cur = 0,delta = (q + 1) * r;
    get((q + 1) * r,r);
    for (ll i = 1;i <= n;i += k) for (ll j = i;j <= i + r - 1;j += 1) ans[j] = seq[++ cur];
    get(q * (k - r),k - r),cur = 0;
    for (ll i = r + 1;i <= n;i += k) for (ll j = i;j <= i + (k - r) - 1;j += 1) ans[j] = seq[++ cur] + delta;
    print();
  }
  return 0;
}
--------------------------------------------------
Problem ID: 1774G
Editorial Content:
1774G - Segment Covering
Hint 1
If there exist two segments $$$(l_1, r_1), (l_2, r_2)$$$ such that $$$l_1 \le l_2 \le r_2 \le r_1$$$ and we choose $$$(l_1, r_1)$$$, number of ways of choosing $$$(l_2, r_2)$$$ at the same time will be equal to that of not choosing. Hence if we choose $$$(l_1, r_1)$$$, the signed number of ways will be $$$0$$$. So we can delete $$$(l_1, r_1)$$$.
Hint 2
It can be proved that the absolute value of every $$$f_{l,r} - g_{l,r}$$$ doesn't exceed $$$1$$$.
Proof: First, find segments $$$(l_i, r_i)$$$ which are completely contained by $$$(l, r)$$$.
Let us sort $$$(l_i, r_i)$$$ in ascending order of $$$l_i$$$. As there does not exist a segment that contains another, $$$r_i$$$ are also sorted.
Assume that $$$l_2 < l_3 \leq r_1$$$ and $$$r_3 \geq r_2$$$. If we choose segments $$$1$$$ and $$$3$$$, choosing $$$2$$$ or not will be the same except for the sign. So $$$3$$$ is useless. So we can delete such useless segments. After the process, $$$l_3 > r_1, l_4 > r_2, \cdots$$$ will be held. If $$$[l_1, r_1] \cup [l_2, r_2] \cup \cdots \cup [l_k, r_k] = [l, r]$$$, answer will be $$$(-1)^k$$$, else answer will be $$$0$$$.
Solution
This picture shows what the segments eventually are like:
For $$$[l_i, r_i]$$$, we can find the lowest $$$j$$$ such that $$$l_j > r_i$$$ and construct a tree by linking such $$$i$$$ and $$$j$$$. Then the LCA of $$$1$$$ and $$$2$$$ will be $$$5$$$, where the answer becomes 0.
So we can get the answer of $$$(ql, qr)$$$ quickly by simply finding the LCA of two segments -- the segment starting with $$$ql$$$ (if no segment starts with $$$ql$$$, the answer is $$$0$$$), and the first segment whose $$$l$$$ is greater than $$$ql$$$ (if it do not intersect with the previous segment, the answer is $$$0$$$).
And find the segment ending with $$$qr$$$. If it is on the path of the two segments, the answer will be $$$\pm 1$$$. Else, the answer will be $$$0$$$.
Code
#include <bits/stdc++.h>

#define File(a) freopen(a ".in", "r", stdin), freopen(a ".out", "w", stdout)

using tp = std::tuple<int, int, int>;
const int sgn[] = {1, 998244352};
const int N = 200005;

int x[N], y[N];
std::vector<tp> V;
bool del[N];
int fa[20][N];
int m, q;

int main() {
  scanf("%d %d", &m, &q);
  for (int i = 1; i <= m; ++i)
    scanf("%d %d", x + i, y + i), V.emplace_back(y[i], -x[i], i);
  std::sort(V.begin(), V.end());
  int mxl = 0;
  for (auto [y, x, i] : V) {
    if (-x <= mxl) del[i] = true;
    mxl = std::max(mxl, -x);
  }
  V.clear();
  x[m + 1] = y[m + 1] = 1e9 + 1;
  for (int i = 1; i <= m + 1; ++i) {
    if (!del[i]) V.emplace_back(x[i], y[i], i);
  }
  std::sort(V.begin(), V.end());
  for (auto [x, y, id] : V) {
    int t = std::get<2>(*std::lower_bound(V.begin(), V.end(), tp{y + 1, 0, 0}));
    fa[0][id] = t;
  }
  fa[0][m + 1] = m + 1;
  for (int k = 1; k <= 17; ++k) {
    for (int i = 1; i <= m + 1; ++i) fa[k][i] = fa[k - 1][fa[k - 1][i]];
  }
  for (int i = 1; i <= q; ++i) {
    int l, r;
    scanf("%d %d", &l, &r);
    int u = std::lower_bound(V.begin(), V.end(), tp{l, 0, 0}) - V.begin(), v = u + 1;
    u = std::get<2>(V[u]);
    if (x[u] != l || y[u] > r) {
      puts("0");
      continue;
    }
    if (y[u] == r) {
      puts("998244352");
      continue;
    }
    v = std::get<2>(V[v]);
    if (y[v] > r || x[v] > y[u]) {
      puts("0");
      continue;
    }
    int numu = 0, numv = 0;
    for (int i = 17; i >= 0; --i) {
      if (y[fa[i][u]] <= r) {
        u = fa[i][u];
        numu += !i;
      }
    }
    for (int i = 17; i >= 0; --i) {
      if (y[fa[i][v]] <= r) {
        v = fa[i][v];
        numv += !i;
      }
    }
    if (u == v || (y[u] != r && y[v] != r))
      puts("0");
    else
      printf("%d\n", sgn[numu ^ numv]);
  }
  return 0;
}
--------------------------------------------------
Problem ID: 1774F2
Editorial Content:
1774F2 - Magician and Pigs (Hard Version)
Solution
For F1, there is another way. Consider every pig. When
Repeat
, it will clone, and when
Attack
, all its clones will be attacked together. Therefore, considering all the operations behind each pig, you can choose to reduce $$$x$$$ (the current total damage) or not when
Repeat
, and you must choose to reduce $$$x$$$ when
Attack
. Any final choice will become a pig (living or not).
We just need to calculate how many
Repeat
choices can make a living pig. For
Repeat
of $$$x=0$$$, there is no difference between the two choices. For the
Repeat
of $$$x\geq 2\times 10^5$$$, it is obvious that you can only choose not to reduce $$$x$$$. Except for the above parts, there are only $$$O(\log x)$$$ choices. You can just find a subset or use knapsack to solve it. It can also pass F1 and the time complexity is $$$O((n+X)\log X)$$$.
The bottleneck of using this method to do F2 lies in the backpack. The problem is that we need to find how many subsets whose sum $$$<x$$$ of of a set whose size is $$$O(\log X)$$$.
Observation: if you sort the set, each element is greater than the sum of all elements smaller than it. We can use observation to solve the problem. Consider each element from large to small. Suppose you now need to find elements and subsets of $$$<x$$$. If the current element $$$\ge x$$$, it must not be selected; If the current element $$$<x$$$, if it is not selected, the following elements can be selected at will (the sum of all the following elements is less than it). It can be recursive. Thus, for a given $$$x$$$, we can find the number of subsets whose sum $$$<x$$$ within $$$O(\log X)$$$.
The time complexity is $$$O(n\log X)$$$.
Code
// Author: Little09
// Problem: F. Magician and Pigs

#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define mem(x) memset(x, 0, sizeof(x))
#define endl "\n"
#define printYes cout << "Yes\n"
#define printYES cout << "YES\n"
#define printNo cout << "No\n"
#define printNO cout << "NO\n"
#define lowbit(x) ((x) & (-(x)))
#define pb push_back
#define mp make_pair
#define pii pair<int, int>
#define fi first
#define se second

const ll inf = 1000000000000000000;
// const ll inf=1000000000;
const ll mod = 998244353;
// const ll mod=1000000007;

const int N = 800005;
int n, m;
ll a[N], b[N], c[N], cnt, s[N], d[N], cntd;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  cin >> n;
  ll maxs = 1e9, sum = 0;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
    if (a[i] != 3) cin >> b[i];
    if (a[i] == 2) sum += b[i];
    sum = min(sum, maxs);
    if (a[i] == 3) b[i] = sum, sum = sum * 2;
    sum = min(sum, maxs);
  }
  sum = 0;
  ll res = 1, ans = 0;
  for (int i = n; i >= 1; i--) {
    if (a[i] == 2)
      sum += b[i];
    else if (a[i] == 3) {
      if (b[i] == maxs) continue;
      if (b[i] == 0) {
        res = res * 2 % mod;
        continue;
      }
      c[++cnt] = b[i];
    } else {
      b[i] -= sum;
      if (b[i] <= 0) continue;
      ll su = 0, r = b[i];
      for (int j = 1; j <= cnt; j++) {
        if (r > c[j]) {
          su = (su + (1ll << (cnt - j))) % mod;
          r -= c[j];
        }
      }
      su = (su + 1) % mod;
      ans = (ans + su * res) % mod;
    }
  }
  cout << ans;
  return 0;
}
--------------------------------------------------
Problem ID: 1774F1
Editorial Content:
1774F1 - Magician and Pigs (Easy Version)
Solution
Let $$$X=\max x$$$.
Think about what ‘Repeat’ is doing. Assuming the total damage is $$$tot$$$ ($$$tot$$$ is easy to calculate because it will be multiplied by $$$2$$$ after each ‘Repeat’ and be added after each ‘Attack’). After repeating, each pig with a current HP of $$$w$$$ ($$$w > tot$$$) will clone a pig with a HP of $$$w-tot$$$.
Why? ‘Repeat’ will do what you just did again, so each original pig will certainly create a pig the same as it, and it will be attacked by $$$tot$$$, so it can be considered that a pig with $$$w-tot$$$ HP has been cloned.
Next, the problem is to maintain a multiset $$$S$$$, which supports: adding a number, subtracting $$$x$$$ for all numbers, and inserting each number after subtracting $$$tot$$$. Find the number of positive elements in the final multiset.
$$$tot$$$ in ‘Repeat’ after the first ‘Attack’ will multiply by $$$2$$$ every time, so it will exceed $$$X$$$ in $$$O(\log X)$$$ times. That is, only $$$O(\log X)$$$ ‘Repeat’ operations are effective. So we can maintain $$$S$$$ in brute force. Every time we do ‘Repeat’, we take out all the numbers larger than $$$tot$$$, then subtract and insert them again. Note that we may do some ‘Repeat’ operations when $$$tot=0$$$, which will result in the number of pigs generated before multiplying by $$$2$$$. Therefore, we also need to maintain the total multiplication.
If you use map to maintain it, the time complexity is $$$O((n+X)\log ^2X)$$$. It can pass F1. You can also use some ways to make the time complexity $$$O((n+X)\log X)$$$.
Code
// Author: Little09
// Problem: F. Magician and Pigs (Easy Version)

#include <bits/stdc++.h>
using namespace std;

#define ll long long
const ll mod = 998244353, inv = (mod + 1) / 2;
int n;
map<ll, ll> s;
ll tot, mul = 1, ts = 1;
inline void add(ll &x, ll y) { (x += y) >= mod && (x -= mod); }

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  cin >> n;
  while (n--) {
    int op;
    cin >> op;
    if (op == 1) {
      ll x;
      cin >> x;
      add(s[x + tot], ts);
    } else if (op == 2) {
      ll x;
      cin >> x;
      tot += x;
    } else if (tot <= 2e5) {
      if (tot == 0)
        mul = mul * 2 % mod, ts = ts * inv % mod;
      else {
        for (ll i = tot + 2e5; i > tot; i--) add(s[i + tot], s[i]);
        tot *= 2;
      }
    }
  }
  ll res = 0;
  for (auto i : s)
    if (i.first > tot) add(res, i.second);
  res = res * mul % mod;
  cout << res;
  return 0;
}
--------------------------------------------------
Problem ID: 1774E
Editorial Content:
1774E - Two Chess Pieces
Solution
We can find that for any $$$d$$$-th ancestor of some $$$b_i$$$, the first piece must pass it some time. Otherwise, we will violate the distance limit. The second piece must pass the $$$d$$$-th ancestor of each $$$b_i$$$ as well. Then we can add the $$$d$$$-th ancestor of each $$$a_i$$$ to the array $$$b$$$, and add the $$$d$$$-th ancestor of each $$$b_i$$$ to the array $$$a$$$.
Then we can find now we can find a solution that each piece only needs to visit its nodes using the shortest route, without considering the limit of $$$d$$$, and the total length can be easily computed. We can find that if we adopt the strategy that we visit these nodes according to their DFS order(we merge the array of $$$a$$$ and $$$b$$$, and sort them according to the DFS order, if the first one is from $$$a$$$, we try to move the first piece to this position, otherwise use the second piece), and move the other piece one step closer to the present piece only if the next step of the present piece will violate the distance limit, then we can ensure the movement exactly just let each piece visit its necessary node without extra operations.
Code
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5;
int t[N * 2], nxt[N * 2], cnt, h[N];
int n, d;
void add(int x, int y) {
  t[++cnt] = y;
  nxt[cnt] = h[x];
  h[x] = cnt;
}
int a[N], b[N];
bool f[2][N];
void dfs1(int x, int fa, int dis) {
  a[dis] = x;
  if (dis > d)
    b[x] = a[dis - d];
  else
    b[x] = 1;
  for (int i = h[x]; i; i = nxt[i]) {
    if (t[i] == fa) continue;
    dfs1(t[i], x, dis + 1);
  }
}
void dfs2(int x, int fa, int tp) {
  bool u = 0;
  for (int i = h[x]; i; i = nxt[i]) {
    if (t[i] == fa) continue;
    dfs2(t[i], x, tp);
    u |= f[tp][t[i]];
  }
  f[tp][x] |= u;
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  cin >> n >> d;
  for (int i = 1; i < n; i++) {
    int x, y;
    cin >> x >> y;
    add(x, y), add(y, x);
  }
  dfs1(1, 0, 1);
  for (int i = 0; i <= 1; i++) {
    int num;
    cin >> num;
    for (int j = 1; j <= num; j++) {
      int x;
      cin >> x;
      f[i][x] = 1, f[i ^ 1][b[x]] = 1;
    }
  }
  for (int i = 0; i <= 1; i++) dfs2(1, 0, i);
  int ans = 0;
  for (int i = 0; i <= 1; i++)
    for (int j = 2; j <= n; j++)
      if (f[i][j]) ans += 2;
  cout << ans;
  return 0;
}
--------------------------------------------------
Problem ID: 1774D
Editorial Content:
1774D - Same Count One
Solution
Considering that we need to make the number of $$$1\text{s}$$$ in each array the same, we should calculate the sum of $$$1\text{s}$$$, and every array has $$$sum / n$$$ $$$1\text{s}$$$. Because only the same position of two different arrays can be selected for exchange each time, for a position $$$pos$$$, we traverse each array each time. If the number of $$$1\text{s}$$$ in this array is not enough, then we need to turn some $$$0\text{s}$$$ into $$$1\text{s}$$$; If the number of $$$1\text{s}$$$ in this array is more than we need, then some $$$1\text{s}$$$ should be turned into $$$0\text{s}$$$. It can be proved that as long as the total number of $$$1\text{s}$$$ is a multiple of $$$n$$$, the number of $$$1\text{s}$$$ in each array can be made the same through exchanges.
Code
#include <bits/stdc++.h>

int main() {
  int T;
  scanf("%d", &T);
  while (T--) {
    int n, m;
    scanf("%d %d", &n, &m);
    std::vector<std::vector<int>> A(n, std::vector<int>(m, 0));
    std::vector<int> sum(n, 0);
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < m; ++j) {
        scanf("%d", &A[i][j]);
        sum[i] += A[i][j];
      }
    }
    int tot = 0;
    for (int i = 0; i < n; ++i) tot += sum[i];
    if (tot % n) {
      puts("-1");
      continue;
    }
    tot /= n;
    std::vector<std::tuple<int, int, int>> ans;
    std::vector<int> Vg, Vl;
    Vg.reserve(n), Vl.reserve(n);
    for (int j = 0; j < m; ++j) {
      for (int i = 0; i < n; ++i) {
        if (sum[i] > tot && A[i][j]) Vg.push_back(i);
        if (sum[i] < tot && !A[i][j]) Vl.push_back(i);
      }
      for (int i = 0; i < (int)std::min(Vl.size(), Vg.size()); ++i) {
        ++sum[Vl[i]], --sum[Vg[i]];
        ans.emplace_back(Vl[i], Vg[i], j);
      }
      Vl.clear(), Vg.clear();
    }
    printf("%d\n", (int)ans.size());
    for (auto [i, j, k] : ans) printf("%d %d %d\n", i + 1, j + 1, k + 1);
  }
  return 0;
}
--------------------------------------------------
Problem ID: 1774C
Editorial Content:
1774C - Ice and Fire
Solution
We define $$$f_i$$$ to mean that the maximum $$$x$$$ satisfies $$$s_{i-x+1}=s_{i-x+2}=...=s_{i}$$$.
It can be proved that for $$$x$$$ players, $$$f_{x-1}$$$ players are bound to lose and the rest have a chance to win. So the answer to the first $$$i$$$ battles is $$$ans_i=i-f_i+1$$$.
Next, we prove this conclusion. Suppose there are $$$n$$$ players and $$$n-1$$$ battles, and $$$s_{n-1}=1$$$, and there are $$$x$$$ consecutive $$$1$$$ at the end. If $$$x=n-1$$$, then obviously only the $$$n$$$-th player can win. Otherwise, $$$s_{n-1-x}$$$ must be 0. Consider the following facts:
Players $$$1$$$ to $$$x$$$ have no chance to win. If the player $$$i$$$ ($$$1\le i\le x$$$) can win, he must defeat the player whose temperature value is lower than him in the last $$$x$$$ battles. However, in total, only the $$$i-1$$$ player's temperature value is lower than his. Because $$$i-1<x$$$, the $$$i$$$-th player cannot win.
Players from $$$x+1$$$ to $$$n$$$ have a chance to win. For the player $$$i$$$ ($$$x+1\le i\le n$$$), we can construct: in the first $$$n-2-x$$$ battles, we let all players whose temperature value in $$$[x+1,n]$$$ except the player $$$i$$$ fight so that only one player will remain. In the $$$(n-1-x)$$$-th battle, we let the remaining player fight with the player $$$1$$$. Since $$$s_{n-1-x}=0$$$, the player $$$1$$$ will win. Then there are only the first $$$x$$$ players and the player $$$i$$$ in the remaining $$$x$$$ battles, so the player $$$i$$$ can win.
For $$$s_{n-1}=0$$$, the situation is similar and it will not be repeated here.
Code
#include <bits/stdc++.h>
using namespace std;

const int N = 300005;
int T, n, ps[2];
char a[N];

void solve() {
  scanf("%d %s", &n, a + 1);
  ps[0] = ps[1] = 0;
  for (int i = 1; i < n; ++i) {
    ps[a[i] - 48] = i;
    if (a[i] == '0')
      printf("%d ", ps[1] + 1);
    else
      printf("%d ", ps[0] + 1);
  }
  putchar('\n');
}
int main() {
  scanf("%d", &T);
  while (T--) solve();
  return 0;
}
--------------------------------------------------
Problem ID: 1774B
Editorial Content:
1774B - Coloring
Solution
First, We can divide $$$n$$$ cells into $$$\left\lceil\frac{n}{k}\right\rceil$$$ segments that except the last segment, all segments have length $$$k$$$. Then in each segment, the colors in it are pairwise different. It's easy to find any $$$a_i$$$ should be smaller than or equal to $$$\left\lceil\frac{n}{k}\right\rceil$$$.
Then we can count the number of $$$a_i$$$ which is equal to $$$\left\lceil\frac{n}{k}\right\rceil$$$. This number must be smaller than or equal to $$$n \bmod k$$$, which is the length of the last segment.
All $$$a$$$ that satisfies the conditions above is valid. We can construct a coloring using the method below:
First, we pick out all colors $$$i$$$ that $$$a_i=\left\lceil\frac{n}{k}\right\rceil$$$, then we use color $$$i$$$ to color the $$$j$$$-th cell in each segment.
Then we pick out all colors $$$i$$$ that $$$a_i<\left\lceil\frac{n}{k}\right\rceil-1$$$ and use these colors to color the rest of cells with cyclic order(i.e. color $$$j$$$-th cell of the first segment, of second the segment ... of the $$$\left\lceil\frac{n}{k}\right\rceil$$$ segment, and let $$$j+1$$$. when one color is used up, we begin to use the next color)
At last, we pick out all colors $$$i$$$ that $$$a_i=\left\lceil\frac{n}{k}\right\rceil-1$$$, and color them with the cyclic order.
This method will always give a valid construction.
Code
#include <bits/stdc++.h>
using namespace std;

int main() {
  int t;
  scanf("%d", &t);
  while (t--) {
    int n, m, k;
    scanf("%d %d %d", &n, &m, &k);
    int fl = 0;
    for (int i = 1; i <= m; ++i) {
      int a;
      scanf("%d", &a);
      if (a == (n + k - 1) / k) ++fl;
      if (a > (n + k - 1) / k) fl = 1 << 30;
    }
    puts(fl <= (n - 1) % k + 1 ? "YES" : "NO");
  }
}
--------------------------------------------------
Problem ID: 1774A
Editorial Content:
1774A - Add Plus Minus Sign
Solution
The answer is the number of $$$1$$$s modulo $$$2$$$.
We can get that by adding '-' before the $$$\text{2nd}, \text{4th}, \cdots, 2k\text{-th}$$$ $$$1$$$, and '+' before the $$$\text{3rd}, \text{5th}, \cdots, 2k+1\text{-th}$$$ $$$1$$$.
Code
#include <bits/stdc++.h>
using namespace std;

char c[1005];
int main() {
  int t;
  scanf("%d", &t);
  int n;
  while (t--) {
    scanf("%d", &n);
    scanf("%s", c + 1);
    int u = 0;
    for (int i = 1; i <= n; ++i) {
      bool fl = (c[i] == '1') && u;
      u ^= (c[i] - '0');
      if (i != 1) putchar(fl ? '-' : '+');
    }
    putchar('\n');
  }
}
--------------------------------------------------
Problem ID: 1773L
Editorial data not available.
--------------------------------------------------
Problem ID: 1773K
Editorial data not available.
--------------------------------------------------
Problem ID: 1773J
Editorial data not available.
--------------------------------------------------
Problem ID: 1773I
Editorial data not available.
--------------------------------------------------
Problem ID: 1773H
Editorial data not available.
--------------------------------------------------
Problem ID: 1773G
Editorial data not available.
--------------------------------------------------
Problem ID: 1773F
Editorial data not available.
--------------------------------------------------
Problem ID: 1773E
Editorial data not available.
--------------------------------------------------
Problem ID: 1773D
Editorial data not available.
--------------------------------------------------
Problem ID: 1773C
Editorial data not available.
--------------------------------------------------
Problem ID: 1773B
Editorial data not available.
--------------------------------------------------
Problem ID: 1773A
Editorial data not available.
--------------------------------------------------
Problem ID: 1772G
Editorial Content:
1772G - Gaining Rating
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>

using namespace std;

#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define sz(a) int((a).size())

typedef long long li;

int n;
li x, y;
vector<li> a;

inline bool read() {
    if(!(cin >> n >> x >> y))
        return false;
    a.resize(n);
    fore (i, 0, n)
        cin >> a[i];
    return true;
}

li ceil(li a, li b) {
    assert(a >= 0 && b >= 0);
    return (a + b - 1) / b;
}

inline void solve() {
    sort(a.begin(), a.end());
    
    vector<li> t(n), b(n);
    fore (i, 0, n) {
        if (i > 0 && b[i - 1] >= a[i]) {
            t[i] = t[i - 1];
            b[i] = b[i - 1] + 1;
        } else {
            t[i] = a[i] - i;
            b[i] = a[i] + 1;
        }
    }
    
    li ans = 0;
    while (x < y) {
        int pos = int(upper_bound(t.begin(), t.end(), x) - t.begin());
        
        li p = pos, m = n - pos;
        if (x + p >= y) {
            cout << ans + (y - x) << endl;
            return;
        }
        if (p <= m) {
            cout << -1 << endl;
            return;
        }
        
        //1. x + k(p - m) + p >= y
        li k = ceil(y - x - p, p - m);
        if (pos < n) {
            //2. x + k(p - m) >= t[pos]
            k = min(k, ceil(t[pos] - x, p - m));
        }
        ans += k * n;
        //x + k(p - m) < y, since 1. and p >= p - m
        x += k * (p - m);
    }
    assert(false);
}

int main() {
#ifdef _DEBUG
    freopen("input.txt", "r", stdin);
    int tt = clock();
#endif
    ios_base::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cout << fixed << setprecision(15);
    
    int t; cin >> t;
    while (t--) {
        read();
        solve();
        
#ifdef _DEBUG
        cerr << "TIME = " << clock() - tt << endl;
        tt = clock();
#endif
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1772F
Editorial Content:
1772F - Copy of a Copy of a Copy
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>
 
using namespace std;
 
#define forn(i, n) for(int i = 0; i < int(n); i++)

struct op{
    int t, x, y, i;
};

int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};

int main(){
    int n, m, k;
    cin >> n >> m >> k;
    vector<vector<string>> a(k + 1, vector<string>(n));
    forn(z, k + 1) forn(i, n)
        cin >> a[z][i];
    
    vector<int> cnt(k + 1);
    forn(z, k + 1){
        for (int i = 1; i < n - 1; ++i){
            for (int j = 1; j < m - 1; ++j){
                bool ok = true;
                forn(t, 4)
                    ok &= a[z][i][j] != a[z][i + dx[t]][j + dy[t]];
                cnt[z] += ok;
            }
        }
    }
    
    vector<int> ord(k + 1);
    iota(ord.begin(), ord.end(), 0);
    sort(ord.begin(), ord.end(), [&cnt](int x, int y){
        return cnt[x] > cnt[y];
    });
    
    vector<op> ops;
    forn(z, k){
        forn(i, n) forn(j, m) if (a[ord[z]][i][j] != a[ord[z + 1]][i][j]){
            a[ord[z]][i][j] ^= '0' ^ '1';
            ops.push_back({1, i + 1, j + 1, -1});
        }
        ops.push_back({2, -1, -1, ord[z + 1] + 1});
    }
    
    cout << ord[0] + 1 << '\n';
    cout << ops.size() << '\n';
    for (auto it : ops){
        cout << it.t << " ";
        if (it.t == 1)
            cout << it.x << " " << it.y << '\n';
        else
            cout << it.i << '\n';
    }
}
--------------------------------------------------
Problem ID: 1772E
Editorial Content:
1772E - Permutation Game
Tutorial
Tutorial is loading...
Solution (Neon)
for tc in range(int(input())):
  n = int(input())
  p = list(map(int, input().split()))
  a, b, c = 0, 0, 0
  for i in range(n):
    if p[i] != i + 1 and p[i] != n - i:
      c += 1
    elif p[i] != i + 1:
      a += 1
    elif p[i] != n - i:
      b += 1
  if a + c <= b:
    print("First")
  elif b + c < a:
    print("Second")
  else:
    print("Tie")
--------------------------------------------------
Problem ID: 1772D
Editorial Content:
1772D - Absolute Sorting
Tutorial
Tutorial is loading...
Solution (BledDest)
#include <bits/stdc++.h>
 
using namespace std;

int main()
{
    int t;
    cin >> t;
    for(int i = 0; i < t; i++)
    {
        int n;
        cin >> n;
        vector<int> a(n);
        for(int j = 0; j < n; j++)
            cin >> a[j];
        int mn = 0, mx = int(1e9);
        for(int j = 0; j + 1 < n; j++)
        {
            int x = a[j];
            int y = a[j + 1];
            int midL = (x + y) / 2;
            int midR = (x + y + 1) / 2;
            if(x < y)
                mx = min(mx, midL);
            if(x > y)
                mn = max(mn, midR);
        }
        if(mn <= mx) cout << mn << endl;
        else cout << -1 << endl;
    }
}
--------------------------------------------------
Problem ID: 1772C
Editorial Content:
1772C - Different Differences
Tutorial
Tutorial is loading...
Solution (BledDest)
def construct(f, k):
    return [(i + 2 if i < f - 1 else 1) for i in range(k)]

t = int(input())
for i in range(t):
    k, n = map(int, input().split())
    ans = 1
    for f in range(1, k):
        d = construct(f, k - 1)
        if sum(d) <= n - 1:
            ans = f
    res = [1]
    d = construct(ans, k - 1)
    for x in d:
        res.append(res[-1] + x)
    print(*res)
--------------------------------------------------
Problem ID: 1772B
Editorial Content:
1772B - Matrix Rotation
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

int main()
{
    int t;
    cin >> t;
    for(int _ = 0; _ < t; _++)
    {
        vector<int> a(4);
        for(int i = 0; i < 4; i++)
            cin >> a[i];
        int maxpos = max_element(a.begin(), a.end()) - a.begin();
        int minpos = min_element(a.begin(), a.end()) - a.begin();
        if(maxpos + minpos == 3)
            puts("YES");
        else
            puts("NO");
    }
}
--------------------------------------------------
Problem ID: 1772A
Editorial Content:
1772A - A+B?
Tutorial
Tutorial is loading...
Solution (BledDest)
t = int(input())
for i in range(t):
    print(eval(input()))
--------------------------------------------------
Problem ID: 1771F
Editorial Content:

--------------------------------------------------
Problem ID: 1771E
Editorial Content:

--------------------------------------------------
Problem ID: 1771D
Editorial Content:

--------------------------------------------------
Problem ID: 1771C
Editorial Content:

--------------------------------------------------
Problem ID: 1771B
Editorial Content:

--------------------------------------------------
Problem ID: 1771A
Editorial Content:

--------------------------------------------------
Problem ID: 1770H
Editorial data not available.
--------------------------------------------------
Problem ID: 1770G
Editorial data not available.
--------------------------------------------------
Problem ID: 1770F
Editorial data not available.
--------------------------------------------------
Problem ID: 1770E
Editorial data not available.
--------------------------------------------------
Problem ID: 1770D
Editorial data not available.
--------------------------------------------------
Problem ID: 1770C
Editorial data not available.
--------------------------------------------------
Problem ID: 1770B
Editorial data not available.
--------------------------------------------------
Problem ID: 1770A
Editorial data not available.
--------------------------------------------------
Problem ID: 1769D3
Editorial data not available.
--------------------------------------------------
Problem ID: 1769D2
Editorial data not available.
--------------------------------------------------
Problem ID: 1769D1
Editorial data not available.
--------------------------------------------------
Problem ID: 1769C2
Editorial data not available.
--------------------------------------------------
Problem ID: 1769C1
Editorial data not available.
--------------------------------------------------
Problem ID: 1769B2
Editorial data not available.
--------------------------------------------------
Problem ID: 1769B1
Editorial data not available.
--------------------------------------------------
Problem ID: 1769A
Editorial data not available.
--------------------------------------------------
Problem ID: 1768F
Editorial Content:
1768F - Wonderful Jump
Hints
Hint 0
Use dynamic programming.
Hint 1
$$$a_i \le n$$$
Hint 2
Compare $$$\min(a_i \ldots a_j) \cdot (j - i)^2$$$ with $$$n \cdot (j - i)$$$.
Hint 3
Compare $$$\min(a_i \ldots a_j) \cdot (j - i)^2$$$ with $$$\min(a_i \ldots a_k) \cdot (k - i)^2 + \min(a_k \ldots a_j) \cdot (j - k)^2$$$ for some $$$i < k < j$$$.
Hint 4
Two cases: $$$\min(a_i \ldots a_j) \ge \sqrt{n}$$$ and $$$\min(a_i \ldots a_j) < \sqrt{n}$$$.
Hint 5
Split $$$\min(a_i \ldots a_j) < \sqrt{n}$$$ into two more cases: $$$\min(a_i \ldots a_j) = a_i$$$ and $$$\min(a_i \ldots a_j) = a_j$$$.
Hint 0
Use dynamic programming.
Hint 1
$$$a_i \le n$$$
Hint 2
Compare $$$\min(a_i \ldots a_j) \cdot (j - i)^2$$$ with $$$n \cdot (j - i)$$$.
Hint 3
Compare $$$\min(a_i \ldots a_j) \cdot (j - i)^2$$$ with $$$\min(a_i \ldots a_k) \cdot (k - i)^2 + \min(a_k \ldots a_j) \cdot (j - k)^2$$$ for some $$$i < k < j$$$.
Hint 4
Two cases: $$$\min(a_i \ldots a_j) \ge \sqrt{n}$$$ and $$$\min(a_i \ldots a_j) < \sqrt{n}$$$.
Hint 5
Split $$$\min(a_i \ldots a_j) < \sqrt{n}$$$ into two more cases: $$$\min(a_i \ldots a_j) = a_i$$$ and $$$\min(a_i \ldots a_j) = a_j$$$.
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define all(x) (x).begin(), (x).end()
#define allr(x) (x).rbegin(), (x).rend()
#define gsize(x) (int)((x).size())

const char nl = '\n';
typedef long long ll;
typedef long double ld;

using namespace std;

const int K = 650;

int main() {
	ios::sync_with_stdio(0); cin.tie(0);
	
	int n;
	cin >> n;
	vector<ll> a(n);
	for (int i = 0; i < n; i++) cin >> a[i];
	
	vector<ll> dp(n, 1e18);
	dp[0] = 0;
	
	vector<int> st = {0};
	for (int i = 1; i < n; i++) {
		// Case 1
		{
			ll mi = a[i];
			for (int j = i - 1; j >= max(0, i - K); j--) {
				mi = min(mi, a[j]);
				dp[i] = min(dp[i], dp[j] + mi * (i - j) * (i - j));
			}
		}
		
		// Case 2
		if (a[i] <= K) {	
			for (int j = i - 1; j >= 0; j--) {
				dp[i] = min(dp[i], dp[j] + a[i] * (i - j) * (i - j));
				if (a[j] <= a[i]) break;
			}
		}
		
		// Case 3 
		{
			for (int j: st) {
				dp[i] = min(dp[i], dp[j] + a[j] * (i - j) * (i - j));
			}
			
			if (a[i] <= K) {
				while (!st.empty() && a[st.back()] >= a[i]) {
					st.pop_back();
				}
				st.push_back(i);
			}
		}
	}
	
	for (int i = 0; i < n; i++) cout << dp[i] << ' ';
	cout << endl;
}
Shorter solution (tfg)
#include <iostream>
#include <vector>
#include <chrono>
#include <random>
#include <cassert>
 
std::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());
 
int main() {
    std::ios_base::sync_with_stdio(false); std::cin.tie(NULL);
    int n;
    std::cin >> n;
    std::vector<int> a(n);
    for(int i = 0; i < n; i++) {
        std::cin >> a[i];
    }
    std::vector<long long> dp(n, 1e18);
    dp[0] = 0;
    for(int i = 0; i < n; i++) {
        int dist = n / a[i] + 1;
        // take from behind
        for(int j = i-1; j >= 0 && i-j <= dist; j--) {
            dp[i] = std::min(dp[i], dp[j] + (long long) a[i] * (i - j) * (i - j));
            if(a[j] <= a[i]) break;
        }
        // propagate forward
        for(int j = i+1; j < n && j-i <= dist; j++) {
            dp[j] = std::min(dp[j], dp[i] + (long long) a[i] * (i - j) * (i - j));
            if(a[j] <= a[i]) break;
        }
        std::cout << dp[i] << (i + 1 == n ? '\n' : ' ');
    }
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1768E
Editorial Content:
1768E - Partial Sorting
Hints
Hint 1
Given a fixed permutation, how many operations do we need to sort it?
Hint 2
Keep in mind there is one already sorted permutation that doesn't need to be sorted.
Hint 3
What if there is exactly $$$1$$$ number in the range $$$[n + 1, 2n]$$$ that appears in the first $$$n$$$ numbers?
Hint 4
This is not really a hint, fft solutions exist, but we made sure most of them cannot pass.
Hint 1
Given a fixed permutation, how many operations do we need to sort it?
Hint 2
Keep in mind there is one already sorted permutation that doesn't need to be sorted.
Hint 3
What if there is exactly $$$1$$$ number in the range $$$[n + 1, 2n]$$$ that appears in the first $$$n$$$ numbers?
Hint 4
This is not really a hint, fft solutions exist, but we made sure most of them cannot pass.
Tutorial
1768E- Partial Sorting
We need at most $$$3$$$ operations to sort the permutation: $$$1 -> 2 -> 1$$$
For $$$f(p) = 0$$$, there is only one case: the initially sorted permutation.
Calculate
return (38912738912739811 & 1)
For $$$f(p) \leq 1$$$, this scenario appears when the first $$$n$$$ numbers or the last $$$n$$$ numbers are in the right places.
Calculate
Both cases have $$$n$$$ fixed positions, so there will be $$$(2n!)$$$ permutations in each case.
Intersection: since both cases share the $$$n$$$ middle elements, $$$(n!)$$$ permutation will appear in both cases.
So there will be $$$2 \times (2n!) - (n!)$$$ such permutations.
For $$$f(p) \leq 2$$$, this scenario appears when the smallest $$$n$$$ elements' positions are in range $$$[1, 2n]$$$, or the largest $$$n$$$ numbers' positions are in range $$$[n + 1, 3n]$$$.
Calculate
If the smallest $$$n$$$ elements are all in position from $$$1$$$ to $$$2n$$$, then:
There are $$$C_{2n}^{n}$$$ ways to choose $$$n$$$ positions for these numbers.
For each way to choose these positions, there are $$$n!$$$ ways to choose the position for the smallest $$$n$$$ numbers, and $$$2n!$$$ ways for the rest.
The total number of valid permuations are: $$$C_{2n}^{n} \times n! \times 2n!$$$
If the largest $$$n$$$ elements are all in position from $$$n + 1$$$ to $$$3n$$$, we do the same calculation.
Intersection: intersection appears when the first $$$n$$$ numbers are all in range $$$[1, 2n]$$$ and the last $$$n$$$ numbers are all in range $$$[n + 1, 3n]$$$.
Let
intersection = 0
Sketch and calculation in details
Let's talk about the numbers in range $$$[n + 1, 2n]$$$. There are $$$n$$$ such numbers.
. Imagine there are EXACTLY $$$i = 0$$$ numbers in this range that appear in the first $$$n$$$ numbers. So:
In the first $$$n$$$ numbers there are $$$n$$$ numbers in range $$$[1, n]$$$. There are $$$C_{n}^{n - 0} \times n!$$$ cases.
In the first $$$n$$$ numbers there are $$$0$$$ numbers in range $$$[n + 1, 2n]$$$. There are $$$C_{n}^{0} \times n!$$$ cases.
In the last $$$n$$$ numbers there are $$$n$$$ numbers in range $$$[n + 1, 3n]$$$, we have used $$$0$$$ numbers for the first n numbers. There are $$$C_{2n - 0}^{n} \times n!$$$ cases.
Then we have:
intersection +=
$$$C_{n}^{n - 0} \times C_{n}^{0} \times C_{2n - 0}^{n} \times n! \times n! \times n!$$$
After convert $$$0$$$ to $$$i$$$, we have
intersection +=
$$$C_{n}^{n - i} \times C_{n}^{i} \times C_{2n - i}^{n} \times n! \times n! \times n!$$$
How about there is EXACTLY $$$i = 1$$$ number in range $$$[n + 1, 2n]$$$ appearing in the first $$$n$$$ numbers?
In the first $$$n$$$ numbers there are $$$n - 1$$$ numbers in range $$$[1, n]$$$. There are $$$C_{n}^{n - 1} \times n!$$$ cases.
In the first $$$n$$$ numbers there are $$$1$$$ numbers in range $$$[n + 1, 2n]$$$. There are $$$C_{n}^{1} \times n!$$$ cases.
In the last $$$n$$$ numbers there are $$$n$$$ numbers in range $$$[n + 1, 3n]$$$, we have used $$$1$$$ numbers for the first $$$n$$$ numbers. There are $$$C_{2n - 1}^{n} \times n!$$$ cases.
Then we have:
intersection +=
$$$C_{n}^{n - 1} \times C_{n}^{1} \times C_{2n - 1}^{n} \times n! \times n! \times n!$$$
After convert $$$1$$$ to $$$i$$$, we have
intersection +=
$$$C_{n}^{n - i} \times C_{n}^{i} \times C_{2n - i}^{n} \times n! \times n! \times n!$$$
We do the same thing with remaining cases, all the way up to $$$i = n$$$.
The number of intersections will be equal to: $$$ \sum_{i = 0}^{n} C_{n}^{n - i} \times C_{n}^{i} \times C_{2n - i}^{n} \times n! \times n! \times n! $$$
So, the answer will be $$$2 \times C_{2n}^{n} \times n! \times 2n! - \sum_{i = 0}^{n} C_{n}^{n - i} \times C_{n}^{i} \times C_{2n - i}^{n} \times n! \times n! \times n!$$$
For $$$f(p) \leq 3$$$, it will be the count of all valid permutations.
Calculate
return __factorial(n * __number_of_sides_of_a_triangle)
Time complexity: $$$\mathcal{O}(n)$$$
1768E- Partial Sorting
Calculate
return (38912738912739811 & 1)
Calculate
Both cases have $$$n$$$ fixed positions, so there will be $$$(2n!)$$$ permutations in each case.
Intersection: since both cases share the $$$n$$$ middle elements, $$$(n!)$$$ permutation will appear in both cases.
So there will be $$$2 \times (2n!) - (n!)$$$ such permutations.
Calculate
If the smallest $$$n$$$ elements are all in position from $$$1$$$ to $$$2n$$$, then:
There are $$$C_{2n}^{n}$$$ ways to choose $$$n$$$ positions for these numbers.
For each way to choose these positions, there are $$$n!$$$ ways to choose the position for the smallest $$$n$$$ numbers, and $$$2n!$$$ ways for the rest.
The total number of valid permuations are: $$$C_{2n}^{n} \times n! \times 2n!$$$
If the largest $$$n$$$ elements are all in position from $$$n + 1$$$ to $$$3n$$$, we do the same calculation.
Intersection: intersection appears when the first $$$n$$$ numbers are all in range $$$[1, 2n]$$$ and the last $$$n$$$ numbers are all in range $$$[n + 1, 3n]$$$.
Let
intersection = 0
Sketch and calculation in details
Let's talk about the numbers in range $$$[n + 1, 2n]$$$. There are $$$n$$$ such numbers.
. Imagine there are EXACTLY $$$i = 0$$$ numbers in this range that appear in the first $$$n$$$ numbers. So:
In the first $$$n$$$ numbers there are $$$n$$$ numbers in range $$$[1, n]$$$. There are $$$C_{n}^{n - 0} \times n!$$$ cases.
In the first $$$n$$$ numbers there are $$$0$$$ numbers in range $$$[n + 1, 2n]$$$. There are $$$C_{n}^{0} \times n!$$$ cases.
In the last $$$n$$$ numbers there are $$$n$$$ numbers in range $$$[n + 1, 3n]$$$, we have used $$$0$$$ numbers for the first n numbers. There are $$$C_{2n - 0}^{n} \times n!$$$ cases.
Then we have:
intersection +=
$$$C_{n}^{n - 0} \times C_{n}^{0} \times C_{2n - 0}^{n} \times n! \times n! \times n!$$$
After convert $$$0$$$ to $$$i$$$, we have
intersection +=
$$$C_{n}^{n - i} \times C_{n}^{i} \times C_{2n - i}^{n} \times n! \times n! \times n!$$$
How about there is EXACTLY $$$i = 1$$$ number in range $$$[n + 1, 2n]$$$ appearing in the first $$$n$$$ numbers?
In the first $$$n$$$ numbers there are $$$n - 1$$$ numbers in range $$$[1, n]$$$. There are $$$C_{n}^{n - 1} \times n!$$$ cases.
In the first $$$n$$$ numbers there are $$$1$$$ numbers in range $$$[n + 1, 2n]$$$. There are $$$C_{n}^{1} \times n!$$$ cases.
In the last $$$n$$$ numbers there are $$$n$$$ numbers in range $$$[n + 1, 3n]$$$, we have used $$$1$$$ numbers for the first $$$n$$$ numbers. There are $$$C_{2n - 1}^{n} \times n!$$$ cases.
Then we have:
intersection +=
$$$C_{n}^{n - 1} \times C_{n}^{1} \times C_{2n - 1}^{n} \times n! \times n! \times n!$$$
After convert $$$1$$$ to $$$i$$$, we have
intersection +=
$$$C_{n}^{n - i} \times C_{n}^{i} \times C_{2n - i}^{n} \times n! \times n! \times n!$$$
We do the same thing with remaining cases, all the way up to $$$i = n$$$.
The number of intersections will be equal to: $$$ \sum_{i = 0}^{n} C_{n}^{n - i} \times C_{n}^{i} \times C_{2n - i}^{n} \times n! \times n! \times n! $$$
So, the answer will be $$$2 \times C_{2n}^{n} \times n! \times 2n! - \sum_{i = 0}^{n} C_{n}^{n - i} \times C_{n}^{i} \times C_{2n - i}^{n} \times n! \times n! \times n!$$$
Sketch and calculation in details
Let's talk about the numbers in range $$$[n + 1, 2n]$$$. There are $$$n$$$ such numbers.
. Imagine there are EXACTLY $$$i = 0$$$ numbers in this range that appear in the first $$$n$$$ numbers. So:
In the first $$$n$$$ numbers there are $$$n$$$ numbers in range $$$[1, n]$$$. There are $$$C_{n}^{n - 0} \times n!$$$ cases.
In the first $$$n$$$ numbers there are $$$0$$$ numbers in range $$$[n + 1, 2n]$$$. There are $$$C_{n}^{0} \times n!$$$ cases.
In the last $$$n$$$ numbers there are $$$n$$$ numbers in range $$$[n + 1, 3n]$$$, we have used $$$0$$$ numbers for the first n numbers. There are $$$C_{2n - 0}^{n} \times n!$$$ cases.
Then we have:
intersection +=
$$$C_{n}^{n - 0} \times C_{n}^{0} \times C_{2n - 0}^{n} \times n! \times n! \times n!$$$
After convert $$$0$$$ to $$$i$$$, we have
intersection +=
$$$C_{n}^{n - i} \times C_{n}^{i} \times C_{2n - i}^{n} \times n! \times n! \times n!$$$
How about there is EXACTLY $$$i = 1$$$ number in range $$$[n + 1, 2n]$$$ appearing in the first $$$n$$$ numbers?
In the first $$$n$$$ numbers there are $$$n - 1$$$ numbers in range $$$[1, n]$$$. There are $$$C_{n}^{n - 1} \times n!$$$ cases.
In the first $$$n$$$ numbers there are $$$1$$$ numbers in range $$$[n + 1, 2n]$$$. There are $$$C_{n}^{1} \times n!$$$ cases.
In the last $$$n$$$ numbers there are $$$n$$$ numbers in range $$$[n + 1, 3n]$$$, we have used $$$1$$$ numbers for the first $$$n$$$ numbers. There are $$$C_{2n - 1}^{n} \times n!$$$ cases.
Then we have:
intersection +=
$$$C_{n}^{n - 1} \times C_{n}^{1} \times C_{2n - 1}^{n} \times n! \times n! \times n!$$$
After convert $$$1$$$ to $$$i$$$, we have
intersection +=
$$$C_{n}^{n - i} \times C_{n}^{i} \times C_{2n - i}^{n} \times n! \times n! \times n!$$$
We do the same thing with remaining cases, all the way up to $$$i = n$$$.
Calculate
return __factorial(n * __number_of_sides_of_a_triangle)
Solution
#include <bits/stdc++.h>

using namespace std;

long long n, M;

long long frac[3000005], inv[3000005];

long long powermod(long long a, long long b, long long m)
{
	if (b == 0) return 1;
	unsigned long long k = powermod(a, b / 2, m);
	k = k * k;
	k %= m;
	if (b & 1) k = (k * a) % m;
	return k;
}

void Ready()
{
	frac[0] = 1;
	inv[0] = 1;
	for (int i = 1; i <= 3000000; i++)
	{
		frac[i] = (frac[i - 1] * i) % M;
	}
	
	inv[3000000] = powermod(frac[3000000], M - 2, M);
	
	for (int i = 3000000; i > 0; i--)
	{
		inv[i - 1] = (inv[i] * i) % M;
	}
}

long long C(long long n, long long k)
{
	return ((frac[n] * inv[k]) % M * inv[n - k]) % M;
}

int main()
{
	cin >> n >> M;
	Ready();
	long long ans[4]{};
	
	// X = 0
	
	ans[0] = 1;
	
	// X = 1
	
	ans[1] = 2 * frac[2 * n] - frac[n] - ans[0] + M + M;
	ans[1] %= M;
	
	// X = 2
	
	ans[2] = frac[2 * n];
	ans[2] = ans[2] * C(2 *n, n) % M;
	ans[2] = ans[2] * frac[n] % M;
	ans[2] = ans[2] * 2 % M;
	
	for (int i = 0; i <= n; i++)
	{
		int sub = C(n, i);
		sub = sub * C(n, n - i) % M;
		sub = sub * C(2 * n - i, n) % M;
		sub = sub * frac[n] % M;
		sub = sub * frac[n] % M;
		sub = sub * frac[n] % M;
		ans[2] = (ans[2] - sub + M) % M;
	}
	ans[2] = (ans[2] - ans[1] + M) % M;
	ans[2] = (ans[2] - ans[0] + M) % M;
	
	// X = 3
	
	ans[3] = frac[3 * n];
	ans[3] = (ans[3] - ans[2] + M) % M;
	ans[3] = (ans[3] - ans[1] + M) % M;
	ans[3] = (ans[3] - ans[0] + M) % M;
	
	long long answer = ans[1] + 2 * ans[2] + 3 * ans[3];
	answer %= M;
	
	cout << answer << endl;
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1768D
Editorial Content:
1768D - Lucky Permutation
Hints
Hint 1
There are $$$n - 1$$$ permutations of length $$$n$$$ that have exactly one inversion in them.
Hint 2
This problem is similar to finding the minimum number of swaps needed to sort a permutation.
Hint 3
Try looking at the permutation like a graph.
Hint 4
Try to find the number of cycles in each of the $$$n - 1$$$ graphs.
Hint 1
There are $$$n - 1$$$ permutations of length $$$n$$$ that have exactly one inversion in them.
Hint 2
This problem is similar to finding the minimum number of swaps needed to sort a permutation.
Hint 3
Try looking at the permutation like a graph.
Hint 4
Try to find the number of cycles in each of the $$$n - 1$$$ graphs.
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define all(x) (x).begin(), (x).end()
#define allr(x) (x).rbegin(), (x).rend()
#define gsize(x) (int)((x).size())

const char nl = '\n';
typedef long long ll;
typedef long double ld;

using namespace std;

void solve() {
	int n;
	cin >> n;
	vector<int> p(n);
	for (int i = 0; i < n; i++) {
		cin >> p[i]; p[i]--;
	}
	
	int ind = 1, ans = 0;
	vector<int> comp(n, 0);
	for (int i = 0; i < n; i++) {
		if (comp[i]) continue;
		{
			int v = i;
			while (comp[v] == 0) {
				comp[v] = ind;
				v = p[v];
				ans++;
			}
			
			ind++; ans--;
		}
	}
	
	for (int i = 0; i < n - 1; i++) {
		if (comp[i] == comp[i + 1]) {
			cout << ans - 1 << nl;
			return;
		}
	}
	cout << ans + 1 << nl;
}

int main() {
	ios::sync_with_stdio(0); cin.tie(0);
	
	int T;
	cin >> T;
	while (T--) solve();
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1768C
Editorial Content:
1768C - Elemental Decompress
Hints
Hint 1
How many times a unique number can appear in the array $$$a$$$?
Hint 2
Can there be two numbers $$$1$$$ in $$$a$$$? What is the conclusion?
Hint 3
If you sort the array, which rules should the new array satisfy? Given the array $$$[1,2,2 ]$$$, is there any answer for this case?
Hint 4
Which element should you construct first?
Hint 1
How many times a unique number can appear in the array $$$a$$$?
Hint 2
Can there be two numbers $$$1$$$ in $$$a$$$? What is the conclusion?
Hint 3
If you sort the array, which rules should the new array satisfy? Given the array $$$[1,2,2 ]$$$, is there any answer for this case?
Hint 4
Which element should you construct first?
Tutorial
1768C- Elemental Decompress
Two cases produce no answers:
One element appears more than twice in $$$a$$$.
After sorting, there is some index that $$$a[i] < i$$$ ($$$1$$$-indexed).
Proof
Consider there is some index that $$$a[i] <i$$$, then both $$$p[i] < i$$$ and $$$q[i] < i$$$ must satisfy. This is also true for the first $$$i - 1$$$ index, so the numbers that are smaller than $$$i$$$ in both $$$p$$$ and $$$q$$$ are $$$(i - 1) \times 2 + 2 = i * 2$$$. This is a contradiction.
Otherwise, solutions always exist. One method is to constructively attach each element in $$$a$$$ to $$$p$$$ or $$$q$$$:
Traverse from the biggest element to the smallest in $$$a$$$, if that number haven't appeared in $$$p$$$ then attach it to $$$p$$$, otherwise attach it to $$$q$$$.
Traverse from the biggest element to the smallest in $$$a$$$ again, if we attached it to $$$p$$$, find the biggest number that did not appear in $$$q$$$ and attach to $$$q$$$, vice versa.
A naive solution requires the $$$O(n^2)$$$ method to solve. We can reduce to $$$O(n \log n)$$$ by sorting elements in $$$a$$$ as pairs
<element, index>
.
Time complexity: $$$\mathcal{O}(n \log(n))$$$
1768C- Elemental Decompress
Proof
Consider there is some index that $$$a[i] <i$$$, then both $$$p[i] < i$$$ and $$$q[i] < i$$$ must satisfy. This is also true for the first $$$i - 1$$$ index, so the numbers that are smaller than $$$i$$$ in both $$$p$$$ and $$$q$$$ are $$$(i - 1) \times 2 + 2 = i * 2$$$. This is a contradiction.
Solution
#include <bits/stdc++.h>

using namespace std;

const int N = 200005;
int n;
int a[N], b[N], c[N], ra[N], rb[N];

void out()
{
	for (int i = 0; i < n; i++)
	{
		cout << a[i] << ' ';
	}
	cout << '\n';
	
	for (int i = 0; i < n; i++)
	{
		cout << b[i] << ' ';
	}
	cout << '\n';
}

void solve()
{
	cin >> n;
	vector<pair<int, int> > V;
	for (int i = 0; i < n; i++)
	{
		cin >> c[i];
		a[i] = b[i] = 0;
		ra[i + 1] = rb[i + 1] = 1;
		V.push_back(make_pair(c[i], i));
	}
	sort(V.rbegin(), V.rend());
	
	for (int i = 0; i < n; i++)
	{
		int k = V[i].second;
		if (ra[c[k]] == 1) a[k] = c[k], ra[c[k]]--;
		else b[k] = c[k], rb[c[k]]--;
	}
	
	int r1 = n, r2 = n;
	for (int i = 0; i < n; i++)
	{
		int k = V[i].second;
		if (a[k] == 0)
		{
			while (ra[r1] == 0) r1--;
			ra[r1]--;
			if (r1 > b[k])
			{
			    cout << "NO" << '\n';
			    return;
			}
			a[k] = r1--;
		}
		else
		{
			while (rb[r2] == 0) r2--;
			rb[r2]--;
			if (r2 > a[k])
			{
			    cout << "NO" << '\n';
			    return;
			}
			b[k] = r2--;
		}
	}
	for (int i = 1; i <= n; i++)
	{
		if (ra[i] != 0 || rb[i] != 0)
		{
			cout << "NO" << '\n';
			return;
		}
	}
	cout << "YES" << '\n';
	out();
}

int main(int argc, char* argv[])
{
	ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	int t;
	cin >> t;
	while(t--)
		solve();
}
Yet another better solution
There is actually a $$$O(n)$$$ solution to this problem.
Fresh meme from SPyofgame to the intended solution of the author
Step 1
If there are at least $$$k > 3$$$ positions $$$i_1, i_2, \ldots, i_k$$$ that $$$a[i_1] = a[i_2] = \ldots = a[i_k]$$$ then there is no solution.
Proof
Since we need the condition $$$a[i] = max(p[i], q[i])$$$, hence $$$p[i] = a[i]$$$ or/and $$$q[i] = a[i]$$$.
If there are already $$$p[i_1] = a[i_1]$$$ and $$$q[i_2] = a[i_2]$$$ then we don't have another number equal to $$$a[i_k]$$$ because $$$p[]$$$ and $$$q[]$$$ are two permutations (each number must appear exactly
once
).
Approach
/// Storing position of each a[i]
    vector<vector<int> > b(n + 1);
    for (int i = 1; i <= n; ++i) {
        b[a[i]].push_back(i);

        /// max(p[i], q[i]) = a[i] so either p[i] = a[i] or/and q[i] = a[i]
        /// so if the number appear the third time or more, then "NO"
        if (b[a[i]].size() >= 3) {
            cout << "NO\n";
            return 0;
        }
    }
Step 2
Since we have the $$$max()$$$ function, we need to use the larger value firsts.
Proof
If we iterate from the smallest value to the top, there will be scenarios where all the remaining positions $$$i$$$ will result in $$$max(p[i], q[i]) \geq a[i]$$$ because you don't have enough smaller integers.
Approach
So for each $$$x = n \rightarrow 1$$$ (iterating from the largest element to the smallest element), we check for each position $$$i$$$ that $$$a_i = x$$$, then assign $$$p[i] := a[i]$$$ if $$$a[i]$$$ didn't appear in permutation $$$p[]$$$, otherwise assign $$$q[i] := a[i]$$$.
/// Initialize permutation p[1..n], q[1..n]
    vector<int> p(n + 1, -1), q(n + 1, -1);

    /// Initialize permutation position, fp[p[i]] = i, fq[q[i]] = i
    vector<int> fp(n + 1, -1), fq(n + 1, -1);
    for (int x = n; x >= 1; --x) {
        for (int i : b[x]) {
            /// Because of max(), we must save up the smaller value
            /// So we assign p[i] or q[i] by x, one by one from x large -> small
                 if (fp[x] == -1) p[fp[x] = i] = x;
            else if (fq[x] == -1) q[fq[x] = i] = x;
        }
    }
Step 3
We fill the remaining integers that wasn't used, from the largest to the smallest.
Approach
We use $$$vp$$$ as the largest integer not used in permutation $$$p[1..n]$$$.
We use $$$vq$$$ as the largest integer not used in permutation $$$q[1..n]$$$.
Then for each of the value $$$x = n \rightarrow 1$$$, we assign to $$$p[i], q[i]$$$ that was not used.
for (int x = n, vp = n, vq = n; x >= 1; --x) {
        for (int i : b[x]) {
            /// Assign the remaining integers
            while (fp[vp] != -1) --vp;
            while (fq[vq] != -1) --vq;
            if (p[i] == -1 && vp > 0) p[fp[vp] = i] = vp;
            if (q[i] == -1 && vq > 0) q[fq[vq] = i] = vq;
        }
    }
Step 4
Check if the permutation $$$p[]$$$ and $$$q[]$$$ satisfied the solution, if it didnt then output "NO", otherwise output "YES" and the two permutations: $$$p[1..n]$$$ and $$$q[1..n]$$$.
Approach
Just iterate through each element as normal.
for (int i = 1; i <= n; ++i) {
        if (max(p[i], q[i]) != a[i]) {
            /// Statement condition is not satisfied
            cout << "NO\n";
            return 0;
        }
    }

    /// Output the answer
    cout << "YES\n";
    for (int i = 1; i <= n; ++i) cout << p[i] << " "; cout << "\n";
    for (int i = 1; i <= n; ++i) cout << q[i] << " "; cout << "\n";
Bonus
There is also another way that you can skip testing if $$$max(p[i], q[i]) = a[i])$$$ is correct.
But the proof is a bit harder to understand, so I prefer using this code instead.
Full Code
#include <iostream>
#include <vector>

using namespace std;

int query()
{
    /// Input number of element
    int n;
    cin >> n;

    /// Input the array a[1..n]
    vector<int> a(n + 1);
    for (int i = 1; i <= n; ++i)
        cin >> a[i];

    /// Storing position of each a[i]
    vector<vector<int> > b(n + 1);
    for (int i = 1; i <= n; ++i) {
        b[a[i]].push_back(i);

        /// max(p[i], q[i]) = a[i] so either p[i] = a[i] or/and q[i] = a[i]
        /// so if the number appear the third time or more, then "NO"
        if (b[a[i]].size() >= 3) {
            cout << "NO\n";
            return 0;
        }
    }

    /// Initialize permutation p[1..n], q[1..n]
    vector<int> p(n + 1, -1), q(n + 1, -1);

    /// Initialize permutation position, fp[p[i]] = i, fq[q[i]] = i
    vector<int> fp(n + 1, -1), fq(n + 1, -1);
    for (int x = n; x >= 1; --x) {
        for (int i : b[x]) {
            /// Because of max(), we must save up the larger value
            /// So we assign p[i] or q[i] by x, one by one from x large -> small
                 if (fp[x] == -1) p[fp[x] = i] = x;
            else if (fq[x] == -1) q[fq[x] = i] = x;
        }
    }

    for (int x = n, vp = n, vq = n; x >= 1; --x) {
        for (int i : b[x]) {
            /// Assign the remaining integers
            while (fp[vp] != -1) --vp;
            while (fq[vq] != -1) --vq;
            if (p[i] == -1 && vp > 0) p[fp[vp] = i] = vp;
            if (q[i] == -1 && vq > 0) q[fq[vq] = i] = vq;
        }
    }

    for (int i = 1; i <= n; ++i) {
        if (max(p[i], q[i]) != a[i]) {
            /// Statement condition is not satisfied
            cout << "NO\n";
            return 0;
        }
    }

    /// Output the answer
    cout << "YES\n";
    for (int i = 1; i <= n; ++i) cout << p[i] << " "; cout << "\n";
    for (int i = 1; i <= n; ++i) cout << q[i] << " "; cout << "\n";
    return 0;
}



signed main()
{
    ios::sync_with_stdio(NULL);
    cin.tie(NULL);



    int q = 1; /// If there is no multiquery
    cin >> q;  /// then comment this

    while (q-->0)
    {
        /// For each query
        query();


    }



    return 0;
}
Feedback
I reached $$$O(n \log n)$$$ solution.
I reached $$$O(n)$$$ solution.
Fresh meme from SPyofgame to the intended solution of the author
Step 1
If there are at least $$$k > 3$$$ positions $$$i_1, i_2, \ldots, i_k$$$ that $$$a[i_1] = a[i_2] = \ldots = a[i_k]$$$ then there is no solution.
Proof
Since we need the condition $$$a[i] = max(p[i], q[i])$$$, hence $$$p[i] = a[i]$$$ or/and $$$q[i] = a[i]$$$.
If there are already $$$p[i_1] = a[i_1]$$$ and $$$q[i_2] = a[i_2]$$$ then we don't have another number equal to $$$a[i_k]$$$ because $$$p[]$$$ and $$$q[]$$$ are two permutations (each number must appear exactly
once
).
Approach
/// Storing position of each a[i]
    vector<vector<int> > b(n + 1);
    for (int i = 1; i <= n; ++i) {
        b[a[i]].push_back(i);

        /// max(p[i], q[i]) = a[i] so either p[i] = a[i] or/and q[i] = a[i]
        /// so if the number appear the third time or more, then "NO"
        if (b[a[i]].size() >= 3) {
            cout << "NO\n";
            return 0;
        }
    }
Proof
Since we need the condition $$$a[i] = max(p[i], q[i])$$$, hence $$$p[i] = a[i]$$$ or/and $$$q[i] = a[i]$$$.
If there are already $$$p[i_1] = a[i_1]$$$ and $$$q[i_2] = a[i_2]$$$ then we don't have another number equal to $$$a[i_k]$$$ because $$$p[]$$$ and $$$q[]$$$ are two permutations (each number must appear exactly
once
).
Approach
/// Storing position of each a[i]
    vector<vector<int> > b(n + 1);
    for (int i = 1; i <= n; ++i) {
        b[a[i]].push_back(i);

        /// max(p[i], q[i]) = a[i] so either p[i] = a[i] or/and q[i] = a[i]
        /// so if the number appear the third time or more, then "NO"
        if (b[a[i]].size() >= 3) {
            cout << "NO\n";
            return 0;
        }
    }
Step 2
Since we have the $$$max()$$$ function, we need to use the larger value firsts.
Proof
If we iterate from the smallest value to the top, there will be scenarios where all the remaining positions $$$i$$$ will result in $$$max(p[i], q[i]) \geq a[i]$$$ because you don't have enough smaller integers.
Approach
So for each $$$x = n \rightarrow 1$$$ (iterating from the largest element to the smallest element), we check for each position $$$i$$$ that $$$a_i = x$$$, then assign $$$p[i] := a[i]$$$ if $$$a[i]$$$ didn't appear in permutation $$$p[]$$$, otherwise assign $$$q[i] := a[i]$$$.
/// Initialize permutation p[1..n], q[1..n]
    vector<int> p(n + 1, -1), q(n + 1, -1);

    /// Initialize permutation position, fp[p[i]] = i, fq[q[i]] = i
    vector<int> fp(n + 1, -1), fq(n + 1, -1);
    for (int x = n; x >= 1; --x) {
        for (int i : b[x]) {
            /// Because of max(), we must save up the smaller value
            /// So we assign p[i] or q[i] by x, one by one from x large -> small
                 if (fp[x] == -1) p[fp[x] = i] = x;
            else if (fq[x] == -1) q[fq[x] = i] = x;
        }
    }
Proof
If we iterate from the smallest value to the top, there will be scenarios where all the remaining positions $$$i$$$ will result in $$$max(p[i], q[i]) \geq a[i]$$$ because you don't have enough smaller integers.
Approach
So for each $$$x = n \rightarrow 1$$$ (iterating from the largest element to the smallest element), we check for each position $$$i$$$ that $$$a_i = x$$$, then assign $$$p[i] := a[i]$$$ if $$$a[i]$$$ didn't appear in permutation $$$p[]$$$, otherwise assign $$$q[i] := a[i]$$$.
/// Initialize permutation p[1..n], q[1..n]
    vector<int> p(n + 1, -1), q(n + 1, -1);

    /// Initialize permutation position, fp[p[i]] = i, fq[q[i]] = i
    vector<int> fp(n + 1, -1), fq(n + 1, -1);
    for (int x = n; x >= 1; --x) {
        for (int i : b[x]) {
            /// Because of max(), we must save up the smaller value
            /// So we assign p[i] or q[i] by x, one by one from x large -> small
                 if (fp[x] == -1) p[fp[x] = i] = x;
            else if (fq[x] == -1) q[fq[x] = i] = x;
        }
    }
Step 3
We fill the remaining integers that wasn't used, from the largest to the smallest.
Approach
We use $$$vp$$$ as the largest integer not used in permutation $$$p[1..n]$$$.
We use $$$vq$$$ as the largest integer not used in permutation $$$q[1..n]$$$.
Then for each of the value $$$x = n \rightarrow 1$$$, we assign to $$$p[i], q[i]$$$ that was not used.
for (int x = n, vp = n, vq = n; x >= 1; --x) {
        for (int i : b[x]) {
            /// Assign the remaining integers
            while (fp[vp] != -1) --vp;
            while (fq[vq] != -1) --vq;
            if (p[i] == -1 && vp > 0) p[fp[vp] = i] = vp;
            if (q[i] == -1 && vq > 0) q[fq[vq] = i] = vq;
        }
    }
Approach
We use $$$vp$$$ as the largest integer not used in permutation $$$p[1..n]$$$.
We use $$$vq$$$ as the largest integer not used in permutation $$$q[1..n]$$$.
Then for each of the value $$$x = n \rightarrow 1$$$, we assign to $$$p[i], q[i]$$$ that was not used.
for (int x = n, vp = n, vq = n; x >= 1; --x) {
        for (int i : b[x]) {
            /// Assign the remaining integers
            while (fp[vp] != -1) --vp;
            while (fq[vq] != -1) --vq;
            if (p[i] == -1 && vp > 0) p[fp[vp] = i] = vp;
            if (q[i] == -1 && vq > 0) q[fq[vq] = i] = vq;
        }
    }
Step 4
Check if the permutation $$$p[]$$$ and $$$q[]$$$ satisfied the solution, if it didnt then output "NO", otherwise output "YES" and the two permutations: $$$p[1..n]$$$ and $$$q[1..n]$$$.
Approach
Just iterate through each element as normal.
for (int i = 1; i <= n; ++i) {
        if (max(p[i], q[i]) != a[i]) {
            /// Statement condition is not satisfied
            cout << "NO\n";
            return 0;
        }
    }

    /// Output the answer
    cout << "YES\n";
    for (int i = 1; i <= n; ++i) cout << p[i] << " "; cout << "\n";
    for (int i = 1; i <= n; ++i) cout << q[i] << " "; cout << "\n";
Approach
Just iterate through each element as normal.
for (int i = 1; i <= n; ++i) {
        if (max(p[i], q[i]) != a[i]) {
            /// Statement condition is not satisfied
            cout << "NO\n";
            return 0;
        }
    }

    /// Output the answer
    cout << "YES\n";
    for (int i = 1; i <= n; ++i) cout << p[i] << " "; cout << "\n";
    for (int i = 1; i <= n; ++i) cout << q[i] << " "; cout << "\n";
Bonus
There is also another way that you can skip testing if $$$max(p[i], q[i]) = a[i])$$$ is correct.
But the proof is a bit harder to understand, so I prefer using this code instead.
Full Code
#include <iostream>
#include <vector>

using namespace std;

int query()
{
    /// Input number of element
    int n;
    cin >> n;

    /// Input the array a[1..n]
    vector<int> a(n + 1);
    for (int i = 1; i <= n; ++i)
        cin >> a[i];

    /// Storing position of each a[i]
    vector<vector<int> > b(n + 1);
    for (int i = 1; i <= n; ++i) {
        b[a[i]].push_back(i);

        /// max(p[i], q[i]) = a[i] so either p[i] = a[i] or/and q[i] = a[i]
        /// so if the number appear the third time or more, then "NO"
        if (b[a[i]].size() >= 3) {
            cout << "NO\n";
            return 0;
        }
    }

    /// Initialize permutation p[1..n], q[1..n]
    vector<int> p(n + 1, -1), q(n + 1, -1);

    /// Initialize permutation position, fp[p[i]] = i, fq[q[i]] = i
    vector<int> fp(n + 1, -1), fq(n + 1, -1);
    for (int x = n; x >= 1; --x) {
        for (int i : b[x]) {
            /// Because of max(), we must save up the larger value
            /// So we assign p[i] or q[i] by x, one by one from x large -> small
                 if (fp[x] == -1) p[fp[x] = i] = x;
            else if (fq[x] == -1) q[fq[x] = i] = x;
        }
    }

    for (int x = n, vp = n, vq = n; x >= 1; --x) {
        for (int i : b[x]) {
            /// Assign the remaining integers
            while (fp[vp] != -1) --vp;
            while (fq[vq] != -1) --vq;
            if (p[i] == -1 && vp > 0) p[fp[vp] = i] = vp;
            if (q[i] == -1 && vq > 0) q[fq[vq] = i] = vq;
        }
    }

    for (int i = 1; i <= n; ++i) {
        if (max(p[i], q[i]) != a[i]) {
            /// Statement condition is not satisfied
            cout << "NO\n";
            return 0;
        }
    }

    /// Output the answer
    cout << "YES\n";
    for (int i = 1; i <= n; ++i) cout << p[i] << " "; cout << "\n";
    for (int i = 1; i <= n; ++i) cout << q[i] << " "; cout << "\n";
    return 0;
}



signed main()
{
    ios::sync_with_stdio(NULL);
    cin.tie(NULL);



    int q = 1; /// If there is no multiquery
    cin >> q;  /// then comment this

    while (q-->0)
    {
        /// For each query
        query();


    }



    return 0;
}
Feedback
I reached $$$O(n \log n)$$$ solution.
I reached $$$O(n)$$$ solution.
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1768B
Editorial Content:
1768B - Quick Sort
Hints
Hint 1
Try to have the last $$$k + 1$$$ numbers sorted.
Hint 2
Fix some set of numbers (not necessary sorted) of size $$$w$$$ and don't choose them in the operation. Try to have the last $$$n - w$$$ numbers sorted.
Hint 3
Fix the set of numbers $$$1,2,3,\ldots$$$
Hint 1
Try to have the last $$$k + 1$$$ numbers sorted.
Hint 2
Fix some set of numbers (not necessary sorted) of size $$$w$$$ and don't choose them in the operation. Try to have the last $$$n - w$$$ numbers sorted.
Hint 3
Fix the set of numbers $$$1,2,3,\ldots$$$
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

#define all(x) (x).begin(), (x).end()
#define allr(x) (x).rbegin(), (x).rend()
#define gsize(x) (int)((x).size())

const char nl = '\n';
typedef long long ll;
typedef long double ld;

using namespace std;

void solve() {
    int n, k;
    cin >> n >> k;
    vector<int> p(n);
    for (int i = 0; i < n; i++) cin >> p[i];
    
    int c_v = 1;
    for (int i = 0; i < n; i++) {
        if (p[i] == c_v) c_v++;
    }
    
    cout << (n  - c_v + k) / k  << nl;
}

int main() {
	ios::sync_with_stdio(0); cin.tie(0);
	
	int T;
	cin >> T;
	while (T--) solve();
}
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1768A
Editorial Content:
1768A - Greatest Convex
Hints
Hint 1
Try to brute force for $$$k < 50$$$. Do you see anything suspicious?
Hint 2
Now try to brute force from $$$k - 1$$$ to $$$0$$$ for large numbers.
Hint 1
Try to brute force for $$$k < 50$$$. Do you see anything suspicious?
Hint 2
Now try to brute force from $$$k - 1$$$ to $$$0$$$ for large numbers.
Tutorial
1768A- Greatest Convex
Is $$$x = k - 1$$$ always suitable?
The answer is yes, as $$$x! + (x - 1)! = (x - 1)! \times (x + 1) = ((k - 1) - 1)! \times ((k - 1) + 1) = (k - 2)! \times (k)$$$, which is clearly a multiple of $$$k$$$.
Therefore, $$$x = k - 1$$$ is the answer.
Time complexity: $$$\mathcal{O}(1)$$$
1768A- Greatest Convex
Solution
answer = [print(int(input()) - 1) for testcase in range(int(input()))]
Feedback
Good problem
Average problem
Bad problem
--------------------------------------------------
Problem ID: 1767F
Editorial Content:
1767F - Two Subtrees
Tutorial
Tutorial is loading...
Solution (shnirelman)
#include <bits/stdc++.h>

#define f first
#define s second

using namespace std;
using li = long long;
using ld = long double;
using pii = pair<int, int>;

const int INF = 2e9 + 13;
const li INF64 = 2e18 + 13;
const int M = 998244353;
const int A = 2e5 + 13;

const int N = 2e5 + 13;
const int B = 2000;
const int SQRTA = 500;
const int K = N / B + 113;

int val[N];
vector<int> g[N];
int sz[N];
int gr[N];
int leaf[N], group_root[N];
int par[N];
bool heavy[N];

int tin[N], tout[N], T = 0, mid[N];
int et[N];
int valet[N];


void dfs1(int v, int pr, int depth) {
    par[v] = pr;
    sz[v] = 1;

    int mx = -1;
    for(int i = 0; i < g[v].size(); i++) {
        int u = g[v][i];
        if(u != pr) {
            dfs1(u, v, depth + 1);
            sz[v] += sz[u];
            if(mx == -1 || sz[g[v][mx]] < sz[u])
                mx = i;
        }
    }

    if(mx != -1)
        swap(g[v][mx], g[v][0]);
}

void dfs2(int v) {
    et[T] = v;
    tin[v] = T++;

    for(int u : g[v]) {
        if(u != par[v])
            dfs2(u);
    }

    tout[v] = T;
}

struct Query {
    int ind;
    int v, u;
    int lv, rv, lu, ru;
    int b;

    Query() {};
};

bool cmp(const Query& a, const Query& b) {
    if(a.b != b.b)
        return a.b < b.b;
    else
        return a.lu < b.lu;
}

int cnt[A];
int block_index[A];
int block_mx[A];
int block_cnt_of_cnt[A / SQRTA + 13][A];

inline void insert(int i) {
    block_cnt_of_cnt[block_index[valet[i]]][cnt[valet[i]]]--;
    cnt[valet[i]]++;
    block_cnt_of_cnt[block_index[valet[i]]][cnt[valet[i]]]++;
    if(cnt[valet[i]] > block_mx[block_index[valet[i]]])
        block_mx[block_index[valet[i]]]++;
}

inline void erase(int i) {
    if(cnt[valet[i]] == block_mx[block_index[valet[i]]] && block_cnt_of_cnt[block_index[valet[i]]][cnt[valet[i]]] == 1)
        block_mx[block_index[valet[i]]]--;
    block_cnt_of_cnt[block_index[valet[i]]][cnt[valet[i]]]--;
    cnt[valet[i]]--;
    block_cnt_of_cnt[block_index[valet[i]]][cnt[valet[i]]]++;
}

int get_mode() {
    int mx = 0;
    for(int i = 0; i < A / SQRTA + 1; i++)
        mx = max(mx, block_mx[i]);
    for(int i = 0; ; i++) {
        if(block_mx[i] == mx) {
            for(int j = i * SQRTA; ; j++) {
                if(cnt[j] == mx)
                    return j;
            }
        }
    }
}

Query queries[N];
int ans[N];

void solve() {
    int n;
    cin >> n;

    for(int i = 0; i < n; i++)
        cin >> val[i];

    for(int i = 1; i < n; i++) {
        int v, u;
        cin >> v >> u;

        v--;
        u--;

        g[v].push_back(u);
        g[u].push_back(v);
    }

    dfs1(0, -1, 0);

    vector<pii> ord(n);
    for(int i = 0; i < n; i++) {
        ord[i] = {sz[i], i};
        gr[i] = -1;
    }

    sort(ord.begin(), ord.end());

    for(int i = 0; i < n; i++) {
        if(sz[i] >= B)
            heavy[i] = true;
    }

    int cur = 0;
    for(int i = 0; i < n; i++) {
        int v = ord[i].s;
        if(sz[v] < B || gr[v] != -1)
            continue;

        leaf[cur] = v;

        int u = v;
        while(gr[u] == -1 && sz[u] - sz[v] < B) {
            gr[u] = cur;
            group_root[cur] = u;
            u = par[u];
        }

        cur++;
    }

    dfs2(0);

    for(int i = 0; i < n; i++) {
        if(sz[i] < B) {
            gr[i] = cur + tin[i] / B;
        }
    }

    for(int i = 0; i < n; i++)
        valet[i] = val[et[i]];

    for(int i = 0; i < A; i++) {
        block_index[i] = i / SQRTA;
    }

    int q;
    cin >> q;

    for(int i = 0; i < q; i++) {
        queries[i].ind = i;
        cin >> queries[i].v >> queries[i].u;

        queries[i].v--;
        queries[i].u--;

        queries[i].lv = tin[queries[i].v];
        queries[i].rv = tout[queries[i].v];
        queries[i].lu = tin[queries[i].u];
        queries[i].ru = tout[queries[i].u];

        if(queries[i].lv > queries[i].lu) {
            swap(queries[i].v, queries[i].u);
            swap(queries[i].lv, queries[i].lu);
            swap(queries[i].rv, queries[i].ru);
        }

        queries[i].b = gr[queries[i].v];
    }

    sort(queries, queries + q, cmp);

    int lv = 0, rv = 0, lu = 0, ru = 0;
    li fir = 0, sec = 0;

    int hs = 0;
    for(int i = 0; i < q; i++) {
        int qlv = queries[i].lv;
        int qrv = queries[i].rv;
        int qlu = queries[i].lu;
        int qru = queries[i].ru;

        fir += abs(lv - qlv) + abs(rv - qrv);
        sec += abs(lu - qlu) + abs(ru - qru);

        if(queries[i].b < cur) {
            while(rv < qrv)
                insert(rv++);
            while(lv > qlv)
                insert(--lv);
            while(rv > qrv)
                erase(--rv);
            while(lv < qlv)
                erase(lv++);
        } else {
            while(rv > lv)
                erase(--rv);
            lv = qlv;
            rv = lv;
            while(rv < qrv)
                insert(rv++);
        }

        while(ru < qru)
                insert(ru++);
            while(lu > qlu)
                insert(--lu);
            while(ru > qru)
                erase(--ru);
            while(lu < qlu)
                erase(lu++);

        ans[queries[i].ind] = get_mode();
    }

    for(int i = 0; i < q; i++)
        cout << ans[i] << endl;
}

mt19937 rnd(1);

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
//    freopen("input.txt", "r", stdin);

    solve();
}
--------------------------------------------------
Problem ID: 1767E
Editorial Content:
1767E - Algebra Flash
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;


int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    vector<int> c(n);
    forn(i, n){
        scanf("%d", &c[i]);
        --c[i];
    }
    vector<int> x(m);
    forn(i, m) scanf("%d", &x[i]);
    
    vector<long long> g(m);
    forn(i, n - 1){
        g[c[i]] |= 1ll << c[i + 1];
        g[c[i + 1]] |= 1ll << c[i];
    }
    g[c[0]] |= 1ll << c[0];
    g[c[n - 1]] |= 1ll << c[n - 1];
    
    int mid = m / 2;
    vector<int> dp(1 << mid, 1e9);
    forn(mask, 1 << (m - mid)){
        long long chk = 0;
        int tot = 0;
        forn(i, m - mid){
            if ((mask >> i) & 1)
                tot += x[i + mid];
            else
                chk |= g[i + mid];
        }
        if (((chk >> mid) | mask) != mask)
            continue;
        chk &= (1ll << mid) - 1;
        dp[chk] = min(dp[chk], tot);
    }
    forn(i, mid) forn(mask, 1 << mid) if (!((mask >> i) & 1)){
        dp[mask | (1 << i)] = min(dp[mask | (1 << i)], dp[mask]);
    }
    int ans = 1e9;
    forn(mask, 1 << mid){
        long long chk = 0;
        int tot = 0;
        forn(i, mid){
            if ((mask >> i) & 1)
                tot += x[i];
            else
                chk |= g[i];
        }
        chk &= (1ll << mid) - 1;
        if ((chk | mask) != mask)
            continue;
        ans = min(ans, dp[mask] + tot);
    }
    printf("%d\n", ans);
    return 0;
}
--------------------------------------------------
Problem ID: 1767D
Editorial Content:
1767D - Playoff
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

int main() {
  int n;
  string s;
  cin >> n >> s;
  int k = count(s.begin(), s.end(), '1');
  for (int x = 1 << k; x <= (1 << n) - (1 << (n - k)) + 1; ++x)
    cout << x << ' ';
}
--------------------------------------------------
Problem ID: 1767C
Editorial Content:
1767C - Count Binary Strings
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

const int MOD = 998244353;

int add(int x, int y)
{
    x += y;
    while(x >= MOD) x -= MOD;
    while(x < 0) x += MOD;
    return x;
}

int mul(int x, int y)
{
    return (x * 1ll * y) % MOD;
}

const int N = 143;
int n;

int a[N][N];
int dp[N][N];

bool check(int cnt, int last)
{
    for(int i = 0; i < cnt; i++)
    {
        if(a[i][cnt - 1] == 0) continue;
        if(a[i][cnt - 1] == 1 && last > i) return false;
        if(a[i][cnt - 1] == 2 && last <= i) return false;
    }
    return true;
}

int main()
{
    cin >> n;
    for(int i = 0; i < n; i++)
    {
        for(int j = i; j < n; j++)
            cin >> a[i][j];
    }
    if(a[0][0] != 2) dp[1][0] = 2;
    for(int i = 1; i < n; i++)
        for(int j = 0; j < i; j++)
            for(int k : vector<int>({j, i}))
                if(check(i + 1, k))
                    dp[i + 1][k] = add(dp[i + 1][k], dp[i][j]);
    int ans = 0;
    for(int i = 0; i < n; i++)
        ans = add(ans, dp[n][i]);
    cout << ans << endl;
}
--------------------------------------------------
Problem ID: 1767B
Editorial Content:
1767B - Block Towers
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    x = a[0]
    a = sorted(a[1:])
    for y in a:
        if y > x:
            x += (y - x + 1) // 2
    print(x)
--------------------------------------------------
Problem ID: 1767A
Editorial Content:
1767A - Cut the Triangle
Tutorial
Tutorial is loading...
Solution (BledDest)
t = int(input())
for i in range(t):
    input()
    xs = []
    ys = []
    for j in range(3):
        x, y = map(int, input().split())
        xs.append(x)
        ys.append(y)
    print('YES' if len(set(xs)) == 3 or len(set(ys)) == 3 else 'NO')
--------------------------------------------------
Problem ID: 1766F
Editorial Content:
1766F - MCF
Tutorial
Tutorial is loading...
Solution (BledDest)
#include <bits/stdc++.h>     

using namespace std;

const int N = 243;

struct edge
{
    int y, c, w, f;
    edge() {};
    edge(int y, int c, int w, int f) : y(y), c(c), w(w), f(f) {};
};

vector<edge> e;
vector<int> g[N];

int rem(int x)
{
    return e[x].c - e[x].f;
}

void add_edge(int x, int y, int c, int w)
{
    g[x].push_back(e.size());
    e.push_back(edge(y, c, w, 0));
    g[y].push_back(e.size());
    e.push_back(edge(x, 0, -w, 0));
}

int n, m, s, t, v;

pair<int, long long> MCMF()
{
    int flow = 0;
    long long cost = 0;
    while(true)
    {
        vector<long long> d(v, (long long)(1e18));
        vector<int> p(v, -1);
        vector<int> pe(v, -1);
        queue<int> q;
        vector<bool> inq(v);
        q.push(s);
        inq[s] = true;
        d[s] = 0;
        while(!q.empty())
        {
            int k = q.front();
            q.pop();
            inq[k] = false;
            for(auto ei : g[k])
            {
                if(rem(ei) == 0) continue;
                int to = e[ei].y;
                int w = e[ei].w;
                if(d[to] > d[k] + w)
                {
                    d[to] = d[k] + w;
                    p[to] = k;
                    pe[to] = ei;
                    if(!inq[to])
                    {
                        inq[to] = true;
                        q.push(to);
                    }
                }
            }
        }
        if(p[t] == -1 || d[t] >= 0) break;
        flow++;
        cost += d[t];
        int cur = t;
        while(cur != s)
        {
            e[pe[cur]].f++;
            e[pe[cur] ^ 1].f--;
            cur = p[cur];
        }
    }
    return make_pair(flow, cost);
}

void no_answer()
{
    cout << "Impossible" << endl;
    exit(0);
}

int main()
{                              
    cin >> n >> m;
    vector<int> excess_flow(n, 0);
    vector<int> orc(m);
    for(int i = 0; i < m; i++)
    {
        int x, y, c, w;
        cin >> x >> y >> c >> w;
        orc[i] = c;
        --x;
        --y;
        add_edge(x, y, c / 2, w);
        if(c % 2 == 1)
        {
            excess_flow[x]--;
            excess_flow[y]++;
        }
    }
    s = n;
    t = n + 1;
    v = n + 2;
    int total_excess = 0;
    if(excess_flow[0] % 2 == -1)
    {
        excess_flow[0]--;
        excess_flow[n - 1]++;
    }
    for(int i = 0; i < n; i++)
    {
        if(excess_flow[i] % 2 != 0)
            no_answer();
        int val = abs(excess_flow[i]) / 2;
        if(excess_flow[i] > 0)
        {
            total_excess += val;
            add_edge(s, i, val, -int(1e9));
        }
        if(excess_flow[i] < 0)
        {
            add_edge(i, t, val, -int(1e9));
        }
    }
    add_edge(s, 0, 100000, 0);
    add_edge(n - 1, t, 100000, 0);
    auto ans = MCMF();
    bool good_answer = true;
    for(int x = 0; x < e.size(); x++)
        if(e[x].w == -int(1e9) && rem(x) != 0)
            good_answer = false;
    if(!good_answer)
        no_answer();
    cout << "Possible" << endl;
    for(int i = 0; i < 2 * m; i += 2)
    {
        if(i) cout << " ";
        cout << e[i].f * 2 + orc[i / 2] % 2;
    }
    cout << endl;
}
--------------------------------------------------
Problem ID: 1766E
Editorial Content:
1766E - Decomposition
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

const int N = 300043;

int n;
int v[N];
map<vector<int>, long long> dp[N];

pair<int, vector<int>> go(vector<int> a, int x)
{
    if(x == 0)
        return {1, a};
    else
    {
        bool f = false;
        for(int i = 0; i < a.size() && !f; i++)
            if((a[i] & x) > 0)
            {
                f = true;
                a[i] = x;
            }
        int c = 0;
        if(!f)
        {
            c = 1;
            a.push_back(x);
        }
        return {c, a};
    }
}

long long calc(int i, vector<int> a)
{
    if(i == n) return 0ll;
    if(dp[i].count(a)) return dp[i][a];
    auto p = go(a, v[i]);
    return (dp[i][a] = p.first * 1ll * (n - i) + calc(i + 1, p.second));
}

int main()
{
    scanf("%d", &n);
    for(int i = 0; i < n; i++) scanf("%d", &v[i]);
    long long ans = 0;
    for(int i = 0; i < n; i++)
        ans += calc(i, vector<int>(0));
    printf("%lld\n", ans);    
}
--------------------------------------------------
Problem ID: 1766D
Editorial Content:
1766D - Lucky Chains
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>

using namespace std;

#define fore(i, l, r) for(int i = int(l); i < int(r); i++)
#define sz(a) int((a).size())

typedef long long li;

const int INF = int(1e9);
const int N = int(1e7) + 5;

int mind[N];

void precalc() {
	fore (i, 0, N)
		mind[i] = i;
	
	for (int p = 2; p < N; p++) {
		if (mind[p] != p)
			continue;
		for (int d = 2 * p; d < N; d += p)
			mind[d] = min(mind[d], p);
	}
}

int x, y;

inline bool read() {
	if(!(cin >> x >> y))
		return false;
	return true;
}

vector<int> getPrimes(int v) {
	vector<int> ps;
	while (v > 1) {
		if (ps.empty() || ps.back() != mind[v])
			ps.push_back(mind[v]);
		v /= mind[v];
	}
	return ps;
}

inline void solve() {
	int d = y - x;
	if (d == 1) {
		cout << -1 << '\n';
		return;
	}
	
	int r = INF;
	for (int p : getPrimes(d))
		r = min(r, ((x + p - 1) / p) * p);
	cout << r - x << '\n';
}

int main() {
#ifdef _DEBUG
	freopen("input.txt", "r", stdin);
	int tt = clock();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(15);
	
	precalc();
	
	int t; cin >> t;
	while (t--) {
		read();
		solve();
		
#ifdef _DEBUG
		cerr << "TIME = " << clock() - tt << endl;
		tt = clock();
#endif
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1766C
Editorial Content:
1766C - Hamiltonian Wall
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	n = int(input())
	s = [input() for i in range(2)]
	pos = -1
	for i in range(n):
		if s[0][i] != s[1][i]:
			pos = i
	if pos == -1:
		print("YES")
		continue
	ok = True
	cur = 0 if s[0][pos] == 'B' else 1
	for i in range(pos + 1, n):
		if s[cur][i] == 'W':
			ok = False
		if s[cur ^ 1][i] == 'B':
			cur ^= 1
	cur = 0 if s[0][pos] == 'B' else 1
	for i in range(pos - 1, -1, -1):
		if s[cur][i] == 'W':
			ok = False
		if s[cur ^ 1][i] == 'B':
			cur ^= 1
	print("YES" if ok else "NO")
--------------------------------------------------
Problem ID: 1766B
Editorial Content:
1766B - Notepad#
Tutorial
Tutorial is loading...
Solution (awoo)
for _ in range(int(input())):
	n = int(input())
	s = input()
	cur = {}
	for i in range(n - 1):
		t = s[i:i+2]
		if t in cur:
			if cur[t] < i - 1:
				print("YES")
				break
		else:
			cur[t] = i
	else:
		print("NO")
--------------------------------------------------
Problem ID: 1766A
Editorial Content:
1766A - Extremely Round
Tutorial
Tutorial is loading...
Solution (BledDest)
def check(x):
    s = str(x)
    cnt = 0
    for c in s:
        if c != '0':
            cnt += 1
    return cnt == 1

a = []
for i in range(1, 1000000):
    if check(i):
        a.append(i)
t = int(input())
for i in range(t):
    n = int(input())
    ans = 0
    for x in a:
        if x <= n:
            ans += 1
    print(ans)
--------------------------------------------------
Problem ID: 1765N
Editorial Content:
1765N - Number Reduction
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  
  int t;
  cin >> t;
  while (t--) {
    string x;
    cin >> x;
    int k;
    cin >> k;
    int n = x.size();
    vector<vector<int>> pos(10);
    for (int i = 0; i < n; ++i)
      pos[x[i] - '0'].push_back(i);
    for (int i = 0; i < 10; ++i)
      reverse(pos[i].begin(), pos[i].end());
    string ans;
    int lst = 0, len = n - k;
    for (int i = 0; i < len; ++i) {
      for (int d = (i == 0); d <= 9; ++d) {
        while (!pos[d].empty() && pos[d].back() < lst)
          pos[d].pop_back();
        if (!pos[d].empty() && pos[d].back() - lst <= k) {
          ans += d + '0';
          k -= pos[d].back() - lst;
          lst = pos[d].back() + 1;
          break;
        }
      }
    }
    cout << ans << '\n';
  }
}
--------------------------------------------------
Problem ID: 1765M
Editorial Content:
1765M - Minimum LCM
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    int a = 1;
    for (int g = 2; g * g <= n; ++g) {
      if (n % g == 0) {
        a = n / g;
        break;
      }
    }
    cout << a << ' ' << n - a << '\n';
  }
}
--------------------------------------------------
Problem ID: 1765L
Editorial Content:
1765L - Project Manager
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

const string days[] = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};

int main() {
    cin.tie(0);
    iostream::sync_with_stdio(false);
    int n, m, k;
    cin >> n >> m >> k;
    vector<vector<char>> ds(n, vector<char>(7));
    forn(i, n){
        int t;
        cin >> t;
        forn(_, t){
            string s;
            cin >> s;
            ds[i][find(days, days + 7, s) - days] = true;
        }
    }
    vector<int> h(m);
    forn(i, m) cin >> h[i];
    vector<vector<int>> a(k);
    forn(i, k){
        int p;
        cin >> p;
        a[i].resize(p);
        forn(j, p){
            cin >> a[i][j];
            --a[i][j];
        }
    }
    int j = 0;
    vector<int> ans(k, -1), lst(k);
    int done = 0;
    vector<map<int, int>> cur(7);
    vector<set<int>> wk(n);
    forn(i, k) forn(j, 7) if (ds[a[i][0]][j])
        ++cur[j][a[i][0]];
    forn(i, k)
        wk[a[i][0]].insert(i);
    for (int d = 1;; ++d){
        if (j < m && h[j] == d){
            ++j;
            continue;
        }
        int wd = (d - 1) % 7;
        vector<int> now, sv;
        for (auto it : cur[wd]) now.push_back(it.first);
        for (int x : now){
            forn(i, 7){
                auto it = cur[i].find(x);
                if (it != cur[i].end()){
                    if (it->second == 1)
                        cur[i].erase(it);
                    else
                        --it->second;
                }
            }
            int y = *wk[x].begin();
            sv.push_back(y);
            wk[x].erase(wk[x].begin());
        }
        forn(i, now.size()){
            int y = sv[i];
            ++lst[y];
            if (lst[y] == int(a[y].size())){
                ans[y] = d;
                ++done;
                continue;
            }
            wk[a[y][lst[y]]].insert(y);
            forn(j, 7) if (ds[a[y][lst[y]]][j])
                ++cur[j][a[y][lst[y]]];
        }
        if (done == k) break;
    }
    forn(i, k) cout << ans[i] << " ";
    cout << endl;
}
--------------------------------------------------
Problem ID: 1765K
Editorial Content:
1765K - Torus Path
Tutorial
Tutorial is loading...
Solution (adedalic)
#include<bits/stdc++.h>

using namespace std;

int n;
vector< vector<int> > a;

bool read() {
    if (!(cin >> n))
        return false;
    a.resize(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            cin >> a[i][j];
    }
    return true;
}

void solve() {
    long long sum = 0;
    for (int i = 0; i < n; i++)
        sum += accumulate(a[i].begin(), a[i].end(), 0LL);
    
    int mn = a[0][n - 1];
    for (int i = 0; i < n; i++)
        mn = min(mn, a[i][n - 1 - i]);
    
    cout << sum - mn << endl;
}

int main() {
#ifdef _DEBUG
    freopen("input.txt", "r", stdin);
    int tt = clock();
#endif
    
    if(read()) {
        solve();
        
#ifdef _DEBUG
        cerr << "TIME = " << clock() - tt << endl;
        tt = clock();
#endif
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1765J
Editorial Content:
1765J - Hero to Zero
Tutorial
Tutorial is loading...
Solution (BledDest)
#include<bits/stdc++.h>

using namespace std;

int main()
{
    int n;
    scanf("%d", &n);
    vector<int> a(n), b(n);
    for(int i = 0; i < n; i++) scanf("%d", &a[i]);
    for(int i = 0; i < n; i++) scanf("%d", &b[i]);
    sort(a.begin(), a.end());
    sort(b.begin(), b.end());
    long long total = 0;
    for(int i = 0; i < n; i++)
    {
        total += n * 1ll * (a[i] + b[i]);
        total -= a[i] * 2ll * (b.end() - lower_bound(b.begin(), b.end(), a[i]));
        total -= b[i] * 2ll * (a.end() - upper_bound(a.begin(), a.end(), b[i]));
    }
    for(int i = 0; i < n; i++)
        total -= (n - 1) * 1ll * abs(a[i] - b[i]);
    cout << total << endl;
}
--------------------------------------------------
Problem ID: 1765I
Editorial Content:
1765I - Infinite Chess
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

const string al = "KQRBN";

const int INF = 1e9;

struct mv{ int dx, dy; };
struct piece{ int x, y, t; };
struct seg{ int l, r; };
struct pos{ int x, y; };

bool operator <(const pos &a, const pos &b){
    if (a.x != b.x) return a.x < b.x;
    return a.y < b.y;
}

vector<vector<mv>> mvs({
    {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}},
    {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, -1}, {1, -1}, {1, 1}, {-1, 1}},
    {{-1, 0}, {0, 1}, {1, 0}, {0, -1}},
    {{-1, -1}, {1, -1}, {1, 1}, {-1, 1}},
    {{-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}}
});

int main() {
    int sx, sy, fx, fy;
    cin >> sx >> sy >> fx >> fy;
    swap(sx, sy), swap(fx, fy);
    --sx, --fx;
    
    int k;
    cin >> k;
    vector<piece> a(k);
    forn(i, k){
        string t;
        cin >> t >> a[i].x >> a[i].y;
        swap(a[i].x, a[i].y);
        --a[i].x;
        a[i].t = al.find(t[0]);
    }
    
    sort(a.begin(), a.end(), [](const piece &a, const piece &b){
        if (a.x != b.x) return a.x < b.x;
        return a.y < b.y;
    });
    
    vector<int> base({sy, fy});
    forn(i, k) base.push_back(a[i].y);
    vector<int> ys;
    for (int y : base) for (int i = y - 16; i <= y + 16; ++i)
        ys.push_back(i);
    sort(ys.begin(), ys.end());
    ys.resize(unique(ys.begin(), ys.end()) - ys.begin());
    
    vector<vector<char>> tk(8, vector<char>(ys.size()));
    forn(i, k){
        a[i].y = lower_bound(ys.begin(), ys.end(), a[i].y) - ys.begin();
        tk[a[i].x][a[i].y] = true;
    }
    sy = lower_bound(ys.begin(), ys.end(), sy) - ys.begin();
    fy = lower_bound(ys.begin(), ys.end(), fy) - ys.begin();
    
    vector<vector<char>> bad = tk;
    
    forn(i, k){
        int x = a[i].x, y = a[i].y;
        if (a[i].t == 0 || a[i].t == 4){
            for (auto it : mvs[a[i].t]){
                int nx = x + it.dx;
                int ny = y + it.dy;
                if (0 <= nx && nx < 8)
                    bad[nx][ny] = true;
            }
        }
        else{
            for (auto it : mvs[a[i].t]){
                for (int nx = x + it.dx, ny = y + it.dy; ; nx += it.dx, ny += it.dy){
                    if (nx < 0 || nx >= 8) break;
                    if (ny < 0 || ny >= int(ys.size())) break;
                    if (tk[nx][ny]) break;
                    bad[nx][ny] = true;
                }
            }
        }
    }
    
    vector<vector<int>> d(8, vector<int>(ys.size(), INF));
    vector<vector<pos>> p(8, vector<pos>(ys.size()));
    set<pair<int, pos>> q;
    d[sx][sy] = 0;
    q.insert({0, {sx, sy}});
    while (!q.empty()){
        int x = q.begin()->second.x;
        int y = q.begin()->second.y;
        q.erase(q.begin());
        if (x == fx && y == fy){
            cout << d[x][y] << endl;
            return 0;
        }
        for (int ny : {y - 1, y, y + 1}){
            if (ny < 0 || ny >= int(ys.size())) continue;
            int dy = max(1, abs(ys[y] - ys[ny]));
            for (int nx = max(0, x - 1); nx <= min(7, x + 1); ++nx) if (!bad[nx][ny]){
                int nd = d[x][y] + dy;
                if (d[nx][ny] > nd){
                    q.erase({d[nx][ny], {nx, ny}});
                    d[nx][ny] = nd;
                    p[nx][ny] = {x, y};
                    q.insert({d[nx][ny], {nx, ny}});
                }
            }
        }
    }
    
    cout << -1 << endl;
    return 0;
}
--------------------------------------------------
Problem ID: 1765H
Editorial Content:
1765H - Hospital Queue
Tutorial
Tutorial is loading...
Solution (Neon)
#include <bits/stdc++.h>

using namespace std;

int main() {
  ios::sync_with_stdio(false); cin.tie(0);
  int n, m;
  cin >> n >> m;
  vector<int> a(n);
  for (auto &x : a) cin >> x;
  vector<vector<int>> g(n);
  for (int i = 0; i < m; ++i) {
    int x, y;
    cin >> x >> y;
    g[y - 1].push_back(x - 1);
  }
    
  vector<int> ans(n, -1);
  for (int s = 0; s < n; ++s) {
    vector<int> deg(n);
    for (int i = 0; i < n; ++i) 
      for (int j : g[i]) ++deg[j];
    priority_queue<pair<int, int>> q;
    for (int v = 0; v < n; ++v)
      if (deg[v] == 0 && v != s)
        q.push({a[v], v});
    for (int i = n; i > 0; --i) {
      if (q.empty() || q.top().first < i) {
        if (deg[s] == 0 && i <= a[s])
          ans[s] = i;
        break;
      }
      int v = q.top().second;
      q.pop();
      for (int u : g[v]) {
        --deg[u];
        if (deg[u] == 0 && u != s)
          q.push({a[u], u});
      }
    }
  }
  
  for (int &x : ans) cout << x << ' ';
}
--------------------------------------------------
Problem ID: 1765G
Editorial Content:
1765G - Guess the String
Tutorial
Tutorial is loading...
Solution (BledDest)
#include <bits/stdc++.h>     

using namespace std;

mt19937 rnd(42);
uniform_int_distribution<int> d(1, 2);

int ask(int t, int i)
{
    cout << t << " " << i + 1 << endl;
    int x;
    cin >> x;
    return x;
}

void giveAnswer(const string& s)
{
    cout << 0 << " " << s << endl;
    int x;
    cin >> x;
    assert(x == 1);
}

void guessOne(string& s, int i)
{
    int res = ask(1, i);
    if(res == 0)
        s[i] = '1';
    else
        s[i] = s[res - 1];
}

char inv(char c)
{
    if(c == '0') return '1';
    return '0';
}

void guessTwo(string& s, int i)
{
    if(s[1] == '0')
    {
        if(d(rnd) == 1)
        {
            int res = ask(1, i);
            if(res >= 2)
            {
                s[i] = s[res - 1];
                s[i - 1] = s[res - 2];
            }
            else if(res == 1)
            {
                s[i] = '0';
                s[i - 1] = '1';
            }
            else
            {
                s[i] = '1';
                guessOne(s, i - 1);
            }
        }
        else
        {
            int res = ask(2, i);
            if(res >= 2)
            {
                s[i] = inv(s[res - 1]);
                s[i - 1] = inv(s[res - 2]);
            }
            else if(res == 1)
            {
                s[i] = '1';
                s[i - 1] = '0';
            }
            else
            {
                s[i] = '0';
                guessOne(s, i - 1);
            }
        }
    }
    else
    {
        if(d(rnd) == 1)
        {
            int res = ask(1, i);
            if(res >= 2)
            {
                s[i] = s[res - 1];
                s[i - 1] = s[res - 2];
            }
            else if(res == 1)
            {
                s[i] = '0';
                guessOne(s, i - 1);
            }
            else
            {
                s[i] = '1';
                s[i - 1] = '1';
            }
        }
        else
        {
            int res = ask(2, i);
            if(res >= 2)
            {
                s[i] = inv(s[res - 1]);
                s[i - 1] = inv(s[res - 2]);
            }
            else if(res == 1)
            {
                s[i] = '1';
                guessOne(s, i - 1);
            }
            else
            {
                s[i] = '0';
                s[i - 1] = '0';
            }
        }
    }
}

int main()
{
    int t;
    cin >> t;
    for(int i = 0; i < t; i++)
    {
        int n;
        cin >> n;
        string s(n, '0');
        for(int j = 1; j < n; j += 2)
        {
            if(j == 1) guessOne(s, j);
            else guessTwo(s, j);
        }
        if(n % 2 == 1) guessOne(s, n - 1);
        giveAnswer(s);
    }
}
--------------------------------------------------
Problem ID: 1765F
Editorial Content:
1765F - Chemistry Lab
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

typedef long long li;

const li INF64 = 1e18;

struct base{
    int x, w, c;
};

li area(const base &a, const base &b){
    return (a.c + b.c) * li(abs(a.x - b.x));
}

int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    vector<base> a(n);
    forn(i, n) scanf("%d%d%d", &a[i].x, &a[i].w, &a[i].c);
    sort(a.begin(), a.end(), [](const base &a, const base &b){ return a.x > b.x; });
    vector<li> dp(n, -INF64);
    li ans = 0;
    forn(i, n){
        dp[i] = max(dp[i], -a[i].w * 200ll);
        for (int j = i + 1; j < n; ++j)
            dp[j] = max(dp[j], dp[i] + area(a[i], a[j]) * k - a[j].w * 200ll);
        ans = max(ans, dp[i]);
    }
    printf("%.15Lf\n", ans / (long double)(200));
    return 0;
}
--------------------------------------------------
Problem ID: 1765E
Editorial Content:
1765E - Exchange
Tutorial
Tutorial is loading...
Solution (BledDest)
#include <bits/stdc++.h>
 
using namespace std;

void solve() 
{
    int n, a, b;
    cin >> n >> a >> b;
    int x = (n + a - 1) / a;
    if(a > b) x = 1;
    cout << x << endl;
}

int main()
{
    int t;
    cin >> t;
    for(int i = 0; i < t; i++)
        solve();
}
--------------------------------------------------
Problem ID: 1765D
Editorial Content:
1765D - Watch the Videos
Tutorial
Tutorial is loading...
Solution (DmitryKlenov)
#include <iostream>
#include <algorithm>
using namespace std;

#define N 200000

int a[N], n, s;

bool can(int x) {
    int l = x - 1, r = n - 1;
    while (l < r) {
        if (a[r] > s - a[l]) return false;
        ++l;
        if (l < r) {
            if (a[l] > s - a[r]) return false;
            --r;
        }
    }
    return true;
}


int main() {
    long long sum = 0;
    scanf("%d %d\n", &n, &s);
    for(int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
        sum += a[i];
    }

    sort(a, a + n, greater<int>());

    int l = 1, r = n;
    while (l < r) {
        int m = (l + r) >> 1;
        if (can(m)) r = m;
        else l = m + 1;
    }

    long long ans = sum + r;
    cout << ans << endl;

    return 0;
}
--------------------------------------------------
Problem ID: 1765C
Editorial Content:
1765C - Card Guessing
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)
#define fore(i, l, r) for (int i = int(l); i < int(r); i++)

using namespace std;

const int MOD = 998244353;

int add(int a, int b){
    a += b;
    if (a >= MOD)
        a -= MOD;
    return a;
}

int mul(int a, int b){
    return a * 1ll * b % MOD;
}

int binpow(int a, int b){
    int res = 1;
    while (b){
        if (b & 1)
            res = mul(res, a);
        a = mul(a, a);
        b >>= 1;
    }
    return res;
}

int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    
    vector<int> fact(4 * n + 1);
    fact[0] = 1;
    fore(i, 1, fact.size()) fact[i] = mul(fact[i - 1], i);
    vector<int> rfact(4 * n + 1);
    rfact.back() = binpow(fact.back(), MOD - 2);
    for (int i = int(fact.size()) - 2; i >= 0; --i)
        rfact[i] = mul(rfact[i + 1], i + 1);
    
    auto cnk = [&](int n, int k){
        return mul(fact[n], mul(rfact[k], rfact[n - k]));
    };
    
    vector<vector<int>> sv(n + 1, vector<int>(5));
    forn(i, n + 1) forn(t, 5) sv[i][t] = mul(binpow(cnk(n, i), t), rfact[t]);
    
    vector<vector<vector<int>>> dp(2, vector<vector<int>>(4 * n + 1, vector<int>(5)));
    forn(ii, n + 1){
        int i = ii & 1;
        int ni = i ^ 1;
        dp[ni] = vector<vector<int>>(4 * n + 1, vector<int>(5));
        for (int t = 1; t <= 4; ++t)
            dp[ni][ii * t][t] = mul(n - ii, sv[ii][t]);
        forn(j, k + 1) for (int p = 1; p <= 4; ++p) if (dp[i][j][p]){
            dp[ni][j][p] = add(dp[ni][j][p], dp[i][j][p]);
            for (int t = 1; p + t <= 4; ++t)
                dp[ni][j + ii * t][p + t] = add(dp[ni][j + ii * t][p + t], mul(dp[i][j][p], sv[ii][t]));
        }
    }
    
    int ans = 0;
    forn(sum, k + 1){
        ans = add(ans, mul(mul(mul(
            sum < k ? 1 : 4 * n - k, 
            dp[(n & 1) ^ 1][sum][4]), 
            mul(binpow(4 * n - sum, MOD - 2), mul(rfact[4 * n], fact[4 * n - sum]))), 
            mul(fact[4], fact[sum]))
        );
    }
    
    printf("%d\n", ans);
    return 0;
}
--------------------------------------------------
Problem ID: 1765B
Editorial Content:
1765B - Broken Keyboard
Tutorial
Tutorial is loading...
Solution (vovuh)
for _ in range(int(input())):
    n = int(input())
    s = input()
    print('YES' if n % 3 != 2 and not False in [s[i * 3 + 1] == s[i * 3 + 2] for i in range(n // 3)] else 'NO')
--------------------------------------------------
Problem ID: 1765A
Editorial Content:
1765A - Access Levels
Tutorial
Tutorial is loading...
Solution (awoo)
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

int n, m, m2;
vector<vector<char>> g;

int T;
vector<int> mt;
vector<int> used;

bool try_kuhn(int v){
    if (used[v] == T)
        return false;
    used[v] = T;
    forn(u, m2) if (g[v][u] && (mt[u] == -1 || try_kuhn(mt[u]))){
        mt[u] = v;
        return true;
    }
    return false;
}

int main() {
    cin >> n >> m;
    vector<string> b(m, string(n, '0'));
    forn(i, n){
        string t;
        cin >> t;
        forn(j, m) b[j][i] = t[j];
    }
    
    vector<string> nw = b;
    sort(nw.begin(), nw.end());
    nw.resize(unique(nw.begin(), nw.end()) - nw.begin());
    m2 = nw.size();
    g.assign(m2, vector<char>(m2, 0));
    forn(i, m2) forn(j, m2) if (i != j){
        bool in = true;
        forn(k, n) in &= nw[i][k] >= nw[j][k];
        if (in) g[i][j] = 1;
    }
    
    mt.assign(m2, -1);
    used.assign(m2, -1);
    T = 0;
    int k = m2;
    forn(i, m2) if (try_kuhn(i)){
        ++T;
        --k;
    }
    
    vector<int> nxt(m2, -1);
    vector<char> st(m2, true);
    forn(i, m2) if (mt[i] != -1){
        nxt[mt[i]] = i;
        st[i] = false;
    }
    
    vector<int> gr(m2), req(m2);
    int t = 0;
    forn(i, m2) if (st[i]){
        int v = i;
        int pos = 2;
        while (v != -1){
            gr[v] = t;
            req[v] = pos;
            ++pos;
            v = nxt[v];
        }
        ++t;
    }
    assert(t == k);
    
    vector<int> num(m);
    forn(i, m) num[i] = lower_bound(nw.begin(), nw.end(), b[i]) - nw.begin();
    
    printf("%d\n", k);
    forn(i, m) printf("%d ", gr[num[i]] + 1);
    puts("");
    forn(i, m) printf("%d ", req[num[i]]);
    puts("");
    forn(i, n){
        vector<int> l(k, 1);
        forn(j, m2) if (nw[j][i] == '1')
            l[gr[j]] = max(l[gr[j]], req[j]);
        forn(j, k)
            printf("%d ", l[j]);
        puts("");
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1764H
Editorial Content:
1764H - Дореми и краски 2
Solution
Tutorial is loading...
Code
By
errorgorn
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define ii pair<int,int>
#define iii tuple<int,int,int>
#define fi first
#define se second
#define endl '\n'

#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define lb lower_bound
#define ub upper_bound

#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

mt19937 rng(chrono::system_clock::now().time_since_epoch().count());

int n,m,k;
ii arr[600005];
int ans[400005];

vector<int> uni;
int nxt[200005];
int state[200005];
int state2[200005];

bool has(int l,int r,set<int> &s){
	auto it=s.lb(l);
	return *it<r;
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin.exceptions(ios::badbit | ios::failbit);
	
	cin>>n>>m>>k;
	rep(x,0,m) cin>>arr[x].fi>>arr[x].se;
	rep(x,0,m) arr[x].fi--,arr[x].se--;
	rep(x,0,2*m) arr[x+m]=arr[x];
	
	int l=0;
	
	while (l<m){
		uni={0,n};
		rep(x,l,l+2*k) uni.pub(arr[x].fi),uni.pub(arr[x].se+1);
		sort(all(uni)); uni.erase(unique(all(uni)),uni.end());
		rep(x,0,sz(uni)-1) nxt[uni[x]]=uni[x+1];
		
		set<ii> s; for (auto it:uni) s.insert({it,it}); //position, color
		rep(x,0,sz(uni)) state[uni[x]]=state2[uni[x]]=1;
		
		vector<iii> proc; //time, position, state
		rep(x,l+k,l+2*k){
			if (s.count({arr[x].fi,arr[x].fi}) && state[arr[x].fi]){
				proc.pub({x,arr[x].fi,state[arr[x].fi]});
				state[arr[x].fi]=0;
			}
			
			while (true){
				auto it=s.ub(ii(arr[x].fi,1e9));
				if ((*it).fi>arr[x].se) break;
				
				if (arr[x].se+1<(*next(it)).fi) s.insert({arr[x].se+1,(*it).se});
				else{
					proc.pub({x,(*it).se,state[(*it).se]});
					state[(*it).se]=0;
				}
				
				s.erase(it);
			}
		}
		
		int curr=0;
		set<int> pos={n};
		for (auto [a,b]:s) if (b!=n){
			curr++;
			if (state[b]) curr+=nxt[b]-b-1;
			pos.insert(b);
		}
		
		s.clear(); for (auto it:uni) s.insert({it,it}); //color, position
		set<ii> ranges; rep(x,0,sz(uni)-1) ranges.insert({uni[x],uni[x+1]});
		
		rep(x,l+k,l){
			//merge things
			auto it=s.lb({arr[x].fi,-1});
			vector<int> v={(*it).se};
			while ((*it).fi<=arr[x].se){
				it=next(it);
				s.erase(prev(it));
				v.pub((*it).se);
			}
			
			if (sz(v)>1){
				rep(x,0,sz(v)-1){
					if (state[v[x]] && state2[v[x]]) curr-=v[x+1]-v[x]-1;
					state2[v[x]]=0;
					curr-=has(v[x],v[x+1],pos);
					ranges.erase({v[x],v[x+1]});
				}
				curr+=has(v[0],v[sz(v)-1],pos);
				s.insert({arr[x].fi,v[0]});
				ranges.insert({v[0],v[sz(v)-1]});
			}
			
			while (!proc.empty() && get<0>(proc.back())==x+k){
				int a,b,c; tie(a,b,c)=proc.back(); proc.pob();
				if (c){
					state[b]=c;
					if (state[b] && state2[b]) curr+=nxt[b]-b-1;
				}
				
				if (!pos.count(b)){
					auto it=prev(ranges.ub({b,1e9}));
					int l,r; tie(l,r)=*it;
					if (!has(l,r,pos)) curr++;
					pos.insert(b);
				}
			}
			
			ans[x]=curr;
		}
		
		
		l+=k;
	}
	
	rep(x,0,m) cout<<ans[x]<<" "; cout<<endl;
}
--------------------------------------------------
Problem ID: 1764G3
Editorial Content:
1764G3 - Дореми и идеальная пара по структурам данных (сложная версия)
Solution
Tutorial is loading...
G1 Code
By
Imakf
#include <bits/stdc++.h>

using namespace std;

#define debug(...) fprintf(stderr, __VA_ARGS__)

std::map<std::pair<int, int>, int> M;
int n;
int query(int l, int r, int k = 2) {
    if (l == r) return 1;
    if (l == 1 && r == n) {
        return n / k + 1; 
    }
    if (k == 2 && M.count(make_pair(l, r)))
        return M[make_pair(l, r)];
    printf("? %d %d %d\n",l ,r, k);
    fflush(stdout);
    int x;
    scanf("%d", &x);
    if (k == 2) {
        M[make_pair(l, r)] = x;
    }
    return x;
}

void answer(int x) {
    printf("! %d\n", x);
    fflush(stdout);
    exit(0);
}

int main() {
     scanf("%d", &n);

    int npos = 0;
    if (n % 2 == 0) {
        int l = 1, r = n, mid;
        while (l <= r) {
            mid = (l + r) >> 1;

            if (query(1, mid, n) == 2) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
            npos = r + 1;
        }
        if (npos == 1 || npos == 2) {
            if (query(2, n, n) == 1) {
                npos = 1;
            } else {
                npos = 2;
            }
        }
    }
    //answer(npos);
    //if (n & 1) {
        int l = 1, r = n - 1, mid;
        while (l <= r) {
            debug("[%d ,%d]\n",l ,r);
            mid = (l + r) >> 1;
            int lq = 2 * query(1, mid) - (mid - 1 + 1);
            int rq = 2 * query(mid + 1, n) - (n - (mid + 1) + 1);
            if (npos) {
                if (npos <= mid) --lq;
                else --rq;
            }
            if (lq > rq) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        // cut [r + 1, r + 2]
        ++r;
        // now cut [r, r + 1]
        answer(r);
   // }
}
G3 Code
By
waaitg
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
int query(int l,int r,int k){
	printf("? %d %d %d\n",l,r,k);
	fflush(stdout);int re;scanf("%d",&re);
	return re;
}
void answer(int x){
	printf("! %d\n",x);
	fflush(stdout);
}
int rt=-1;
void divide(int l,int r,int l1,int l2,int r1,int r2){
	if(l==r){
		answer(l);
		return;
	}
	if(l+1==r){
		if(r1==r2+1){
			if(query(r,n,2)==r2+1)answer(r);
			else answer(l);
		}
		else if(l1==l2+1){
			if(query(1,l,2)==l2+1)answer(l);
			else answer(r);
		}
		else{
			if(l>1){
				if(query(1,l,n)==2)answer(r);
				else answer(l);
			}
			else{
				if(query(r,n,n)==2)answer(l);
				else answer(r);
			}
		}
		return;
	}
	int mid=(l+r)>>1;
	int L=query(1,mid,2),R=query(mid+1,n,2);
	if(L*2-mid>R*2-(n-mid))divide(l,mid,L,l2,r1,R);
	else if(L*2-mid<R*2-(n-mid))divide(mid+1,r,l1,L,R,r2);
	else{
		if(~rt){
			if(rt)divide(l,mid,L,l2,r1,R);
			else divide(mid+1,r,l1,L,R,r2);
		}
		if(query(1,mid,n)==2)rt=0,divide(mid+1,r,l1,L,R,r2);
		else rt=1,divide(l,mid,L,l2,r1,R);
	}
}
int main(){
	scanf("%d",&n);
	divide(1,n,n/2+1,0,n/2+1,0);
	return 0;
}
--------------------------------------------------
Problem ID: 1764G2
Editorial Content:

--------------------------------------------------
Problem ID: 1764G1
Editorial Content:

--------------------------------------------------
Problem ID: 1764F
Editorial Content:
1764F - Дореми и экспериментальное дерево
Solution
Tutorial is loading...
Code
By
Imakf
#include <bits/stdc++.h>

#define debug(...) fprintf(stderr ,__VA_ARGS__)
#define LL long long

const int MX = 3e3 + 5;

bool vis[MX];
LL w[MX][MX] ,dis[MX];

std::vector<int> e[MX];

int size[MX];
void dfs(int x ,int f){
    size[x] = 1;
    for(auto i : e[x]){
        if(i == f) continue;
        dfs(i ,x);
        size[x] += size[i];
    }
    for(auto i : e[x]){
        if(i == f) continue;
        printf("%d %d %lld\n" ,x ,i ,(w[1][x] - w[1][i]) / size[i]);
    }
}

int main(){
    int n; scanf("%d" ,&n);
    memset(w ,-0x3f ,sizeof w);
    for(int i = 1 ; i <= n ; ++i){
        for(int j = 1 ; j <= i ; ++j){
            scanf("%lld" ,&w[i][j]);
            w[j][i] = w[i][j];
        }
    }
    memset(dis ,-0x3f ,sizeof dis);
    dis[1] = 0;
    for(int i = 1 ; i <= n ; ++i){
        int x = 0;
        for(int j = 1 ; j <= n ; ++j){
            if(!vis[j] && (!x || dis[j] > dis[x])){
                x = j;
            }
        }
        //debug("x = %d " ,x);
        //ans += dis[x];
        if(i != 1) for(int j = 1 ; j <= n ; ++j){
            if(w[j][x] == dis[x] && vis[j]){
                e[x].push_back(j);
                e[j].push_back(x);
                //debug("%d %d\n" ,x ,j);
            }
        }
        vis[x] = true;
        for(int j = 1 ; j <= n ; ++j){
            dis[j] = std::max(dis[j] ,w[x][j]);
        }
    }
    //return 0;
    dfs(1 ,1);
    return 0;
}
--------------------------------------------------
Problem ID: 1764E
Editorial Content:
1764E - Дореми и числовая прямая
Solution
Tutorial is loading...
Code
By
Imakf
#include <bits/stdc++.h>

#define debug(...) fprintf(stderr ,__VA_ARGS__)
#define LL long long
const int MX = 2e5 + 5;

int n ,s;
struct Goat{
    int x ,y ,id;
}A[MX];

bool cmp(Goat a ,Goat b){
    return a.x < b.x;
}

int mx[MX];
int calc(int id){
    if(id == 1) return A[id].x;
    int far = std::max(calc(id - 1) ,mx[id - 2]);
    return std::max(std::min(far ,A[id].x) + A[id].y ,A[id].x);
}

int ans[MX];
void solve(){
    scanf("%d%d" ,&n ,&s);
    for(int i = 1 ,x ,y ; i <= n ; ++i){
        scanf("%d%d" ,&x ,&y);
        A[i] = (Goat){x ,y ,i};
        ans[i] = false;
    }
    std::sort(A + 1 ,A + 1 + n ,cmp);
    for(int i = 1 ; i <= n ; ++i){
        mx[i] = std::max(A[i].x + A[i].y ,mx[i - 1]);
    }
    for(int i = 1 ; i < n ; ++i){
        if(A[i].x + A[i].y >= s){
            ans[A[i].id] = true;
        }
    }
    if(calc(n) >= s) ans[A[n].id] = true;
    puts(ans[1] ? "YES" : "NO");
}

int main(){
    int t; scanf("%d" ,&t);
    while(t--) solve();
    return 0;
}
--------------------------------------------------
Problem ID: 1764D
Editorial Content:
1764D - Дореми и игра с колышками
Solution
Tutorial is loading...
Code
By
Imakf
#include <cstdio>
#include <iostream>

#define LL long long

const int MX = 5000 + 233;
LL C[MX][MX] ,n ,p ,fac[MX];

void init(){
	for(int i = 0 ; i < MX ; ++i) C[i][0] = 1;
	for(int i = 1 ; i < MX ; ++i)
		for(int j = 1 ; j < MX ; ++j)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p;
	fac[0] = fac[1] = 1 % p;
	for(int i = 2 ; i < MX ; ++i) fac[i] = fac[i - 1] * i % p;
}

int main(){
	std::cin >> n >> p;
	init();
	int t = n / 2;
	LL Ans = 0;
	for(int i = t ; i <= n - 1 ; ++i){
		if((n & 1) && i == n - 1) break;
		int upper = (i == n - 1) ? n - i - 1 : n - i - 2;
		for(int j = 0 ; j <= upper ; ++j){
			Ans = (Ans + n * (2 * t - i) * C[upper][j] % p * fac[j + i - 1]) % p;
		}
	}
	std::cout << Ans << std::endl;
	return 0;
}
--------------------------------------------------
Problem ID: 1764C
Editorial Content:
1764C - Дореми и строительство города
Solution
Tutorial is loading...
Code
By
waaitg
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ch() getchar()
#define pc(x) putchar(x)
using namespace std;
template<typename T>void read(T&x){
	static char c;static int f;
	for(f=1,c=ch();c<'0'||c>'9';c=ch())if(c=='-')f=-f;
	for(x=0;c>='0'&&c<='9';c=ch()){x=x*10+(c&15);}x*=f;
}
template<typename T>void write(T x){
	static char q[64];int cnt=0;
	if(x==0)return pc('0'),void();
	if(x<0)pc('-'),x=-x;
	while(x)q[cnt++]=x%10+'0',x/=10;
	while(cnt--)pc(q[cnt]);
}
const int maxn=200005;
int a[maxn];
int main(){
	int t;read(t);
	while(t--){
		int n;read(n);
		for(int i=1;i<=n;++i)
			read(a[i]);
		sort(a+1,a+n+1);
		if(a[1]==a[n]){
			write(n/2),pc('\n');
			continue;
		}
		long long ans=0;
		for(int l=1,r=1;l<=n;l=r=r+1){
			while(r+1<=n&&a[r+1]==a[l])++r;
			ans=max(ans,1ll*(n-r)*r);
		}
		write(ans),pc('\n');
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1764B
Editorial Content:
1764B - Дореми и идеальный урок по математике
Solution
Tutorial is loading...
Code
By
waaitg
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
int a[maxn];
int gcd(int a,int b){
	return b==0?a:gcd(b,a%b);
}
int main(){
	int t;scanf("%d",&t);
	while(t--){
		int n;scanf("%d",&n);
		int tmp=0;
		for(int i=1;i<=n;++i){
			scanf("%d",&a[i]);
			tmp=gcd(tmp,a[i]);
		}
		printf("%d\n",a[n]/tmp+(a[1]==0));
	}
	return 0;
}
--------------------------------------------------
Problem ID: 1764A
Editorial Content:
1764A - Дореми и краски
Solution
Tutorial is loading...
Code
By
Imakf
#include <iostream>

void solve(){
    int n; std::cin >> n;
    for(int i = 1 ,nouse ; i <= n ; ++i){
        std::cin >> nouse;
    }
    std::cout << "1 " << n << std::endl;
}

int main(){
    int t; std::cin >> t;
    while(t--) solve();
    return 0;
}
--------------------------------------------------
Problem ID: 1763F
Editorial Content:
1763F - Edge Queries
Hint 1
What kind of graph meets the conditions given in the statement?
Answer
A graph with bridges connecting components with a hamiltonian cycle.
Answer
A graph with bridges connecting components with a hamiltonian cycle.
Hint 2
Which edges will never be counted in answer to any query?
Answer
Of course, the bridges.
Answer
Of course, the bridges.
Hint 3
Restructure the graph to be able to answer queries.
Hint 4
$$$query(u, v)$$$ on a tree can be solved efficiently via Lowest Common Ancestor (LCA).
Solution
First, let us see examples of graphs that are valid or invalid according to the statement.
Valid Graph Example
In this graph, for node $$$4$$$, the longest simple cycle is $$$4 \rightarrow 1 \rightarrow 2 \rightarrow 3 \rightarrow 4$$$.
$$$S_4 = {1, 2, 3, 4}$$$
All simple cycles from node $$$4$$$ are $$$4 \rightarrow 1 \rightarrow 2 \rightarrow 3 \rightarrow 4$$$ and $$$4 \rightarrow 1 \rightarrow 3 \rightarrow 4$$$.
$$$C_4 = {1, 2, 3, 4}$$$
So, $$$S_4 = C_4$$$. Similarly, $$$S_u = C_u$$$ for all $$$u$$$.
A tree of such components is also a valid graph!
Invalid Graph Example
Here, $$$S_4 = {1, 2, 3, 4}$$$ and $$$C_4 = {1, 2, 3, 4, 5, 6}$$$.
So, $$$S_4 \neq C_4$$$
The queries ask us to count all non-bridge edges in any simple path from $$$u$$$ to $$$v$$$.
There are many ways to proceed with the solution. We will first go into a simple one that gives more insight into the problem.
We can see our graph as a tree of BiConnected Components (BCCs).
The edges of the tree are all bridges.
Let’s define a few things before continuing further.
The first node of a BCC that is visited in the DFS tree will represent that BCC.
Let $$$rep[u]$$$ be the representative of the BCC of node $$$u$$$.
$$$cnt[u]$$$ be the number of edges in the BCC of $$$u$$$.
Root node of our tree of BCCs is $$$root$$$.
$$$lca(u, v)$$$ is the lowest common ancestor of $$$u$$$ and $$$v$$$.
With all that set, let us now look at the DFS tree.
We can build an array $$$dp$$$ to store the answer to $$$query(root, u)$$$, for all $$$u$$$, and to answer queries, we can use LCA.
In a typical LCA use case, query(u, v) would be $$$dp[u] + dp[v] - 2 * dp[lca(u, v)]$$$, But is that the case here?
Let us bring attention to a few things.
First
Is $$$u = rep[u]$$$?
Why?
If $$$u = rep[u]$$$, $$$u$$$ is the first vertex of its BCC in the DFS tree. Therefore all the edges in the BCC of $$$u$$$ will not lie in any simple path from $$$u$$$ to $$$root$$$.
Example:
In this graph, Let's say $$$root$$$ is $$$1$$$.
See that, $$$dp[3]$$$ should be $$$0$$$, and $$$dp[4]$$$ should be $$$3$$$. They are in the same BCC, but $$$3$$$ is the topmost node, that is, the representative.
Let $$$p$$$ be the parent of $$$u$$$.
So, to calculate $$$dp[u]$$$,
\begin{align} dp[u] = \begin{cases} dp[p] & \text{if $$$rep[u] = u$$$,}\\dp[rep[u]] + cnt[u] & \text{otherwise} \end{cases} \end{align}
Second
Passing through the representative of a BCC.
Let's say we have a graph of this type,
Let's choose our $$$root$$$ to be $$$0$$$ and look at node $$$6$$$.
There will be no simple path from $$$root$$$ to $$$6$$$ that uses the edges of the BCC of node $$$2$$$.
Therefore, $$$dp[6]$$$ should not include edges from the BCC of node $$$2$$$. This is already dealt with by our earlier definition of $$$dp[u]$$$!
Third
The cases of $$$query(u, v)$$$.
Now, $$$query(u, v)$$$ depends upon how $$$u$$$ and $$$v$$$ are connected in the graph. These are some significant cases.
Case 1:
$$$rep[u] = rep[v]$$$
That is, $$$u$$$ and $$$v$$$ are part of the same BCC. Therefore, the answer to $$$query(u, v)$$$ is just $$$cnt[u]$$$.
Then, we have two cases concerning $$$lca(u, v)$$$.
Case 2.1:
We must visit only one node in the BCC of $$$lca(u, v)$$$.
Case 2.2:
We must visit at least two nodes in the BCC of $$$lca(u, v)$$$.
Example: $$$u = 6, v = 5$$$
In 2.1, in any simple path from $$$u$$$ to $$$v$$$ we won’t have any edge from the BCC of $$$lca(u, v)$$$. Therefore, we don’t need to include $$$cnt[lca(u, v)]$$$ in the answer. While in 2.2, those edges will be included.
In conclusion, in this setup, we need to determine how the simple paths from $$$u$$$ to $$$v$$$ cross through the BCC of $$$lca(u,v)$$$, then the queries will be answered.
How to distinguish?
We can use binary lifting to determine which node is the lowest ancestor of $$$u$$$ in the DFS tree that is a part of the BCC of $$$lca(u, v)$$$. Similarly, we can find that node for $$$v$$$.
We can judge which of the above cases any $$$query(u, v)$$$ is based on these two nodes.
There are other ways to distinguish, including using a link-cut tree.
Or make a better graph to deal with this…
We can create a smart graph to make it so that $$$query(u, v)$$$ is $$$dp[u] + dp[v] - 2 * dp[lca(u, v)] + val[lca(u, v)]$$$, with no casework involved.
We will create virtual nodes representing each BCC. Remove all non-bridges from the graph, and connect all nodes of a BCC to its virtual node.
For example:
-->
Here $$$v$$$ is the virtual node, and all the nodes present in BCC of $$$2$$$ are directly connected to the BCC's virtual node.
Let us define the value of each actual node to be $$$0$$$ and every virtual node to be the count of edges of its BCC. Build an array $$$dp$$$ that stores the sum of the values of all vertices from $$$root$$$ to the current node.
You can go back and see how each of the cases would be dealt with by this new graph.
Valid Graph Example
In this graph, for node $$$4$$$, the longest simple cycle is $$$4 \rightarrow 1 \rightarrow 2 \rightarrow 3 \rightarrow 4$$$.
$$$S_4 = {1, 2, 3, 4}$$$
All simple cycles from node $$$4$$$ are $$$4 \rightarrow 1 \rightarrow 2 \rightarrow 3 \rightarrow 4$$$ and $$$4 \rightarrow 1 \rightarrow 3 \rightarrow 4$$$.
$$$C_4 = {1, 2, 3, 4}$$$
So, $$$S_4 = C_4$$$. Similarly, $$$S_u = C_u$$$ for all $$$u$$$.
A tree of such components is also a valid graph!
Invalid Graph Example
Here, $$$S_4 = {1, 2, 3, 4}$$$ and $$$C_4 = {1, 2, 3, 4, 5, 6}$$$.
So, $$$S_4 \neq C_4$$$
First
Is $$$u = rep[u]$$$?
Why?
If $$$u = rep[u]$$$, $$$u$$$ is the first vertex of its BCC in the DFS tree. Therefore all the edges in the BCC of $$$u$$$ will not lie in any simple path from $$$u$$$ to $$$root$$$.
Example:
In this graph, Let's say $$$root$$$ is $$$1$$$.
See that, $$$dp[3]$$$ should be $$$0$$$, and $$$dp[4]$$$ should be $$$3$$$. They are in the same BCC, but $$$3$$$ is the topmost node, that is, the representative.
Let $$$p$$$ be the parent of $$$u$$$.
So, to calculate $$$dp[u]$$$,
\begin{align} dp[u] = \begin{cases} dp[p] & \text{if $$$rep[u] = u$$$,}\\dp[rep[u]] + cnt[u] & \text{otherwise} \end{cases} \end{align}
Why?
If $$$u = rep[u]$$$, $$$u$$$ is the first vertex of its BCC in the DFS tree. Therefore all the edges in the BCC of $$$u$$$ will not lie in any simple path from $$$u$$$ to $$$root$$$.
Second
Passing through the representative of a BCC.
Let's say we have a graph of this type,
Let's choose our $$$root$$$ to be $$$0$$$ and look at node $$$6$$$.
There will be no simple path from $$$root$$$ to $$$6$$$ that uses the edges of the BCC of node $$$2$$$.
Therefore, $$$dp[6]$$$ should not include edges from the BCC of node $$$2$$$. This is already dealt with by our earlier definition of $$$dp[u]$$$!
Third
The cases of $$$query(u, v)$$$.
Now, $$$query(u, v)$$$ depends upon how $$$u$$$ and $$$v$$$ are connected in the graph. These are some significant cases.
Case 1:
$$$rep[u] = rep[v]$$$
That is, $$$u$$$ and $$$v$$$ are part of the same BCC. Therefore, the answer to $$$query(u, v)$$$ is just $$$cnt[u]$$$.
Then, we have two cases concerning $$$lca(u, v)$$$.
Case 2.1:
We must visit only one node in the BCC of $$$lca(u, v)$$$.
Case 2.2:
We must visit at least two nodes in the BCC of $$$lca(u, v)$$$.
Example: $$$u = 6, v = 5$$$
In 2.1, in any simple path from $$$u$$$ to $$$v$$$ we won’t have any edge from the BCC of $$$lca(u, v)$$$. Therefore, we don’t need to include $$$cnt[lca(u, v)]$$$ in the answer. While in 2.2, those edges will be included.
How to distinguish?
We can use binary lifting to determine which node is the lowest ancestor of $$$u$$$ in the DFS tree that is a part of the BCC of $$$lca(u, v)$$$. Similarly, we can find that node for $$$v$$$.
We can judge which of the above cases any $$$query(u, v)$$$ is based on these two nodes.
There are other ways to distinguish, including using a link-cut tree.
Or make a better graph to deal with this…
We can create a smart graph to make it so that $$$query(u, v)$$$ is $$$dp[u] + dp[v] - 2 * dp[lca(u, v)] + val[lca(u, v)]$$$, with no casework involved.
We will create virtual nodes representing each BCC. Remove all non-bridges from the graph, and connect all nodes of a BCC to its virtual node.
For example:
-->
Here $$$v$$$ is the virtual node, and all the nodes present in BCC of $$$2$$$ are directly connected to the BCC's virtual node.
Let us define the value of each actual node to be $$$0$$$ and every virtual node to be the count of edges of its BCC. Build an array $$$dp$$$ that stores the sum of the values of all vertices from $$$root$$$ to the current node.
You can go back and see how each of the cases would be dealt with by this new graph.
--------------------------------------------------
Problem ID: 1763E
Editorial Content:
1763E - Node Pairs
Hint 1
In a directed graph, which nodes are reachable from each other? How many such pairs of nodes exist?
Hint 2
Think about a sequence of SCCs.
Solution
For two nodes $$$u$$$ and $$$v$$$ to be reachable from each other, they must lie in the same strongly connected component (SCC). Let's define $$$f(i)$$$ as the minimum number of nodes required to construct an $$$i$$$-reachable graph. We can use dynamic programming and calculate $$$f(i)$$$ as $$$f(i) = \min(f(i — \frac{s (s — 1)}{2}) + s)$$$ over all the valid SCC sizes $$$s$$$ for which $$$\frac{s (s — 1)}{2} \leq i$$$, i.e., over those $$$s$$$ which have less pairs of the required type than $$$i$$$. Thus, $$$f(p)$$$ gives us the minimum number of nodes required to create a $$$p$$$-reachable graph.
In all $$$p$$$-reachable graphs with $$$f(p)$$$ nodes, the upper bound on the number of unidirectional pairs of nodes is $$$\binom{f(p)}{2} - p$$$, because we have exactly $$$p$$$ pairs of nodes which are reachable from each other. It is possible to achieve this upper bound using the following construction: let $$$s_1, s_2, \ldots, s_k$$$ be any sequence of SCC sizes which agrees with the dp values we calculated earlier. Let the first SCC contain the nodes $$$[1, s_1]$$$, the second one contain $$$[s_1 + 1, s_1 + s_2]$$$, and so on. We add a directed edge from $$$u$$$ to $$$v$$$ if $$$u < v$$$.
Time Complexity: $$$\mathcal{O}(p\sqrt{p})$$$
Code
#include <bits/stdc++.h>
using namespace std;

const int INF = 1e9;

void solve()
{
    int p;
    cin >> p;
 
    vector<int> dp(p + 1, INF);
    dp[0] = 0;
    for (int i = 1; i <= p; ++i)
        for (int s = 1; (s * (s - 1)) / 2 <= i; ++s)
            dp[i] = min(dp[i], dp[i - (s * (s - 1)) / 2] + s);

    cout << dp[p] << ' ' << ((long long) dp[p] * (dp[p] - 1)) / 2 - p << '\n';
}
 
int main()
{
    solve();
    return 0;
}
--------------------------------------------------
Problem ID: 1763D
Editorial Content:
1763D - Valid Bitonic Permutations
Hint 1
Can you solve the problem when $$$x < y$$$?
Spoiler
When $$$x > y$$$, perform $$$i'=n-j+1$$$, $$$j'=n-i +1$$$, $$$x' = y$$$, and $$$y' = x$$$.
Spoiler
When $$$x > y$$$, perform $$$i'=n-j+1$$$, $$$j'=n-i +1$$$, $$$x' = y$$$, and $$$y' = x$$$.
Hint 2
Can you solve the problem for a fixed value of $$$k$$$?
Spoiler
Iterate over possible values of $$$k$$$. The total count is the sum of the individual counts.
Spoiler
Iterate over possible values of $$$k$$$. The total count is the sum of the individual counts.
Hint 3
Club the remaining numbers into ranges as follows: $$$[1,x-1]$$$, $$$[x+1,y-1]$$$, and $$$[y+1,n-1]$$$.
Solution
For simplicity, if $$$x > y$$$, perform $$$i' = n-j+1$$$, $$$j' = n-i+1$$$, $$$x' = y$$$, and $$$y' = x$$$. Hereafter, the variables $$$i$$$, $$$j$$$, $$$x$$$, and $$$y$$$, will refer to these values. Now, $$$i < j$$$ and $$$x < y$$$.
For now, assume that $$$y < n$$$. We shall consider the case where $$$y = n$$$ at a later stage.
Let us consider solving the problem for fixed $$$k$$$. Valid values for $$$k$$$ are $$$[2,i-1]$$$, $$$[i+1,j-1]$$$, $$$[j+1,n-1]$$$.
If we think about it, when $$$x < y$$$, $$$k$$$ cannot lie in the range $$$[2, i-1]$$$. So, we can discard them as possible values for $$$k$$$.
Let us consider the case where $$$k$$$ belongs to $$$[i+1,j-1]$$$.
The permutation adheres to the following pattern: $$$B_1 < .. < B_i = x < .. < B_k = n > .. > B_j = y > .. > B_n$$$.
Numbers to the left of $$$i$$$ must lie in the range $$$[1,x-1]$$$. We choose $$$i-1$$$ elements from $$$[1,x-1]$$$ and place them to the left of $$$i$$$. There are $$${x-1 \choose i-1}$$$ ways to do this. The remaining $$$x-i$$$ elements from $$$[1,x-1]$$$ lie to the right of $$$j$$$ by default.
Numbers to the right of $$$j$$$ must lie in the range $$$[1,x-1]$$$ or $$$[x+1,y-1]$$$. Since numbers in the range $$$[1,x-1]$$$ have already been placed, therefore, we choose numbers in the range $$$[x+1,y-1]$$$, and place them in the $$$n-j-(x-i)$$$ remaining positions. There are $$${y-x-1 \choose n-j-(x-i)}$$$ ways to do this. The remaining elements in the range $$$[x+1,y-1]$$$ lie between $$$i$$$ and $$$k$$$ by default.
Numbers between $$$k$$$ and $$$j$$$ must lie in the range $$$[y+1,n-1]$$$. We choose $$$j-k-1$$$ elements from $$$[y+1,n-1]$$$ and place them between $$$k$$$ and $$$j$$$. There are $$${n-y-1 \choose j-k-1}$$$ ways to do this. Afterwards, the remaining elements in the range lie between $$$i$$$ and $$$k$$$ by default, and the permutation is full.
Multiplying the ways for the above three actions, we get that the answer for a fixed $$$k$$$, when between $$$i$$$ and $$$j$$$ as:
$$${x-1 \choose i-1} * {y-x-1 \choose n-j-(x-i)} * {n-y-1 \choose j-k-1}$$$
Let us consider the case where $$$k$$$ belongs to the range $$$[j+1,n-1]$$$.
The permutation adheres to the following pattern: $$$B_1 < .. < B_i = x < .. < B_j= y < .. < B_k = n > .. > B_n$$$.
Similar to above, the numbers to the left of $$$i$$$ must lie in the range $$$[1,x-1]$$$. We choose $$$i-1$$$ elements from $$$[1,x-1]$$$, and place them to the left of $$$i$$$. The remaining $$$x-i$$$ elements from $$$[1,x-1]$$$ lie to the right of $$$k$$$ by default.
Numbers between $$$i$$$ and $$$j$$$ must lie in the range $$$[x+1,y-1]$$$. We choose $$$j-i-1$$$ elements from $$$[x+1,y-1]$$$ and place them between $$$i$$$ and $$$j$$$. There are $$${y-x-1 \choose j-i-1}$$$ ways to do this, and the remaining elements from $$$[x+1,y-1]$$$ lie to the right of $$$k$$$ by default.
Numbers between $$$j$$$ and $$$k$$$ must lie in the range $$$[y+1,n-1]$$$. We choose $$$k-j-1$$$ elements from $$$[y+1,n-1]$$$ and place them in these positions. Afterwards, the remaining elements in the range get placed to the right of $$$k$$$ by default, and the permutation is full.
Multiplying the ways for the above three actions, we get the answer for a fixed $$$k$$$, when between $$$j+1$$$, and $$$n-1$$$ as:
$$${x-1 \choose i-1} * {y-x-1 \choose j-i-1} * {n-y-1 \choose k-j-1}$$$
The answer to the problem is the sum of individual answers for all iterated values of $$$k$$$.
$$$ans = {x-1 \choose i-1} * {y-x-1 \choose n-j-(x-i)} * \sum_{k=i+1}^{j-1} {n-y-1 \choose j-k-1}$$$ + $$${x-1 \choose i-1} * {y-x-1 \choose j-i-1} * \sum_{k=j+1}^{n-1} {n-y-1 \choose k-j-1}$$$
Let us now consider the case where $$$y = n$$$.
The permutation adheres to the following pattern: $$$B_1 < .. < B_i = x < .. < B_j = B_k = n > .. > B_n$$$.
Again, the numbers to the left of $$$i$$$ must lie in the range $$$[1,x-1]$$$. We choose $$$i-1$$$ elements from $$$[1,x-1]$$$ and place them to the left of $$$i$$$. The remaining $$$x-i$$$ elements from $$$[1,x-1]$$$ lie to the right of $$$j$$$ (here, $$$k$$$) by default.
Numbers between $$$i$$$ and $$$j$$$ must lie in the range $$$[x+1,y-1]$$$. We choose $$$j-i-1$$$ elements form $$$[x+1,y-1]$$$ and place them between $$$i$$$ and $$$j$$$. The remaining elements from $$$[x+1,y-1]$$$ lie to the right of $$$j$$$ (here, $$$k$$$) by default, and the permutation is full.
Multiplying the ways for the above two actions, we get the answer for $$$k = j$$$ ($$$y = n$$$) as:
$$${x-1 \choose i-1} * {y-x-1 \choose j-i-1}$$$
With $$$O(n_{max}*log(10^9+7-2))$$$ precomputation for factorials and their modular inverses, each individual test can be solved as above in $$$O(n)$$$. Therefore, the overall complexity of this approach is $$$O(n_{max}*log(10^9+7-2) + t*n)$$$, but the constraints allowed for slower solutions as well.
$$$Bonus:$$$ Can you solve the problem when $$$1 \le t, n \le 10^5$$$.
Code
#include <iostream>
#include <vector>
using namespace std;

const int MOD = 1000000007;
vector<int> fac;
vector<int> ifac;

int binExp(int base, int exp) {
    base %= MOD;
    int res = 1;
    while (exp > 0) {
        if (exp & 1) {
            res = (int) ((long long) res * base % MOD);
        }
        base = (int) ((long long) base * base % MOD);
        exp >>= 1;
    }
    return res;
}

void precompute(int n) {
    fac.resize(n + 1);
    fac[0] = fac[1] = 1;
    for (int i = 2; i <= n; i++) {
        fac[i] = (int) ((long long) i * fac[i-1] % MOD);
    }

    ifac.resize(n + 1);
    for (int i = 0; i < fac.size(); i++) {
        ifac[i] = binExp(fac[i], MOD - 2);
    }
    return;
}

int nCr(int n, int r) {
    if ((n < 0) || (r < 0) || (r > n)) {
        return 0;
    }
    return (int) ((long long) fac[n] * ifac[r] % MOD * ifac[n - r] % MOD);
}

int countValidBitonicPerm(int n, int i, int j, int x, int y) {
    if (x > y) {
        i = n - i + 1;
        j = n - j + 1;
        swap(i, j);
        swap(x, y);
    }

    int sum = 0;
    for (int k = i + 1; k < j; k++) {
        sum += nCr(n - y - 1, j - k - 1);
        sum %= MOD;
    }
    int count = (int) ((long long) nCr (x - 1, i - 1) * nCr(y - x - 1, n - j - (x - i)) % MOD * sum % MOD);

    sum = 0;
    for (int k = j + 1; k < n; k++) {
        sum += nCr(n - y - 1, k - j - 1);
        sum %= MOD;
    }
    count += (int) ((long long) nCr(x - 1, i - 1) * nCr(y - x - 1, j - i - 1) % MOD * sum % MOD);
    count %= MOD;

    if (y == n) {
        if (j == n) {
            return 0;
        } else {
            return (int) ((long long) nCr(x - 1, i - 1) * nCr(y - x - 1, j - i - 1) % MOD);
        }
    }
    
    return count;
}

int main() {
    const int MAXN = 100;
    precompute(MAXN);

    int testCases;
    cin >> testCases;
    for (int test = 1; test <= testCases; test++) {
        int n, i, j, x, y;
        cin >> n >> i >> j >> x >> y;
        cout << countValidBitonicPerm(n, i, j, x, y) << endl;
    }

    return 0;
}
--------------------------------------------------
Problem ID: 1763C
Editorial Content:
1763C - Another Array Problem
Hint 1
What happens when we apply the same operation twice?
Hint 2
What about n = 3 ?
Solution
Let’s first consider the case for $$$n \geq 4$$$. The key observation to make here is that we can make all the elements of a subarray $$$a_l,...a_r$$$ zero by applying the operation on range $$$[l,r]$$$ twice. Then let’s assume the maximum element $$$mx$$$ of the array is at an index $$$m > r$$$. We can apply the operation on the range $$$[l,m]$$$ and turn all its elements into $$$mx$$$.
Using the above information we can see that to achieve the final array with maximum sum we need to make all the elements in it equal to the maximum element in the array. Regardless of the given array this can be achieved by making the last two elements (n-1,n) zero. Then applying the operation on subarray $$$[m,n]$$$ to make all its elements equal to $$$mx$$$. Then making the first two elements (1,2) zero and applying the operation on the whole array making all the elements equal to $$$mx$$$. Thus the maximum sum for the final array will always be $$$n*mx$$$. (In case $$$m = n-1$$$ or $$$n$$$, we can operate on the left side first to reach the same solution).
For $$$n = 2$$$ the maximum final sum would be $$$\max(a_1+a_2, 2*(|a_1-a_2|))$$$.
For $$$n=3$$$, when the maximum element is present at index $$$1$$$ or $$$3$$$ we can make all the elements of the array into $$$mx$$$. When the maximum element is at index $$$2$$$, we have the following options.
Case 1: We can apply the operation on (1,2), then we can convert all the elements of the array into $$$ \max(a_3,|a_2-a_1|)$$$.
Case 2: We can apply the operation on (2,3), then we can convert all the elements of the array into $$$ \max(a_1,|a_2-a_3|)$$$.
Case 3: We can apply the operation on (1,3) making all the elements in the array $$$|a_1-a_3|$$$. This is redundant since $$$a_2 > a_1,a_3$$$ either case 1 or case 2 will give a larger sum as $$$a_2 - \min(a_1,a_3) > \max(a_1,a_3) - \min(a_1,a_3)$$$.
Now considering case 1, if $$$ 3* \max(a_3,|a_2-a_1|) \leq a_1+a_2+a_3 $$$ the maximum sum possible would be the current sum of the array (see sample 1 and 3). Therefore no operations are required. Similar case for case 2.
So the maximum possible sum for $$$n=3$$$ will be $$$\max(3*a_1, 3*a_3, 3*|a_1-a_2|, 3*|a_3-a_2|,a_1+a_2+a_3)$$$.
To avoid doing this casework for $$$n = 3$$$, we can see that there are only 3 possible operations -> (1,2) , (2,3), (1,3). We will be required to perform operations (1,2) and (2,3) at most two times. So we can brute force all possible combinations of operations [(1,2),(1,2),(2,3),(2,3),(1,3)] to find the maximum sum.
Brute force solution
186019483
Author:
satyam343
--------------------------------------------------
Problem ID: 1763B
Editorial Content:
1763B - Incinerate
Hint 1
What if the array $$$p$$$ was sorted?
Hint 2
Is it necessary to decrease the health of each monster manually after every attack?
Solution 1
Sort the monsters in ascending order of their powers.
Now we iterate through the monsters while maintaining the current attack power and the total damage dealt.
Only the monsters with health greater than the total damage dealt are considered alive, and every time we encounter such a monster it will be the weakest one at the current time, thus we need to attack until the total damage dealt exceeds the current monster's health while lowering our attack power by its power each time.
If we can kill all the monsters in this way, the answer is YES, otherwise it is NO.
Time Complexity: $$$O(nlogn)$$$
Sort by power solution
Code
Author:
DreadArceus
Solution 2
Sort the monsters in ascending order of their health.
Now we maintain a count of monsters alive after each attack. This could be achieved by applying $$$upper bound()$$$ on $$$h$$$ array for each attack. The total damage dealt could be stored and updated in a separate variable.
To find the power of the weakest monster alive, we could just precompute the minimum power of monsters in a suffix array. In other words,
$$$p_i = \min(p_i, p_{i+1}).$$$
Time Complexity: $$$O(nlogn)$$$
Sort by health solution
Code
Author:
og_
--------------------------------------------------
Problem ID: 1763A
Editorial Content:
1763A - Absolute Maximization
Hint 1
Which $$$1$$$s in the binary representation cannot be changed to $$$0$$$.
Hint 2
Similarly, Which $$$0$$$s in the binary representation cannot be changed to $$$1$$$.
Need more hints?
Considering the last two hints, try to maximize the maximum element and minimize the minimum element.
Solution
In the minimum element, we want to make every bit $$$0$$$ when possible, it won't be possible to set a particular bit to $$$0$$$ when that bit is set in all the elements of $$$a$$$. Therefore, the minimum value we can achieve after performing the operations is the bitwise AND of all the elements of $$$a$$$.
In the maximum element, we want to make every bit $$$1$$$ when possible, it won’t be possible to set a particular bit to $$$1$$$ when that bit is not set in any of the elements of $$$a$$$. Therefore, the maximum value we can achieve after performing the operations is the bitwise OR of all the elements of $$$a$$$.
Therefore the answer is (OR of the array — AND of the array).
Time Complexity: $$$O(n)$$$
--------------------------------------------------
Problem ID: 1762G
Editorial Content:
1762G - Неравные соседние элементы
Hint 1
Answer is NO only when there exists an element of $$$a$$$ which occurs more that $$$\lceil \frac{n}{2} \rceil$$$ times.
Hint 2
Let us say an array $$$b$$$ is beautiful if length of $$$b$$$ is odd and mode(say $$$x$$$) of $$$b$$$ occurs exactly $$$\lceil \frac{n}{2} \rceil$$$ times.
If $$$a$$$ is beautiful, there exists only one permutation.
We have rearrange such that $$$x$$$ occupies all the odd indices and keep the elements at even indices such that condition $$$2$$$ in satisfied.
Hint 3
To solve the original problem, we will divide the array $$$a$$$ into multiple beautiful subarrays and arrange the elements in those subarrays.
Solution
Let us continue from where we left off.
So our motivation is to break the original array into multiple beautiful subarrays and the elements in those subarrays, as mentioned before. Now for condition $$$1$$$ to be satisfied, we should not have two adjacent subarrays such that the elements at the end positions of both subarrays(after rearranging the elements) are the same.
Here is one construction using which we can achieve our goal.
Suppose $$$l$$$ denotes the leftmost point of our concerned subarray.
If $$$a_l \neq a_{l+1}$$$, we move forward, as subarray $$$a[l,l]$$$ is good.
Otherwise, we keep moving towards the right till index $$$r$$$(here, $$$r$$$ should be the smallest possible) such that the subarray $$$a[l,r]$$$ is beautiful and $$$a_l \neq a_{r+1}$$$. So it is easy to notice the following observations about the subarray $$$a[l,r]$$$
length of this subarray is odd
$$$a_l$$$ occurs exactly $$$\lceil \frac{r-l+1}{2} \rceil$$$ times in this subarray
Now we can rearrange the elements of this subarray $$$a[l,r]$$$.
Do note that the subarray $$$a[1,r]$$$ satisfies both the conditions stated in the statement.
So our task is to make the subarray $$$a[r+1,n]$$$ good now.
We can now update $$$l=r+1$$$ and continue searching for the corresponding $$$r$$$ and so on.
Now it might be the case that we did not get a valid $$$r$$$ for the last search.
From here, I assume we did not get valid $$$r$$$ for the last search. We could print the obtained permutation if we got it, as $$$a$$$ would satisfy both conditions.
Assume that we had started at $$$pos=l$$$ and couldn't find $$$r$$$.
Subarray $$$a[1,pos-1]$$$ is already good.
To fix this issue, we will do a similar search that we did before.
We start from the back(from index $$$n$$$) and move towards left till index $$$m$$$ such that
$$$m < pos$$$
$$$a[m,n]$$$ is beautiful
$$$a_{pos}$$$ occurs exactly $$$\lceil \frac{n-m+1}{2} \rceil$$$ times in this subarray
$$$a_{pos} \neq a_{m-1}$$$
Now we arrange elements of this subarray in the same fashion that we did before.
Are we done?
No. First, we must prove that we will always get some $$$m$$$.
Let us have function $$$f(a,l,r,x)$$$, which denotes the score of the subarray $$$a[l,r]$$$ for the element $$$x$$$. $$$f(a,l,r,x)=freq_x-(r-l+1-freq_x)$$$, where $$$freq_x$$$ denotes the frequency of element $$$x$$$ in the subarray $$$a[l,r]$$$
It is easy to note that $$$f(a,pos,n,a_{pos}) > 1$$$
(Hint $$$ — $$$ Prove that $$$f(a,pos,r,a_{pos}) \neq 0$$$ for $$$pos \leq r \leq n$$$. Why?(If it does then $$$a[pos,r-1]$$$ would be beautiful ))
Now we start from the back and move towards the right to find $$$m$$$ with $$$n$$$ as our right endpoint of the concerned subarray.
Note that $$$f(a,1,n,a_{pos}) \leq 1$$$ (Why? $$$a_{pos}$$$ would have occurred at most $$$\lceil \frac{n}{2} \rceil$$$ times in $$$a$$$)
So while moving from $$$pos$$$ to $$$1$$$ we will indeed find a $$$m$$$ such that $$$f(a,m,n,a_{pos})=1$$$, and $$$a_{m-1} \neq a_{pos}$$$ (assuming $$$a_0=-1$$$)
Are we done?
Not still :p. We can observe that condition $$$1$$$ is satisfied, but sometimes condition $$$2$$$ would not be. For example, simulate the above approach on the array $$$a=[1,1,2,3,3]$$$.
How to fix this issue? It's pretty easy to fix this issue.
Hint
Instead of rearranging the subarray $$$a[m,n]$$$, we will rearrange the subarray $$$a[m-1,n]$$$.
How to rearrange?
Okay, time for one more hint.
What will be the answer for $$$a=[1,1,2,3,3]$$$?
Answer
$$$p=[1,4,2,5,3]$$$
You can refer to the attached code for implementation details.
Hint
Instead of rearranging the subarray $$$a[m,n]$$$, we will rearrange the subarray $$$a[m-1,n]$$$.
How to rearrange?
Okay, time for one more hint.
What will be the answer for $$$a=[1,1,2,3,3]$$$?
Answer
$$$p=[1,4,2,5,3]$$$
Answer
$$$p=[1,4,2,5,3]$$$
Code
#include <bits/stdc++.h>     
using namespace std;  
#define ll long long  
#define all(x) x.begin(),x.end()     
void solve(){    
    ll n; cin>>n;
    vector<ll> a(n+5),freq(n+5,0);
    for(ll i=1;i<=n;i++){
        cin>>a[i]; freq[a[i]]++;
    }
    for(ll i=1;i<=n;i++){
        ll till=(n+1)/2;
        if(freq[i]>till){
            cout<<"NO\n";
            return;
        }
    }
    cout<<"YES\n";
    vector<ll> ans;
    ll cur=1;
    while(cur<=n){
        ll val=a[cur];
        vector<ll> v1,v2;
        while(cur<=n){
            if(a[cur]==val){
                v1.push_back(cur);
            }
            else{
                v2.push_back(cur);
            }
            if(v1.size()==v2.size()){
                for(ll i=0;i<v1.size();i++){
                    ans.push_back(v1[i]); ans.push_back(v2[i]);
                }
                ans.pop_back();
                break; 
            }
            if(cur==n){
                while(1){
                    if(ans.empty()||v1.size()==v2.size()){
                        sort(all(v1)); sort(all(v2));
                        if(v1.size()!=v2.size()){
                            ans.push_back(v1[0]);
                            v1.erase(v1.begin());
                        }
                        if(!v2.empty()&&!ans.empty()){
                            if(a[ans.back()]==a[v2[0]]){
                                swap(v1,v2);
                            }
                        }
                        for(ll i=0;i<v1.size();i++){
                            ans.push_back(v2[i]); ans.push_back(v1[i]);  
                        }
                        break;
                    }
                    if(a[ans.back()]==val){
                        v1.push_back(ans.back());
                    }
                    else{
                        v2.push_back(ans.back());
                    }
                    ans.pop_back();
                }
                cur=n+1;
            }
            cur++;
        }
    }
    for(auto it:ans){
        cout<<it<<" ";
    }
    cout<<"\n";
    return;                                
}                                                
int main()                                                                                             
{                          
    ll test_cases=1;               
    cin>>test_cases;
    while(test_cases--){
        solve();
    } 
}
--------------------------------------------------
Problem ID: 1762F
Editorial Content:
1762F - Хорошие пары
Hint 1
We should have $$$|a_{i_j}-a_{i_{j+1}}| \leq k$$$. This seems a bit hard, as we can have $$$a_{i_{j+1}}$$$ greater than, smaller than or equal to $$$a_{i_j}$$$.
Why not solve the easier version first?
A pair $$$(l,r)$$$ is
good
if there exists a sequence of indices $$$i_1, i_2, \dots, i_m$$$ such that
$$$i_1=l$$$ and $$$i_m=r$$$;
$$$i_j < i_{j+1}$$$ for all $$$1 \leq j < m$$$; and
$$$0 < a_{i_j}-a_{i_{j+1}} \leq k$$$ for all $$$1 \leq j < m$$$.
Suppose $$$F(a,k)$$$ number of pairs $$$(l,r)$$$ ($$$1 \leq l < r \leq n$$$) that are good.
Find $$$F(a,k)$$$.
Hint 2
To solve the problem in hint $$$1$$$, let us define $$$dp_i$$$ as the number of pairs $$$j(i<j)$$$ such that $$$(i,j)$$$ is good.
Let us move from $$$i=n$$$ to $$$1$$$. To find $$$dp_i$$$, let us first find the smallest index $$$j$$$ such that $$$a_j$$$ lies in range $$$[a_i+1,a_i+k]$$$.
We can observe that $$$dp_i=dp_j+f(i,a_i+1,a_j)$$$, where $$$f(i,l,r)$$$ gives us the number of indices $$$x$$$ among last $$$i$$$ elements of $$$a$$$ such that $$$a_x$$$ lies in the range $$$[l,r]$$$. We can use fenwik tree or ordered set to find $$$f(i,l,r)$$$.
Hint 3
Now let us get back to original problem.
First let us count number of pairs $$$(i,j)(1 \leq i \leq j)$$$ such that $$$a_i=a_j$$$. Assume $$$cnt$$$ is number of such pairs.
Time for another cool claim!
For our original problem, answer is $$$cnt+F(a,k)+F(rev(a),k)$$$, where $$$rev(a)$$$ denotes the array $$$a$$$ when it is reversed.
Solution
How to prove the claim in hint $$$3$$$?
Suppose we have a good pair $$$(l,r)$$$ such that $$$a_l \neq a_r$$$. Now using exchange arguments we can claim that there always exists a sequence(say $$$s$$$) starting at index $$$l$$$ and ending at index $$$r$$$
such that difference between adjacent elements of $$$a$$$ is atmost $$$k$$$
strictly increasing if $$$a_l < a_r$$$
strictly decreasing if $$$a_l > a_r$$$
Thus $$$(l,r)$$$ will be counted in $$$F(a,k)$$$ if $$$a_l < a_r$$$ and $$$(l,r)$$$ will be counted in $$$F(rev(a),k)$$$ if $$$a_l > a_r$$$.
Time complexity is $$$O(n \cdot \log(n))$$$.
Code
#include <bits/stdc++.h>     
using namespace std;
#define ll long long
const ll MAX=1000100;
class ST{
public:
    vector<ll> segs;
    ll size=0;                       
    ll ID=MAX;
 
    ST(ll sz) {
        segs.assign(2*sz,ID);
        size=sz;  
    }   
   
    ll comb(ll a,ll b) {
        return min(a,b);  
    }
 
    void upd(ll idx, ll val) {
        segs[idx+=size]=val;
        for(idx/=2;idx;idx/=2){
            segs[idx]=comb(segs[2*idx],segs[2*idx+1]);
        }
    }
 
    ll query(ll l,ll r) {
        ll lans=ID,rans=ID;
        for(l+=size,r+=size+1;l<r;l/=2,r/=2) {
            if(l&1) {
                lans=comb(lans,segs[l++]);
            }
            if(r&1){
                rans=comb(segs[--r],rans);
            }
        }
        return comb(lans,rans);
    }
};
struct FenwickTree{
    vector<ll> bit; 
    ll n;
    FenwickTree(ll n){
        this->n = n;
        bit.assign(n, 0);
    }
    FenwickTree(vector<ll> a):FenwickTree(a.size()){
        ll x=a.size();
        for(size_t i=0;i<x;i++)
            add(i,a[i]);
    }
    ll sum(ll r) {
        ll ret=0;
        for(;r>=0;r=(r&(r+1))-1)
            ret+=bit[r];
        return ret;
    }
    ll sum(ll l,ll r) {
        if(l>r)
            return 0;
        return sum(r)-sum(l-1);
    }
    void add(ll idx,ll delta) {
        for(;idx<n;idx=idx|(idx+1))
            bit[idx]+=delta;
    }
};
FenwickTree freq(MAX);  
ST segtree(MAX);
vector<ll> dp(MAX,0);
ll solve(vector<ll> a,ll n,ll k){
    ll now=0;
    for(ll i=n-1;i>=0;i--){  
        ll j=segtree.query(a[i]+1,a[i]+k);
        if(j<n){
            dp[i]=dp[j]+freq.sum(a[i]+1,a[j]);
        }
        else{
            dp[i]=0;
        }
        now+=dp[i];
        segtree.upd(a[i],i);
        freq.add(a[i],1);
    }  
    for(auto it:a){  
        segtree.upd(it,MAX);  
        freq.add(it,-1); 
    }
    return now;
}
void solve(){         
    ll n,k; cin>>n>>k;
    vector<ll> a(n);
    ll ans=0;
    map<ll,ll> cnt;  
    for(auto &it:a){
        cin>>it;
        cnt[it]++;
        ans+=cnt[it];
    }
    ans+=solve(a,n,k);
    reverse(a.begin(),a.end());
    ans+=solve(a,n,k);
    cout<<ans<<"\n"; 
    return;            
} 
int main()                                                                                
{  
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);  
    ll t=1; 
    cin>>t;
    while(t--){
        solve();
    }
}
--------------------------------------------------
Problem ID: 1762E
Editorial Content:
1762E - Сумма на дереве
Hint 1
There does not exist any good tree of size $$$n$$$ if $$$n$$$ is odd.
How to prove it? Suppose $$$f(v)$$$ gives the product of weight of edges incident to node $$$v$$$ in a good tree. We know that $$$f(i)=-1$$$ as if tree is good. Now $$$\prod_{i=1}^{n} f(i) = -1$$$ if $$$n$$$ is odd.
There is another way to find $$$\prod_{i=1}^{n} f(i)$$$. Look at contribution of each edge. Each edge contribitues $$$1$$$ to $$$\prod_{i=1}^{n} f(i)$$$, no matter what the weight of this edge is, as it gets multiplied twice. Thus we get $$$\prod_{i=1}^{n} f(i) = 1$$$. We got contradiction. Thus no good tree of size $$$n$$$ exists.
Hint 2
Now assume $$$n$$$ is even.
Here is an interesting claim.
For any unweighted tree,there exists exactly
one
assignment of weight of edges which makes it good.
Thus there are $$$n^{n-2}$$$ distinct edge-weighted trees.
Hint 3
How to prove the claim in hint $$$2$$$?
Arbitrarily root the tree at node $$$1$$$.
Now start from leaves and move towards root and assign the weight of edges in the path.
First of all the edge incident to any leaf node will have $$$-1$$$ as the weight. While moving towards root, it can be observed that weight of edge between $$$u$$$ and parent of $$$u$$$ depends on the product of weight of edges between $$$u$$$ and its children.
As we are moving from leaves towards root, weight of edges between $$$u$$$ and its children are already fixed. Weight of edge between $$$u$$$ and parent $$$u$$$ is $$$-1 \cdot \prod_{x \in C(u)}{pw(x)}$$$, where $$$pw(x)$$$ gives the weight of edge between $$$x$$$ and its parent, and $$$C(u)$$$ denotes the set of children of $$$u$$$.
Solution
Time for one more interesting claim. The weight of edge $$$e$$$ is $$$(-1)^{l}$$$ if there are $$$l$$$ nodes on one side and $$$n-l$$$ nodes on other side of $$$e$$$, irrespective of the structure of tree.
We can prove this claim by induction, similar to what we did in hint $$$3$$$.
To find answer we will look at contribution of each edge.
Here's detailed explanation on how to dot it.
In total, we have $$$n^{n-2} \cdot (n-1)$$$ edges.
Suppose for some edge(say $$$e$$$), we have $$$l$$$ nodes(including node $$$1$$$) on left side and $$$r$$$ nodes(including node $$$n$$$) on right side.
Among $$$n^{n-2} \cdot (n-1)$$$ edges, how many possibilities do we have for $$$e$$$?
It is $$${{n-2} \choose {l-1}} \cdot l \cdot r \cdot l^{l-2} \cdot r^{r-2}$$$. Why? First we select $$$l-1$$$ nodes(as node $$$1$$$ is fixed to be on left side) to be on left side, we get $$${{n-2} \choose {l-1}}$$$ for this.
Now we have $$$l$$$ nodes on left side and $$$r$$$ nodes on right side. Edge $$$e$$$ will connect one among $$$l$$$ nodes on left and one among $$$r$$$ nodes on right. So edge $$$e$$$ will exist between $$$l \cdot r$$$ pairs. We know that number of distinct trees having $$$x$$$ nodes is $$$x^{x-2}$$$.
Now on selecting one node from left and one from right, we have fixed the root of subtree on left side, and have also fixed the root of subtree on right side. So, number of distinct subtrees on left side is $$$l^{l-2}$$$, and number of distinct subtrees on right side is $$$r^{r-2}$$$.
Thus, on mutliplying all(since they are independent), we get $$${n \choose l} \cdot l \cdot r \cdot l^{l-2} \cdot r^{r-2}$$$ possibilities for $$$e$$$.
Now this edge lies on the path from $$$1$$$ to $$$n$$$ as both lie on opposite sides of this node.
So this edge contributes $$$(-1)^l \cdot {{n-2} \choose {l-1}} \cdot l \cdot r \cdot l^{l-2} \cdot r^{r-2}$$$ to answer.
Hence $$$d(1,n)=\sum_{l=1}^{n-1} (-1)^l \cdot {{n-2} \choose {l-1}} \cdot l \cdot r \cdot l^{l-2} \cdot r^{r-2}$$$ where $$$l+r=n$$$. Note that we assumed that we are always going from left subtree to right subtree while calculating contribution. As we have tried all possibilties for l, all cases get covered. We used left and right subtrees just for our own convention.
Time complexity is $$$O(n \cdot \log(n))$$$.
Code
#include <bits/stdc++.h>     
using namespace std;
#define ll long long
const ll MOD=998244353;
const ll MAX=500500;
vector<ll> fact(MAX+2,1),inv_fact(MAX+2,1);
ll binpow(ll a,ll b,ll MOD){
    ll ans=1;
    a%=MOD;  
    while(b){
        if(b&1)
            ans=(ans*a)%MOD;
        b/=2;
        a=(a*a)%MOD;
    }
    return ans;
}
ll inverse(ll a,ll MOD){
    return binpow(a,MOD-2,MOD);
} 
void precompute(ll MOD){
    for(ll i=2;i<MAX;i++){
        fact[i]=(fact[i-1]*i)%MOD;
    }
    inv_fact[MAX-1]=inverse(fact[MAX-1],MOD);
    for(ll i=MAX-2;i>=0;i--){
        inv_fact[i]=(inv_fact[i+1]*(i+1))%MOD;
    }
}
ll nCr(ll a,ll b,ll MOD){
    if((a<0)||(a<b)||(b<0))
        return 0;   
    ll denom=(inv_fact[b]*inv_fact[a-b])%MOD;
    return (denom*fact[a])%MOD;  
}
void solve(){         
    ll n,ans=0; cin>>n;
    if(n&1){  
        cout<<0;    
        return;
    }
    ll sgn=1;  
    for(ll i=1;i<n;i++){ 
        sgn*=-1; 
        ll r=n-i,l=i;
        ll fix_l=nCr(n-2,l-1,MOD); //fixing l nodes on left side  
        ll fix_root=(l*r)%MOD; //fixing roots of subtrees on both sides 
        ll trees=(binpow(l,l-2,MOD)*binpow(r,r-2,MOD))%MOD; //counting no of subtrees
        ll no_of_e=(((fix_l*fix_root)%MOD)*trees)%MOD; //no of possibilities for e
        ans=(ans+sgn*no_of_e)%MOD;
    }     
    ans=(ans+MOD)%MOD;          
    cout<<ans; 
    return;            
} 
int main()                                                                                
{  
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);  
    precompute(MOD);
    ll t=1; 
    //cin>>t;
    while(t--){
        solve();
    }
}
--------------------------------------------------
Problem ID: 1762D
Editorial Content:
1762D - Запросы НОД
Hint 1
Intended solution uses $$$2 \cdot (n-2)$$$. You are allowed to guess two indices. Doesn't this hint towards something?
Hint 2
If we can eliminate $$$n-2$$$ elements that cannot be $$$0$$$ for sure, we are done.
Hint 3
Suppose we have three distinct indices $$$i$$$, $$$j$$$ and $$$k$$$. Is it possible to remove one index(say $$$x$$$) out of these three indices such that $$$p_x \neq 0$$$ for sure. You are allowed to query two times.
Solution
So suppose we have three distinct indices $$$i$$$, $$$j$$$ and $$$k$$$.
Let us assume $$$l=query(i,k)$$$ and $$$r=query(j,k)$$$
Now we have only three possibilities.
$$$l=r$$$ In this case, $$$p_k$$$ cannot be $$$0$$$. Why? $$$p_i$$$ and $$$p_j$$$ are distinct, and we have $$$\gcd(0,x) \neq \gcd(0,y)$$$ if $$$x \neq y$$$
$$$l > r$$$ In this case, $$$p_j$$$ cannot be $$$0$$$. Why? Note $$$\gcd(0,p_k)=p_k$$$ and $$$\gcd(m,p_k)$$$ can be atmost $$$p_k$$$ for any non negative integer. If $$$l > r$$$, this means $$$r$$$ cannot be $$$p_k$$$. Thus $$$p_r \neq 0$$$ for sure
$$$l < r$$$ In this case, $$$p_i$$$ cannot be $$$0$$$. Why? Refer to the above argument.
This we can eliminate one index on using $$$2$$$ queries. We will perform this operation $$$n-2$$$ times. Refer to attached code for details.
Time complexity is $$$O(n)$$$.
Code
#include <bits/stdc++.h>     
using namespace std;
#define ll long long
void solve(){
    ll n; cin>>n;
    ll l=1,r=2;
    for(ll i=3;i<=n;i++){
        ll ql,qr;
        cout<<"? "<<l<<" "<<i<<endl;
        cin>>ql;
        cout<<"? "<<r<<" "<<i<<endl;
        cin>>qr;
        if(ql>qr){
            r=i;
        }
        else if(ql<qr){
            l=i;
        }
    }
    cout<<"! "<<l<<" "<<r<<endl;
    ll check; cin>>check;
    assert(check==1); 
}
int main()                                                                                
{  
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);  
    ll t; cin>>t;
    while(t--){
        solve();
    }
}
--------------------------------------------------
Problem ID: 1762C
Editorial Content:
1762C - Бинарные строки это весело
Hint 1
Let us first find $$$f(s[1,n])$$$.
Hint 2
$$$f(s[1,n])=2^{len-1}$$$ where $$$len$$$ is the length of longest suffix of $$$s$$$ in which all characters are same.
Hint 3
How to prove the result in hint $$$2$$$?
First of all it is easy to see if all characters of $$$s$$$ are same, $$$f(s[1,n])=2^{n-1}$$$ as median is always $$$s_i$$$.
Now we assume that $$$s$$$ contains distinct characters.
Suppose $$$t$$$ is one good extension of $$$s$$$. Assume we are index $$$i$$$. If there exists an index $$$j(j>i)$$$ such that $$$s_i \neq s_j$$$, we should have $$$t_{2i} \neq s_i$$$.
Why? Assume $$$k$$$ is the smallest index greater than $$$i$$$ such that $$$s_i \neq s_k$$$. Now if we have $$$t_{2i} = s_i$$$, $$$s_k$$$ can never be median of subarray $$$t[1,2k-1]$$$. So if longest suffix of $$$s$$$ having same characters of starts at index $$$i$$$, $$$t_{2j} \neq s_j$$$ for all $$$j(1 \leq j < i)$$$ and $$$t_{2j}$$$ can be anything(either $$$0$$$ or $$$1$$$) for all $$$j(i \leq j < n)$$$.
Solution
Now we know how to solve for whole string $$$s$$$.
We can similarly solve for all prefixes.
To find $$$f(s[1,i])$$$, we need to find the longest suffix of $$$s[1,i]$$$ containing same character.
We can easily calculate this all prefixes while moving from $$$i=1$$$ to $$$n$$$.
Time complexity is $$$O(n)$$$.
Code
#include <bits/stdc++.h>     
using namespace std;
#define ll long long
const ll MOD=998244353;
void solve(){
    ll n; cin>>n;
    string s; cin>>s; s=" "+s;
    ll ans=0,cur=1;
    for(ll i=1;i<=n;i++){
        if(s[i]==s[i-1]){
            cur=(2*cur)%MOD;
        }
        else{
            cur=1;
        }
        ans=(ans+cur)%MOD;
    }
    cout<<ans<<"\n";
}
int main()                                                                                
{  
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);  
    ll t; cin>>t;
    while(t--){
        solve();
    }
}
--------------------------------------------------
Problem ID: 1762B
Editorial Content:
1762B - Сделайте массив хорошим
Hint 1
Suppose we have a prime number $$$p$$$. Suppose there are two perfect powers of $$$p$$$ — $$$l$$$ and $$$r$$$. Now it is easy to see $$$\max(l,r)$$$ is divisible by $$$\min(l,r)$$$.
Hint 2
So now we need to choose some prime number $$$p$$$. Let us start with the smallest prime number $$$p=2$$$.
Hint 3
Here is one interesting fact. There always exists a power of $$$2$$$ in the range $$$[x,2x]$$$ for any positive integer $$$x$$$.
Solution
Suppose $$$f(x)$$$ gives the smallest power of $$$2$$$ which is greater than $$$x$$$.
Iterate from $$$i=1$$$ to $$$n$$$ and change $$$a_i$$$ to $$$f(a_i)$$$ by adding $$$f(a_i)-a_i$$$ to $$$i$$$-th element.
Time complexity is $$$O(n \cdot log(A_{max}))$$$.
Code
#include <bits/stdc++.h>     
using namespace std;
#define ll long long
ll f(ll x){
    ll cur=1;
    while(cur<=x){
        cur*=2;
    }
    return cur;
}
void solve(){
    ll n; cin>>n;
    cout<<n<<"\n";
    for(ll i=1;i<=n;i++){
        ll x; cin>>x;
        cout<<i<<" "<<f(x)-x<<"\n";
    }
}
int main()                                                                                
{  
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);  
    ll t; cin>>t;
    while(t--){
        solve();
    }
}
--------------------------------------------------
Problem ID: 1762A
Editorial Content:
1762A - Разделяй и властвуй
Hint 1
If sum is even, answer is $$$0$$$. Otherwise we need to change parity of atleast one element of $$$a$$$.
Hint 2
It it optimal to change parity of atmost one element.
Hint 3
Answer can be atmost $$$20$$$, as we need to divide any integer $$$x$$$ ($$$1 \leq x \leq 10^6$$$) atmost $$$20$$$ times to change its parity.
Solution
We are assuming initial sum is odd. Suppose $$$f(x)(1 \leq x \leq 10^6)$$$ gives the minimum number of operations needed to change parity of $$$x$$$.
Iterate from $$$i=1$$$ to $$$n$$$ and calculate $$$f(a_i)$$$ for each $$$i$$$.
Answer is minimum among all the calculated values.
Time complexity is $$$O(n \cdot log(A_{max}))$$$.
Code
#include <bits/stdc++.h>     
using namespace std;
#define ll long long
void solve(){
    ll n; cin>>n;
    ll sum=0,ans=21;
    vector<ll> a(n);
    for(auto &it:a){
        cin>>it;
        sum+=it;
    }
    if(sum&1){
        for(auto &it:a){
            ll cur=it,now=0;
            while(!((cur+it)&1)){
                now++;
                cur/=2;
            }
            ans=min(ans,now);
        }
    }
    else{
        ans=0;
    }
    cout<<ans<<"\n";
}
int main()                                                                                
{  
    ios_base::sync_with_stdio(false);                         
    cin.tie(NULL);  
    ll t; cin>>t;
    while(t--){
        solve();
    }
}
--------------------------------------------------
Problem ID: 1761G
Editorial Content:

--------------------------------------------------
Problem ID: 1761F2
Editorial Content:

--------------------------------------------------
Problem ID: 1761F1
Editorial Content:

--------------------------------------------------
Problem ID: 1761E
Editorial Content:

--------------------------------------------------
Problem ID: 1761D
Editorial Content:

--------------------------------------------------
Problem ID: 1761C
Editorial Content:

--------------------------------------------------
Problem ID: 1761B
Editorial Content:

--------------------------------------------------
Problem ID: 1761A
Editorial Content:

--------------------------------------------------
Problem ID: 1760G
Editorial Content:
1760G - SlavicG's Favorite Problem
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
using ll = long long;
 
#define       forn(i,n)              for(int i=0;i<n;i++)
#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()

const int N = 1e5 + 10;
vector<pair<int, int>> adj[N];
set<int> s;
bool ok = true;
int n, a, b;
void dfs1(int u, int par, int x) {
    if(u == b) return;
    s.insert(x);
    for(auto e: adj[u]) {
        int v = e.first, w = e.second;
        if(v == par) continue;
        dfs1(v, u, x ^ w);
    }
}

bool dfs2(int u, int par, int x) {
    if(u != b && s.count(x)) return true;
    for(auto e: adj[u]) {
        int v = e.first, w = e.second;
        if(v == par) continue;
        if(dfs2(v, u, w ^ x)) return true;
    } 
    return false;
}

void solve() {
    s.clear();
    cin >> n >> a >> b; --a, --b;
    forn(i, n) adj[i].clear();
    for(int i = 0; i < n - 1; ++i) {
        int u, v, w; cin >> u >> v >> w; --u, --v;
        adj[u].pb({v, w});
        adj[v].pb({u, w});
    }
    dfs1(a, -1, 0);
    if(dfs2(b, -1, 0)) cout << "YES\n";
    else cout << "NO\n";
}   
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1760F
Editorial Content:
1760F - Quests
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

const int MAX = 200007;
const int MOD = 1000000007;

void solve() {
	int n, d;
	long long c;
	cin >> n >> c >> d;
	long long a[n];
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	sort(a, a + n, greater<long long>());
	int l = 0, r = d + 2;
	while (l < r) {
		int m = l + (r - l + 1) / 2;
		long long tot = 0;
		int curr = 0;
		for (int i = 0; i < d; i++) {
			if (i % m < n) {tot += a[i % m];}
		}
		if (tot >= c) {
			l = m;
		}
		else {
			r = m - 1;
		}
	}
	if (l == d + 2) {cout << "Infinity\n"; return;}
	if (l == 0) {cout << "Impossible\n"; return;}
	cout << l - 1 << '\n';
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1760E
Editorial Content:
1760E - Binary Inversions
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
using ll = long long;
 
#define       forn(i,n)              for(int i=0;i<n;i++)
#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()

ll calc(vector<int>& a) {
    ll zeroes = 0, ans = 0;
    for(int i = sz(a) - 1; i >= 0; --i) {
        if(a[i] == 0) ++zeroes;
        else ans += zeroes;
    }
    return ans;
}
void solve() {
    int n; cin >> n;
    vector<int> a(n);
    forn(i, n) cin >> a[i];
    ll ans = calc(a);
    forn(i, n) {
        if(a[i] == 0) {
            a[i] = 1;
            ans = max(ans, calc(a));
            a[i] = 0;
            break;
        }
    }
    for(int i = n - 1; i >= 0; --i) {
        if(a[i] == 1) {
            a[i] = 0;
            ans = max(ans, calc(a));
            a[i] = 1;
            break;
        }
    }
    cout << ans << "\n";
}   
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1760D
Editorial Content:
1760D - Challenging Valleys
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>
using namespace std;
void solve()
{
    int n;
    cin >> n;
    vector<int> a;
    for(int i = 0; i < n; i++)
    {
        int x;
        cin >> x;
        if(i == 0 || x != a.back())
        {
            a.push_back(x);
        }
    }
    int num_valley = 0;
    for(int i = 0; i < a.size(); i++)
    {
        if((i == 0 || a[i-1] > a[i]) && (i == a.size()-1 || a[i] < a[i+1]))
        {
            num_valley++;
        }
    }
    if(num_valley == 1)
    {
        cout << "YES" << endl;
    }
    else
    {
        cout << "NO" << endl;
    }
}

int32_t main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1760C
Editorial Content:
1760C - Advantage
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

#define forn(i, n) for (int i = 0; i < int(n); i++)

int main() {
    int t;
    cin >> t;
    forn(tt, t) {
        int n;
        cin >> n;
        vector<int> a(n);
        forn(i, n)
            cin >> a[i];
        vector<int> b(a);
        sort(b.begin(), b.end());
        forn(i, n) {
            if (a[i] == b[n - 1])
                cout << a[i] - b[n - 2] << " ";
            else
                cout << a[i] - b[n - 1] << " ";
        }
        cout << endl;
   }
}
--------------------------------------------------
Problem ID: 1760B
Editorial Content:
1760B - Atilla's Favorite Problem
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
 
using ll = long long;
 
#define       forn(i,n)              for(int i=0;i<n;i++)
#define          all(v)              v.begin(), v.end()
#define         rall(v)              v.rbegin(),v.rend()
 
#define            pb                push_back
#define          sz(a)               (int)a.size()

void solve() {
    int n; string s; cin >> n >> s;
    sort(all(s));
    cout << s.back() - 'a' + 1 << "\n";
}   
 
int32_t main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1760A
Editorial Content:
1760A - Medium Number
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

const int MAX = 200007;
const int MOD = 1000000007;

void solve() {
	int a[3];
	cin >> a[0] >> a[1] >> a[2];
	sort(a, a + 3);
	cout << a[1] << '\n';	
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}
	// solve();
}
--------------------------------------------------
Problem ID: 1759G
Editorial Content:
1759G - Restore the Permutation
Tutorial
Tutorial is loading...
Solution
#include "bits/stdc++.h"
using namespace std;
int n;

void solve(){
    cin >> n;
    vector<int>b(n / 2), p(n);
    vector<bool>isUsed(n + 1, false);
    set<int>unused;

    for(int i = 0; i < n / 2; i++){
        cin >> b[i];
        p[i * 2 + 1] = b[i];
        isUsed[b[i]] = true;
    }
    for(int i = 1; i <= n; i++){
        if(!isUsed[i]) unused.insert(i);
    }


    if(int(unused.size()) != n / 2){
        cout << "-1\n";
        return;
    }

    for(int i = n / 2 - 1; i >= 0; i--){
        auto k = unused.upper_bound(p[2 * i + 1]);
        if(k == unused.begin()){
            cout << "-1\n";
            return;
        }

        k--;


        if(*k < p[2 * i + 1]){
            p[2 * i] = *k;
            unused.erase(k);
        }
        else{
            cout << "-1\n";
            return;
        }
    }
    for(auto i : p) cout << i << ' ';
    cout << endl;
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while(t--){
        solve();
    }

}
--------------------------------------------------
Problem ID: 1759F
Editorial Content:
1759F - All Possible Digits
Tutorial
Tutorial is loading...
Solution
#pragma GCC optimize("Ofast")

#include <bits/stdc++.h>

using namespace std;

#include <ext/pb_ds/assoc_container.hpp>

using namespace __gnu_pbds;

typedef long long ll;
typedef long double ld;
typedef tree<pair<int, int>, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

int newDigit = -1;

bool check(set<int> digits, int l, int r, bool useNewDigit) {
    for (int i = l; i <= r; ++i) {
        if (useNewDigit && i == newDigit) {
            continue;
        }
        if (!digits.count(i)) {
            return false;
        }
    }
    return true;
}

void solve() {
    int n, p;
    cin >> n >> p;
    vector<int> a(n + 1);
    set<int> digits;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        digits.insert(a[i]);
    }
    if (digits.size() == p) {
        cout << "0\n";
        return;
    }
    for (int i = n - 1; i >= 0; --i) {
        if (a[i] < p - 1) {
            newDigit = a[i] + 1;
            break;
        }
    }
    int l = 0, r = p - 1;
    int x = a[n];
    while (l < r) {
        int m = (l + r) >> 1;
        bool res = false;
        if (x + m >= p) {
            if (check(digits, x + m + 1 - p, x - 1, true)) {
                res = true;
            }
        } else {
            if (check(digits, 0, x - 1, false) && check(digits, x + m + 1, p - 1, false)) {
                res = true;
            }
        }
        if (res) {
            r = m;
        } else {
            l = m + 1;
        }
    }
    cout << l << '\n';
}

bool multitest = true;

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cout.precision(25);
    size_t number_of_tests = 1;
    if (multitest) {
        cin >> number_of_tests;
    }
    for (size_t _ = 0; _ < number_of_tests; ++_) {
        solve();
    }
    return 0;
}
--------------------------------------------------
Problem ID: 1759E
Editorial Content:
1759E - The Humanoid
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 200200;

int n;
int arr[MAXN];

int solve(int i, long long h, int s2, int s3) {
	if (i == n) return 0;
	if (arr[i] < h)
		return solve(i + 1, h + (arr[i] / 2), s2, s3) + 1;
	int ans1 = (s2 ? solve(i, h * 2, s2 - 1, s3) : 0);
	int ans2 = (s3 ? solve(i, h * 3, s2, s3 - 1) : 0);
	return max(ans1, ans2);
}

int main() {
	int t; cin >> t;
	while(t--) {
		long long h; cin >> n >> h;
		for (int i = 0; i < n; ++i)
			cin >> arr[i];
		sort(arr, arr + n);
		cout << solve(0, h, 2, 1) << endl;
	}
}
--------------------------------------------------
Problem ID: 1759D
Editorial Content:
1759D - Make It Round
Tutorial
Tutorial is loading...
Solution
#include <bits/stdc++.h>

using namespace std;

#define forn(i, n) for (int i = 0; i < int(n); i++)
#define sz(v) (int)v.size()
#define all(v) v.begin(),v.end()
#define eb emplace_back

using ll = long long;

void solve() {
    ll n,m; cin >> n >> m;
    ll n0 = n;
    int cnt2 = 0, cnt5 = 0;
    ll k = 1;
    while (n > 0 && n % 2 == 0) {
        n /= 2;
        cnt2++;
    }
    while (n > 0 && n % 5 == 0) {
        n /= 5;
        cnt5++;
    }
    while (cnt2 < cnt5 && k * 2 <= m) {
        cnt2++;
        k *= 2;
    }
    while (cnt5 < cnt2 && k * 5 <= m) {
        cnt5++;
        k *= 5;
    }
    while (k * 10 <= m) {
        k *= 10;
    }
    if (k == 1) {
        cout << n0 * m << endl;
    } else {
        k *= m / k; // 1 <= m/k < 10
        cout << n0 * k << endl;
    }
}

int main() {
    int t;
    cin >> t;

    forn(tt, t) {
        solve();
    }
}
--------------------------------------------------
Problem ID: 1759C
Editorial Content:
1759C - Thermostat
Tutorial
Tutorial is loading...
Solution
def solve():
    l, r, x = map(int, input().split())
    a, b = map(int, input().split())
    if a == b:
        return 0
    if abs(a - b) >= x:
        return 1
    if r - max(a, b) >= x or min(a, b) - l >= x:
        return 2
    if r - b >= x and a - l >= x or r - a >= x and b - l >= x:
        return 3
    return -1


t = int(input())
for _ in range(t):
    print(solve())
--------------------------------------------------
Problem ID: 1759B
Editorial Content:
1759B - Lost Permutation
Tutorial
Tutorial is loading...
Solution
t = int(input())
for _ in range(t):
    n, s = map(int, input().split())
    a = [int(x) for x in input().split()]
    s += sum(a)
    sm = 0
    cnt = 0
    for i in range(1, s + 1):
        if sm >= s:
            break
        sm += i
        cnt = i
    if sm != s or max(a) > cnt or cnt <= n:
        print("NO");
    else:
        print("YES")
--------------------------------------------------
Problem ID: 1759A
Editorial Content:
1759A - Yes-Yes?
Tutorial
Tutorial is loading...
Solution
full = 'Yes' * 18
t = int(input())
for _ in range(t):
    if full.find(input()) >= 0:
        print('YES')
    else:
        print('NO')
--------------------------------------------------
Problem ID: 1758F
Editorial Content:
1758F - Decent Division
Hint
If we are modifying a point already in an interval, how can we grow/split the interval to maintain balance?
Solution
Tutorial is loading...
Implementation (C++)
182550752
--------------------------------------------------
