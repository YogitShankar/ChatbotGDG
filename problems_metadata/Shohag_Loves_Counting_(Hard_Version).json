{
    "time_limit": "4 seconds",
    "memory_limit": "512 megabytes",
    "tags": [
        "dp",
        "number theory",
        "*3200"
    ],
    "solution": "2039F1 - Shohag Loves Counting (Easy Version)Letskskbe the sequence ofkklength subarray maximums of the array. Thensk+1sk+1is just the adjacent maximum sequence ofsksk.Also, letgkgkbe the GCD of the elements ofsksk. Then notice that every element ofsk+1sk+1is also divisible bygkgk. That isgkgkdividesgk+1gk+1.For the array to be good,gkgkmust be different for allkk. Sogk<gk+1gk<gk+1andgkgkdividesgk+1gk+1. This means if the length of the array isnn, thenn\u2264\u230alog2m\u230b+1n\u2264\u230alog2\u2061m\u230b+1.Now consider a non-decreasing sequence of integersaaof lengthnnsuch that1\u2264ai\u2264m1\u2264ai\u2264mfor allii. Then thekklength subarray maximums ofaaare just the lastkkelements ofaa. Sogkgkis the GCD of the lastkkelements ofaa. Then forgkgkto be different for allkk, all the elements ofaamust be distinct. So the condition foraato be good is that the elements are distinct and all suffix GCDs are distinct as well.Next the question is how many permutations of this increasing sequenceaais good as well? To count this, lets start fromsnsn.snsnis just[an][an]. Now considersn\u22121sn\u22121. We need to putan\u22121an\u22121in the sequence such that the adjacent maximum sequence ofsn\u22121sn\u22121becomessnsn. For this we clearly have22ways:[an\u22121,an][an\u22121,an]and[an,an\u22121][an,an\u22121].Now considersn\u22122sn\u22122. We need to putan\u22122an\u22122in the sequence such that the adjacent maximum sequence ofsn\u22122sn\u22122becomessn\u22121sn\u22121. For this we again have22ways becausean\u22122an\u22122can be inserted in22places: beforean\u22121an\u22121or afteran\u22121an\u22121.Similarly for all otherskskwe have22ways to insert it: putting it beforeak+1ak+1or afterak+1ak+1. So the total number of good permutations ofaais2n\u221212n\u22121.So our problem reduces to the following:Select a lengthnnsuch that1\u2264n\u2264\u230alog2m\u230b+11\u2264n\u2264\u230alog2\u2061m\u230b+1.Count the number of strictly increasing sequences of lengthnnsuch that all suffix GCDs are distinct.Multiply the answer by2n\u221212n\u22121.Sum up the answer for all validnn.For a fixednn, let's count the number of strictly increasing sequences of lengthnnsuch that all suffix GCDs are distinct.Letdpi,gdpi,gbe the number of strictly increasing sequences of lengthnnsuch that the starting element isiiand the GCD of the elements isgg.Now iterate fromi=mi=mto11. Then the transition is to iterate over the next suffix GCDhhsuch thatggdivideshh,g<h\u2264mg<h\u2264mandg=gcd(i,h)g=gcd(i,h)and then adddp\u2217,hdp\u2217,htodpi,gdpi,g. Heredp\u2217,hdp\u2217,his the sum of alldpj,hdpj,hfor allj>ij>i.Another way to look at the transition is that for a fixedii, we iterate over allhhand ifgcd(i,h)<hgcd(i,h)<h, then we adddp\u2217,hdp\u2217,htodpi,gcd(i,h)dpi,gcd(i,h).But doing everything like this would still beO(m2logm)O(m2log\u2061m)which is too slow.Notice that allggare the divisors ofii. Here the main difficulty is that we need update at the indexgcd(i,h)gcd(i,h)over allhhbut it is hard to track the exact gcd but what's easier is to track the multiple of the gcd.So for eachgg, let's say we know the sum of alldp\u2217,hdp\u2217,hover allhhsuch thatggdivideshh. So this sums up alldp\u2217,hdp\u2217,hsuch thatggdividesgcd(i,h)gcd(i,h).Then using inclusion exclusion on the divisors ofiiwe can get the sum of alldp\u2217,hdp\u2217,hfor allhhsuch thatggis exactlygcd(i,h)gcd(i,h). This will takeO(\u03c3(i)2)O(\u03c3(i)2)time for eachiiwhere\u03c3(i)\u03c3(i)is the number of divisors ofii.And once we calculate thedpi,gdpi,gfor someiiandgg, then before transitioning toi\u22121i\u22121, we can add the value ofdpi,gdpi,gto all divisors ofggto get the value ofdp\u2217,hdp\u2217,hfaster in the future. To keep track of this, we can use a separate array.So for a fixednn, the time complexity isO(\u2211mi=1\u03c3(i)2)O(\u2211i=1m\u03c3(i)2). And we need to do this for allnnfrom11to\u230alog2m\u230b+1\u230alog2\u2061m\u230b+1.So the overall time complexity isO(logm\u22c5\u2211mi=1\u03c3(i)2)O(log\u2061m\u22c5\u2211i=1m\u03c3(i)2). We actually allowed this to pass in F1.We can make the time complexity much better with a simple modification in the dp. Note that we don't need to use the length of array in the dp state. As we need to sum up after multiplying by2length of array\u221212length of array\u22121at the end, we can modify the dp to directly store the sum of2length of array\u221212length of array\u22121. So we can just multiply the dp by22during each transition.So the time complexity becomesO(\u2211mi=1\u03c3(i)2)O(\u2211i=1m\u03c3(i)2). This is very fast for F1."
}