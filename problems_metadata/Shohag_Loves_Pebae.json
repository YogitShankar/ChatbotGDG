{
    "time_limit": "5 seconds",
    "memory_limit": "768 megabytes",
    "tags": [
        "math",
        "number theory",
        "*3500"
    ],
    "solution": "2039G - Shohag Loves PebaeLet's say we assignauauto the nodeuu. Lethuhube the maximum length of a simple path that passes throughuu. Then a necessary condition is thatauaucan not be a multiple of any number\u2264hu\u2264hu. Because ifauauis a multiple ofk\u2264huk\u2264huandvvis a node such that the unique simple path fromuutovvhas lengthkk, then the LCM of the values of the nodes fromuutovvis a multiple ofkk, which is a contradiction.The condition also means thatauaucan not be a multiple of any prime numberp\u2264hup\u2264hu.Is this a sufficient condition? Yes, and the proof is also simple.So now the problem is to count the number of assignments such that for each nodeuu,auauis not a multiple of any prime numberp\u2264hup\u2264huandgcd(a1,a2,\u2026,an)=1gcd(a1,a2,\u2026,an)=1.Letfw,pfw,pbe the count of numbers from11towwthat are not divisible by any prime\u2264p\u2264p,DDbe the diameter of the tree,A numberxxis good ifxxis not divisible by any prime\u2264D\u2264D,\u03bc(g)\u03bc(g)be the Mobius function,\u03c0(x)\u03c0(x)be the number of primes\u2264x\u2264x.Then the answer to our problem is\u2211mg=1\u03bc(g)\u22c5[gis good]\u22c5\u220fni=1f\u230amg\u230b,hi\u2211g=1m\u03bc(g)\u22c5[gis good]\u22c5\u220fi=1nf\u230amg\u230b,hi.As\u230amg\u230b\u230amg\u230bis a non-decreasing function and has at most2m\u2212\u2212\u221a2mdistinct values, we can iterate over\u230amg\u230b\u230amg\u230band calculate range sums of\u03bc(g)\u22c5[gis good]\u03bc(g)\u22c5[gis good].For calculating prefix sums of a multiplicative function (like\u03bc(g)\u03bc(g)), it's a standard task and can be solved using Dirichlet convolution, Min25 sieve or multiple other methods.Here, we need a slight variant of the method as we need the prefix sums of\u03bc(g)\u22c5[gis good]\u03bc(g)\u22c5[gis good]. This can be achieved using Dirichlet convolution inO(m2/3)O(m2/3)if we just imagine the prime numbers\u2264D\u2264Ddo not exist in the number system. Refer to my code for more details.But for each fixed\u230amg\u230b\u230amg\u230b, how do we calculate\u220fni=1f\u230amg\u230b,hi\u220fi=1nf\u230amg\u230b,hifast enough? Trivially doing it will make the total complexity aroundO(nm\u2212\u2212\u221a)O(nm)which is too slow.The key observation is to not forget that the values ofhihiare not random, they are the maximum length of a simple path that passes through the nodeii. Sohi\u2265\u2308D2\u2309hi\u2265\u2308D2\u2309for alliibecause from each node, the endpoints of the diameter are at least\u2308D2\u2309\u2308D2\u2309away.So now consider two cases:Case 1:D>2m\u2212\u2212\u221aD>2mIn this case, allhi\u2265\u2308D2\u2309\u2265m\u2212\u2212\u221ahi\u2265\u2308D2\u2309\u2265mfor allii. So only primes or11are the good numbers. So instead of going with the mobius route, we can just directly solve it by calculating the total number of ways and subtracting the number of ways where the gcd is a prime.We can calculate the total number of ways by first calculating the number of primes\u2264m\u2264mand thenfm,hifm,hiis just\u03c0(m)\u2212\u03c0(hi)+1\u03c0(m)\u2212\u03c0(hi)+1.And the number of ways where the gcd is a prime is just11for all primes>D>Dand00otherwise.Counting primes undermmis also a standard task and can be done inO(m2/3logm)O(m2/3log\u2061m)or faster.Case 2:D\u22642m\u2212\u2212\u221aD\u22642mWe can convert eachhihito the maximum prime\u2264hi\u2264hiand then grouphihiby their values. Then the maximum number of groups will beO(\u03c0(m\u2212\u2212\u221a))O(\u03c0(m)). So for each fixedk=\u230amg\u230bk=\u230amg\u230b, if the sum of the mobius function in the range(\u230amk+1\u230b,\u230amk\u230b](\u230amk+1\u230b,\u230amk\u230b]is non-zero (keep in mind that when all numbers in the range are bad numbers, then the sum will definitely be00), then we can calculate the product offk,hifk,hidirectly. Then the upper bound of the complexity will be aroundO(mlog2m\u22c5log(n\u03c0(m\u221a3)))O(mlog2\u2061m\u22c5log\u2061(n\u03c0(m3))). The proof will be added later. This works fast enough."
}