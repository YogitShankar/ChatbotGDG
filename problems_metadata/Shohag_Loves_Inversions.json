{
    "time_limit": "2 seconds",
    "memory_limit": "256 megabytes",
    "tags": [
        "combinatorics",
        "dp",
        "implementation",
        "math",
        "*2200"
    ],
    "solution": "2039E - Shohag Loves InversionsIt's hard to track the array when we insert new inversions as the inversion number can quickly become very large.The key observation here is to notice what happens when the inversion count becomes more than11. As the initial array has only00and11as elements when we insert an inversion count that is more than11, the inversion count will be larger than any element of the array. And this gives us a way to control everything!Letdpidpibe the number of final arrays of lengthnnwe can get from the current array of lengthiiif the current number of inversions in it is larger than any element of the array.Letkkbe the number of inversions in the current array andk>max(a)k>max(a). ThenIf we insertkknot in the end, then the new inversion count will be more thankk, so we get the same situation fordpi+1dpi+1Or if we insertkkin the end then the number of inversions will still bekk. So if we inserted itjjtimes in the end and once somewhere else (iiways to do so) then we will get the situation fordpi+j+1dpi+j+1Sodpi=(i\u22c5\u2211j>idpj)+1dpi=(i\u22c5\u2211j>idpj)+1, here11is added as we can end the sequence here by insertingkkin the end(n\u2212i)(n\u2212i)times.This can be computed with simple dp inO(n)O(n)time using suffix sums.Now we just need to deal with the starting array when it starts to have more than11inversion.There are(n\u22121)(n\u22121)ways to finish the sequence having\u22641\u22641inversion. And they are of the form0,0,\u2026,0,[0,1,0],1,\u2026,1,10,0,\u2026,0,[0,1,0],1,\u2026,1,1this is because we first insert00at the beginning for some time and then we get11inversion count when we insert00at the end for the first time and then we will have to insert11at the end every time after that.And to count the ways to get the starting array of lengthmmwith more than11inversion, we can notice that it's just the sum of ways where we insert11before the first11in any sequence of the form like above0,0,\u2026,0,[0,1,0],1,\u2026,1,10,0,\u2026,0,[0,1,0],1,\u2026,1,1. And if the position of the first11isjjthen we have(j\u22121)(j\u22121)ways to do so. So total ways is\u2211m\u22121j=2(j\u22121)=(m\u22122)\u22c5(m\u22121)2\u22121\u2211j=2m\u22121(j\u22121)=(m\u22122)\u22c5(m\u22121)2\u22121So the answer is justn\u22121+\u2211nm=3((m\u22122)\u22c5(m\u22121)2\u22121)\u22c5dpmn\u22121+\u2211m=3n((m\u22122)\u22c5(m\u22121)2\u22121)\u22c5dpmTime Complexity:O(n)O(n)Note that there are ways to write the dp so that you don't have to handle the starting array separately. Also in this problem, we have limited the total sum ofnnover all test cases. But there exists solutions where the solution works even without the limit but we decided to let both solutions pass.Also, I am extremely sorry that during the contest we found out that some people found the second difference/derivative of the sequence on OEIS. We searched on OEIS before but couldn't find it, otherwise we would have modified the problem. Again, sorry for this issue."
}