Editorial for Problem: B. Elimination of a Ring
Problem ID: 1761B

Solution:
The tutorial for problem G will be added soon, we are translating it.Update #1: OK it's added now.Update #2: Chinese editorial with lots of pretty derby anime pictures 1761A - Two PermutationsIf $$$a+b+2\leq n$$$, we can always find such pair, here is a possible construction: $$$$$$A=\{\color{red}{1,2,\cdots,a},\color{orange}{n-b},\color{green}{a+1,a+2,\cdots,n-b-1},\color{blue}{n-b+1,n-b+2,\cdots,n}\}\\B=\{\color{red}{1,2,\cdots,a},\color{green}{a+1,a+2,\cdots,n-b-1},\color{orange}{n-b},\color{blue}{n-b+1,n-b+2,\cdots,n}\}$$$$$$The red part is their longest common prefix, and the blue part is their longest common suffix.Otherwise, the two permutations must be equal, so such pair exists iff $$$a=b=n$$$.Author: dXqwq 1761B - Elimination of a RingHintDo we need more than $$$3$$$ types of elements? Try to solve the problem with $$$a_i\leq 3$$$.SolutionFirst of all, when there're only $$$2$$$ types of elements appearing in the sequence, the answer would be $$$\frac{n}2+1$$$.Otherwise, the conclusion is that we can always reach $$$n$$$ operations when there are more than $$$2$$$ types of elements appearing in the sequence.The proof is given below: When the length of the sequence is greater than $$$3$$$, there will always be a pair of positions $$$(i,j)$$$, such that $$$a_i=a_j$$$ and $$$a_i$$$ has two different neighboring elements. Then we can erase $$$a_i$$$ and then the problem is decomposed into a smaller one. If there do not exist such pairs, then we can infer that there exists at least $$$1$$$ element which appeared only once in the sequence. If there exists such element $$$b$$$, then we can continuously erase all the elements next to $$$b$$$, then erase $$$b$$$ at last. When the length $$$n$$$ of the sequence is less than $$$3$$$, it is clear that there will be exactly $$$n$$$ operations as well.So we only need to check the number of elements that appeared in the sequence of length $$$n$$$. If the number is $$$2$$$, the answer will be $$$\frac n2 + 1$$$. Otherwise, the answer equals $$$n$$$. Author: Jelefy 1761C - Set ConstructionHint 1: When you are trying to add an element into a set $$$S$$$, you will have to add the element to every set that is meant to include $$$S$$$.Hint 2: If $$$A$$$ does not include $$$B$$$, then $$$A$$$ and $$$B$$$ are already distinct.If $$$A$$$ does include $$$B$$$, What is the easiest way of making $$$A$$$ and $$$B$$$ distinct?Solution: Denote an ancestor to $$$S$$$ as a set that is meant to include $$$S$$$.Denote a descendant to $$$S$$$ as a set that is meant to be included by $$$S$$$.Let all sets be empty from the beginning.Iterate through the sets. To make set $$$S$$$ distinct from its descendants, we can add a new number $$$x_S$$$ that hasn't been added to any previous sets to $$$S$$$ and all of its ancestors.After the execution above, we will find out that the conditions are all satisfied, since:- For all descendants of a set $$$S$$$, all the elements they have will be included in $$$S$$$;- Vice versa for all ancestors of a set $$$S$$$;- For each set $$$T$$$ that is not an ancestor nor a descendant to $$$S$$$, they will not include each other. This is because $$$S$$$ does not include $$$T$$$, since $$$S$$$ does not have the element $$$x_T$$$; and $$$T$$$ does not include $$$S$$$ for the same reason.Therefore, the construction above satisfies all given conditions.Moreover, we can set $$$x_S$$$ to the index of $$$S$$$ for a simpler implementation. Author: Forever_Pursuit 1761D - Carry BitHint 1: Try to solve the problem in $$$O(nk)$$$ using DP.Hint 2: There is no need for DP.Hint 3: You can consider enumerating the bits to carry, and then counting.Let $$$a_i$$$ represents the $$$i$$$-th bit of $$$a$$$ in binary representation (that is, $$$2^i \times a_i=a \wedge 2^i$$$) and define $$$b_i$$$ similarly.If you decide which bits to carry ahead, you will find that every bit of $$$a,b$$$ is independent (because whether the previous bit carries or not is decided), so you can use the multiplication principle to count. Therefore, in the remaining tutorial, we should determine the carries first and then count the number of options of $$$a_i,b_i$$$ meeting the constraints of carries.Define array $$$c$$$ as our decided carry plan, $$$c_i=1$$$ indicates that the $$$i$$$-th bit is carried, and define $$$c_{-1}$$$ as $$$0$$$.Notice that $$$c_i=a_i \vee b_i \vee c_{i-1}$$$.Ponder each bit, we will notice that if  $$$c_i=c_{i-1}=0$$$, $$$(a_i,b_i)$$$ can be $$$(0,0),(0,1),(1,0)$$$.  $$$c_i=c_{i-1}=1$$$, $$$(a_i,b_i)$$$ can be $$$(1,1),(0,1),(1,0)$$$.  $$$c_i=1$$$ and $$$c_{i-1}=0$$$, $$$(a_i,b_i)$$$ must be $$$(1,1)$$$.  $$$c_i=0$$$ and $$$c_{i-1}=1$$$, $$$(a_i,b_i)$$$ must be $$$(0,0)$$$. That means that pair $$$(a_i,b_i)$$$ has $$$3$$$ options if $$$c_i=c_{i-1}$$$, and pair $$$(a_i,b_i)$$$ has $$$1$$$ options if $$$c_i\neq c_{i-1}$$$.So if array $$$c$$$ has $$$q$$$ positions that $$$c_i\neq c_{i-1}$$$ ( $$$0 \leq i < n$$$, remember we define $$$c_{-1}$$$ as $$$0$$$ ), the count of pair $$$(a,b)$$$ is $$$3^{n-q}$$$.Now we can enumerate $$$q$$$, and count the number of $$$c$$$ has $$$q$$$ positions that $$$c_i\neq c_{i-1}$$$.The new problem equals a typical binomial problem.Notice that for every $$$q$$$, a valid $$$c$$$ should have $$$\lfloor \frac{q}{2} \rfloor$$$ segment of consecutive $$$1$$$s and $$$\lceil \frac{q}{2} \rceil$$$ segment of consecutive $$$0$$$s if we seen $$$c_{-1}$$$ as a normal bit (so that we have $$$n-k+1$$$ zeros).The number of solutions that divide $$$a$$$ elements into $$$b$$$ segments is $$$\binom{a-1}{b-1}$$$. Therefore the answer of each $$$q$$$ is $$$3^{n-q} \times \binom{k-1}{\lfloor \frac{q}{2} \rfloor-1} \times \binom{(n-k+1)-1}{\lceil \frac{q}{2} \rceil-1}$$$, and we can calculate it in $$$\Theta(1)$$$.Add them all and you can find the answer in $$$\Theta(n)$$$. Author: unputdownable 1761E - Make It ConnectedHint 1Try to figure out the conditions where a task can be solved with $$$1$$$ operation. Then $$$2$$$ operations, and then even more operations.Hint 2The answer could be larger than $$$2$$$ only when the graph is made up of $$$2$$$ cliques, where you could only perform the operations on every vertex in the smaller clique to get the minimum number of operations.SolutionFirst of all, we need to check if the graph is already connected at the beginning. If so, the answer would be $$$0$$$.Otherwise, there will be more than $$$1$$$ connected component. If there exists a vertex that is the only vertex required to be operated to make the graph connected, we call such a vertex "feasible vertex". We may find out that a feasible vertex can only appear in a connected component that is not a clique.But actually, there will always be such a vertex in a non-clique component. To prove this, we may figure out the sufficient condition for being a feasible vertex first.The sufficient condition is that, if a vertex is not a cut vertex, and it is not adjacent to all other vertices in the connected component, then it must be a feasible vertex. We can prove that such a vertex always exists in a non-clique component. Here is the proof:   Firstly, if there exist non-cut vertices that are adjacent to all other vertices in the component, we erase them one by one until there don't exist any non-cut vertices which are adjacent to all other vertices (note that a non-cut vertex which is adjacent to all other vertices may become a cut vertex after erasing some of the other vertices). Apparently, the remaining component would still be a non-clique component. Otherwise, the component could only be a clique from the beginning, which contradicts the premise. Then, we will find a non-cut vertex in the remaining component, since that vertices in a graph couldn't be all cut vertices. The non-cut vertex we found is the vertex we are searching for. But implementing it directly (meaning using Tarjan's algorithm to find a non-cut vertex) might not be the easiest way to solve the problem. Actually, the vertex with the least degree in a connected component always satisfy the condition. We would like to leave the proof work of the alternative method to you.Now we have proven that, if there exists a connected component that is not a clique, then the answer would be at most $$$1$$$. What if all connected components are cliques?If there are exactly $$$2$$$ connected components, then apparently we will have to operate on all vertices in a connected component. So we'll choose the smaller connected component to operate, and the answer is exactly the size of it.Otherwise, we can arbitrarily choose two vertices from two different connected components and operate on them. The answer is $$$2$$$.Note that we also need to deal with isolated vertices (meaning vertices that are not adjacent to any other vertices) separately. Author: Jelefy 1761F1 - Anti-median (Easy Version)Let's analyze the structure of anti-median permutations.First, if for any $$$2 \le i \le n-1$$$ holds $$$a_{i-1}>a_i>a_{i+1}$$$, or $$$a_{i-1}<a_i<a_{i+1}$$$, then segment $$$p[i-1:i+1]$$$ is bad. So, the signs between adjacent elements are alternating. So, consider two cases: all elements on even positions are local maximums, and on odd local minimums, and vice versa.Let's find the answer for the first case (for the second, you can find the answer similarly). Consider a segment of length $$$5$$$, $$$[p_{i-2}, p_{i-1}, p_i, p_{i+1}, p_{i+2}]$$$. Consider the case when $$$i$$$ is even first. Then $$$p_i>p_{i-1}, p_{i+1}$$$. For $$$p_i$$$ to not be median, it has to be larger than one of $$$p_{i-2}, p_{i+2}$$$. So, when we consider only even elements, each element (except the first and last one) has at least one adjacent element smaller than it. It's easy to see that this implies that elements at even positions are first increasing and then decreasing. Similarly, we can see that elements at odd positions are first decreasing, then increasing. It's not hard to see that these conditions are sufficient. Indeed, suppose that: All elements on even positions are local maximums, and all elements on odd positions are local minimums Elements at even positions are first increasing and then decreasing.  Elements at odd positions are first decreasing, then increasing.Then, consider any segment of odd length. Denote it by $$$b_1, b_2, \ldots, b_{2m+1}$$$, and wlog $$$b_{m+1}$$$ is local maximum. If we look at local maximums, at least one of the following two conditions has to hold: all local maximums to the right of $$$b_{m+1}$$$ are smaller than it, or all local maximums to the left of $$$b_{m+1}$$$ are smaller than it. Wlog first case. Then all elements to the right of $$$b_{m+1}$$$ are smaller than it, and $$$b_m$$$ is also smaller than it, so $$$b_{m+1}$$$ can't be a median.Now, let's put all elements on the circle in the following order: first, all even elements from left to right, then all odd elements from right to left. In this circle, the elements on both paths between $$$n$$$ and $$$1$$$ are decreasing. It follows that for any $$$k$$$, numbers from $$$k$$$ to $$$n$$$ form a segment (in this cyclic arrangement).Then, we can write a $$$dp$$$ of the form: $$$dp[l][r]$$$: how many ways are there to arrange the largest $$$(r-l+1+n)\bmod n$$$ elements so that they end up in the positions from $$$l$$$-th to $$$r$$$-th in this cyclic arrangement. All the transitions and checks are done in $$$O(1)$$$, and there are $$$O(n^2)$$$ states, so we are done. Author: antontrygubO_o 1761F2 - Anti-median (Hard Version)For this version, we have to analyze our dp a bit more.Once again, how do anti-median permutations look? We consider the order of positions on the cycle, as in F1. We choose the position of $$$n$$$, and then, for $$$i$$$ from $$$n-1$$$ to $$$1$$$, we choose a position of number $$$i$$$ among two options: right to the right of the current segment or right to the left.If we fill this way, do we always get an anti-median permutation? Not really. This way makes sure that elements at even positions are first increasing, then decreasing, and at odd positions, first decreasing, then increasing, but it doesn't make sure that the element at the even position is larger than its neighbors. How do we guarantee that? Well, some segments are just not allowed: those, which contain a prefix of odd positions, prefix of even positions, and the prefix of odd positions is larger (off by $$$\pm 1$$$, depending on the parity of $$$n$$$), and same for suffixes.Another observation is that if we know where $$$x$$$ is, we only have to options for where can the segment of numbers from $$$x$$$ to $$$n$$$ be (to the right or to the left of $$$x$$$). This reduces our problem to the following subproblem: we start from some segment and have to end in another segment by expanding the current segment by $$$1$$$ to the right or to the left without ever entering "bad segments." Turns out that we can solve this in $$$O(1)$$$! Indeed, represent expanding segment to the right by a move up in a coordinate plane and to the left by a move to the right. Then, we have to get from point $$$(0, 0)$$$ to some point $$$(a, b)$$$ by moving up or to the right without ever crossing some line of form $$$x = y + c$$$. This is a well-known counting problem. Idea: antontrygubO_oSolution: orzdevinwang 1761G - Centroid GuessAssuming we have already determined that the centroid of the tree is located on the path between $$$u$$$ and $$$v$$$, we may now consider how to locate it.Let $$$c_1,c_2,\dots,c_k$$$ be the vertices on the path from $$$u$$$ to $$$v$$$. Let $$$A_i$$$ be the set of vertices reachable from $$$c_i$$$ (including $$$c_i$$$) if we erase all other vertices on the path from $$$u$$$ to $$$v$$$. Then we may find that $$$A_1,A_2,\dots,A_k$$$ are a division of all vertices.Let $$$s_i$$$ be the size of $$$A_i$$$. Then there must exist a vertex $$$c_x$$$ on the path satisfying that $$$\max\{\sum_{i=1}^{x-1}s_i,\sum_{i=x+1}^ks_i\}\leq \lfloor\frac n2\rfloor$$$. Notice that the vertices that do not satisfy the condition could not be a centroid, and it is already determined that the centroid is on the path, so $$$c_x$$$ is exactly the centroid of the tree.Then we may consider finding out which set each vertex belongs to with $$$2n$$$ queries so that we can calculate the value of $$$s_i$$$. For each vertex $$$x$$$, we may query $$$dis_{u,x}$$$ and $$$dis_{v,x}$$$. For any two vertices $$$x$$$ and $$$y$$$ that belong to the same set, $$$dis_{u,x}-dist_{v,x}$$$ should be equal to $$$dis_{u,y}-dis_{v,y}$$$. Let $$$t_1=dis_{u,x}-dis_{v,x}$$$ and $$$t_2=dis_{u,v}$$$, then $$$x\in A_{(t_1+t_2)/2+1}$$$. Thus we have found out the sets each vertex belongs to, as well as the value of $$$s_i$$$, as well as the centroid. This process requires at most $$$7.5\times10^4\times2=1.5\times 10^5$$$ queries.Now the problem remains to find a pair of vertices $$$u$$$ and $$$v$$$ such that the centroid locates on the path from $$$u$$$ to $$$v$$$.We can pick a constant $$$M$$$ satisfying that $$$\frac{M(M-1)}2\leq 5\times 10^4$$$, then select $$$M$$$ vertices on the tree randomly, and query the distances between every pair of selected vertices. This requires $$$\frac{M(M-1)}2\leq 5\times 10^4$$$ queries.Let these $$$M$$$ vertices be $$$p_1,p_2,\dots,p_M$$$. We can build a virtual tree with $$$p_1$$$ being the root that contains all the LCAs of each pair of vertices. Observe that $$$dis_{x,y}+dis_{y,z}=dis_{x,z}$$$ if and only if $$$y$$$ is located on the path between $$$x$$$ and $$$z$$$. For a vertex $$$p_x$$$, we can find out all vertices on the path from $$$p_1$$$ to $$$p_x$$$, and then find out the closest vertex to $$$p_x$$$ and connect them. It is exactly the deepest ancestor of $$$p_x$$$.Now that we have constructed the virtual tree without the LCAs with $$$p_1$$$ being the root, we will then add the LCAs into the virtual tree.Start DFS from $$$p_1$$$. Assume the current vertex is $$$u$$$. Enumerate through the nodes adjacent to $$$u$$$. Assume the current vertex is $$$v$$$. If there exists another vertex $$$x$$$ which is adjacent to $$$u$$$ satisfying that $$$u$$$ is not on the path between $$$x$$$ and $$$v$$$, then $$$x$$$ and $$$u$$$ should be both in the subtree of one of $$$u$$$'s child nodes. After finding out all vertices that are in the same subtree as $$$v$$$, it would be easy to calculate the depth of their LCAs as well as the distance between an LCA vertex and all other vertices in the virtual tree. Then, remove the old edge, and then add edges between the LCA and all vertices found in the same subtree as $$$v$$$. Lastly, add an edge between the LCA and $$$u$$$. Then repeat the process above, until any two vertices adjacent to $$$u$$$ are not in the same subtree of a child node of $$$u$$$. Then DFS the child nodes of $$$u$$$. We will get the whole virtual tree after all DFS are done.For the $$$M$$$ vertices chosen from the beginning, we assume that their weights are all $$$1$$$, while other vertices have $$$0$$$ weight. Then we may find the weighted centroid of the virtual tree (when there are multiple such centroids, arbitrarily pick one), and then make it the root. Then for the two vertices with the largest and second-largest subtree of the root, DFS them, recursively find their child vertex with the largest subtree. We will be resulted with $$$2$$$ leaf nodes. Then the centroid of the hidden tree is highly possible to be located on the path between these $$$2$$$ nodes. The number of queries in both parts would not exceed $$$2\times 10^5$$$.Proof of correctness:If the centroid is not on the path between $$$u$$$ and $$$v$$$, assume the centroid of the virtual tree is in the subtree $$$E$$$ of the centroid of the hidden tree. If the subtrees other than $$$E$$$ contain at least $$$\frac 13$$$ of the $$$M$$$ vertices, then the centroid of the hidden tree must be on the path between $$$u$$$ and $$$v$$$. So there will be at most $$$\frac 13$$$ of the $$$M$$$ vertices not being in $$$E$$$. In other words, for each of $$$M$$$ vertices, it has a possibility greater than $$$\frac 12$$$ of not being in $$$E$$$, and there will be at most $$$\frac 13$$$ of the vertices which are not in $$$E$$$. The possibility of the algorithm being wrong is not greater than $$$\sum_{i=0}^{M/3}C_M^i/2^M$$$, let $$$M=316$$$, then the value would be approximately $$$6\times 10^{-10}$$$. Author: orzdevinwang
The tutorial for problem G will be added soon, we are translating it.
Update #1: OK it's added now.
Update #2: Chinese editorial with lots of pretty derby anime pictures