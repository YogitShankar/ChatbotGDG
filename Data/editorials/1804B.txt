Editorial for Problem: B. Vaccination
Problem ID: 1804B

Solution:
1804A - Хромой корольObservation 1. Let $$$|a| = |b|$$$. The king can reach $$$(a, b)$$$ in $$$2 \cdot |a|$$$ moves by alternating moves along rows and moves along columns.Observation 2. Let $$$|a| \ne |b|$$$, in particular $$$a > b \geq 0$$$ (without loss of generality due to the board symmetry). The king can reach $$$(a, b)$$$ in $$$2a - 1$$$ moves. He moves towards $$$a$$$ on turns $$$1, 3, 5, \ldots, 2a - 1$$$. The remaining $$$a - 1$$$ moves are enough to reach $$$b$$$. Finally, the remaining slots can be filled with "skip" moves.Thus, the answer is $$$|a| + |b|$$$ if $$$|a| = |b|$$$ and $$$2 \cdot \max(|a|, |b|) - 1$$$ otherwise. 1804B - ВакцинацияObservation 1. There exists an optimal answer where each pack of vaccine is used for a consecutive segment of patients. Indeed, if there are three patients $$$a < b < c$$$ such that $$$a$$$ and $$$c$$$ are vaccinated using the dose from one pack and $$$b$$$ is vaccinated using the dose from the other pack we can swap the packs used for $$$b$$$ and $$$c$$$ and the answer will still be valid.Observation 2. It always makes sense to ask new patients to wait as long as possible before opening a new pack.From these two observations we derive a very easy strategy. Consider patients one by one in order of non-decreasing $$$t_i$$$. If we consider some patient $$$i$$$ and there is an open pack that still valid and still has some doses remaining, use it immediately. If there is no valid open pack of vaccines and there is no one waiting, ask patient $$$i$$$ to wait till $$$t_i + w$$$ moment of time. If there is no valid pack of vaccines, but there is someone already waiting for moment $$$x$$$, ask patient $$$i$$$ to wait for moment $$$x$$$ as well.As a courtesy to our participants the values of $$$d$$$ and $$$w$$$ are limited by $$$10^6$$$ to avoid a potential overflow of a signed 32-bit integer type. 1804C - Вращайте барабан!Assuming the constraint on the the sum of $$$n$$$ over all test cases we might want to simulate the process for each test case. However, we need an $$$O(n)$$$ (or other quasilinear complexity) solution.The key observation is that the sum of all integers from $$$1$$$ to $$$2n$$$ inclusive is divisible by $$$n$$$. Indeed, $$$\sum_{i = 1}^{2n} i = \frac{(2n + 1) \cdot 2n}{2} = (2n + 1) \cdot n$$$.As the remainders of $$$x$$$ of modulo $$$n$$$ will repeat after $$$2n$$$ steps there is no point in trying values of $$$x$$$ for more than $$$\min(2n, p)$$$.Question, can you build the test that required Vesper to use $$$x$$$ more than $$$100k$$$? There is exactly one such test. 1804D - РазмещениеThe number of one-bedroom and two-bedroom apartments is the same for each floor and each floor can have its own independent apartments layout. Thus, we can independently solve the problem for each floor and then just sum the results. Below is given the solution for one floor in $$$O(m)$$$ time.First, lets introduce some variables.  $$$B$$$ is the total number of bright windows.  $$$D$$$ is the total number of dark windows.  $$$O_0$$$ is the number of one-bedroom apartments that are not occupied ($$$0$$$ bright windows).  $$$O_1$$$ is the number of one-bedroom apartments that are occupied ($$$1$$$ bright window).  $$$T_0$$$ is the number of two-bedroom apartments that are not occupied ($$$0$$$ bright windows).  $$$T_1$$$ is the number of two-bedroom apartments that are occupied and have $$$1$$$ bright window.  $$$T_2$$$ is the number of two-bedroom apartments that are occupied and have $$$2$$$ bright windows.  $$$A$$$ is the total number of occupied apartments. We know that $$$A = O_1 + T_1 + T_2$$$ and $$$B = O_1 + T_1 + 2 \cdot T_2$$$. Thus, $$$A = B - T_2$$$, so in order to minimize the number of occupied apartments we need to maximize $$$T_2$$$ and vice versa.Maximizing $$$T_2$$$ is easier, you just determine the length of all maximal segments of bright windows, denote these lengths as $$$l_0, l_1, l_2, \ldots, l_x$$$. Then you pack each segment with as many two-bedroom apartments as possible. So, the maximum possible value of $$$T_2 = \min(\sum_{i = 0}^{x} \lfloor \frac{l_i}{2} \rfloor, \frac{m}{4}$$$. Here we must note the importance of having exactly $$$\frac{m}{4}$$$ two-bedroom apartments and exactly $$$\frac{m}{2}$$$ one-bedroom apartments. If the actual number of apartments of each type was given in the input we won't be able to guarantee the value of $$$T_2$$$ defined above. It could be the case that it is not actually possible to place all the remaining apartments and close the gaps between the placement of two-bedroom apartments with two bright windows. However, as we have $$$\frac{m}{2}$$$ one-bedroom apartments we can guarantee that such a placement is always possible.Now we would like to minimize $$$T_2$$$. Actually, we will do it in exactly the same way as the maximization, but instead of taking maximal segments of bright windows, we will find and use maximal segments that have at least one dark window and do not have two consecutive bright windows. Denote the lengths of such maximal segments as $$$l'_0, l'_1, l'_2, \ldots, l'_y$$$. Then, the minimum possible $$$T_2 = \min(0, \frac{m}{4} - \sum_{i=0}^{y} \lfloor \frac{l'_i}{2} \rfloor)$$$. Again, thanks to $$$\frac{m}{2}$$$ one-bedroom apartments we will be able to fill all the gaps and achieve the desired placement. 1804E - МаршрутизацияA directed graph where each node has an out-degree equal to $$$1$$$ (exactly one arc starts at this node) is called functional. By setting auxiliary servers $$$a(v)$$$ for each server $$$v$$$ we define a functional graph.The following condition is necessary and sufficient. The answer exists if and only if there exists a functional graph defined by $$$a(v)$$$ that contains a cycle $$$C$$$ such that $$$N_G(C) = V(G)$$$. That means that each node should be neighbouring to at least one node of this cycle in the original graph. Note that cycles of length $$$1$$$ are not allowed as $$$a(v) \ne v$$$ by definition. The proof is easy. If such a cycle $$$C$$$ exists we can reconstruct all other $$$a(v)$$$ to lead to this cycle. This will allow WRP to construct a path to each server after the procedure gets to the cycle. If such a cycle doesn't exists, we can pick any node of any cycle (functional graph always has at least one) and some servers will be unreachable from it.Wow we need to find a cycle of length $$$\geq 2$$$ such that each server belongs to this cycle or is directly connected to at least one server of the cycle.First we run a dynamic programming similar to Hamiltonian path and identify all the subsets of servers that can form a cycle. This will take $$$O(2^n \cdot n^2)$$$ if we use the following meaning of $$$d(m, v)$$$. $$$d(m, v) = 0$$$ if there exists a path that starts from node $$$u$$$, visits all nodes of a subset defined by bitmask $$$m$$$ and ends in node $$$v$$$. Here node $$$u$$$ is the node with minimum index in subset $$$m$$$, as you can always pick the minimum-indexed node as the beginning of the cycle.After we compute $$$d(m, v)$$$ we take all $$$m$$$ such that there exists $$$d(m, v) = 1$$$ and check whether $$$N_G(m) = V(G)$$$. This can be done in $$$O(2^n \cdot n^2)$$$ as well.Thus, the overall complexity is $$$O(2^n \cdot n^2)$$$. 1804F - Приближение диаметраLet's recall some definitions to start with.  $$$\rho_G(u, v)$$$ is the length of the shortest path between vertices $$$u$$$ and $$$v$$$ in graph $$$G$$$.  Define as $$$c_G(u)$$$ the maximum distance from vertex $$$u$$$ to some other vertex of graph $$$G$$$. $$$c_G(u) = \max_{v \in V(G)} \rho(u, v)$$$.  $$$d(G) = \max_{u, v \in V(G)} \rho(u, v) = \max_{u \in V(G)} c_G(u)$$$ is called the diameter of graph $$$G$$$. It is the maximum distance between some pair of vertices of graph $$$G$$$.  $$$r(G) = \min_{u \in V(G)} \max_{v \in V(G)} \rho(u, v) = \min_{u \in V(G)} c(u)$$$ is called the radius of graph $$$G$$$. It is the minimum possible distance from one vertex of the graph to the farthest from it vertex of this graph. The key inequality we will use for this problem solution is the following. Let $$$v$$$ be arbitrary vertex of graph $$$G$$$.$$$$$$\frac{d(G)}{2} \leq r(G) \leq c_G(v) \leq d(G) \leq 2 \cdot r(G) \leq 2 \cdot c_G(v) \leq 2 \cdot d(G)$$$$$$  $$$r(G) \leq c_G(v) \leq d(G)$$$ by definition.  $$$d(G) \leq 2 \cdot r(G)$$$ because of triangle inequality.  All other inequalities are derived from the first two items. The good thing is that we can compute $$$c_G(v)$$$ in linear time using BFS algorithm. Now we can solve the problem in $$$O(q \cdot (n + m + q))$$$ time. It is important to note that the task tolerates errors both ways, so any value between $$$c_{G_i}(v)$$$ and $$$2 \cdot c_{G_i}(v)$$$ will be a correct approximation of $$$d(G_i)$$$.The next key observation is that the sequence of $$$d_i(G)$$$ is non-increasing. If $$$i < j$$$ and $$$c_{G_i}(v) \leq 2 \cdot c_{G_j}(v)$$$ we can use $$$2 \cdot c_{G_j}(v)$$$ as an approximation for $$$d(G_{i + 1}), d(G_{i + 2}), \ldots, d(G_{j - 1})$$$.Using the idea above we can do one of the following.   Having the correct value of $$$c_{G_i}(v)$$$ we can use the binary search to find the maximum $$$j$$$ such that $$$c_{G_i}(v) \leq 2 \cdot c_{G_j}(v)$$$ in $$$\log{q}$$$ iterations.  Use divide&conquer with the stop condition $$$c_{G_l}(v) \leq 2 \cdot c_{G_r}(v)$$$. That would actually work a way more faster (up to five times) as it re-uses the information very efficiently. Thus, we have a solion that runs BFS no more than $$$\log{n} \cdot \log{q}$$$ times. The overall complexity is $$$O(\log{n} \cdot \log{q} \cdot (n + m + q))$$$.How did we get the correct answers for the checker? We precomputed them using the power of distributed computing. We are a cloud technology company after all!Bonus question, can you guess the total number of cpu-days we have used to compute all the answers? Post you version in the comments! 1804G - Управление потокомThe problem is inspired by AIMD algorithm for TCP flow and congestion control.The key solution idea comes from a real-world networking, every time the congestion happens the difference between the maximum active $$$t_i$$$ and the minimum active $$$t_i$$$ halves. Thus, if all users were to start and to stop at the same time there will be no more than two distinct values of $$$t_i$$$ in just $$$\log C$$$ congestions. Here $$$C$$$ stands for the upper limit on values $$$d_i$$$ and $$$b$$$.Let's store all the unique values of active $$$t_i$$$ in a hash-map together with a supplementary information. Information we need is the sum of all $$$t_i$$$ right after the last congestion, the number of milliseconds past since the last congestion and so on. Using this information we can compute the time of the next congestion in $$$O(1)$$$.The processing of one congestion will work in $$$O(d)$$$ time where $$$d$$$ is the current number of distinct values of $$$t_i$$$. We also need to be able to merge two groups when congestion happens, this information will be used to process delete operations. That can be done using DSU with path compression and doesn't add much to the total complexity.We will call the period between two consecutive congestions an epoch. There are epochs of two types: general and repetitive. A repetitive epoch is an epoch that goes in exactly the same way as the previous epoch. That means no new users appear, no users turn off, the epoch starts with exactly the same values of $$$t_i$$$ as the previous epoch and gets to exactly the same state after the closest congestion happens. All other epochs are called general.Though the total number of epochs can be large (up to $$$\max(f_i)$$$), there will be no more than $$$n \log{C}$$$ general epochs. Indeed, if no users start or finish data transmission, the process will converge to a repetitive epoch in no more than $$$\log{C}$$$ congestions. Here, $$$C$$$ is the upper bound for $$$b$$$ and values $$$d_i$$$.Repetitive epochs contain no more than two distinct value of $$$t_i$$$, they can be identified and simulated efficiently. How do we simulate general epochs? There is no need to this efficiently, doing this in $$$O(d)$$$ ($$$d$$$ is the number of distinct $$$t_i$$$) will be efficient enough. One can prove this using amortized analysis with the following potential function. Let $$$d$$$ be the number of distinct values of $$$t_i$$$ and $$$t_0 < t_1 < \ldots < t_{d - 1}$$$ be the sequence of these values. $$$P(epoch) = d + \sum_{i = 0}^{d - 2} \log{(t_{i + 1} - t_i)}$$$.The total complexity is $$$O(n \log C + n \log n)$$$. 1804H - Кодовый замокFirst, let's solve the task for the case of linear arrangement of letters instead of a circle. Then we will upgrade the solution.Let $$$c(x, y)$$$ be the number of positions $$$i$$$ of the password string $$$s$$$ such that $$$s_i = x$$$ and $$$s_{i + 1} = y$$$. In other words, $$$c(x, y)$$$ is the number of times Lara has to enter letter $$$y$$$ after entering letter $$$x$$$. We need to find any permutation of letters $$$p_0, p_1, p_2, \ldots, p_{k-1}$$$ of minimum cost. Integer $$$p_i$$$ stands for the index of the letter that will be placed at position $$$i$$$. The cost of a permutation is computed as $$$w(p) = \sum_{0 \leq i, j < k, i \ne j} c(p_i, p_j) \cdot |i - j|$$$.Pointwise weights are much more convenient to use rather than pairwise weights. Re-write the cost function as follows. $$$$$$w(p) = \sum_{0 \leq i, j < k, i \ne j} c(p_i, p_j) \cdot |i - j| = \sum_{0 \leq i < j < k} (c(p_i, p_j) + c(p_j, p_i)) \cdot (j - i) = \sum_{i = 0}^{i < k} i \cdot (\sum_{j = 0}^{j < i} (c(p_j, p_i) + c(p_i, p_j)) - \sum_{j = i + 1}^{j < k} (c(p_j, p_i) + c(p_i, p_j)))$$$$$$Usage of pointwise weights allows us to obtain the permutation step by step from left to right. When we place the new element $$$x$$$ we only need to know the subset of all already placed elements and the optimal cost of the prefix.Define $$$d(mask)$$$ as the minimum total cost of a permutation prefix containing first $$$|mask|$$$ elements. The update function looks as follows. $$$$$$d(mask) = \min_{x \in mask} (d(mask - x) + |mask| \cdot (\sum_{y \in mask, y \ne x} (c(y, x) + c(x, y)) - \sum_{y \not\in mask} (c(y, x) + c(x, y))))$$$$$$The above solution works in $$$O(2^n \cdot n)$$$. However, in can be updated to $$$O(2^n \cdot n)$$$ with some precomputations of the sums in the formula above.Now we need to learn how to apply the similar idea for a positioning on a circle. The cost function now looks as follows. $$$$$$w(p) = \sum_{0 \leq i, j < k, i \ne j} c(p_i, p_j) \cdot \min(|i - j|, k - |i - j|) = \sum_{i = 0}^{k - 1} pw(p, i)$$$$$$In order to write the cost function using pointwise weights we need to distinguish between two halves. The pointwise cost of an element in the first half is: $$$$$$pw(p, i) = i \cdot \sum_{j = 0}^{j < i} (c(p_i, p_j) + c(p_j, p_i)) - i \cdot \sum_{j = i + 1}^{j \leq i + \lfloor \frac{k}{2} \rfloor} (c(p_i, p_j) + c(p_j, p_i)) + (i + n) \cdot \sum_{j = i + \lfloor \frac{k}{2} \rfloor + 1}^{k - 1} (c(p_i, p_j) + c(p_j, p_i))$$$$$$Similarly, the poinwise cost of an element in the second half is: $$$$$$pw(p, i) = -i \cdot \sum_{j = 0}^{j < i - \lfloor \frac{k}{2} \rfloor} (c(p_i, p_j) + c(p_j, p_i)) + i \cdot \sum_{j = i - \lfloor \frac{k}{2} \rfloor}^{j < i} (c(p_i, p_j) + c(p_j, p_i)) - i \cdot \sum_{j = i + 1}^{k - 1} (c(p_i, p_j) + c(p_j, p_i))$$$$$$The above formulas show that it makes sense to first split all elements in two parts: left and right halves of the circle. Then we will alternate steps in adding one element to the first unoccupied position of the left part, then to the first unoccupied position of the right part. This way we will always be able to compute the value of a pointwise cost function.So we compute the dynamic programming $$$d(S, M)$$$, where $$$S$$$ is the subset identifying the way to split the set of all letters in two equal (or almost equal for the case of odd size) parts, and $$$M$$$ is the subset of already added elements. Elements $$$S \cap M$$$ are placed at the beginning of the first half and elements $$$\overline{S} \cap M$$$ are placed at the beginning of the second half.The simpliest complexity estimation is $$$O(4^n \cdot n)$$$. However, we should consider the following optimizations.   We only use $$$|S| = \lceil \frac{k}{2} \rceil$$$.  We only use states such that $$$|S \cap M| = |\overline{S} \cap M|$$$ or $$$|S \cap M| = |\overline{S} \cap M| + 1$$$.  The character $$$s_0$$$ is always located at the first sector of the code lock, so Lara doesn't have to make any moves to enter the first character of her password. Thus, we only consider $$$s_0 \in S$$$ and $$$s_0 \in M$$$. Considering all the above optimizations we end up with only $$$82818450 \approx 83 \cdot 10^6$$$ states. The problem statement asks you to compute the number of permutations as well. That doesn't add anything to the difficulty of this dynamic programming solution and is just used to cut away all the heuristic optimizations like annealing simulation.