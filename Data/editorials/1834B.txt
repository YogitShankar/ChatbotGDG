Editorial for Problem: B. Maximum Strength
Problem ID: 1834B

Solution:
Thank you for participating!1834A - Unit Array was authored and prepared by Artyom1231834B - Maximum Strength was authored by jury of the olympiad, and prepared by TheEvilBird1834C - Game with Reversing was authored and prepared by sevlll7771834D - Survey in Class was authored by vaaven and Mikhango and prepared by Alexdat20001834E - MEX of LCM was authored by TeaTime and prepared by I_love_kirill221834F - Typewriter was authored and prepared by Ziware 1834A - Unit ArrayFirst, let's make the sum of the array elements ≥0≥0. To do this, we just need to change some −1−1 to 1. The number of such replacements can be calculated using a formula or explicitly simulated.After that, there are two possible situations: either the product of all elements is equal to 1, or the product of all elements is equal to −1. In the first case, we don't need to do anything else. In the second case, we need to replace one more −1 with 1 (note that in this case the sum will remain ≥0). 1834B - Maximum StrengthLet's add leading zeros to L if necessary. Now we can represent the numbers L and R as their longest common prefix, the digit k at which the values differ, and the remaining digits. After digit k, any digits can be placed, so it is advantageous to put 9 in one number and 0 in the other. Then the answer is equal to (rk−lk)+9⋅(n−k). For example, it is achieved with numbers A=¯l1l2…lk99…9⏟n−k and B=¯r1r2…rk00…0⏟n−k. 1834C - Game with ReversingLet's show that the specific choice of a turn by Bob (which of the strings to reverse) does not affect Alice's strategy and therefore the answer to the problem.Reversing the string twice does not change anything → we are only interested in the parity of the number of reverses for both strings.If Bob made an even number of moves in total, then the parity of the number of moves made by Bob with string s coincides with the parity of the number of moves made by Bob with string t→ pairs of characters at the same indices, after all reverses, will be (s1,t1),(s2,t2),…,(sn,tn), possibly in reverse order, but it doesn't matter. Here s1,…,sn and t1,…,tn are the original indices of the strings, which do not change with reversing.If Bob made an odd number of moves, then exactly one of the strings will be reversed, and the pairs of characters in the same indices will be: (s1,tn),(s2,tn−1),…,(sn,t1) (or in reverse order).That is, the specific pairs of corresponding characters are determined only by the parity of the total number of moves made by Bob, and it does not matter which specific moves were made.Therefore, Alice can choose one of two strategies: Make s1=t1,s2=t2,…,sn=tn, and fix the end of the game when the number of moves made by Bob is even. Make s1=tn,s2=tn−1,…,sn=t1, and fix the end of the game when the number of moves made by Bob is odd.Let's count cnt — the number of indices where s and t differ, and cntrev — the number of indices where s and rev(t) differ.For the first strategy, Alice must make at least cnt moves herself, and it is also necessary that the number of moves made by Bob is even → it is easy to see that for this strategy the game will last 2⋅cnt−cnt%2 moves.For the second strategy, everything is roughly similar: the game will last 2⋅cntrev−(1−cntrev%2) moves, but the case cntrev=0 needs to be handled separately.And the answer to the problem will be the minimum of these two values. Asymptotic: O(n). 1834D - Survey in ClassLet's fix the students who will end up with the highest and lowest hands. Then, to maximize the difference, we can ask all the topics that the student with the highest hand knows. Then the second student will raise his hand for each topic in the intersection of their segments, and lower for each topic that only the first student knows. That is, the problem is to find 2 segments a and b such that the value of |a|−|a|∩b| is maximal, since the answer is 2⋅(|a|−|a∩b|).The segment b can intersect the segment a in four ways: intersect the beginning of a, intersect the end of a, be completely inside a, or not intersect it at all. So, if in the answer segment b intersects the beginning of a, then you can choose the segment with the minimal right end as the segment b — the intersection of such a segment with a will be no greater than the intersection of b with a. Similarly, for the right end, you can select the segment with the maximal left end. If the answer has one segment in another, then you can consider the shortest segment in the set as the inner segment. If the segments in the answer do not intersect, then the segment does not intersect one of the "edge" segments.Thus, to find the segment with which it has the minimum intersection for a given segment, you need to check 3 candidates: the shortest segment in the set, the segment with the minimal right end, and the one with the maximal left end. In total, to find the answer, you need to check 3n pairs of segments. 1834E - MEX of LCMNotice that the MEX of n2 numbers will not exceed n2+1. Let's calculate all possible LCM values on segments that do not exceed n2. To do this, we will iterate over the right endpoint of the segments and maintain a set of different LCM values on segments with such a right endpoint.Let these values be x1<x2<…<xk. Then k≤1+2log2n, indeed, for each 1≤i<k, it is true that xi+1 is divisible by xi, and therefore xi+1≥2xi, that is, n2≥x2≥2k−1, from which the required follows. That is, the values x1,…,xk can be stored naively in some dynamic array. Now suppose we want to move the right endpoint, then the array (x1,…,xk) should be replaced by ([x1,ar],…,[xk,ak],ak) and remove values greater than n2+1 from the new array, as well as get rid of duplicates.All these actions can be performed in O(nlogn) time, after which we just need to find the MEX among the known set of values. This solution can also serve as proof that the desired MEX does not exceed n⋅(1+2log2n), which is less than 109 under the constraints of the problem. Thus, initially, we can only maintain numbers less than 109 and not worry about overflows of a 64-bit integer type. 1834F - TypewriterLet's solve the problem if there are no requests. The key object for us will be such cells that the number in them is less than the cell index. Note that for one carriage reset, we can transfer no more than one such number. So we have a lower bound on the answer.Let's build a graph with edges $$$i\rightarrow a[i]$$$. Then it will break up into cycles. Let's find the first position where $$$a[i] \neq i$$$, take a number from this position, shift it to $$$a[i]$$$, take a number from position $$$a[i]$$$, and so on. Then we will put the whole cycle in its place. How many carriage drops will there be? Exactly as many edges as there are such that $$$a[i] < i$$$. That is, the answer is exactly equal to the number of positions where $$$a[i] < i$$$.Let's learn how to solve for shifts. Let's find for each cell such positions of the beginning of the array that it will satisfy $$$a[i] < i$$$ in this configuration. It is easy to see that for a particular cell, such indexes will form a segment (possibly a prefix + suffix). Let's create a separate array and add one on these segments. Then in the i-th position there will be an answer if the array starts from the i-th cell.Now let's solve for an array flip. It is easy to see that for this you can simply maintain the entire previous structure, but with the inverted original configuration of cells. Asymptotic: $$$O(n + q)$$$.
Thank you for participating!