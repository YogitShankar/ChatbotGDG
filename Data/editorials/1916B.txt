Editorial for Problem: B. Two Divisors
Problem ID: 1916B

Solution:
Thanks for your participating!author: RedMachine-74, developer: marzipan, zwezdinv 1916A - 2023Let the product of the numbers in our array be $$$x$$$. If $$$2023$$$ is not divisible by $$$x$$$, then the answer is NO, otherwise the answer is YES. One of the ways to construct the removed numbers is as follows—$$$1$$$ number $$$\frac{2023}{x}$$$ and $$$k - 1$$$ numbers $$$1$$$.author: OR_LOVe, developer: marzipan 1916B - Two DivisorsFirst case: $$$b \mod a = 0$$$.In this case, $$$b = a \cdot p$$$, where $$$p$$$ is the smallest prime factor of $$$x$$$. Then $$$x = b \cdot p = b \cdot \frac{b}{a}$$$.Second case: $$$b \mod a \neq 0$$$.In this case, $$$b = \frac{x}{p}, a = \frac{x}{q}$$$, where $$$p, q$$$ are the two smallest prime factors of $$$x$$$. Then $$$\gcd(a, b) = \frac{x}{p \cdot q}, x = b \cdot p = b \cdot \frac{a}{\gcd(a, b)}$$$.author: sadness, developer: marzipan 1916C - Training Before the OlympiadNote that our operation replaces two numbers with their sum if they are of the same parity, and with their sum $$$-1$$$ otherwise. Therefore, the second player needs to perform as many operations as possible where an even and an odd number are used. Also, note that on any move of the second player, there will be at least one even number that the first player made on the previous move. Then our task for the first player is to remove two odd numbers as often as possible. It can also be observed that the number of odd numbers in the array does not decrease, which means all operations with two odd numbers will go before operations with two even numbers. And after each such move, the second player will remove one odd number from the array. That is, in two moves, the number of odd numbers decreases by $$$3$$$. Let's consider all possible remainders of the number of odd numbers modulo $$$3$$$. If the remainder is $$$0$$$, then the answer is $$$sum - \frac{cnt}{3}$$$, where $$$sum$$$ is the sum of all numbers. If the remainder modulo is $$$1$$$, then two situations are possible: when the size of the array is $$$1$$$ — then the answer is the single number in the array. Otherwise, at the moment when there is $$$1$$$ odd number left, there will be one more move of player number $$$2$$$, which means he will reduce the total sum once more, and the answer will be $$$sum - \lfloor \frac{cnt}{3} \rfloor - 1$$$. If the remainder modulo is $$$2$$$, then the number of moves when the second player reduces the sum does not change, so the answer is $$$sum - \lfloor \frac{cnt}{3} \rfloor$$$.author: OR_LOVe, developer: zwezdinv 1916D - Mathematical Problem$$$1.$$$ For $$$n = 1$$$ the answer is $$$1$$$.$$$2.$$$ For $$$n = 3$$$ the answers are $$$169, 961, 196$$$.$$$3.$$$ How to obtain the answer for $$$n + 2$$$: multiply each number for the answer of length $$$n$$$ by $$$100$$$ (the square of the number $$$10$$$), then each number will also remain a square. And we still have 2 numbers left, let's compose them as follows: $$$9...6...1$$$, $$$1...6...9$$$ where in the gaps between the digits there should be $$$(n - 3) / 2$$$ zeros, these will respectively be the squares of numbers $$$1...3, 3...1$$$ with $$$(n - 3) / 2$$$ zeros in the gaps between the digits.Alternative solution:For $$$n = 11$$$ generate 99 such numbers, for $$$n \ge 11$$$ pad them with zeros. For $$$n < 11$$$ solve in $$$O(\sqrt{10^n})$$$author: marzipan, developer: marzipan 1916E - Happy Life in UniversityLet's initiate a tree traversal from the first vertex, in which for each color on the path from the root to the current vertex, we will maintain the nearest vertex with that color, or note that it does not exist. This can be maintained using an array that is recalculated in $$$O(1)$$$. Now, for each vertex, let's remember all the vertices for which we are the nearest ancestor with the same color. Build a segment tree on the Euler tour that will support two operations — adding to a segment and finding the maximum. Let's start another traversal of the tree, and for each vertex, we will maintain the count of different colors on the path from it to the vertex we are currently traversing with depth-first search. It is then asserted that we need to add $$$1$$$ to the entire subtree of this vertex and subtract $$$1$$$ from the subtrees of all vertices for which we are the nearest ancestor with the same color. After that, we need to find the $$$2$$$ maximums among all the subtrees of the children and update the answer using them.author: zwezdinv, developer: zwezdinv 1916F - Group DivisionWe will generate the first set by adding one vertex at a time.Initially, we will include any vertex. Then, to add a vertex from the second set, it must not be a cut vertex and must be connected to some vertex in the first set.Statement: such a vertex always exists.Proof: No cut vertex $$$\Rightarrow$$$ such a vertex exists. Otherwise, consider a cut vertex such that, if removed, at least one of the resulting components will not have any other cut vertices. Then, if none of the vertices in this component is connected to the second component, this cut vertex will be a cut vertex in the original graph. Contradiction.Time — $$$O(n_1 \cdot (n_1 + n_2 + m))$$$author: RedMachine-74, developer: RedMachine-74 1916G - Optimizations From ChelsuLet's perform centroid decomposition and maintain the current found answer $$$ans$$$. On vertical paths, simply find the value of the function, and we will immediately update the answer, We need to learn how to update the answer for a pair of vertical paths, combining pairs $$$(g_1, len_1)$$$ and $$$(g_2, len_2)$$$. Let's make several observations. First. If $$$len_1 \ge len_2$$$, then $$$gcd(g_1, g_2) = g_1$$$. Because if $$$gcd(g_1, g_2)$$$ is not equal to $$$g_1$$$, then it is at least twice smaller than $$$g_1$$$. Second. From the first fact, we conclude that $$$g_2 = g_1 \cdot k$$$, so in order to make sense to update the answer, we need $$$g_1 \cdot (len_1 + len_2) > g_1 \cdot k \cdot len_2$$$ and from here we get that $$$len_1 > len_2 \cdot (k - 1)$$$. This means that $$$k \leq len_1$$$.Let's do the following for a fixed centroid for each component: For each $$$g$$$, we will only keep the largest value of $$$len$$$, We will iterate over all such pairs and assume that we have fixed the pair $$$(g_1, len_1)$$$. For this, we will need to iterate over $$$1 \leq k \leq len_1$$$. Let's make the following optimization—if $$$g \cdot (len + d) \leq ans$$$, then there is no need to iterate over $$$k$$$, because we are guaranteed not to improve the answer. $$$d$$$—is the farthest distance from the centroid to any vertex.We have an upper bound estimate for this solution $$$O(n \sqrt n \log n)$$$. Let's prove it.For the pair $$$(len_i, gcd_i)$$$, we iterate over $$$k$$$ such that $$$1 \leq k \leq k_i$$$, where $$$k_i \leq len_i$$$ and we also cut off by the answer. Let's mark $$$k_i$$$ edges on the path from the centroid to the vertex from which this pair came. Let's look at some edge, suppose it is marked $$$c$$$ times, the distance from the centroid is $$$L$$$, and the $$$\gcd$$$ from the centroid, including this edge, is $$$g$$$. This means that we also marked it for some $$$gcd_i \leq \frac{g}{c}$$$. But we already knew that the answer was at least $$$g$$$, which means the size of the current graph is at least $$$L \cdot c$$$. It turns out that we could not have marked an edge at a distance $$$L$$$ from the centroid more than $$$\frac{n}{L}$$$ times.We need to estimate in the tree the sum of $$$min(\frac{n}{depth[v]}, sz[v])$$$. It can be estimated as $$$n \sqrt n$$$. For $$$depth[v] \leq \sqrt n$$$, we have a total size of subtrees at the level of $$$n$$$, and then the value $$$\frac{n}{depth[v]} \leq \sqrt n$$$.author: platelet, developer: errorgorn 1916H2 - Matrix Rank (Hard Version)Let $$$dp_{m,k}$$$ denote the number of $$$m \times n$$$ matrices whose rank is $$$k$$$.The recurrence for $$$dp_{m,k} = dp_{m-1,k} \cdot p^k + dp_{m-1,k-1} \cdot (p^n-p^{k-1})$$$ with the base case of $$$dp_{0,0}=1$$$.Consider enumerating $$$m \times n$$$ matrices $$$A$$$ such that $$$\text{rank}(A)=k$$$ based on a $$$(m-1) \times n$$$ matrix $$$B$$$ and a row vector $$$C$$$ such that $$$A$$$ is made by appending $$$C$$$ to $$$B$$$:  If $$$\text{rank}(B) = \text{rank}(A)$$$, then $$$C$$$ must be inside the span of $$$B$$$ which has size $$$p^k$$$.  If $$$\text{rank}(B)+1=\text{rank}(A)$$$, then $$$C$$$ must be outside the span of $$$B$$$ which has size $$$p^n-p^{k-1}$$$. The $$$p^n-p^{k-1}$$$ term in our recurrence is annoying to handle. So we will define $$$g_{m,k}$$$ as $$$g_{m,k} = g_{m-1,k} \cdot p^k + g_{m-1,k-1}$$$. It should be easy to see that $$$dp_{m,k}=g_{m,k} \cdot \prod\limits_{i=0}^{k-1} (p^n-p^i)$$$.Method 1: Easy Version OnlyWe will show how to compute $$$g_{2m}$$$ from $$$g_m$$$. I claim that $$$g_{2m,k} = \sum\limits_{a+b=k} g_{m,a} \cdot g_{m,b} \cdot p^{a(m-b)}$$$.The justification for this is to consider moving the DP state from $$$(0,0) \to (m,a) \to (2m,a+b)$$$. The contribution of moving $$$(m,a) \to (2m,a+b)$$$ is actually very similar to that of moving $$$(0,a) \to (m,a+b)$$$, except every time we multiply the value by $$$p^k$$$, we have to instead multiply it by $$$p^{k+a}$$$. And conveniently, the number of times we need to additionally multiply by $$$p^k$$$ is $$$m-b$$$.To convolute these sequences, we will use a technique that is similar to chirp-z transform. Note that $$$ab = \binom{a+b}{2} - \binom{a}{2} - \binom{b}{2}$$$, you can prove this geometrically by looking at $$$\binom{x}{2}$$$ as a triangle pyramid.$$$$$$\begin{aligned} \sum\limits_{a+b=k} g_{m,a} \cdot g_{m,b} \cdot p^{a(m-b)} &= \sum\limits_{a+b=k} g_{m,a} \cdot g_{m,b} \cdot p^{am + \binom{a}{2} + \binom{b}{2} - \binom{a+b}{2}} \\ &= p^{-\binom{k}{2}} \sum\limits_{a+b=k} (g_{m,a} \cdot p^{am + \binom{a}{2}}) \cdot (g_{m,b} \cdot p^{\binom{b}{2}}) \end{aligned}$$$$$$Therefore, it is we can get $$$g_{2m}$$$ from $$$g_m$$$ by convoluting $$$(g_{m,i} \cdot p^{im+\binom{i}{2}})$$$ and $$$(g_{m,i} \cdot p^{\binom{i}{2}})$$$ in $$$O(k \log k)$$$ time. By performing a process similar to fast exponentiation, we can compute $$$g_n$$$ in $$$O(k \log k \log n)$$$.Method 2: Easy Version OnlyConsider the ordinary generating function $$$G_k = \sum\limits g_{m,k} x^m$$$. Based on the recurrence above, We have $$$G_k = x(p^kG_k + G_{k-1})$$$. This gives us $$$G_k = \frac{xG_{k-1}}{1-p^kx} = x^k \prod\limits_{i=0}^k \frac{1}{1-p^ix}$$$.We want to find $$$[x^n] G_0, [x^n] G_1, \ldots, [x^n] G_k$$$. Notice that $$$[x^n] G_k = [x^{n-k}] \prod\limits_{i=0}^k \frac{1}{1-p^ix} = [x^k] x^n ~\%~ (\prod\limits_{i=0}^k x-p^i)$$$. Where $$$A ~\%~ B$$$ denotes the unique polynomial $$$C$$$ with $$$\text{deg}(C)<\text{deg}(B)$$$ and there exists $$$D$$$ such that $$$A = BD + C$$$.We can compute all required coefficient in a divide and conquer-esque way. Note that $$$A ~\%~ B = (A ~\%~ BC)~\%~B$$$.We want $$$\text{dnc}(l,r)$$$ to find all the answers for $$$[x^n] G_l, [x^n] G_{l+1}, \ldots, [x^n] G_r$$$. $$$\text{dnc}(l,r)$$$ will be provided with $$$P(x)=x^n ~\%~ (\prod\limits_{i=0}^r x-p^i)$$$ and $$$Q(x) = \prod\limits_{i=0}^{l} x-p^i$$$.Then the pseudocode of the DnC is as follows:fun dnc(l,r,P,Q):	if (l==r):		ans[l] = [x^l]P		return	m=(l+r)/2	Q2=Q * (x-p^(l+1)) * ... (x-p^m)	dnc(l,m,P%Q2,Q)	dnc(m+1,r,P,Q2)The above code is at least quadratic. However, we only need to save the last $$$(r-l+1)$$$ non-zero coefficients from both $$$P$$$ and $$$Q$$$. If implemented properly, this code runs in $$$O(k \log k \log n)$$$.Method 3: Hard VersionAs with the first part of method $$$2$$$, we want to find $$$[x^n] G_0, [x^n] G_1, \ldots, [x^n] G_k$$$ where $$$G_k = x^k \prod\limits_{i=0}^k \frac{1}{1-p^ix}$$$. We will try to decompose $$$\prod\limits_{i=0}^k \frac{1}{1-p^ix}$$$ into partial fractions.Repeated factors in partial fractions is hard to deal with. It turns out, we do not need to deal with them at all. Suppose $$$ord$$$ is the smallest positive integer that such $$$p^{ord} = 1 \pmod{998244353}$$$. Then $$$p^0,p^1,\ldots,p^{ord-1}$$$ are all distinct. Furthermore, $$$dp_{n,k}=0$$$ for $$$k \geq ord$$$ as $$$dp_{m,k}=g_{m,k} \cdot \prod\limits_{i=0}^{k-1} (p^n-p^i)$$$.Therefore, we can safely assume $$$k < ord$$$ so that $$$p^0,p^1,\ldots,p^k$$$ will be all distinct.By using the cover-up rule on $$$\prod\limits_{i=0}^k \frac{1}{1-p^ix}$$$, we obtain a partial fraction decomposition of $$$\sum\limits_{i=0}^k \frac{c_i}{1-p^ix}$$$ where $$$c_i = \prod\limits_{j=0, i\neq j}^k \frac{1}{1-p^{j-i}}$$$.Let $$$L_i=\prod_{j=1}^i\frac 1{1-p^{-j}},R_i=\prod_{j=1}^i\frac 1{1-p^j}$$$，so that $$$c_i=L_iR_{k-i}$$$.$$$$$$\begin{aligned}[x^n] G_k &= [x^{n-k}] \prod\limits_{i=0}^k \frac{1}{1-p^ix} \\ &= [x^{n-k}] \sum\limits_{a+b=k} \frac{L_a R_b}{1-p^ax} \\ &= \sum\limits_{a+b=k} p^{a(n-k)} L_a R_b \\ &=\sum\limits_{a+b=k} p^{\binom{n-b}{2} - \binom{n-k}{2} - \binom{a}{2}} L_a R_b \\ &=p^{-\binom{n-k}{2}} \sum\limits_{a+b=k} (L_a \cdot p^{-\binom{a}{2}}) (R_{b} \cdot p^{\binom{n-b}{2}}) \end{aligned}$$$$$$So we can find $$$[x^n] G_0, [x^n] G_1, \ldots, [x^n] G_k$$$ by convoluting $$$(L_i \cdot p^{\binom{i}{2}})$$$ and $$$(R_{i} \cdot p^{\binom{n-i}{2}})$$$.The final time complexity is $$$O(k \log k)$$$.Method 4: Hard VersionThanks to Endagorion for finding this solution during testing.For an $$$n$$$-dimensional vector space of $$$\mathbb{F}_q$$$, the number of $$$k$$$-dimensional vector subspace is denoted as $$$\binom{n}{k}_q$$$ and is known as the q-analogue of binomial coefficients.It is known that $$$\binom{n}{k}_q = \frac{(q^n-1)\ldots(q^{n-k+1}-1)}{(1-q)\ldots(1-q^k)}$$$. This fact is not too hard to derive by considering the number of possible independent sets dividing the the number of sets that results in the same span. Here it is helpful to use the form $$$\binom{n}{k}_q = \frac{[n!]_q}{[k!]_q[n-k!]_q}$$$ where $$$[n!]_q = (1) \cdot (1+q) \ldots \cdot (1+q+\ldots+q^{n-1})$$$. If you want to read more about these series, I recommend checking out Enumerative Combinatorics.We will proceed with PIE (principle of inclusion-exclusion) on these $$$q$$$-binomials. We want to find the number of ways to choose $$$n$$$ vectors that spans exactly some $$$k$$$-dimensional vector space, but this is hard. However, we realize that we are able to count the number of ways to choose to choose $$$n$$$ vectors that spans a subset of some $$$k$$$-dimensional vector space. Let $$$f_k$$$ and $$$g_k$$$ denote these values respectively.Then we have $$$g_k = \sum\limits_{i=0}^k f_i \cdot \binom{k}{i}_q$$$. Note that this is very similar to egf-convolution with the identity sequence. Indeed, if we define the generating functions $$$F = \sum f_k \frac{x^k}{[k!]_q}$$$, $$$G = \sum g_k \frac{x^k}{[k!]_q}$$$ and the identity sequence $$$I = \sum \frac{x^k}{[k!]_q}$$$, we have $$$F \cdot I = G$$$.We are able to calculate $$$I$$$ and $$$G$$$, so we can find $$$F = G \cdot I^{-1}$$$.Then, the number of matrices with rank $$$k$$$ is simply $$$f_k \cdot \binom{n}{k}_q$$$.Of course, a caveat is that division might not be defined when some $$$[n!]_q=0$$$, and it is a simple exercise to the reader to figure out why defining $$$0^{-1}=0$$$, which aligns with our usual definition of $$$a^{MOD-2}=a^{-1}$$$ does not break anything in the solution.The final time complexity is $$$O(k \log k)$$$.
Thanks for your participating!
author: RedMachine-74, developer: marzipan, zwezdinv 