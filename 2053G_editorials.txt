 Problem_ID: 2053G
note that: since i+(n−i)=n , then max(i,n−i)≥ n 2 . denote X= s 1 s 2 … s i and Y= s i+1 s i+2 … s n , then max(|X|,|Y|)=O(n) . If X and Y have a common shortest period, the problem can be transformed into a pure number theory problem: Whether there are non-negative integers p,q such that px+qy=m . By simply enumerating the coefficient of max(x,y) , the total time complexity is O( m n )⋅O(n)=O(m) , which is affordable. In other cases, we can prove that if there is at least one possible partition, then there is exactly one partition. This can be proved inductively. If X is not a prefix of Y and Y is not a prefix of X , greedy matching would work. Otherwise, WLOG Y=X+ Y ′ , we can try to split t using X and Y ′ , then recover the partition using X and Y . This is like the process of doing Euclid algorithms on numbers, so if X and Y don't share a common shortest period, there is at most one partition. How do we judge it efficiently? WLOG |X|≤|Y| , we can write Y= X k + Y ′ , in which k is the maximum possible. We can always try to match with X , and if it fails withdraw the last k matches of X (if there is not that much, then no solution), and try to match with Y (if it still fails, then no solution). Why would it work? If Y ′ is a prefix of X and for some k ′ , Y ′ k ′ +X is a prefix of X , then it can be proven that the conditions lead to a common period, which makes a contradiction. Otherwise, as proved above, it works correctly. To judge whether a prefix or suffix of s matches a substring in t , it's more efficient to use Z Function. Well-implemented hashing methods can also pass comfortably. The time complexity can be proven by harmonic series, therefore it is O(mlogn) .