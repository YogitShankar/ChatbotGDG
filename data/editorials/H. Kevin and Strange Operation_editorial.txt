Hint 1 
 Consider how to determine if the 01 string t can be generated. 
Hint 2 
 Try designing a DP that only records the useful variables. 
Hint 3 
 Optimize using data structures or improve the complexity of the transitions. 
Tutorial 
 2048H - Kevin and Strange OperationAssume that after performing several operations on the 01 string s, we get the 01 string t. It’s not hard to notice that each element in t corresponds to the max of a subset of elements from s. Further observation shows that this subset must form a continuous segment, so we can express ti as rimaxk=lisk.Initially, t=s, so all li=ri=i. Suppose the current length of string t is m, corresponding to two sequences l and r. If an operation is performed at position p where 1≤p≤m, the new sequence t′ will correspond to two sequences l′ and r′. Then, since for 1≤i<p, we have t′i=max(ti,ti+1), and for p≤i<m, t′i=ti+1, it can be observed that for 1≤i<p, we have l′i=li,r′i=ri+1, and for p≤i<m, l′i=li+1,r′i=ri+1. If we only focus on the change of sequences l and r to l′ and r′, it is equivalent to deleting the values lp and r1.Thus, performing k operations starting from the sequence s, the resulting sequence t will correspond to the sequences l and r, where l is obtained by deleting any k values from 1 to n, and r is the sequence from k+1 to n.Now, let's consider how to determine if the 01 string t can be generated. By reversing t to get t′, the task becomes finding n≥p1>p2>⋯>pk≥1 such that for all 1≤i≤k, we have t′i=n−i+1maxk=pisk. A clearly correct greedy strategy is to choose pi in the order i=1∼k, always selecting the largest possible value.Now consider performing DP. Let dpi,j represent how many length-i 01 strings t can be generated such that after running the above greedy algorithm, pi exactly equals j. We assume that p0=n+1 and the boundary condition is dp0,n+1=1. We now consider the transition from dpi−1,j to dpi,∗:  If s[j−1,n−i+1] already contains 1, then the i-th position in the reversed t must be 1, and it must be the case that pi=j−1, so we add dpi,j−1 to dpi−1,j. If s[j−1,n−i+1] does not contain 1, the i-th position in the reversed t can be 0. If it is 0, then it must be the case that pi=j−1, and we add dpi,j−1 to dpi−1,j; if we want the i-th position in the reversed t to be 1, we need to find the largest pos≤n−i+1 such that spos=1, and then set pi=pos, adding dpi,pos to dpi−1,j. Both types of transitions can be considered as adding dpi,j−1 to dpi−1,j, then finding the largest pos≤n−i+1 where spos=1, and for all j−1>pos (i.e., j≥pos+2), adding dpi,pos to dpi,j.The first type of transition can be viewed as a global shift of the DP array, while the second type requires calculating a segment suffix sum of the DP array and then performing a point update. This can be done efficiently using a segment tree in O(nlogn) time for all transitions.The final answer is the sum of all 1≤i≤n,1≤j≤n of dpi,j. Using a segment tree for maintenance, we can also query the sum of each entry of dpi in O(1) time (by setting to zero those entries where dpi−1,1 is out of range after the shift).Since the transitions have better properties, it's actually possible to solve the problem cleverly using prefix sums in O(n) time without needing complex data structures, but that is not strictly necessary. 
