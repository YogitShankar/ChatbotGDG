Solution Step 1: Prove that for the minimum value of ğ‘šm, we must have ğ‘š%ğ‘=ğ‘š%ğ‘=0m%a=m%b=0. Step 2: To prove this, show that if ğ‘š%ğ‘=ğ‘š%ğ‘=ğ‘¥>0m%a=m%b=x>0, then ğ‘šâˆ’1mâˆ’1 will also satisfy the problem's requirements. Step 3: Since ğ‘šâ‰¥min(ğ‘,ğ‘)mâ‰¥min(a,b), if ğ‘¥>0x>0, then ğ‘š>min(ğ‘,ğ‘)m>min(a,b) must hold. Therefore, ğ‘šâˆ’1â‰¥min(ğ‘,ğ‘)mâˆ’1â‰¥min(a,b) implies that ğ‘šâˆ’1mâˆ’1 satisfies the requirements. Step 4: Thus, ğ‘šm must be divisible by both ğ‘a and ğ‘b. The smallest such ğ‘šm is ğ‘™ğ‘ğ‘š(ğ‘,ğ‘)lcm(a,b) which can be calculated in ğ‘‚(log(max(ğ‘,ğ‘)))O(logâ¡(max(a,b))). 

Implementation#include <bits/stdc++.h>

using namespace std;

int main(){
  int tt;
  cin >> tt;
  while(tt--){
    int a, b;
    cin >> a >> b;
    cout << lcm(a , b) << endl;
  }
}

SolutionWe will solve the problem using the following approach:  Start from the leftmost spot and move rightwards. Whenever a consecutive segment of ğ‘šm weak spots (i.e., 00's) is found, apply Timar to a segment of length ğ‘˜k, starting from the last index of the weak segment. Repeat this process until no segment of ğ‘šm consecutive weak spots remains. The key idea behind this solution is that whenever we encounter a block of ğ‘šm consecutive 00's, we need to strengthen it. Since we can apply Timar to a segment of length ğ‘˜k, the optimal strategy is always to apply Timar starting at the last index of the block of ğ‘šm consecutive 00's.Correctness Proof:  For any block of ğ‘šm consecutive 00's, we must apply Timar to at least one index within this block. Hence, the strengthened segment of length ğ‘˜k must overlap with the block of weak spots. Suppose an optimal solution exists where Timar is applied to a segment starting leftward within the block. Suppose we shift this segment one step to the right (closer to the end of the block). In that case, the solution remains valid and optimal since it covers all weak spots in the block while reducing unnecessary overlap with already-strengthened areas. By always starting from the last index of a block of ğ‘šm consecutive 00's, this greedy strategy ensures that Timar is used in the minimum number of applications, making it correct and efficient.

Implementation# include <bits/stdc++.h>

using namespace std;

const int xn = 2e5 + 10;

int q, n, m, k, ps[xn];
string s;

int main() {
    cin >> q;
    while (q --) {
        cin >> n >> m >> k >> s;
        fill(ps, ps + n, 0);
        int ans = 0, cnt = 0, sum = 0;
        for (int i = 0; i < n; ++ i) {
            sum += ps[i];
            if (sum || s[i] == '1') cnt = 0;
            else {
                cnt++;
                if (cnt == m) {
                    sum++, ans++, cnt = 0;
                    if (i + k < n) ps[i + k]--;
                }
            }
        }
        cout << ans << "\n";
    }
}

Solution If a cell has a fixed direction (i.e., it points to another cell), and following that direction leads outside the maze, it must eventually exit the maze. Such cells cannot be part of any loop. We can analyze the remaining cells once we identify cells that lead out of the maze. Any undirected cell or ?? cell might either lead to the exit or form part of a loop. If all neighboring cells of a ?? cell can eventually lead out of the maze, then this ?? cell will also lead out of the maze. The state of such ?? cells can be determined based on their surroundings. For any remaining cells (directed cells that do not lead out of the maze, or other ?? cells that cannot be determined to lead to an exit), we can assign directions such that starting from those cells will eventually lead to a loop. These cells will form the loops. To find how many cells will eventually lead to a loop, we can use a Depth-First Search (DFS) on the reversed graph, where all directions are reversed. By performing DFS starting from the "out-of-maze" cells, we can identify all cells that are reachable from the outside and thus will eventually lead out of the maze. Count the number of cells that can reach the exit. Subtract this number from the total number of cells in the maze to determine how many are part of loops (i.e., cells that cannot reach the exit). 

Implementation#include <bits/stdc++.h>
 
using namespace std;
 
int main() 
{
    int tc;
    cin >> tc;
    while(tc--){
        int n, m;
        cin >> n >> m;
        string c[n+1];
        for(int i = 1 ; i <= n ; i++) cin >> c[i] , c[i] = "-" + c[i];
        vector<pair<int,int>> jda[n+2][m+2];
        for(int i = 1 ; i <= n ; i++){
            for(int j = 1 ; j <= m ; j++){
                if(c[i][j] == 'U') jda[i-1][j].push_back({i , j});
                if(c[i][j] == 'R') jda[i][j+1].push_back({i , j});
                if(c[i][j] == 'D') jda[i+1][j].push_back({i , j});
                if(c[i][j] == 'L') jda[i][j-1].push_back({i , j});
            }
        }
        int vis[n+2][m+2] = {};
        queue<pair<int,int>> q;
        for(int j = 0 ; j <= m+1 ; j++) vis[0][j] = 1 , q.push({0 , j});
        for(int i = 1 ; i <= n+1 ; i++) vis[i][0] = 1 , q.push({i , 0});
        for(int j = 1 ; j <= m+1 ; j++) vis[n+1][j] = 1 , q.push({n+1 , j});
        for(int i = 1 ; i <= n ; i++) vis[i][m+1] = 1 , q.push({i , m+1});
        while(q.size()){
            auto [i , j] = q.front();
            q.pop();
            for(auto [a , b] : jda[i][j]){
                if(vis[a][b] == 0){
                    vis[a][b] = 1;
                    q.push({a , b});
                }
            }
        }
        for(int i = 1 ; i <= n ; i++){
            for(int j = 1 ; j <= m ; j++){
                if(c[i][j] == '?' and
                vis[i-1][j] and vis[i][j+1] and vis[i+1][j] and vis[i][j-1]) vis[i][j] = 1;
            }
        }
        int ans = n * m;
        for(int i = 1 ; i <= n ; i++){
            for(int j = 1 ; j <= m ; j++){
                if(vis[i][j] == 1) ans -= 1;
            }
        }
        cout << ans << endl;
    }
    return 0;
}

Solution Step 1: Using two moves, we can move an element to any arbitrary position in the array. Thus, we can place all 00's in their correct positions with at most 2min(ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(0),ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(1)+ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(2))2min(count(0),count(1)+count(2)) moves. Step 2: After placing all 00's, the rest of the array will contain only 11's and 22's. To sort this part of the array, we need at most ğ‘šğ‘–ğ‘›(ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(1),ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(2))min(count(1),count(2)) moves. Step 3: The first step takes at most ğ‘›n moves, and the second step takes at most ğ‘›2n2 moves. However, it can be proven that the total number of moves is at most 8ğ‘›78n7. Step 4: We can assume ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(0)â‰¤ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(2)count(0)â‰¤count(2) without loss of generality (Why?). So, the maximum number of moves are:  2min(ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(0),ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(1)+ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(2))+min(ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(1),ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(2))2min(count(0),count(1)+count(2))+min(count(1),count(2)) =2â‹…ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(0)+min(ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(1),ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(2))=2â‹…count(0)+min(count(1),count(2)) â‰¤ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(0)+max(ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(1),ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(2))+min(ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(1),ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(2))â‰¤count(0)+max(count(1),count(2))+min(count(1),count(2)) =ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(0)+ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(1)+ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡(2)=ğ‘›=count(0)+count(1)+count(2)=nBetter approach:  Step 1: Since we are allowed to perform ğ‘›n moves, assign each index one "move" as its "specified cost". Step 2: While there exists an index with a value of 00 or 22 that can be fixed with just one move, fix it using its assigned cost. Step 3: After fixing all 00's, 22's, and all 11's except one, the remaining array will have the following structure and we are now allowed to use 2ğ‘¥+12x+1 moves:  2Â 2Â â€¦Â 2Â (ğ‘¥Â times)Â 1Â 0Â 0Â â€¦Â 0Â (ğ‘¥Â times),2Â 2Â â€¦Â 2Â (xÂ times)Â 1Â 0Â 0Â â€¦Â 0Â (xÂ times),  Step 4: First, swap the 11 with a random element (denote it as ğ‘Ÿr). Then, for 2ğ‘¥âˆ’12xâˆ’1 moves, swap the index with the value 11 with any index where the correct value must be placed, except ğ‘Ÿr. Finally, swap 11 and ğ‘Ÿr. 

Implementation (first approach)#include <bits/stdc++.h>

using namespace std;

const int N = 200000;
int n, cnt[3], a[N];
vector<int> vip[3][3]; // Value In Position
vector<pair<int, int>> swaps;

inline int Pos(int index) {
    if(index < cnt[0])
        return 0;
    else if(index < cnt[0]+cnt[1])
        return 1;
    else
        return 2; 
}

inline void AddBack(int index) {
    vip[a[index]][Pos(index)].push_back(index);
}

inline void RemoveBack(int index) {
    vip[a[index]][Pos(index)].pop_back();
}

inline void Swap(int i, int j) {
    swaps.push_back({i, j});
    RemoveBack(i);
    RemoveBack(j);
    swap(a[i], a[j]);
    AddBack(i);
    AddBack(j);
}

inline void Fix(int x) {
    while(!vip[1][x].empty() or !vip[2-x][x].empty()) {
        if(vip[1][x].empty()) {
            if(!vip[1][2-x].empty())
                Swap(vip[2-x][x].back(), vip[1][2-x].back());
            else
                Swap(vip[2-x][x].back(), vip[1][1].back());
        }
        if(!vip[x][1].empty()) 
            Swap(vip[1][x].back(), vip[x][1].back());
        else
            Swap(vip[1][x].back(), vip[x][2-x].back());
    }  
}


int main() 
{
    ios_base::sync_with_stdio(false), cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        cin >> n;
        for(int i = 0; i < n; i++)
            cin >> a[i], cnt[a[i]]++;
        for(int i = 0; i < n; i++)
            AddBack(i);
        if(cnt[0] <= cnt[2]) {
            Fix(0);
            Fix(2);
        } else {
            Fix(2);
            Fix(0);
        }
        cout << swaps.size() << endl;
        for(auto [i, j]: swaps)
            cout << i+1 << ' ' << j+1 << endl;
        cnt[0] = cnt[1] = cnt[2] = 0;
        for(int i = 0; i < 3; i++)
            for(int j = 0; j < 3; j++)
                vip[i][j].clear();
        swaps.clear();
    }
    return 0;
}

Implementation (second approach)// In the name of god
#include <bits/stdc++.h>

using namespace std;

const int N = 200000;
int n, cnt[3], a[N];
vector<int> vip[3][3]; // Value In Position
vector<pair<int, int>> swaps;

inline int Pos(int index) {
    if(index < cnt[0])
        return 0;
    else if(index < cnt[0]+cnt[1])
        return 1;
    else
        return 2; 
}

inline void AddBack(int index) {
    vip[a[index]][Pos(index)].push_back(index);
}

inline void RemoveBack(int index) {
    vip[a[index]][Pos(index)].pop_back();
}

inline void Swap(int i, int j) {
    swaps.push_back({i, j});
    RemoveBack(i);
    RemoveBack(j);
    swap(a[i], a[j]);
    AddBack(i);
    AddBack(j);
}

inline void Fix() {
    bool change;
    do {
        change = false;
        while ((!vip[1][0].empty()) && (!vip[0][1].empty()))
            Swap(vip[1][0].back(), vip[0][1].back()), change = true;
        while ((!vip[1][0].empty()) && (!vip[0][2].empty()))
            Swap(vip[1][0].back(), vip[0][2-0].back()), change = true;
        while ((!vip[1][2].empty()) && (!vip[2][1].empty()))
            Swap(vip[1][2].back(), vip[2][1].back()), change = true;
        while ((!vip[1][2].empty()) && (!vip[2][0].empty()))
            Swap(vip[1][2].back(), vip[2][0].back()), change = true;
    } while (change);    
}

inline void PingPong() {
    if(vip[0][2].empty())
        return;
    Swap(vip[1][1].back(), vip[0][2].back());
    while (true){
        Swap(vip[1][2].back(), vip[2][0].back());
        if(vip[0][2].empty())
            break;
        Swap(vip[1][0].back(), vip[0][2].back());
    }
    Swap(vip[1][0].back(), vip[0][1].back());
}

int main() 
{
    ios_base::sync_with_stdio(false), cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        cin >> n;
        for(int i = 0; i < n; i++)
            cin >> a[i], cnt[a[i]]++;
        for(int i = 0; i < n; i++)
            AddBack(i);
        Fix();
        PingPong();
        cout << swaps.size() << endl;
        for(auto [i, j]: swaps)
            cout << i+1 << ' ' << j+1 << endl;
        // reset
        cnt[0] = cnt[1] = cnt[2] = 0;
        for(int i = 0; i < 3; i++)
            for(int j = 0; j < 3; j++)
                vip[i][j].clear();
        swaps.clear();
    }
    return 0;
}

Solution Step 1: There are ğ‘›n positions that must be equal, and their sum is ğ‘›â‹…(ğ‘›+1)â‹…ğ‘˜2nâ‹…(n+1)â‹…k2. Hence, each position must be (ğ‘›+1)â‹…ğ‘˜2(n+1)â‹…k2. Additionally, there must be ğ‘˜k distinct permutations, so ğ‘˜â‰¤ğ‘›!kâ‰¤n!. Step 2: For even ğ‘˜k, we can group ğ‘›!n! permutations into ğ‘›!2n!2 double handles, where each group corresponds to a solution for ğ‘˜=2k=2. Then, pick ğ‘˜2k2 handles. The match for permutation ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›a1,a2,â€¦,an is (ğ‘›+1)âˆ’ğ‘1,(ğ‘›+1)âˆ’ğ‘2,â€¦,(ğ‘›+1)âˆ’ğ‘ğ‘›(n+1)âˆ’a1,(n+1)âˆ’a2,â€¦,(n+1)âˆ’an. Step 3: For ğ‘˜=1k=1, ğ‘›n must be 11. Symmetrically, ğ‘˜k cannot be ğ‘›!âˆ’1n!âˆ’1. Solutions for other odd ğ‘˜k will now be provided. Step 4: To construct an answer for ğ‘˜=3k=3 and ğ‘›=2ğ‘¥+1n=2x+1, consider the following derived using a greedy approach:     ğ‘1p1  ğ‘2p2  ğ‘3p3  ğ‘4p4  ğ‘5p5  â€¦â€¦  ğ‘2ğ‘¥âˆ’1p2xâˆ’1  ğ‘2ğ‘¥p2x  ğ‘2ğ‘¥+1p2x+1      1  2  3  4  5  â€¦â€¦  2ğ‘¥âˆ’12xâˆ’1  2ğ‘¥2x  2ğ‘¥+12x+1    ğ‘¥+1x+1  2ğ‘¥+12x+1  ğ‘¥x  2ğ‘¥2x  ğ‘¥âˆ’1xâˆ’1  â€¦â€¦  2  ğ‘¥+2x+2  1    2ğ‘¥+12x+1  ğ‘¥x  2ğ‘¥2x  ğ‘¥âˆ’1xâˆ’1  2ğ‘¥âˆ’12xâˆ’1  â€¦â€¦  ğ‘¥+2x+2  1  ğ‘¥+1x+1      Step 5: Now, combine the solution for even ğ‘˜k and the ğ‘˜=3k=3 solution by selecting the 3 permutations and ğ‘˜âˆ’32kâˆ’32 other handles. 

Implementation// In the name of God
#include <bits/stdc++.h>
using namespace std;
 
int main() {
    ios_base::sync_with_stdio(false), cin.tie(0);
    int t;
    cin >> t;
    int f[8] = {1,1,2,6,24,120,720,5040};
    while(t--) {
        int n, k;
        cin >> n >> k;
        if(min(n, k) == 1) {
            if(n*k == 1) {
                cout << "Yes\n1\n";
            } else cout << "No\n";
        } else if(n < 8 and (f[n] < k or f[n] == k+1)) {
            cout << "No\n";
        } else if(n % 2 == 0 and k % 2 == 1) {
            cout << "No\n";
        } else {
            vector<vector<int>> base, all;
            vector<int> per(n);
            for(int i = 0; i < n; i++) per[i] = i+1;
            if(k % 2) {
                vector<int> p1(n), p2(n);
                for(int i = 0; i < n; i += 2) p1[i] = (n+1)/2-i/2, p2[i] = n-i/2;
                for(int i = 1; i < n; i += 2) p1[i] = n-i/2, p2[i] = n/2-i/2;
                all = base = {per, p1, p2};
                k -= 3;
            }
            do {
                if(k == 0)
                    break;
                vector<int> mirror(n);
                for(int i = 0; i < n; i++)
                    mirror[i] = n+1-per[i];
                if(per < mirror) {
                    bool used = false;
                    for(auto &p: base) used |= (p == per), used |= (p == mirror);
                    if(not used) {
                        k -= 2;
                        all.push_back(per);
                        all.push_back(mirror);
                    }
                }
            } while (next_permutation(per.begin(), per.end()));
            cout << "Yes\n";
            for(auto p: all) {
                for(int i = 0; i < n; i++)
                    cout << p[i] << (i+1==n?'\n':' ');
            }
        }
    }
 
    return 0;
}
 
// Thanks God


Solution Step 1: For simplicity, redefine the special conditions for the number of rubies and sapphires in your satchel (not chest). Add two dummy states, (0,0)(0,0) and (ğ‘›,ğ‘š)(n,m) for convenience (the first one indexed as 00 and the second one indexed as ğ‘˜+1k+1). Note that these dummy states wonâ€™t involve doubling the value. Step 2: Order the redefined conditions (ğ‘¥,ğ‘¦)(x,y) in increasing order based on the value of ğ‘¥+ğ‘¦x+y. Step 3: Define ğ‘¤ğ‘ğ‘¦ğ‘ ğ‘–,ğ‘—waysi,j as the number of ways to move from state ğ‘–i to state ğ‘—j without passing through any other special condition. This can be computed using inclusion-exclusion in ğ‘‚(ğ‘˜3)O(k3). Step 4: Define ğ‘ğ‘œğ‘ ğ‘¡ğ‘–,ğ‘—costi,j, the increase in value for moving directly from state ğ‘–i to state ğ‘—j without intermediate doubling, as:  ğ‘ğ‘œğ‘ ğ‘¡ğ‘–,ğ‘—=2|ğ‘¥ğ‘–âˆ’ğ‘¥ğ‘—|+|ğ‘¦ğ‘–âˆ’ğ‘¦ğ‘—|costi,j=2|xiâˆ’xj|+|yiâˆ’yj|  Step 5: Define ğ‘‘ğ‘ğ‘–dpi as the total sum of the value of your satchel across all ways to reach the state defined by the ğ‘–i-th condition. This can be computed recursively as:  ğ‘‘ğ‘ğ‘–=2âˆ‘0â‰¤ğ‘—<ğ‘–ğ‘¤ğ‘ğ‘¦ğ‘ ğ‘—,ğ‘–Ã—(ğ‘‘ğ‘ğ‘—+(ğ‘¥ğ‘—+ğ‘¦ğ‘—ğ‘¥ğ‘—)Ã—ğ‘ğ‘œğ‘ ğ‘¡ğ‘—,ğ‘–)dpi=2âˆ‘0â‰¤j<iwaysj,iÃ—(dpj+(xj+yjxj)Ã—costj,i)  Step 6: Compute the final answer as the value of ğ‘‘ğ‘ğ‘˜+1dpk+1 divided by the total number of ways to move from (0,0)(0,0) to (ğ‘›,ğ‘š)(n,m), which is (ğ‘›+ğ‘šğ‘›)(n+mn). 

Implementation#include <bits/stdc++.h>
using namespace std;
 
#define nl "\n"
#define nf endl
#define ll long long
#define pb push_back
#define _ << ' ' <<
 
#define INF (ll)1e18
#define mod 998244353
#define maxn 400010
 
ll fc[maxn], nv[maxn];
 
ll fxp(ll b, ll e) {
    ll r = 1, k = b;
    while (e != 0) {
        if (e % 2) r = (r * k) % mod;
        k = (k * k) % mod; e /= 2;
    }
    return r;
}
 
ll inv(ll x) {
    return fxp(x, mod - 2);
}
 
ll bnm(ll a, ll b) {
    if (a < b || b < 0) return 0;
    ll r = (fc[a] * nv[b]) % mod;
    r = (r * nv[a - b]) % mod;
    return r;
}
 
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
 
    fc[0] = 1; nv[0] = 1;
    for (ll i = 1; i < maxn; i++) {
        fc[i] = (i * fc[i - 1]) % mod; nv[i] = inv(fc[i]);
    }
 
    ll t; cin >> t;
    while (t--) {
        ll n, m, k; cin >> n >> m >> k;
        vector<array<ll, 2>> a(k + 2, {0, 0});
        for (ll i = 1; i <= k; i++) {
            cin >> a[i][0] >> a[i][1];
            a[i][0] = n - a[i][0]; a[i][1] = m - a[i][1];
        }
        a[k + 1] = {n, m}; k++;
        sort(a.begin() + 1, a.end());
 
        auto paths = [&](ll i, ll j) {
            ll dx = a[j][0] - a[i][0], dy = a[j][1] - a[i][1];
            return bnm(dx + dy, dx);
        };
 
        auto add = [&](ll &x, ll y) {
            x = (x + y) % mod;
            x = (x + mod) % mod;
        };
 
        vector direct(k + 1, vector<ll>(k + 1, 0));
        for (ll i = 1; i <= k; i++) {
            for (ll j = i - 1; j >= 0; j--) {
                direct[j][i] = paths(j, i);
                for (ll l = j + 1; l < i; l++) {
                    add(direct[j][i], -paths(j, l) * direct[l][i]);
                }
            }
        }
 
        vector<ll> dp(k + 1, 0);
        for (ll i = 1; i <= k; i++) {
            for (ll j = 0; j < i; j++) {
                if (direct[j][i] == 0) continue;
                ll partial = dp[j];
                ll delta = 2 * (a[i][0] - a[j][0]) + (a[i][1] - a[j][1]);
                add(partial, paths(0, j) * delta);
                add(dp[i], partial * direct[j][i]);
            }
            if (i != k) dp[i] = (2 * dp[i]) % mod;
        }
 
        ll ans = (dp[k] * inv(bnm(n + m, m))) % mod;
        cout << ans << nl;
    }
 
    return 0;
}

Solution Step 1: For simplicity, redefine the special conditions for the number of rubies and sapphires in your satchel (not chest). Step 2: Order the redefined conditions (ğ‘¥,ğ‘¦)(x,y) in increasing order based on the value of ğ‘¥+ğ‘¦x+y. Step 3: Define ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ğ‘–,ğ‘—totali,j as the total number of ways to move from state ğ‘–i to state ğ‘—j (ignoring special condition constraints). This can be computed as:  ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ğ‘–,ğ‘—=(|ğ‘¥ğ‘–âˆ’ğ‘¥ğ‘—|+|ğ‘¦ğ‘–âˆ’ğ‘¦ğ‘—||ğ‘¥ğ‘–âˆ’ğ‘¥ğ‘—|)totali,j=(|xiâˆ’xj|+|yiâˆ’yj||xiâˆ’xj|)  Step 4: Define ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡ğ‘–weighti as the total contribution of all paths passing through condition ğ‘–i to reach the final state (ğ‘›,ğ‘š)(n,m). This can be computed recursively as:  ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡ğ‘–=âˆ‘ğ‘–<ğ‘—â‰¤ğ‘˜ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ğ‘–,ğ‘—Ã—ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡ğ‘—weighti=âˆ‘i<jâ‰¤ktotali,jÃ—weightj  Step 5: The main insight is to account for the doubling effect of passing through multiple scrolls. If a path passes through a sequence of conditions ğ‘ 1,â€¦,ğ‘ ğ‘s1,â€¦,sc, each gem collected before entering ğ‘ 1s1 is counted with multiplicity 2ğ‘2c. Instead of explicitly multiplying by 2ğ‘2c, consider the number of subsets ğ‘1,â€¦,ğ‘ğ‘‘q1,â€¦,qd of ğ‘ 1,â€¦,ğ‘ ğ‘s1,â€¦,sc. By summing over all subsets, the correct multiplicity is automatically handled. Step 6: Define ğ‘‘ğ‘ğ‘–dpi as the total value of all paths passing through condition ğ‘–i, considering the contribution of each stateâ€™s rubies and sapphires. This can be computed as:  ğ‘‘ğ‘ğ‘–=(2ğ‘¥ğ‘–+ğ‘¦ğ‘–)Ã—ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™0,ğ‘–Ã—ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡ğ‘–dpi=(2xi+yi)Ã—total0,iÃ—weighti  Step 7: Compute the final answer as âˆ‘ğ‘‘ğ‘ğ‘–âˆ‘dpi divided by the total number of ways to move from (0,0)(0,0) to (ğ‘›,ğ‘š)(n,m), which is equal to (ğ‘›+ğ‘šğ‘›)(n+mn). Clarification: The approach hinges on the insight that 2ğ‘–2i can be derived from the structure of subsets of scrolls ğ‘ 1,â€¦,ğ‘ ğ‘s1,â€¦,sc. Generalizations to 3ğ‘–3i or other multiplicative factors are possible by appropriately modifying ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡ğ‘–weighti and adjusting the factor in Step 5. For example, a factor of 3 can be applied by multiplying path contributions by 2 at the relevant steps.

Implementation#include <bits/stdc++.h>
using namespace std;
 
#define nl "\n"
#define nf endl
#define ll long long
#define pb push_back
#define _ << ' ' <<
 
#define INF (ll)1e18
#define mod 998244353
#define maxn 400010
 
ll fc[maxn], nv[maxn];
 
ll fxp(ll b, ll e) {
    ll r = 1, k = b;
    while (e != 0) {
        if (e % 2) r = (r * k) % mod;
        k = (k * k) % mod; e /= 2;
    }
    return r;
}
 
ll inv(ll x) {
    return fxp(x, mod - 2);
}
 
ll bnm(ll a, ll b) {
    if (a < b || b < 0) return 0;
    ll r = (fc[a] * nv[b]) % mod;
    r = (r * nv[a - b]) % mod;
    return r;
}
 
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
 
    fc[0] = 1; nv[0] = 1;
    for (ll i = 1; i < maxn; i++) {
        fc[i] = (i * fc[i - 1]) % mod; nv[i] = inv(fc[i]);
    }
 
    ll t; cin >> t;
    while (t--) {
        ll n, m, k; cin >> n >> m >> k;
        vector<array<ll, 2>> a(k + 2, {0, 0});
        for (ll i = 1; i <= k; i++) {
            cin >> a[i][0] >> a[i][1];
            a[i][0] = n - a[i][0]; a[i][1] = m - a[i][1];
        }
        a[k + 1] = {n, m}; k++;
        sort(a.begin() + 1, a.end());
 
        auto paths = [&](ll i, ll j) {
            ll dx = a[j][0] - a[i][0], dy = a[j][1] - a[i][1];
            return bnm(dx + dy, dx);
        };
 
        auto add = [&](ll &x, ll y) {
            x = (x + y) % mod;
            x = (x + mod) % mod;
        };
 
        vector<ll> cnt_weighted(k + 1, 0);
        cnt_weighted[k] = 1;
        for (ll i = k - 1; i >= 1; i--) {
            for (ll j = i + 1; j <= k; j++) {
                add(cnt_weighted[i], paths(i, j) * cnt_weighted[j]);
            }
        }
 
        ll ans = 0;
        for (ll i = 1; i <= k; i++) {
            ll delta = 2 * a[i][0] + a[i][1];
            add(ans, delta * paths(0, i) % mod * cnt_weighted[i]);
        }
 
        ans = (ans * inv(bnm(n + m, m))) % mod;
        cout << ans << nl;
    }
 
    return 0;
}

Solution It is easy to check if the solution can be achieved with only one color. For any time point ğ‘¥x, there must be at most one interval containing ğ‘¥x, since if multiple intervals contain ğ‘¥x, they must be colored differently. A simple strategy is to solve the problem using three colors. First, we color some intervals with colors 1 and 2, then color others with color 3.    For each step, we find the leftmost point that has not been colored yet and color the segment that contains this point. We always choose the interval with the largest endpoint that contains the current point. By coloring the intervals alternately with colors 1 and 2, we ensure that all points are covered by exactly one of these colors.  Now, we check if we can color the intervals with just two colors using a greedy algorithm:    We iterate over the intervals sorted by start (increasingly) and then by end (decreasingly). At each point, we keep track of the number of colors used in previous intervals that are not yet closed. Let this number be ğ¼I, and suppose we are currently at interval ğ‘–i. We color the current interval based on the value of ğ¼I:      If ğ¼=0I=0, color interval ğ‘–i with color 1. If ğ¼=1I=1, color interval ğ‘–i with the opposite color of the current used color. If ğ¼=2I=2, color interval ğ‘–i with the opposite color of the interval with the greatest endpoint among the currently open intervals.  If it is impossible to assign a unique color between overlapping intervals at any point, it can be shown that coloring the intervals using only 2 colors is impossible.  Solving G1 using G2:  Itâ€™s sufficient to check the integer points and half-points (e.g., 1.5, 2.5, â€¦) to verify whether the coloring is valid (Why?). To handle this, we can multiply all the given points by two, effectively converting the problem into one in which only integer points exist. After this transformation, we solve the problem in the integer system of G2, where the intervals and coloring rules are defined using integer boundaries! Note: A brief explanation of why this greedy algorithm works can be found here.

Implementation/* In the name of Allah */
// Welcome to the Soldier Side!
// Where there's no one here, but me...
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
int t, n, l[N], r[N], col[N];
vector<int> st[N << 1], en[N << 1];

void compress_points() {
    vector<int> help;
    for (int i = 0; i < n; i++) {
        help.push_back(l[i]);
        help.push_back(r[i]);
    }

    sort(help.begin(), help.end());
    help.resize(unique(help.begin(), help.end()) - help.begin());
    for (int i = 0; i < n; i++) {
        l[i] = lower_bound(help.begin(), help.end(), l[i]) - help.begin();
        r[i] = lower_bound(help.begin(), help.end(), r[i]) - help.begin();
    }
}

void record_points() {
    for (int i = 0; i < n; i++) {
        st[l[i]].push_back(i);
        en[r[i] + 1].push_back(i);
    }
    for (int i = 0; i < 2 * n; i++)
        sort(st[i].begin(), st[i].end(), [](int i, int j) {
            return r[i] > r[j];
        });
}

void try3_points() {
    fill(col, col + n, 0);
    int cur = -1, nxt = -1, c = 2;
    for (int i = 0; i < 2 * n; i++) {
        if (st[i].empty())
            continue;

        if (!~cur || i > r[cur]) {
            if (cur ^ nxt && r[nxt] < i) {
                col[nxt] = (c ^= 3);
                cur = nxt;
            }

            if (cur ^ nxt)
                cur = nxt;
            else {
                cur = st[i][0];
                for (int p: st[i])
                    if (r[p] > r[cur])
                        cur = p;
                nxt = cur;
            }
            col[cur] = (c ^= 3);
        }
        
        for (int p: st[i])
            if (r[p] > r[nxt])
                nxt = p;
    }
    if (cur ^ nxt)
        col[nxt] = c ^ 3;
}

bool is_bad(set<pair<int, int>> s[2]) {
    int cnt1 = s[0].size(), cnt2 = s[1].size();
    return cnt1 + cnt2 && cnt1 ^ 1 && cnt2 ^ 1;
}

void try2_points() {
    set<pair<int, int>> s[2];
    for (int i = 0; i <= 2 * n; i++) {
        for (int p: en[i])
            s[col[p]].erase({r[p], p});
        if (is_bad(s)) {
            try3_points();
            return;
        }

        for (int p: st[i]) {
            int cnt1 = s[0].size();
            int cnt2 = s[1].size();
            if (!cnt1 || !cnt2)
                col[p] = cnt1 > 0;
            else if (cnt1 ^ cnt2)
                col[p] = cnt1 < cnt2;
            else
                col[p] = s[0].begin()->first > s[1].begin()->first;

            s[col[p]].insert({r[p], p});
            if (is_bad(s)) {
                try3_points();
                return;
            }
        }
    }
}

void read_input() {
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> l[i] >> r[i];
}

void solve() {
    compress_points();
    record_points();
    try2_points();
}

void write_output() {
    cout << *max_element(col, col + n) + 1 << endl;
    for (int i = 0; i < n; i++)
        cout << col[i] + 1 << "\n "[i < n - 1];
}

void reset_variables() {
    for (int i = 0; i < n; i++) {
        col[i] = 0;
        st[l[i]].clear();
        en[r[i] + 1].clear();
    }
}

int main() {
    ios:: sync_with_stdio(0), cin.tie(0), cout.tie(0);
    for (cin >> t; t--; reset_variables())
        read_input(), solve(), write_output();
    return 0;
}

Solution Step 1: It is easy to check if the solution can be achieved with only one color. For any time point ğ‘¥x, there must be at most one interval containing ğ‘¥x, since if multiple intervals contain ğ‘¥x, they must be colored differently. Step 2: A simple strategy is to solve the problem using three colors; First, we color some intervals with colors 1 and 2, then color others with color 3. For each step, we find the leftmost point that has not been colored yet and color the segment that contains this point. We always choose the interval with the largest endpoint that contains the current point. By coloring the intervals alternately with colors 1 and 2, we ensure that all points are covered by exactly one of these colors. Step 3: Now, we check if we can color the intervals with just two colors. For some point, ğ‘¥x, suppose we have already colored the intervals [ğ‘™ğ‘–,ğ‘Ÿğ‘–][li,ri] with ğ‘™ğ‘–â‰¤ğ‘¥liâ‰¤x, such that all points before ğ‘¥x have a unique color. At each step, we only need to determine which of the intervals like ğ‘p that ğ‘™ğ‘â‰¤ğ‘¥â‰¤ğ‘Ÿğ‘lpâ‰¤xâ‰¤rp can have a unique color. The key observation is that if an interval can be uniquely colored at time ğ‘¥x, it can also remain uniquely colored for all times ğ‘¡t such that ğ‘¥â‰¤ğ‘¡â‰¤ğ‘Ÿğ‘–xâ‰¤tâ‰¤ri.    Lemma: If an interval [ğ‘™ğ‘–,ğ‘Ÿğ‘–][li,ri] can be uniquely colored at time ğ‘¥x, it can also be uniquely colored at all subsequent times ğ‘¥â‰¤ğ‘¡â‰¤ğ‘Ÿğ‘–xâ‰¤tâ‰¤ri. Proof: Consider coloring the intervals at time ğ‘¥x. Intervals starting at ğ‘¥+1x+1 will be colored with the opposite color to interval ğ‘–i, ensuring that the interval remains uniquely colored at time ğ‘¥+1x+1. With this lemma, we can conclude that the changes in the coloring are ğ‘‚(ğ‘›)O(n). It suffices to track the intervals that are added and removed at each point in time.  Step 4: To efficiently move from time ğ‘¥x to ğ‘¥+1x+1, we perform the following steps:    Remove the intervals that have ğ‘Ÿğ‘–=ğ‘¥ri=x (since they no longer contain ğ‘¥+1x+1). Add the intervals that have ğ‘™ğ‘–=ğ‘¥+1li=x+1. Update the set of intervals that can be uniquely colored at time ğ‘¥+1x+1.  Step 5: Finally, we observe that only the following points are important for the coloring:  ğ‘™ğ‘–li and ğ‘Ÿğ‘–ri for each interval. ğ‘™ğ‘–âˆ’1liâˆ’1 and ğ‘Ÿğ‘–+1ri+1, since these points mark the boundaries where intervals start or end.  Thus, we can compress the numbers to reduce the range of values we need to process.

Implementation/* In the name of Allah */
// Welcome to the Soldier Side!
// Where there's no one here, but me...
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
vector<int> st[N << 2], en[N << 2];
int t, n, k, l[N], r[N], dp[N], col[N], prv[N];

void compress_numbers() {
    vector<int> help;
    for (int i = 0; i < n; i++) {
        help.push_back(l[i] - 1);
        help.push_back(l[i]);
        help.push_back(r[i]);
        help.push_back(r[i] + 1);
    }

    sort(help.begin(), help.end());
    help.resize(k = unique(help.begin(), help.end()) - help.begin());
    for (int i = 0; i < n; i++) {
        l[i] = lower_bound(help.begin(), help.end(), l[i]) - help.begin();
        r[i] = lower_bound(help.begin(), help.end(), r[i]) - help.begin();
    }
}

void save_checkpoints() {
    for (int i = 0; i < n; i++) {
        st[l[i]].push_back(i);
        en[r[i]].push_back(i);
    }
}

bool check_one() {
    for (int i = 0, open = 0; i < k; i++) {
        open += st[i].size();
        if (open > 1)
            return false;
        open -= en[i].size();
    }
    return true;
}

void color_with_two() {
    for (int i = k - 1, cur = -1; ~i; i--) {
        if (en[i].empty())
            continue;

        while (!~cur || i < dp[cur])
            if (~cur && ~prv[cur]) {
                col[prv[cur]] = col[cur];
                if (r[prv[cur]] >= l[cur])
                    col[prv[cur]] ^= 1;
                cur = prv[cur];
            }
            else
                for (int p: en[i])
                    if (~dp[p] && (!~cur || dp[p] < dp[cur]))
                        cur = p;

        for (int p: en[i])
            if (p ^ cur)
                col[p] = col[cur] ^ 1;
    }
}

bool check_two() {
    set<int> goods, bads;
    fill(dp, dp + n, -1);
    fill(prv, prv + n, -1);
    for (int i = 0; i < k; i++) {
        int prev = -1;
        if (i)
            for (int p: en[i - 1]) {
                bads.erase(p), goods.erase(p);
                if (~dp[p] && (!~prev || dp[p] < dp[prev]))
                    prev = p;
            }
        int open = goods.size() + bads.size();

        if (open == 1 || (open == 2 && !goods.empty())) {
            for (int p: bads) {
                if (open == 1)
                    prv[p] = prev;
                else
                    prv[p] = *goods.begin();
                goods.insert(p);
                dp[p] = i;
            }
            bads.clear();
        }

        if (open == 1)
            prev = *goods.begin();
        for (int p: st[i])
            if (!open || open == 1 || ~prev) {
                goods.insert(p);
                prv[p] = prev;
                dp[p] = i;
            }
            else
                bads.insert(p);
        open += st[i].size();

        if (open && goods.empty())
            return false;
    }

    color_with_two();
    return true;
}

void color_with_three() {
    int cur = -1, nxt = -1;
    for (int i = 0; i < k; i++) {
        if (st[i].empty())
            continue;

        if (~cur && i > r[cur] && nxt ^ cur) {
            col[nxt] = col[cur] ^ 3;
            cur = nxt;
        }
        if (!~cur || i > r[cur]) {
            for (int p: st[i])
                if (!~cur || r[p] > r[cur])
                    cur = p;
            col[nxt = cur] = 1;
        }

        for (int p: st[i])
            if (r[p] > r[nxt])
                nxt = p;
    }

    if (cur ^ nxt)
        col[nxt] = col[cur] ^ 3;
}

void read_input() {
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> l[i] >> r[i];
}

void solve() {
    compress_numbers();
    save_checkpoints();
    if (check_one())
        return;
    if (check_two())
        return;
    color_with_three();
}

void write_output() {
    cout << *max_element(col, col + n) + 1 << endl;
    for (int i = 0; i < n; i++)
        cout << col[i] + 1 << "\n "[i < n - 1];
}

void reset_variables() {
    fill(col, col + n, 0);
    for (int i = 0; i < k; i++) {
        st[i].clear();
        en[i].clear();
    }
}

int main() {
    ios:: sync_with_stdio(0), cin.tie(0), cout.tie(0);
    for (cin >> t; t--; reset_variables())
        read_input(), solve(), write_output();
    return 0;
}

Solution Step 1: According to BÃ©zout's Identity, we can compute gcd(ğ‘¥1,â€¦,ğ‘¥ğ‘¡)gcd(x1,â€¦,xt) and all its multipliers as an integer linear combination of ğ‘¥1,ğ‘¥2,â€¦,ğ‘¥ğ‘¡x1,x2,â€¦,xt. Step 2: A set {ğ‘1,â€¦,ğ‘ğ‘˜a1,â€¦,ak} is good (integer linearly independent) if for every ğ‘–i, gcd(gcd({ğ‘ğ‘—âˆ£ğ‘—â‰ ğ‘–ajâˆ£jâ‰ i})âˆ¤ğ‘ğ‘–)âˆ¤ai. Step 3: A set {ğ‘1,â€¦,ğ‘ğ‘˜a1,â€¦,ak} is good if and only if there exists a set {ğ‘1ğ‘1,ğ‘2ğ‘2,â€¦,ğ‘ğ‘˜ğ‘ğ‘˜p1q1,p2q2,â€¦,pkqk} such that ğ‘ğ‘–ğ‘ğ‘–âˆ£ğ‘ğ‘—piqiâˆ£aj for ğ‘—â‰ ğ‘–jâ‰ i and ğ‘ğ‘–ğ‘ğ‘–âˆ¤ğ‘ğ‘–piqiâˆ¤ai. Step 4: The set {ğ‘1,â€¦,ğ‘ğ‘˜a1,â€¦,ak} can be identified by determining {ğ‘1ğ‘1,ğ‘2ğ‘2,â€¦,ğ‘ğ‘˜ğ‘ğ‘˜p1q1,p2q2,â€¦,pkqk}. Assume ğ‘ğ‘11<ğ‘ğ‘22<â€¦<ğ‘ğ‘ğ‘˜ğ‘˜p1q1<p2q2<â€¦<pkqk, where ğ‘ğ‘–â‰ ğ‘ğ‘—piâ‰ pj and ğ‘ğ‘–pi is prime. Step 5: Let ğº=ğ‘1ğ‘1â‹…ğ‘2ğ‘2â€¦â‹…ğ‘ğ‘˜ğ‘ğ‘˜.G=p1q1â‹…p2q2â€¦â‹…pkqk. Then {ğ‘1,â€¦,ğ‘ğ‘˜a1,â€¦,ak} is good if and only if ğºğ‘ğ‘–ğ‘ğ‘–âˆ£ğ‘ğ‘–Gpiqiâˆ£ai and ğºâˆ¤ğ‘ğ‘–Gâˆ¤ai for every ğ‘–i. Step 6: The answer is a singleton if, for every pair of numbers ğ‘¥x and ğ‘¦y in the array, ğ‘¥âˆ£ğ‘¦xâˆ£y or ğ‘¦âˆ£ğ‘¥yâˆ£x. Since the numbers are distinct, a good subset {ğ‘1,ğ‘2a1,a2} can always be found by searching the first logğ‘€+2logâ¡M+2 elements. Step 7: Define ğ¶ğ‘€[ğ‘–]CM[i] (count multipliers of ğ‘–i) as the number of ğ‘¥x such that ğ‘–âˆ£ğ‘ğ‘¥iâˆ£ax. This can be computed in ğ‘‚(ğ‘›+ğ‘€logğ‘€)O(n+Mlogâ¡M). Step 8: A corresponding set {ğ‘1,â€¦,ğ‘ğ‘˜a1,â€¦,ak} exists for a set {ğ‘1ğ‘1,ğ‘2ğ‘2,â€¦,ğ‘ğ‘˜ğ‘ğ‘˜p1q1,p2q2,â€¦,pkqk} if and only if ğ¶ğ‘€[ğºğ‘ğ‘–ğ‘ğ‘–]>ğ¶ğ‘€[ğº]â‰¥0CM[Gpiqi]>CM[G]â‰¥0 for all ğ‘–i. Step 9: Iterate over all valid sets of the form {ğ‘1ğ‘1,ğ‘2ğ‘2,â€¦,ğ‘ğ‘˜ğ‘ğ‘˜p1q1,p2q2,â€¦,pkqk}, and check if a corresponding {ğ‘1,ğ‘2,â€¦,ğ‘ğ‘˜a1,a2,â€¦,ak} exists. Note that ğ‘˜â‰¥3kâ‰¥3 since a good subset {ğ‘1,ğ‘2a1,a2} is found using another method. Step 10: We know ğºğ‘1ğ‘1â‰¤ğ‘€Gp1q1â‰¤M and also ğ‘1ğ‘1â‰¤ğ‘€â€¾â€¾â€¾âˆš,p1q1â‰¤M, as ğ‘1ğ‘1â‰¤ğ‘2ğ‘2â‹…ğ‘3ğ‘3â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆšâ‰¤ğºğ‘1ğ‘1â€¾â€¾â€¾â€¾âˆšâ‰¤ğ‘€â€¾â€¾â€¾âˆš.p1q1â‰¤p2q2â‹…p3q3â‰¤Gp1q1â‰¤M. Step 11: There are âˆ‘logğ‘€2ğ‘–=1ğ‘ƒ[âŒŠğ‘€â€¾â€¾â€¾âˆš2ğ‘–âŒ‹]âˆ‘i=1logâ¡M2P[âŒŠM2iâŒ‹] numbers in the form ğ‘1ğ‘1p1q1, where ğ‘ƒ[ğ‘–]P[i] denotes the number of primes in the range [1,ğ‘–][1,i]. This count is ğ‘‚(ğ‘€âˆšlogğ‘€)O(Mlogâ¡M). Step 12: The value of ğ‘˜k is at most 6 (denoted as ğ¾K), as ğ‘2ğ‘2â€¦ğ‘ğ‘˜ğ‘ğ‘˜=ğºğ‘1ğ‘1â‰¤ğ‘€,p2q2â€¦pkqk=Gp1q1â‰¤M, and 3â‹…5â‹…7â‹…11â‹…13â‰¤ğ‘€<3â‹…5â‹…7â‹…11â‹…13â‹…17.3â‹…5â‹…7â‹…11â‹…13â‰¤M<3â‹…5â‹…7â‹…11â‹…13â‹…17. Step 13: We can determine {ğ‘1,â€¦,ğ‘ğ‘˜a1,â€¦,ak} from {ğ‘1ğ‘1,ğ‘2ğ‘2,â€¦,ğ‘ğ‘˜ğ‘ğ‘˜p1q1,p2q2,â€¦,pkqk} in ğ‘‚(ğ‘›â‹…ğ¾)O(nâ‹…K). The total time complexity is ğ‘‚(ğ‘‡â‹…ğ‘€â‹…ğ‘€âˆšlogğ‘€â‹…ğ¾+ğ‘‡â‹…ğ‘€â‹…logğ‘€+âˆ‘ğ‘‡ğ‘–=0ğ‘›ğ‘–â‹…ğ¾).O(Tâ‹…Mâ‹…Mlogâ¡Mâ‹…K+Tâ‹…Mâ‹…logâ¡M+âˆ‘i=0Tniâ‹…K).

Implementation/// In the name of God the most beneficent the most merciful

#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math,O3")
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

constexpr int T = 100;
constexpr int M = 100001;
constexpr int SQM = 320;
constexpr int LGM = 20;
vector<pair<int,int>> factor;
int t, n[T], count_multipliers[T][M];
bitset<M> is_composite;
vector<int> ans[T], a[T];

inline void calculate_importants() {
    for(int i = 2; i < SQM; i++)
        if(!is_composite[i]) {
            for(int j = i; j < M; j *= i)
                factor.push_back({j,i});
            for(int j = i*i; j < M; j += i)
                is_composite.set(j);
        }
    for(int i = SQM; i < M; i++)
        if(!is_composite[i])
            factor.push_back({i,i});
    sort(factor.begin(), factor.end());
}

void check(vector<int> &factors, int G) {
    if(factors.size() > 2u) {
        for(int i = 0; i < t; i++) 
            if(ans[i].size() < factors.size()) {
                int count_product = (G < M? count_multipliers[i][G] : 0);
                bool can = true;	
                for(auto u: factors)
                    if(count_multipliers[i][G/factor[u].first] == count_product) {
                        can = false;
                        break;
                    }
                if(can)
                    ans[i] = factors;
            }
    }
    int bound = (factors.size() == 1 ? SQM : M);
    if(1LL*G/factor[factors[0]].first*factor[factors.back()].first > bound)
        return;
    for(int new_factor = factors.back(); G/factor[factors[0]].first*factor[new_factor].first <= bound; new_factor++) 
        if(G%factor[new_factor].second) {
            factors.push_back(new_factor);
            check(factors, G*factor[new_factor].first);
            factors.pop_back();
        }
}

int main() {
    ios_base :: sync_with_stdio(false); cin.tie(nullptr);
    calculate_importants();
    cin >> t;
    for(int i = 0; i < t; i++) {
        cin >> n[i];
        a[i].resize(n[i]);
        for(int j = 0; j < n[i]; j++) {
            cin >> a[i][j];
            count_multipliers[i][a[i][j]]++;
        }
        ans[i] = {a[i][0]};
        sort(a[i].begin(), a[i].begin()+min(n[i], LGM));
        for(int c = 0; c+1 < n[i]; c++)
            if(a[i][c+1]%a[i][c]) {
                ans[i] = {a[i][c], a[i][c+1]};
                break;
            }
        for(int c = 1; c < M; c++)
            for(int j = c+c; j < M; j += c)
                count_multipliers[i][c] += count_multipliers[i][j];
    }
    for(int i = 0; factor[i].first < SQM; i++) {
        vector<int> starter = {i};
        check(starter, factor[i].first);
    }
    for(int i = 0; i < t; i++) {
        int k = ans[i].size();
        cout << k << '\n';
        if(k == 1u) {
            cout << ans[i][0] << '\n';
        } else if(k == 2u) {
            cout << ans[i][0] << ' ' << ans[i][1] << '\n';
        } else {
            int subset[k];
            for(auto u: a[i]) {
                int ls = -1;
                for(int j = 0; j < (int)k; j++)
                    if(u%factor[ans[i][j]].first)
                        ls = (ls == -1? j: -2);
                if(ls >= 0)
                    subset[ls] = u;
            }
            for(int j = 0; j < k; j++)
                cout << subset[j] << (j+1 == k? '\n' : ' ');
        }
    }
    return 0;
}

/// Thank God . . .

Top 60 participants Handle: orzdevinwang, Country: China Handle: tourist, Country: Belarus Handle: jqdai0815, Country: Samoa Handle: maspy, Country: Japan Handle: hyman00, Country: China Handle: ksun48, Country: Canada Handle: ugly2333, Country: China Handle: errorgorn, Country: Singapore Handle: hos.lyric, Country: Japan Handle: Benq, Country: United States Handle: Um_nik, Country: United Kingdom Handle: Golovanov399, Country: Russia Handle: gamegame, Country: Hong Kong Handle: A_G, Country: United States Handle: antontrygubO_o, Country: Ukraine Handle: Crystally, Country: United States Handle: maroonrk, Country: Japan Handle: cmk666, Country: Antarctica Handle: 79brue, Country: South Korea Handle: junie, Country: South Korea Handle: arvindf232, Country: Hong Kong Handle: QwertyPi, Country: Hong Kong Handle: Radewoosh, Country: Poland Handle: 244mhq, Country: Belarus Handle: Amoo_Safar, Country: Iran Handle: SomethingNew, Country: Serbia Handle: phoenix0423, Country: Taiwan Handle: daubi, Country: Russia Handle: Karuna, Country: South Korea Handle: kostylevGO, Country: Russia Handle: oleh1421, Country: Ukraine Handle: alireza_kaviani, Country: Iran Handle: Tlatoani, Country: Mexico Handle: ymmparsa, Country: Iran Handle: KevinWan, Country: Canada Handle: OIer_kzc, Country: Spain Handle: win114514, Country: France Handle: JettyOller, Country: Vietnam Handle: Swistakk, Country: Poland Handle: Dominater069, Country: India Handle: MridulAhi, Country: India Handle: tkacper, Country: Poland Handle: PedroBigMan, Country: Portugal Handle: Thienu, Country: Thailand Handle: Egor, Country: Germany Handle: lmqzzz, Country: Vietnam Handle: Farhod, Country: Tajikistan Handle: kevinyang, Country: Canada Handle: busamate, Country: Hungary Handle: CDuongg, Country: Vietnam Handle: bthero, Country: Kazakhstan Handle: InternetPerson10, Country: Philippines Handle: Kaey, Country: Italy Handle: sstrong, Country: Kazakhstan Handle: Misuki, Country: Taiwan Handle: sevlll777, Country: Wallis and Futuna Handle: Kilani, Country: Jordan Handle: Xellos, Country: Slovakia Handle: aimoon, Country: Kyrgyzstan Handle: Kira_1234, Country: India 

