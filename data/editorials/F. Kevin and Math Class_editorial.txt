Hint 1 
 Can you find a strategy such that only n intervals might be operated on? 
Hint 2 
 By operating on the entire sequence in each step, the answer can be made ≤63. 
Tutorial 
 2048F - Kevin and Math ClassConstruct a min Cartesian tree for the sequence b. It is easy to observe that we will only operate on the intervals defined by this Cartesian tree.  Proof: For any bx, find the last bp≤bx on its left and the first bq<bx on its right. If we want to divide the interval by bx, the operation interval cannot include both p and q. At the same time, choosing the largest possible interval is always optimal. Hence, the operation interval must be [p+1,q−1]. All such intervals are exactly the intervals corresponding to the Cartesian tree. To solve the problem, we can use DP on the Cartesian tree. Let fu,i represent the minimum possible maximum value of ax within the subtree rooted at u after performing i operations on all positions within that subtree.When merging, suppose the two child subtrees of u are ls and rs. The transition can be written as: fu,k=mini+j=k(max(fls,i,frs,j,au))Then consider division at the position corresponding to bu, which updates the DP state: fu,k+1←⌈fu,kbu⌉Since operating on the entire sequence repeatedly can ensure that log2(max(ai))≤63 operations suffice, the second dimension of the DP state only needs to be defined for 0∼63. Thus, the time complexity for this approach is O(nlog2a).The bottleneck of this approach lies in merging the DP states of the two subtrees. Observing that fu,i is monotonically non-increasing, the min−max convolution for fls,i and frs,i is equivalent to merging two sequences using a merge sort-like approach. This reduces the merging complexity to O(loga).Consequently, the overall complexity becomes O(nloga), which is an optimal solution. 
