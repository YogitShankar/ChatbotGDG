How did you find the contest? Great: 




179





 Good: 

    


259



 Average: 

    


69



 Bad: 

    


79



 Trash: 

    


74



 

Which problem is your most favourite? A: 

    


27



 B: 

    


63



 C1: 

    


60



 C2: 

    


58



 D: 

    


232



 E: 

    


45



 F1: 

    


7



 F2: 

    


4



 G: 

    


5



 H1: 

    


7



 H2: 

    


4



 

Which problem you hate the most? A: 

    


10



 B: 

    


18



 C1: 

    


49



 C2: 

    


447



 D: 

    


13



 E: 

    


49



 F1: 

    


13



 F2: 

    


2



 G: 

    


1



 H1: 

    


2



 H2: 

    


1



 

Tutorial2039A - Shohag Loves ModTHOUGHT: A general approach to tackle ad-hoc problems is to play around with the conditions and see if we can add more constraints to limit the search space.ACTION: Let's analyze the modular condition ğ‘ğ‘–modğ‘–aimodi.We know that ğ‘ğ‘–modğ‘–<ğ‘–aimodi<i, and all ğ‘ğ‘–modğ‘–aimodi values are distinct. Let's explore this step by step:  ğ‘1mod1a1mod1 is always 00.  ğ‘2mod2a2mod2 can be 00 or 11. But since all ğ‘ğ‘–modğ‘–aimodi values must be distinct, ğ‘2mod2a2mod2 must be 11 (otherwise, it would equal ğ‘1mod1a1mod1).  ğ‘3mod3a3mod3 can be 00, 11, or 22. Similarly, ğ‘3mod3a3mod3 must be 22 (to avoid duplication with ğ‘1mod1a1mod1 or ğ‘2mod2a2mod2).  â€¦â€¦  ğ‘ğ‘›modğ‘›anmodn must be ğ‘›âˆ’1nâˆ’1. OBSERVATION: This leads to the constraint ğ‘ğ‘–modğ‘–=ğ‘–âˆ’1aimodi=iâˆ’1.THOUGHT: Next, let's consider the increasing sequence condition.OBSERVATION: Since the sequence must be increasing, we add the constraint ğ‘ğ‘–â‰¥ğ‘–aiâ‰¥i.THOUGHT: To further limit the search space, note that ğ‘›n can be up to 5050, and ğ‘ğ‘–ai must be â‰¤100â‰¤100.OBSERVATION: This suggests that we can restrict ğ‘ğ‘–ai to values up to 2â‹…ğ‘›2â‹…n.THOUGHT: Let's compile the constraints:   ğ‘ğ‘–modğ‘–=ğ‘–âˆ’1aimodi=iâˆ’1.  ğ‘ğ‘–â‰¥ğ‘–aiâ‰¥i.  ğ‘ğ‘–â‰¤2â‹…ğ‘›aiâ‰¤2â‹…n. Now we need to build the sequence that satisfies these conditions.ACTION: Let's build the sequence starting from the end.  ğ‘ğ‘›modğ‘›=ğ‘›âˆ’1anmodn=nâˆ’1. Thus, ğ‘ğ‘›an can be ğ‘›âˆ’1nâˆ’1 or 2â‹…ğ‘›âˆ’12â‹…nâˆ’1. Since ğ‘ğ‘›â‰¥ğ‘›anâ‰¥n, ğ‘ğ‘›an must be 2â‹…ğ‘›âˆ’12â‹…nâˆ’1.  ğ‘ğ‘›âˆ’1mod(ğ‘›âˆ’1)=ğ‘›âˆ’2anâˆ’1mod(nâˆ’1)=nâˆ’2. So ğ‘ğ‘›âˆ’1anâˆ’1 can be ğ‘›âˆ’2nâˆ’2 or (ğ‘›âˆ’2)+(ğ‘›âˆ’1)=2â‹…ğ‘›âˆ’3(nâˆ’2)+(nâˆ’1)=2â‹…nâˆ’3. Since ğ‘ğ‘›âˆ’1â‰¥ğ‘›âˆ’1anâˆ’1â‰¥nâˆ’1, ğ‘ğ‘›âˆ’1anâˆ’1 must be 2â‹…ğ‘›âˆ’32â‹…nâˆ’3.  â€¦â€¦  ğ‘ğ‘–modğ‘–=ğ‘–âˆ’1aimodi=iâˆ’1. Thus, ğ‘ğ‘–ai can be ğ‘–âˆ’1iâˆ’1 or 2â‹…ğ‘–âˆ’12â‹…iâˆ’1 or 3â‹…ğ‘–âˆ’1â€¦3â‹…iâˆ’1â€¦. Since ğ‘ğ‘–â‰¥ğ‘–aiâ‰¥i and the odd numbers greater than 2â‹…ğ‘–2â‹…i have already been used, ğ‘ğ‘–ai must be 2â‹…ğ‘–âˆ’12â‹…iâˆ’1. OBSERVATION: If we limit the elements to 2â‹…ğ‘›2â‹…n, there is exactly one sequence that satisfies all conditions.CONCLUSION: The sequence is ğ‘ğ‘–=2â‹…ğ‘–âˆ’1ai=2â‹…iâˆ’1, which is 1,3,5,â€¦,2â‹…ğ‘›âˆ’11,3,5,â€¦,2â‹…nâˆ’1.VALIDATION: We can validate the solution by checking if it satisfies all the constraints. ğ‘ğ‘–modğ‘–=(2â‹…ğ‘–âˆ’1)modğ‘–=ğ‘–âˆ’1aimodi=(2â‹…iâˆ’1)modi=iâˆ’1. So all ğ‘ğ‘–modğ‘–aimodi are distinct and values are under 2â‹…ğ‘›2â‹…n. So the sequence is valid.Time Complexity: îˆ»(ğ‘›)O(n).

Code#include<bits/stdc++.h>
using namespace std;

const int N = 3e5 + 9;
using ll = long long;

void solve() {
  int n; cin >> n;
  for (int i = 1; i <= n; i++) {
    cout << 2 * i - 1 << ' ';
  }
  cout << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}

Rate the Problem Amazing problem: 

    


269



 Good problem: 

    


55



 Average problem: 

    


39



 Bad problem: 

    


12



 Didn't solve: 

    


10



 

Tutorial2039B - Shohag Loves StringsTHOUGHT: The condition seems hard to track. So a good way is to play around with smaller cases and see if we can make some observations.ACTION: Let's start with the smallest string. When ğ‘ =s= a, the number of unique substrings ğ‘“(ğ‘ )=1f(s)=1, so it's odd and not valid.OBSERVATION: No one length strings are valid.ACTION: Let's try the next smallest strings. When ğ‘ =s= aa, ğ‘“(ğ‘ )=2f(s)=2, so it's even and valid. When ğ‘ =s= ab, ğ‘“(ğ‘ )=3f(s)=3, so it's odd and not valid.OBSERVATION: Two length strings are valid if the adjacent characters are same.THOUGHT: So if ğ‘ s contains two consecutive same characters, we can print it right away. All that remains is to consider strings without two consecutive same characters.ACTION: Let's try the next smallest strings with adjacent different characters. When ğ‘ =s= aba, ğ‘“(ğ‘ )=5f(s)=5, so it's odd and not valid. When ğ‘ =s= abc, ğ‘“(ğ‘ )=6f(s)=6, so it's even and valid.OBSERVATION: Three length strings are valid if all characters are different.THOUGHT: So if ğ‘ s contains three consecutive different characters, we can print it right away. All that remains is to consider strings without two adjacent same characters but no three consecutive different characters.So all the remaining strings are of the form ğ‘ =s= abababababa...Let's try to see if we can make some observations about these strings.ACTION: Let's try to calculate the number of unique substrings for a string of the form ğ‘ =s= abababababa...  There are exactly 22 unique substrings of length 11: a and b.  There are exactly 22 unique substrings of length 22: ab and ba.  There are exactly 22 unique substrings of length 33: aba and bab.  â€¦â€¦  There are exactly 22 unique substrings of length ğ‘›âˆ’1nâˆ’1.  However, the length ğ‘›n substring occurs exactly once. OBSERVATION: The number of unique substrings of any length is 22. But only the length ğ‘›n substring occurs exactly once. So total number of unique substrings is 2ğ‘›âˆ’12nâˆ’1. And this is always odd! So there is no solution for these strings.THOUGHT: We have covered all the cases. CONCLUSION: If there are adjacent same characters, we can print it right away. If there are three consecutive different characters, we can print it right away. Otherwise there is no solution.Time Complexity: îˆ»(ğ‘›)O(n).

Code#include<bits/stdc++.h>
using namespace std;

const int N = 3e5 + 9;
using ll = long long;

void solve() {
  string s; cin >> s;
  int n = s.size();
  for (int i = 0; i + 1 < n; i++) {
    if (s[i] == s[i + 1]) {
      cout << s.substr(i, 2) << '\n';
      return;
    }
  }
  for (int i = 0; i + 2 < n; i++) {
    if (s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]) {
      cout << s.substr(i, 3) << '\n';
      return;
    }
  }
  cout << -1 << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}

Rate the Problem Amazing problem: 

    


313



 Good problem: 

    


54



 Average problem: 

    


32



 Bad problem: 

    


29



 Didn't solve: 

    


20



 

Tutorial2039C1 - Shohag Loves XOR (Easy Version)THOUGHT: Here ğ‘¥>0x>0 and ğ‘¦>0y>0. So ğ‘¥âŠ•ğ‘¦xâŠ•y is neither equal to ğ‘¥x nor ğ‘¦y. So ğ‘¥âŠ•ğ‘¦xâŠ•y is a divisor of ğ‘¥x or ğ‘¦y and ğ‘¥âŠ•ğ‘¦<ğ‘¥xâŠ•y<x or ğ‘¥âŠ•ğ‘¦<ğ‘¦xâŠ•y<y.OBSERVATION: Any divisor ğ‘‘d of ğ‘p such that ğ‘‘<ğ‘d<p we know that ğ‘‘â‰¤âŒŠğ‘2âŒ‹dâ‰¤âŒŠp2âŒ‹. Also, the highest bits of ğ‘‘d and ğ‘p are different when ğ‘‘â‰¤âŒŠğ‘2âŒ‹dâ‰¤âŒŠp2âŒ‹.THOUGHT: Wait but ğ‘¥âŠ•ğ‘¦xâŠ•y has the same highest bit as ğ‘¦y if ğ‘¦â‰¥2â‹…ğ‘¥yâ‰¥2â‹…x.CONCLUSION: So if ğ‘¦â‰¥2â‹…ğ‘¥yâ‰¥2â‹…x, then ğ‘¥âŠ•ğ‘¦xâŠ•y can not be a divisor of ğ‘¦y.THOUGHT: But can it be a divisor of ğ‘¥x?OBSERVATION: If ğ‘¦â‰¥2â‹…ğ‘¥yâ‰¥2â‹…x, then ğ‘¥âŠ•ğ‘¦>ğ‘¥xâŠ•y>x because the highest bit in ğ‘¥âŠ•ğ‘¦xâŠ•y is greater than that in ğ‘¥x. So ğ‘¥âŠ•ğ‘¦xâŠ•y can not be a divisor of ğ‘¥x.CONCLUSION: If ğ‘¦â‰¥2â‹…ğ‘¥yâ‰¥2â‹…x, then ğ‘¥âŠ•ğ‘¦xâŠ•y can not be a divisor of ğ‘¥x or ğ‘¦y. So no solution in this case.THOUGHT: Now we need to consider the case when ğ‘¦<2â‹…ğ‘¥y<2â‹…x. But ğ‘¥x is small in this problem, making it feasible to iterate over all possible values of ğ‘¦y.ACTION: Iterate over all possible values of ğ‘¦<2â‹…ğ‘¥y<2â‹…x and check if ğ‘¥âŠ•ğ‘¦xâŠ•y is a divisor of either ğ‘¥x or ğ‘¦y.Time Complexity: îˆ»(ğ‘¥)O(x).

Code#include<bits/stdc++.h>
using namespace std;

using ll = long long;

void solve() {
  int x; ll m; cin >> x >> m;

  int ans = 0;
  for (int y = 1; y <= min(2LL * x, m); y++) {
    if (x != y and ((x % (x ^ y)) == 0 or (y % (x ^ y) == 0))) {
      ++ans;
    }
  }
  cout << ans << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}

Rate the Problem Amazing problem: 

    


269



 Good problem: 

    


82



 Average problem: 

    


39



 Bad problem: 

    


59



 Didn't solve: 

    


29



 

Tutorial2039C2 - Shohag Loves XOR (Hard Version)THOUGHT: Consider the three cases of when ğ‘¥âŠ•ğ‘¦xâŠ•y is divisible by ğ‘¥x, ğ‘¦y, or both separately.Case 1: ğ‘¥âŠ•ğ‘¦xâŠ•y is divisible by ğ‘¥x.THOUGHT: Let ğ‘=ğ‘¥âŠ•ğ‘¦p=xâŠ•y. So ğ‘¦=ğ‘âŠ•ğ‘¥y=pâŠ•x. So we can rephrase the problem as counting the number of integers ğ‘p such that ğ‘p is divisible by ğ‘¥x and 1â‰¤ğ‘âŠ•ğ‘¥â‰¤ğ‘š1â‰¤pâŠ•xâ‰¤m.OBSERVATION: ğ‘âŠ•ğ‘¥â‰¤ğ‘+ğ‘¥pâŠ•xâ‰¤p+x, because xor is just addition without carry.THOUGHT: So it feels like almost all values of ğ‘â‰¤ğ‘špâ‰¤m might work! And it's actually true because ğ‘âŠ•ğ‘¥â‰¤ğ‘+ğ‘¥â‰¤ğ‘špâŠ•xâ‰¤p+xâ‰¤m, so if ğ‘+ğ‘¥â‰¤ğ‘šp+xâ‰¤m i.e. ğ‘â‰¤ğ‘šâˆ’ğ‘¥pâ‰¤mâˆ’x then ğ‘âŠ•ğ‘¥â‰¤ğ‘špâŠ•xâ‰¤m is always true.CONCLUSION: All multiples of ğ‘¥x under ğ‘šâˆ’ğ‘¥mâˆ’x always work! So the count is âŒŠğ‘šâˆ’ğ‘¥ğ‘¥âŒ‹âŒŠmâˆ’xxâŒ‹.THOUGHT: But how about when ğ‘>ğ‘šâˆ’ğ‘¥p>mâˆ’x?OBSERVATION: if ğ‘>ğ‘¥p>x, then ğ‘âŠ•ğ‘¥â‰¥ğ‘âˆ’ğ‘¥pâŠ•xâ‰¥pâˆ’x, because xor is like subtraction without borrowing.THOUGHT: So if ğ‘âˆ’ğ‘¥>ğ‘špâˆ’x>m i.e. ğ‘>ğ‘š+ğ‘¥p>m+x then ğ‘âŠ•ğ‘¥â‰¥ğ‘âˆ’ğ‘¥>ğ‘špâŠ•xâ‰¥pâˆ’x>m is always true.CONCLUSION: So no values of ğ‘p work when ğ‘>ğ‘š+ğ‘¥p>m+x.THOUGHT: And there are two multiples of ğ‘¥x in the range (ğ‘šâˆ’ğ‘¥,ğ‘š+ğ‘¥](mâˆ’x,m+x]. So we can just check them manually.CONCLUSION: Answer is âŒŠğ‘šâˆ’ğ‘¥ğ‘¥âŒ‹âŒŠmâˆ’xxâŒ‹ plus manually checking the two multiples of ğ‘¥x in the range (ğ‘šâˆ’ğ‘¥,ğ‘š+ğ‘¥](mâˆ’x,m+x].Case 2: ğ‘¥âŠ•ğ‘¦xâŠ•y is divisible by ğ‘¦y.THOUGHT: As we already know that ğ‘¥âŠ•ğ‘¦â‰¤ğ‘¥+ğ‘¦xâŠ•yâ‰¤x+y, and when ğ‘¥<ğ‘¦x<y, ğ‘¥âŠ•ğ‘¦â‰¤ğ‘¥+ğ‘¦<ğ‘¦+ğ‘¦=2â‹…ğ‘¦xâŠ•yâ‰¤x+y<y+y=2â‹…y.But as ğ‘¥>0x>0 and ğ‘¦>0y>0, so ğ‘¥âŠ•ğ‘¦xâŠ•y is neither ğ‘¥x nor ğ‘¦y, so the smallest multiple of ğ‘¦y that can work is 2â‹…ğ‘¦2â‹…y. But ğ‘¥âŠ•ğ‘¦<2â‹…ğ‘¦xâŠ•y<2â‹…y, so no solution here.CONCLUSION: No solution when ğ‘¥<ğ‘¦x<y. And as ğ‘¥x is small in this problem, so we can just iterate over all values of ğ‘¦â‰¤ğ‘¥yâ‰¤x and manually check if ğ‘¥âŠ•ğ‘¦xâŠ•y is divisible by ğ‘¦y.Case 3: ğ‘¥âŠ•ğ‘¦xâŠ•y is divisible by both ğ‘¥x and ğ‘¦y.THOUGHT: So the xor is divisible by lcm(ğ‘¥,ğ‘¦)lcm(x,y). So when ğ‘¥â‰ ğ‘¦xâ‰ y, lcm(ğ‘¥,ğ‘¦)â‰¥2â‹…max(ğ‘¥,ğ‘¦)lcm(x,y)â‰¥2â‹…max(x,y) but ğ‘¥âŠ•ğ‘¦<2â‹…max(ğ‘¥,ğ‘¦)xâŠ•y<2â‹…max(x,y), so no solution here.CONCLUSION: Only works when ğ‘¦=ğ‘¥y=x.FINAL CONCLUSION: So we just implement the above cases and the answer is the sum of case 11 and case 22 subtracted by case 33.Time Complexity: îˆ»(ğ‘¥)O(x).

Code#include<bits/stdc++.h>
using namespace std;

using ll = long long;

void solve() {
  int x; ll m; cin >> x >> m;

  // divisible by x
  ll p = m - m % x;
  ll ans = p / x - (x < p);
  if ((x ^ p) >= 1 and (x ^ p) <= m) ++ans;
  p += x;
  if ((x ^ p) >= 1 and (x ^ p) <= m) ++ans;

  // divisibly by y
  for (int y = 1; y <= min(1LL * x, m); y++) {
    ll cur = x ^ y;
    if (cur % y == 0) {
      ++ans;
    }
  }

  // divisible by both
  if (x <= m) {
    --ans;
  }

  cout << ans << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}

Rate the Problem Amazing problem: 

    


131



 Good problem: 

    


36



 Average problem: 

    


49



 Bad problem: 

    


303



 Didn't solve: 

    


41



 

Tutorial2039D - Shohag Loves GCDTHOUGHT: For problems where we need to construct something under some conditions, then a good idea is to first see the nature of the sequences that satisfy the conditions. And to find the properties of such sequences we can try to find some necessary conditions that must have to be met for the sequence to satisfy the conditions.ACTION: The given condition is that ğ‘gcd(ğ‘–,ğ‘—)â‰ gcd(ğ‘ğ‘–,ğ‘ğ‘—)agcd(i,j)â‰ gcd(ai,aj) all ğ‘–<ğ‘—i<j. As the given operation is gcd on indices and values, it's hard to directly find the properties of the sequence.But what happens when ğ‘–i divides ğ‘—j? Then ğ‘gcd(ğ‘–,ğ‘—)=ğ‘ğ‘–agcd(i,j)=ai. So the condition becomes ğ‘ğ‘–â‰ gcd(ğ‘ğ‘–,ğ‘ğ‘—)aiâ‰ gcd(ai,aj) which translates to ğ‘ğ‘–ai can not divide ğ‘ğ‘—aj because otherwise gcd(ğ‘ğ‘–,ğ‘ğ‘—)=ğ‘ğ‘–gcd(ai,aj)=ai.So we have found a necessary condition: for any pair ğ‘–<ğ‘—i<j where ğ‘–i divides ğ‘—j, ğ‘ğ‘–ai can not divide ğ‘ğ‘—aj.THOUGHT: Hmm, but is the condition sufficient? One way to check the sufficiency is to find a contradiction.ACTION: Imagine two indices ğ‘–i and ğ‘—j where ğ‘–i does not divide ğ‘—j but the condition is violated: ğ‘gcd(ğ‘–,ğ‘—)=gcd(ğ‘ğ‘–,ğ‘ğ‘—)agcd(i,j)=gcd(ai,aj).Then ğ‘”=gcd(ğ‘–,ğ‘—)g=gcd(i,j) is a divisor of both ğ‘–i and ğ‘—j and as ğ‘ğ‘”ag divides both ğ‘ğ‘–ai and ğ‘ğ‘—aj, so for pair (ğ‘”,ğ‘–)(g,i) we have ğ‘gcd(ğ‘”,ğ‘–)=ğ‘ğ‘”agcd(g,i)=ag and gcd(ğ‘ğ‘”,ğ‘ğ‘–)=ğ‘ğ‘”gcd(ag,ai)=ag because ğ‘ğ‘”ag divides ğ‘ğ‘–ai. So for this pair the condition is violated!So if the condition is violated for some pair (ğ‘–,ğ‘—)(i,j) then it is violated for the pair (ğ‘”,ğ‘–)(g,i) and (ğ‘”,ğ‘—)(g,j) as well where ğ‘”=gcd(ğ‘–,ğ‘—)g=gcd(i,j).So if there is no pair (ğ‘–,ğ‘—)(i,j) where ğ‘–i divides ğ‘—j and the condition is violated, then all the pairs also satisfy the condition. This proves the sufficiency of the condition.THOUGHT: So we have found a necessary and sufficient condition. Now we need to construct the lexicographically largest sequence that satisfies the condition.Solution 1:Consider a multiple chain ğ‘–1<ğ‘–2<â€¦<ğ‘–ğ‘˜i1<i2<â€¦<ik. Such that ğ‘–1i1 divides ğ‘–2i2, ğ‘–2i2 divides ğ‘–3i3, ..., ğ‘–ğ‘˜âˆ’1ikâˆ’1 divides ğ‘–ğ‘˜ik.Then we know that we have to put distinct values for all the indices in the multiple chain otherwise one number will be divisible by another which will violate the condition.And as we are aiming for the lexicographically largest sequence, it makes sense to put the values in decreasing order in a multiple chain i.e. ğ‘ğ‘–1>ğ‘ğ‘–2>â€¦>ğ‘ğ‘–ğ‘˜ai1>ai2>â€¦>aik. This way we don't have to care about the divisibility condition, as the numbers are in decreasing order.Now, we definitely will try to put the largest number possible for each index. So what is the largest number that we can put for the index ğ‘¥x?Consider a directed graph where there is an edge from ğ‘–i to ğ‘—j if ğ‘–i divides ğ‘—j. Then the question is what is the length of the longest path in this graph ending at ğ‘¥x.You can find it using a simple DP on this directed acyclic graph in ğ‘‚(ğ‘›logğ‘›)O(nlogâ¡n) time.But if you think about it, the answer is actually simple. Let ğ‘(ğ‘¥)p(x) the number of prime factors of ğ‘¥x counted with multiplicity. Then the answer is ğ‘(ğ‘¥)+1p(x)+1. For example, if ğ‘¥=2â‹…32â‹…5x=2â‹…32â‹…5, then one of the longest chains ending at ğ‘¥x is 1â†’2â†’2â‹…3â†’2â‹…32â†’2â‹…32â‹…51â†’2â†’2â‹…3â†’2â‹…32â†’2â‹…32â‹…5 which has length 44.We can precalculate the values ğ‘(ğ‘¥)p(x) for all 1â‰¤ğ‘¥â‰¤ğ‘›1â‰¤xâ‰¤n in ğ‘‚(ğ‘›logğ‘›)O(nlogâ¡n) time using sieve.So at index ğ‘–i we will put the (ğ‘(ğ‘–)+1p(i)+1)-th largest number from the set ğ‘†S. And the largest value of ğ‘(ğ‘–)p(i) for 1â‰¤ğ‘–â‰¤ğ‘›1â‰¤iâ‰¤n is âŒŠlog2ğ‘›âŒ‹âŒŠlog2â¡nâŒ‹ for the chain 1â†’2â†’22â†’â€¦â†’2âŒŠlog2ğ‘›âŒ‹1â†’2â†’22â†’â€¦â†’2âŒŠlog2â¡nâŒ‹.So if ğ‘š<âŒŠlog2ğ‘›âŒ‹+1m<âŒŠlog2â¡nâŒ‹+1, then we can't construct the sequence and the answer is âˆ’1âˆ’1. Otherwise set ğ‘ğ‘–=ğ‘ ğ‘šâˆ’ğ‘(ğ‘–)ai=smâˆ’p(i) for all ğ‘–i.Also, unless you have noticed already, the actual numbers don't matter!Time Complexity: ğ‘‚(ğ‘›logğ‘›)O(nlogâ¡n)Solution 2:As we are trying to construct the lexicographically largest sequence, it's always better to take larger values first. Let ğ‘ ğ‘–si be the ğ‘–i-th smallest number in the set ğ‘†S.  So, initially set ğ‘1=ğ‘ ğ‘ša1=sm. Then we can't use ğ‘ ğ‘šsm for any other index as it will violate the condition. Then set ğ‘2=ğ‘ ğ‘šâˆ’1a2=smâˆ’1 (because we can't use ğ‘ ğ‘šsm). Then we can't use ğ‘ ğ‘šâˆ’1smâˆ’1 for any other index ğ‘—j where ğ‘—j is divisible by 22 as it will violate the condition. Then set ğ‘3=ğ‘ ğ‘šâˆ’1a3=smâˆ’1 (because we can't use ğ‘ ğ‘šsm). Then we can't use ğ‘ ğ‘šâˆ’1smâˆ’1 for any other index ğ‘—j where ğ‘—j is divisible by 33 as it will violate the condition. Now set ğ‘4=ğ‘ ğ‘šâˆ’2a4=smâˆ’2 (because we can't use ğ‘ ğ‘šâˆ’1smâˆ’1 or ğ‘ ğ‘šsm). Then we can't use ğ‘ ğ‘šâˆ’2smâˆ’2 for any other index ğ‘—j where ğ‘—j is divisible by 44 as it will violate the condition. Then for ğ‘5a5 we can actually use ğ‘ ğ‘šâˆ’1smâˆ’1 as 55 is not divisible by 2,3,2,3, or 44 so the only constraint is that ğ‘5â‰ ğ‘1a5â‰ a1. ... Notice that this is a sieve-like process where we are using the maximum number that we can use for the current index and then we are remembering that in the multiples of the current index, the current number can't be used. We can use sets to simulate the process.So this process will always construct a valid lexicographically largest sequence. If it is not possible to construct the sequence, then the answer is âˆ’1âˆ’1.Also, if you notice the construction process carefully, the actual numbers don't matter!Time Complexity: ğ‘‚(ğ‘›log2ğ‘›)O(nlog2â¡n)

Code (Solution 1)#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 9;
int p[N];
void solve() {
  int n, m; cin >> n >> m;
  vector<int> s(m + 1);
  for (int i = 1; i <= m; i++) {
    cin >> s[i];
  }
  if (m < __lg(n) + 1) {
    cout << -1 << '\n';
    return;
  }
  for (int i = 1; i <= n; i++) {
    cout << s[m - p[i]] << ' ';
  }
  cout << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  for (int i = 2; i < N; i++) {
    if (p[i]) continue;
    for (int j = i; j < N; j += i) {
      int x = j;
      while (x % i == 0) x /= i, ++p[j];
    }
  }
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}

Code (Solution 2)#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 9;
using ll = long long;

vector<int> d[N];
void solve() {
  int n, m; cin >> n >> m;
  vector<int> s(m + 1);
  for (int i = 1; i <= m; i++) {
    cin >> s[i];
  }
  vector<int> a(n + 1, -1);
  for (int i = 1; i <= n; i++) {
    set<int> banned;
    for (int j: d[i]) {
      banned.insert(a[j]);
    }
    for (int k = m; k >= 1; k--) {
        if (banned.find(s[k]) == banned.end()) {
            a[i] = s[k];
            break;
        }
    }
    if (a[i] == -1) {
        cout << -1 << '\n';
        return;
    }
  }
  for (int i = 1; i <= n; i++) {
    cout << a[i] << ' ';
  }
  cout << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  for (int i = 1; i < N; i++) {
    for (int j = i + i; j < N; j += i) {
        d[j].push_back(i);
    }
  }
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}

Rate the Problem Amazing problem: 

    


242



 Good problem: 

    


32



 Average problem: 

    


16



 Bad problem: 

    


28



 Didn't solve: 

    


10



 

Tutorial2039E - Shohag Loves InversionsIt's hard to track the array when we insert new inversions as the inversion number can quickly become very large.The key observation here is to notice what happens when the inversion count becomes more than 11. As the initial array has only 00 and 11 as elements when we insert an inversion count that is more than 11, the inversion count will be larger than any element of the array. And this gives us a way to control everything!Let dpğ‘–dpi be the number of final arrays of length ğ‘›n we can get from the current array of length ğ‘–i if the current number of inversions in it is larger than any element of the array.Let ğ‘˜k be the number of inversions in the current array and ğ‘˜>max(ğ‘)k>max(a). Then  If we insert ğ‘˜k not in the end, then the new inversion count will be more than ğ‘˜k, so we get the same situation for ğ‘‘ğ‘ğ‘–+1dpi+1  Or if we insert ğ‘˜k in the end then the number of inversions will still be ğ‘˜k. So if we inserted it ğ‘—j times in the end and once somewhere else (ğ‘–i ways to do so) then we will get the situation for ğ‘‘ğ‘ğ‘–+ğ‘—+1dpi+j+1 So dpğ‘–=(ğ‘–â‹…âˆ‘ğ‘—>ğ‘–dpğ‘—)+1dpi=(iâ‹…âˆ‘j>idpj)+1, here 11 is added as we can end the sequence here by inserting ğ‘˜k in the end (ğ‘›âˆ’ğ‘–)(nâˆ’i) times.This can be computed with simple dp in ğ‘‚(ğ‘›)O(n) time using suffix sums.Now we just need to deal with the starting array when it starts to have more than 11 inversion.There are (ğ‘›âˆ’1)(nâˆ’1) ways to finish the sequence having â‰¤1â‰¤1 inversion. And they are of the form 0,0,â€¦,0,[0,1,0],1,â€¦,1,10,0,â€¦,0,[0,1,0],1,â€¦,1,1 this is because we first insert 00 at the beginning for some time and then we get 11 inversion count when we insert 00 at the end for the first time and then we will have to insert 11 at the end every time after that.And to count the ways to get the starting array of length ğ‘šm with more than 11 inversion, we can notice that it's just the sum of ways where we insert 11 before the first 11 in any sequence of the form like above 0,0,â€¦,0,[0,1,0],1,â€¦,1,10,0,â€¦,0,[0,1,0],1,â€¦,1,1. And if the position of the first 11 is ğ‘—j then we have (ğ‘—âˆ’1)(jâˆ’1) ways to do so. So total ways is âˆ‘ğ‘šâˆ’1ğ‘—=2(ğ‘—âˆ’1)=(ğ‘šâˆ’2)â‹…(ğ‘šâˆ’1)2âˆ’1âˆ‘j=2mâˆ’1(jâˆ’1)=(mâˆ’2)â‹…(mâˆ’1)2âˆ’1So the answer is just ğ‘›âˆ’1+âˆ‘ğ‘›ğ‘š=3((ğ‘šâˆ’2)â‹…(ğ‘šâˆ’1)2âˆ’1)â‹…dpğ‘šnâˆ’1+âˆ‘m=3n((mâˆ’2)â‹…(mâˆ’1)2âˆ’1)â‹…dpmTime Complexity: ğ‘‚(ğ‘›)O(n)Note that there are ways to write the dp so that you don't have to handle the starting array separately. Also in this problem, we have limited the total sum of ğ‘›n over all test cases. But there exists solutions where the solution works even without the limit but we decided to let both solutions pass.Also, I am extremely sorry that during the contest we found out that some people found the second difference/derivative of the sequence on OEIS. We searched on OEIS before but couldn't find it, otherwise we would have modified the problem. Again, sorry for this issue.

Code#include<bits/stdc++.h>
using namespace std;

const int N = 1e6 + 9, mod = 998244353;
using ll = long long;

int dp[N]; // count of arrays that we can get if the current number of inversions is > max element of the array
void solve() {
  int n; cin >> n;
  int sum = 0;
  for (int i = n; i >= 1; i--) {
    dp[i] = (1LL * i * sum % mod + 1) % mod;
    sum = (sum + dp[i]) % mod;
  }
  int ans = n - 1; // arrays having 0 and 1 inversions
  for (int k = 3; k <= n; k++) {
    int ways = (1LL * (k - 1) * (k - 2) / 2 - 1 + mod) % mod; // count of arrays achievable such that > 1 inversion count was inserted for the first time
    ans += 1LL * ways * dp[k] % mod;
    ans %= mod;
  }
  cout << ans << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}

Code (by wyrqwq, without initial casework)#include <bits/stdc++.h>

#include <chrono>
std::mt19937 eng(std::chrono::steady_clock::now().time_since_epoch().count());
int rnd(int l, int r) { return std::uniform_int_distribution<int>(l, r)(eng); }

namespace FastIO {
//	char buf[1 << 21], *p1 = buf, *p2 = buf;
//	#define getchar() (p1 == p2 && (p1 = buf, p2 = (p1 + fread(buf, 1, 1 << 21, stdin))) == p1 ? EOF : *p1++)
	template <typename T> inline T read() { T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= (ch == '-'), ch = getchar(); while ('0' <= ch && ch <= '9') x = x * 10 + (ch ^ '0'), ch = getchar(); return w ? -x : x; }
	template <typename T> inline void write(T x) { if (!x) return; write<T>(x / 10), putchar((x % 10) ^ '0'); }
	template <typename T> inline void print(T x) { if (x > 0) write<T>(x); else if (x < 0) putchar('-'), write<T>(-x); else putchar('0'); }
	template <typename T> inline void print(T x, char en) { print<T>(x), putchar(en); }
//	inline char rChar() { char ch = getchar(); while (!isalpha(ch)) ch = getchar(); return ch; }
}; using namespace FastIO;

using i32 = int32_t;
using u32 = uint32_t;
using u64 = uint64_t;
template <uint32_t MOD> struct mint {
	static constexpr u32 get_r() {
		u32 ret = MOD;
		for (i32 i = 0; i < 4; ++i) ret *= 2 - MOD * ret;
		return ret;
	}
	static constexpr u32 r = get_r();
	static constexpr u32 n2 = -u64(MOD) % MOD;
	static_assert(r * MOD == 1, "invalid, r * MOD != 1");
	static_assert(MOD < (1 << 30), "invalid, MOD >= 2 ^ 30");
	static_assert((MOD & 1) == 1, "invalid, MOD % 2 == 0");
	u32 a;
	constexpr mint() : a(0) {}
	constexpr mint(const int64_t &b) : a(reduce(u64(b % MOD + MOD) * n2)){};
	static constexpr u32 reduce(const u64 &b) { return (b + u64(u32(b) * u32(-r)) * MOD) >> 32; }
	 constexpr mint &operator += (const mint &b) { if (i32(a += b.a - 2 * MOD) < 0) a += 2 * MOD; return *this; }
	constexpr mint &operator -= (const mint &b) { if (i32(a -= b.a) < 0) a += 2 * MOD; return *this; }
	constexpr mint &operator *= (const mint &b) { a = reduce(u64(a) * b.a); return *this; }
	constexpr mint &operator /= (const mint &b) { *this *= b.inverse(); return *this; }
	constexpr mint operator + (const mint &b) const { return mint(*this) += b; }
	constexpr mint operator - (const mint &b) const { return mint(*this) -= b; }
	constexpr mint operator * (const mint &b) const { return mint(*this) *= b; }
	constexpr mint operator / (const mint &b) const { return mint(*this) /= b; }
	constexpr bool operator == (const mint &b) const { return (a >= MOD ? a - MOD : a) == (b.a >= MOD ? b.a - MOD : b.a); }
	constexpr bool operator != (const mint &b) const { return (a >= MOD ? a - MOD : a) != (b.a >= MOD ? b.a - MOD : b.a); }
	constexpr mint operator-() const { return mint() - mint(*this); }
	constexpr mint pow(u64 n) const { mint ret(1), mul(*this); while (n > 0) { if (n & 1) ret *= mul; mul *= mul, n >>= 1; } return ret; }
	constexpr mint inverse() const { return pow(MOD - 2); }
	friend std::ostream &operator<< (std::ostream &os, const mint &b) { return os << b.get(); }
	friend std::istream &operator>> (std::istream &is, mint &b) { int64_t t; is >> t; b = mint<MOD>(t); return (is); }
	constexpr u32 get() const { u32 ret = reduce(a); return ret >= MOD ? ret - MOD : ret; }
	static constexpr u32 get_MOD() { return MOD; }
    explicit operator u32() const { return get(); }
}; using modint = mint<998244353>;

// Let's write some brute first
// dp[i][j] := current length is i, current number of inversions is j (not inserted)
// dp[i][j] -> dp[>= i + 1][[j + 1, j + i]]
// this is true for j >= 1, so let's do something when j = 0
// we can generate [0, (0 ... ), 1, 0] -> dp[>= 3][1]
// this is still kinda annoying because 1 > 1 does not hold, we process it till j >= 2
// [0, 0, ..., 0, 1, 0] -> [0, 0, ..., 0, 1, 0, 1, ..., 1]
// after that we insert an 1 before some numbers of 0 and we get dp[i][1] -> dp[>= i + 1][[j + 1, j + i - 1]]
// the answer is sum dp[i][j] for all 1 <= i <= n, j >= 1, plus 1 ([0, 0, 0 ... 1])
// actually we care nothing 'bout, j so let's say f[i] = sum dp[i][j]
// (f[i] * i - 1) -> f[i + 1], f[i + 2], ..., f[n]

#define MAXN 1000001
modint f[MAXN];
void solve() {
	int n = read<int>(); modint ans = 1, pre = 2;
	f[3] = 1;
	for (int i = 4; i <= n; ++i) 
		f[i] = pre + modint(1), pre += f[i] * modint(i) - modint(1);
	for (int i = 3; i <= n; ++i) ans += f[i];
	// f[3] : [0, 1, 0]
	// f[4] : [0, 0, 1, 0] (+1), [0, 1, 1, 0], [1, 0, 1, 0] (dp[3][1] * 2)
	print<int>(ans.get(), '\n');
}

int main() { int T = read<int>(); while (T--) solve(); return 0; }

Rate the Problem Amazing problem: 

    


49



 Good problem: 

    


31



 Average problem: 

    


28



 Bad problem: 

    


90



 Didn't solve: 

    


19



 

Tutorial2039F1 - Shohag Loves Counting (Easy Version)Let ğ‘ ğ‘˜sk be the sequence of ğ‘˜k length subarray maximums of the array. Then ğ‘ ğ‘˜+1sk+1 is just the adjacent maximum sequence of ğ‘ ğ‘˜sk.Also, let ğ‘”ğ‘˜gk be the GCD of the elements of ğ‘ ğ‘˜sk. Then notice that every element of ğ‘ ğ‘˜+1sk+1 is also divisible by ğ‘”ğ‘˜gk. That is ğ‘”ğ‘˜gk divides ğ‘”ğ‘˜+1gk+1.For the array to be good, ğ‘”ğ‘˜gk must be different for all ğ‘˜k. So ğ‘”ğ‘˜<ğ‘”ğ‘˜+1gk<gk+1 and ğ‘”ğ‘˜gk divides ğ‘”ğ‘˜+1gk+1. This means if the length of the array is ğ‘›n, then ğ‘›â‰¤âŒŠlog2ğ‘šâŒ‹+1nâ‰¤âŒŠlog2â¡mâŒ‹+1.Now consider a non-decreasing sequence of integers ğ‘a of length ğ‘›n such that 1â‰¤ğ‘ğ‘–â‰¤ğ‘š1â‰¤aiâ‰¤m for all ğ‘–i. Then the ğ‘˜k length subarray maximums of ğ‘a are just the last ğ‘˜k elements of ğ‘a. So ğ‘”ğ‘˜gk is the GCD of the last ğ‘˜k elements of ğ‘a. Then for ğ‘”ğ‘˜gk to be different for all ğ‘˜k, all the elements of ğ‘a must be distinct. So the condition for ğ‘a to be good is that the elements are distinct and all suffix GCDs are distinct as well.Next the question is how many permutations of this increasing sequence ğ‘a is good as well? To count this, lets start from ğ‘ ğ‘›sn. ğ‘ ğ‘›sn is just [ğ‘ğ‘›][an]. Now consider ğ‘ ğ‘›âˆ’1snâˆ’1. We need to put ğ‘ğ‘›âˆ’1anâˆ’1 in the sequence such that the adjacent maximum sequence of ğ‘ ğ‘›âˆ’1snâˆ’1 becomes ğ‘ ğ‘›sn. For this we clearly have 22 ways: [ğ‘ğ‘›âˆ’1,ğ‘ğ‘›][anâˆ’1,an] and [ğ‘ğ‘›,ğ‘ğ‘›âˆ’1][an,anâˆ’1].Now consider ğ‘ ğ‘›âˆ’2snâˆ’2. We need to put ğ‘ğ‘›âˆ’2anâˆ’2 in the sequence such that the adjacent maximum sequence of ğ‘ ğ‘›âˆ’2snâˆ’2 becomes ğ‘ ğ‘›âˆ’1snâˆ’1. For this we again have 22 ways because ğ‘ğ‘›âˆ’2anâˆ’2 can be inserted in 22 places: before ğ‘ğ‘›âˆ’1anâˆ’1 or after ğ‘ğ‘›âˆ’1anâˆ’1.Similarly for all other ğ‘ ğ‘˜sk we have 22 ways to insert it: putting it before ğ‘ğ‘˜+1ak+1 or after ğ‘ğ‘˜+1ak+1. So the total number of good permutations of ğ‘a is 2ğ‘›âˆ’12nâˆ’1.So our problem reduces to the following:  Select a length ğ‘›n such that 1â‰¤ğ‘›â‰¤âŒŠlog2ğ‘šâŒ‹+11â‰¤nâ‰¤âŒŠlog2â¡mâŒ‹+1.  Count the number of strictly increasing sequences of length ğ‘›n such that all suffix GCDs are distinct.  Multiply the answer by 2ğ‘›âˆ’12nâˆ’1.  Sum up the answer for all valid ğ‘›n. For a fixed ğ‘›n, let's count the number of strictly increasing sequences of length ğ‘›n such that all suffix GCDs are distinct.Let dpğ‘–,ğ‘”dpi,g be the number of strictly increasing sequences of length ğ‘›n such that the starting element is ğ‘–i and the GCD of the elements is ğ‘”g.Now iterate from ğ‘–=ğ‘ši=m to 11. Then the transition is to iterate over the next suffix GCD â„h such that ğ‘”g divides â„h, ğ‘”<â„â‰¤ğ‘šg<hâ‰¤m and ğ‘”=gcd(ğ‘–,â„)g=gcd(i,h) and then add dpâˆ—,â„dpâˆ—,h to dpğ‘–,ğ‘”dpi,g. Here dpâˆ—,â„dpâˆ—,h is the sum of all dpğ‘—,â„dpj,h for all ğ‘—>ğ‘–j>i.Another way to look at the transition is that for a fixed ğ‘–i, we iterate over all â„h and if gcd(ğ‘–,â„)<â„gcd(i,h)<h, then we add dpâˆ—,â„dpâˆ—,h to dpğ‘–,gcd(ğ‘–,â„)dpi,gcd(i,h).But doing everything like this would still be ğ‘‚(ğ‘š2logğ‘š)O(m2logâ¡m) which is too slow.Notice that all ğ‘”g are the divisors of ğ‘–i. Here the main difficulty is that we need update at the index gcd(ğ‘–,â„)gcd(i,h) over all â„h but it is hard to track the exact gcd but what's easier is to track the multiple of the gcd.So for each ğ‘”g, let's say we know the sum of all dpâˆ—,â„dpâˆ—,h over all â„h such that ğ‘”g divides â„h. So this sums up all dpâˆ—,â„dpâˆ—,h such that ğ‘”g divides gcd(ğ‘–,â„)gcd(i,h). Then using inclusion exclusion on the divisors of ğ‘–i we can get the sum of all dpâˆ—,â„dpâˆ—,h for all â„h such that ğ‘”g is exactly gcd(ğ‘–,â„)gcd(i,h). This will take ğ‘‚(ğœ(ğ‘–)2)O(Ïƒ(i)2) time for each ğ‘–i where ğœ(ğ‘–)Ïƒ(i) is the number of divisors of ğ‘–i.And once we calculate the dpğ‘–,ğ‘”dpi,g for some ğ‘–i and ğ‘”g, then before transitioning to ğ‘–âˆ’1iâˆ’1, we can add the value of dpğ‘–,ğ‘”dpi,g to all divisors of ğ‘”g to get the value of dpâˆ—,â„dpâˆ—,h faster in the future. To keep track of this, we can use a separate array.So for a fixed ğ‘›n, the time complexity is ğ‘‚(âˆ‘ğ‘šğ‘–=1ğœ(ğ‘–)2)O(âˆ‘i=1mÏƒ(i)2). And we need to do this for all ğ‘›n from 11 to âŒŠlog2ğ‘šâŒ‹+1âŒŠlog2â¡mâŒ‹+1.So the overall time complexity is ğ‘‚(logğ‘šâ‹…âˆ‘ğ‘šğ‘–=1ğœ(ğ‘–)2)O(logâ¡mâ‹…âˆ‘i=1mÏƒ(i)2). We actually allowed this to pass in F1.We can make the time complexity much better with a simple modification in the dp. Note that we don't need to use the length of array in the dp state. As we need to sum up after multiplying by 2length of arrayâˆ’12length of arrayâˆ’1 at the end, we can modify the dp to directly store the sum of 2length of arrayâˆ’12length of arrayâˆ’1. So we can just multiply the dp by 22 during each transition.So the time complexity becomes ğ‘‚(âˆ‘ğ‘šğ‘–=1ğœ(ğ‘–)2)O(âˆ‘i=1mÏƒ(i)2). This is very fast for F1.

Code (by LipArcanjo)#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 9, mod = 998244353;
using ll = long long;

int add(int a, int b){
	a += b;
	if(a > mod) a -= mod;
	if(a < 0) a += mod;
	return a;
}

// dp[i][j] = number of arrays where starting element is i and gcd of the array is j
int dp[N], cur[N], uni[N];
int sum[N];
vector<int> d[N];
void solve() {
  int m; cin >> m;
  for (int i = 1; i <= m; i++) {
    dp[i] = cur[i] = 0;
	uni[i] = 0;
	sum[i] = 0;
  }
  int ans = 0;
  ans = 0;
  for (int i = m; i >= 1; i--) {
    for (int j: d[i]) {
      cur[j] = 0;
    }
	int sz = d[i].size();
	for(int idj = sz-1; idj >= 0; idj--){
		int j = d[i][idj];
		uni[j] = add(sum[j],sum[j]);
		for(int idk = idj+1; idk < sz; idk++){
			int k = d[i][idk];
			if(k%j) continue;
			uni[j] = add(uni[j],-uni[k]);
		}
		cur[j] = add(uni[j], - add(dp[j],dp[j]));
	}

    cur[i] += 1;

    for (int j : d[i]) {
	  dp[j] = add(dp[j],cur[j]);
	  for(auto k : d[j]){
	  	sum[k] = add(sum[k],cur[j]);
	  }
	  ans = add(ans,cur[j]);
    }
	
  }
  cout << ans << '\n';
}

int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  for (int i = 1; i < N; i++) {
    for (int j = i; j < N; j += i) {
      d[j].push_back(i);
    }
  }
  int t = 1;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}

Rate the Problem Amazing problem: 

    


37



 Good problem: 

    


8



 Average problem: 

    


2



 Bad problem: 

    


9



 Didn't solve: 

    


12



 

Tutorial2039F2 - Shohag Loves Counting (Hard Version)First, check the editorial of F1.Note that for F2 there is no limit on the sum of ğ‘šm, so we need to change the approach a bit.And for F2 you need to remove the length from the dp state (which I described at the end of the editorial of F1).Now instead of iterating ğ‘–i from ğ‘šm to 11, we iterate from 11 to ğ‘šm. And reformulate the dp as follows.Let's say we are building the strictly increasing sequence ğ‘a from left to right and we are fixing what the suffix GCD of the final array ğ‘a starting from each element will be.Let dpğ‘—,â„dpj,h be the sum of 2length of array so farâˆ’12length of array so farâˆ’1 for all ğ‘a such that we are at element ğ‘—j and the suffix GCD of the final array ğ‘a starting from element ğ‘—j is â„h.Then the transition is to iterate over the previous suffix GCD ğ‘”g at element ğ‘–i such that ğ‘”g divides â„h, ğ‘”<â„g<h and ğ‘”=gcd(ğ‘–,â„)g=gcd(i,h) and then add dpğ‘–,ğ‘”dpi,g to dpğ‘—,â„dpj,h.Just like F1, we can speed up the transitions by tracking some prefix sums and doing inclusion-exclusion on the divisors of ğ‘–i. We can use the Mobius Inversion Formula to do it in ğ‘‚(âˆ‘ğ‘‘|ğ‘–ğœ(ğ‘‘))O(âˆ‘d|iÏƒ(d)). Another way to make it faster is to do SOS DP on the divisors of ğ‘–i which will take ğ‘‚(ğœ(ğ‘–)â‹…ğ‘(ğ‘–))O(Ïƒ(i)â‹…p(i)) where ğ‘(ğ‘–)p(i) is the number of unique prime factors of ğ‘–i.It is hard to describe all the little details of the implementation here, please refer to the code for more details.The overall time complexity is ğ‘‚(âˆ‘ğ‘€ğ‘–=1ğœ(ğ‘–)â‹…ğ‘(ğ‘–))O(âˆ‘i=1MÏƒ(i)â‹…p(i)) or ğ‘‚(âˆ‘ğ‘€ğ‘–=1âˆ‘ğ‘‘|ğ‘–ğœ(ğ‘‘))O(âˆ‘i=1Mâˆ‘d|iÏƒ(d)) where ğ‘€M is the maximum value of ğ‘šm. Both work fast enough. 

Code (unoptimized)#include<bits/stdc++.h>
using namespace std;
 
const int N = 1e6 + 9, mod = 998244353;
 
inline void add(int &x, int y) {
  x = x + y >= mod ? x + y - mod : x + y;
}
int mob[N];
void mobius() {
  mob[1] = 1;
  for (int i = 2; i < N; i++){
    mob[i]--;
    for (int j = i + i; j < N; j += i) {
      mob[j] -= mob[i];
    }
  }
  for (int i = 1; i < N; i++) {
    mob[i] = (mob[i] % mod + mod) % mod;
  }
}
vector<int> divs[N];
int dp[N];
int f[N];
int tmp[N], ans[N];
void solve() {
  for (int i = 1; i < N; i++) {
    for (int d: divs[i]) {
      tmp[d] = (mod - f[d]) % mod;
      for (int c: divs[d]) {
        add(tmp[d], dp[c]);
      }
      tmp[d] = (2 * tmp[d] + 1) % mod;
    }

    // apply mobius inversion formula
    for (int d: divs[i]) {
      for (int c: divs[d]) {
        add(dp[d], 1LL * mob[c] * tmp[d / c] % mod);
      }
      add(f[d], tmp[d]);
    }

    ans[i] = ans[i - 1];
    add(ans[i], f[i]);
  }
}
 
int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  for (int i = 1; i < N; i++) {
    for (int j = i; j < N; j += i) {
      divs[j].push_back(i);
    }
  }
  mobius();
  solve();
  int t = 1;
  cin >> t;
  while (t--) {
    int m; cin >> m;
    cout << ans[m] << '\n';
  }
  return 0;
}


Code (optimized)#include<bits/stdc++.h>
using namespace std;
 
const int N = 1e6 + 9, mod = 998244353;
 
inline void add(int &x, int y) {
  x = x + y >= mod ? x + y - mod : x + y;
}
int spf[N];
void sieve() {
  vector<int> p;
  for(int i = 2; i < N; i++) {
    if (spf[i] == 0) spf[i] = i, p.push_back(i);
    int sz = p.size();
    for (int j = 0; j < sz && i * p[j] < N && p[j] <= spf[i]; j++) {
      spf[i * p[j]] = p[j];
    }
  }
}
int mob[N];
void mobius() {
  mob[1] = 1;
  for (int i = 2; i < N; i++){
    mob[i]--;
    for (int j = i + i; j < N; j += i) {
      mob[j] -= mob[i];
    }
  }
  for (int i = 1; i < N; i++) {
    mob[i] = (mob[i] % mod + mod) % mod;
  }
}
int c[N];
vector<int> divs[N];
void gen_divs(int n) { // not sorted
  int id = 1, x = n;
  divs[n][0] = 1;
  while (n > 1) {
    int k = spf[n];
    int cur = 1, sz = id;
    while (n % k == 0) {
      cur *= k;
      n /= k;
      for (int i = 0; i < sz; i++) {
        divs[x][id++] = divs[x][i] * cur;
      }
    }
  }
}

void prec() {
  sieve();
  // generate divisors without using push_back as its really slow on Codeforces
  for (int i = 1; i < N; i++) {
    for (int j = i; j < N; j += i) {
      c[j]++;
    }
    divs[i].resize(c[i]);
    gen_divs(i);
  }
  mobius();
}
int dp[N];
int f[N];
int tmp[N], ans[N];
void solve() {
  for (int i = 1; i < N; i++) {
    for (int d: divs[i]) {
      tmp[d] = (mod - f[d]) % mod;
      for (int c: divs[d]) {
        add(tmp[d], dp[c]);
      }
      tmp[d] = (2 * tmp[d] + 1) % mod;
    }

    // apply mobius inversion formula
    for (int d: divs[i]) {
      for (int c: divs[d]) {
        add(dp[d], 1LL * mob[c] * tmp[d / c] % mod);
      }
      add(f[d], tmp[d]);
    }

    ans[i] = ans[i - 1];
    add(ans[i], f[i]);
  }
}
 
int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  prec();
  solve();
  int t = 1;
  cin >> t;
  while (t--) {
    int m; cin >> m;
    cout << ans[m] << '\n';
  }
  return 0;
}


Rate the Problem Amazing problem: 

    


18



 Good problem: 

    


1



 Average problem: 

    


3



 Bad problem: 

    


25



 Didn't solve: 

    


12



 

Tutorial2039G - Shohag Loves PebaeLet's say we assign ğ‘ğ‘¢au to the node ğ‘¢u. Let â„ğ‘¢hu be the maximum length of a simple path that passes through ğ‘¢u. Then a necessary condition is that ğ‘ğ‘¢au can not be a multiple of any number â‰¤â„ğ‘¢â‰¤hu. Because if ğ‘ğ‘¢au is a multiple of ğ‘˜â‰¤â„ğ‘¢kâ‰¤hu and ğ‘£v is a node such that the unique simple path from ğ‘¢u to ğ‘£v has length ğ‘˜k, then the LCM of the values of the nodes from ğ‘¢u to ğ‘£v is a multiple of ğ‘˜k, which is a contradiction.The condition also means that ğ‘ğ‘¢au can not be a multiple of any prime number ğ‘â‰¤â„ğ‘¢pâ‰¤hu.Is this a sufficient condition? Yes, and the proof is also simple.So now the problem is to count the number of assignments such that for each node ğ‘¢u, ğ‘ğ‘¢au is not a multiple of any prime number ğ‘â‰¤â„ğ‘¢pâ‰¤hu and gcd(ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›)=1gcd(a1,a2,â€¦,an)=1.Let   ğ‘“ğ‘¤,ğ‘fw,p be the count of numbers from 11 to ğ‘¤w that are not divisible by any prime â‰¤ğ‘â‰¤p,  ğ·D be the diameter of the tree,  A number ğ‘¥x is good if ğ‘¥x is not divisible by any prime â‰¤ğ·â‰¤D,  ğœ‡(ğ‘”)Î¼(g) be the Mobius function,  ğœ‹(ğ‘¥)Ï€(x) be the number of primes â‰¤ğ‘¥â‰¤x. Then the answer to our problem is âˆ‘ğ‘šğ‘”=1ğœ‡(ğ‘”)â‹…[ğ‘”Â is good]â‹…âˆğ‘›ğ‘–=1ğ‘“âŒŠğ‘šğ‘”âŒ‹,â„ğ‘–âˆ‘g=1mÎ¼(g)â‹…[gÂ is good]â‹…âˆi=1nfâŒŠmgâŒ‹,hi.As âŒŠğ‘šğ‘”âŒ‹âŒŠmgâŒ‹ is a non-decreasing function and has at most 2ğ‘šâ€¾â€¾âˆš2m distinct values, we can iterate over âŒŠğ‘šğ‘”âŒ‹âŒŠmgâŒ‹ and calculate range sums of ğœ‡(ğ‘”)â‹…[ğ‘”Â is good]Î¼(g)â‹…[gÂ is good].For calculating prefix sums of a multiplicative function (like ğœ‡(ğ‘”)Î¼(g)), it's a standard task and can be solved using Dirichlet convolution, Min25 sieve or multiple other methods.Here, we need a slight variant of the method as we need the prefix sums of ğœ‡(ğ‘”)â‹…[ğ‘”Â is good]Î¼(g)â‹…[gÂ is good]. This can be achieved using Dirichlet convolution in îˆ»(ğ‘š2/3)O(m2/3) if we just imagine the prime numbers â‰¤ğ·â‰¤D do not exist in the number system. Refer to my code for more details.But for each fixed âŒŠğ‘šğ‘”âŒ‹âŒŠmgâŒ‹, how do we calculate âˆğ‘›ğ‘–=1ğ‘“âŒŠğ‘šğ‘”âŒ‹,â„ğ‘–âˆi=1nfâŒŠmgâŒ‹,hi fast enough? Trivially doing it will make the total complexity around îˆ»(ğ‘›ğ‘šâ€¾â€¾âˆš)O(nm) which is too slow.The key observation is to not forget that the values of â„ğ‘–hi are not random, they are the maximum length of a simple path that passes through the node ğ‘–i. So â„ğ‘–â‰¥âŒˆğ·2âŒ‰hiâ‰¥âŒˆD2âŒ‰ for all ğ‘–i because from each node, the endpoints of the diameter are at least âŒˆğ·2âŒ‰âŒˆD2âŒ‰ away.So now consider two cases:Case 1: ğ·>2ğ‘šâ€¾â€¾âˆšD>2mIn this case, all â„ğ‘–â‰¥âŒˆğ·2âŒ‰â‰¥ğ‘šâ€¾â€¾âˆšhiâ‰¥âŒˆD2âŒ‰â‰¥m for all ğ‘–i. So only primes or 11 are the good numbers. So instead of going with the mobius route, we can just directly solve it by calculating the total number of ways and subtracting the number of ways where the gcd is a prime.We can calculate the total number of ways by first calculating the number of primes â‰¤ğ‘šâ‰¤m and then ğ‘“ğ‘š,â„ğ‘–fm,hi is just ğœ‹(ğ‘š)âˆ’ğœ‹(â„ğ‘–)+1Ï€(m)âˆ’Ï€(hi)+1.And the number of ways where the gcd is a prime is just 11 for all primes >ğ·>D and 00 otherwise.Counting primes under ğ‘šm is also a standard task and can be done in îˆ»(ğ‘š2/3logğ‘š)O(m2/3logâ¡m) or faster.Case 2: ğ·â‰¤2ğ‘šâ€¾â€¾âˆšDâ‰¤2mWe can convert each â„ğ‘–hi to the maximum prime â‰¤â„ğ‘–â‰¤hi and then group â„ğ‘–hi by their values. Then the maximum number of groups will be îˆ»(ğœ‹(ğ‘šâ€¾â€¾âˆš))O(Ï€(m)). So for each fixed ğ‘˜=âŒŠğ‘šğ‘”âŒ‹k=âŒŠmgâŒ‹, if the sum of the mobius function in the range (âŒŠğ‘šğ‘˜+1âŒ‹,âŒŠğ‘šğ‘˜âŒ‹](âŒŠmk+1âŒ‹,âŒŠmkâŒ‹] is non-zero (keep in mind that when all numbers in the range are bad numbers, then the sum will definitely be 00), then we can calculate the product of ğ‘“ğ‘˜,â„ğ‘–fk,hi directly. Then the upper bound of the complexity will be around îˆ»(ğ‘šlog2ğ‘šâ‹…log(ğ‘›ğœ‹(ğ‘šâˆš3)))O(mlog2â¡mâ‹…logâ¡(nÏ€(m3))). The proof will be added later. This works fast enough.

Code#include<bits/stdc++.h>
using namespace std;
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;

struct custom_hash {
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
    return x ^ (x >> 31);
  }
  size_t operator()(uint64_t x) const {
    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x + FIXED_RANDOM);
  }
};

const int N = 1e6 + 9, T = 1e7 + 9, RT = 33333, mod = 998244353; 
using ll = long long;

int power(int n, long long k) {
  int ans = 1 % mod;
  while (k) {
    if (k & 1) ans = (long long) ans * n % mod;
    n = (long long) n * n % mod;
    k >>= 1;
  }
  return ans;
}

int SQRT(int n) {
  int x = sqrt(n);
  while (x * x < n) ++x;
  while (x * x > n) --x;
  return x;
}

int spf[T], id[T], DIAMETER, mu[T];
vector<int> primes; // 1 indexed
int prefix_prime_count[T], prefix_sum_mu[T];
void init() {
  mu[1] = 1;
  for(int i = 2; i < T; i++) {
    if (spf[i] == 0) spf[i] = i, mu[i] = i <= DIAMETER ? 0 : -1, primes.push_back(i);
    int sz = primes.size();
    for (int j = 0; j < sz && i * primes[j] < T && primes[j] <= spf[i]; j++) {
      spf[i * primes[j]] = primes[j];
      if (i % primes[j] == 0) mu[i * primes[j]] = 0;
      else mu[i * primes[j]] = mu[i] * (primes[j] <= DIAMETER ? 0 : -1);
    }
  }
  primes.insert(primes.begin(), 0);
  for (int i = 1; i < primes.size(); i++) {
    id[primes[i]] = i;
  }
  for (int i = 2; i < T; i++) {
    prefix_prime_count[i] = prefix_prime_count[i - 1] + (spf[i] == i);
  }
  for (int i = 1; i < T; i++) prefix_sum_mu[i] = prefix_sum_mu[i - 1] + mu[i];
}
int cnt[N]; // count of nodes having each diameter
int m;
namespace GoodNumbers { // numbers which aren't divisible by the first k primes
  gp_hash_table<int, int, custom_hash> mp[RT << 1];
  int count_num(int n, int k) { // n is a floor value, returns good numbers <= n
    if (k == 0 or n == 0) return n;
    if (primes[k] >= n) return 1;
    if (n < T and 1LL * primes[k] * primes[k] > n) {
      return 1 + prefix_prime_count[n] - k;
    }
    if (mp[k].find(n) != mp[k].end()) return mp[k][n];
    int ans;
    if (1LL * primes[k] * primes[k] > n) {
      int x = upper_bound(primes.begin(), primes.begin() + k, (int)SQRT(n)) - primes.begin() - 1;
      ans = count_num(n, x) - (k - x);
    }
    else ans = count_num(n, k - 1) - count_num(n / primes[k], k - 1);
    mp[k][n] = ans;
    return ans;
  }
};

vector<pair<int, int>> v;
namespace Dirichlet {
  // good number = numbers that aren't divisible by any prime <= DIAMETER
  // we will run dirichlet imagining there exists no prime <= DIAMETER
  gp_hash_table<int, int, custom_hash> mp;
  int p_c(int n) {
    return n < 1 ? 0 : 1;
  }
  int p_g(int n) {
    return GoodNumbers::count_num(n, v.back().first);
  }
  int solve (int x) { // sum of mob[i] over 1 <= i <= x and i is a good number
    if (x < T) return prefix_sum_mu[x];
    if (mp.find(x) != mp.end()) return mp[x];
    int ans = 0;
    for (int i = 2, last; i <= x; i = last + 1) {
      last = x / (x / i);
      ans += solve(x / i) * (p_g(last) - p_g(i - 1));
    }
    ans = p_c(x) - ans;
    return mp[x] = ans;
  }
};

int count_primes(int n) {
  if (n < T) return prefix_prime_count[n];
  int x = SQRT(n);
  int k = upper_bound(primes.begin(), primes.end(), x) - primes.begin() - 1;
  return GoodNumbers::count_num(n, k) + k - 1;
}


// diameter > 2 * sqrt(m)
void solve_large() {
  // only primes are good, so count total ways
  // and subtract where gcd is prime (means all nodes have a fixed prime)
  int total_ways = 1;
  int primes_under_m = count_primes(m);
  for (auto [k, c]: v) {
    if (m <= primes[k]) break;
    total_ways = 1LL * total_ways * power((primes_under_m - k + 1) % mod, c) % mod; // 1 or a prime > k
  }
  int bad_ways = (max(0, primes_under_m - v.back().first)) % mod;
  int ans = (total_ways - bad_ways + mod) % mod;
  cout << ans << '\n';
}

// diameter <= 2 * sqrt(m)
void solve_small() {
  int ans = 0;
  for (int l = 1, r; l <= m; l = r + 1) {
    int x = m / l;
    r = m / x;
    int cur = ((Dirichlet::solve(r) - Dirichlet::solve(l - 1)) % mod + mod) % mod;
    if (cur) {
      int mul = 1;
      for (auto [k, c]: v) {
        if (x <= primes[k]) break;
        mul = 1LL * mul * power(GoodNumbers::count_num(x, k) % mod, c) % mod;
      }
      ans += 1LL * cur * mul % mod;
      ans %= mod;
    }
  }
  cout << ans << '\n';
}

vector<int> g[N];
int dp[N], up[N];
void dfs(int u, int p = 0) {
  dp[u] = 0;
  if (p) g[u].erase(find(g[u].begin(), g[u].end(), p));
  for (auto v: g[u]) {
    if (v ^ p) {
      dfs(v, u);
      dp[u] = max(dp[u], dp[v] + 1);
    }
  }
}
int pref[N], suf[N];
void dfs2(int u) {
  int sz = g[u].size();
  for (int i = 0; i < sz; i++) {
    int v = g[u][i];
    pref[i] = dp[v] + 1;
    if (i) pref[i] = max(pref[i], pref[i - 1]);
  }
  for (int i = sz - 1; i >= 0; i--) {
    int v = g[u][i];
    suf[i] = dp[v] + 1;
    if (i + 1 < sz) suf[i] = max(suf[i], suf[i + 1]);
  }
  for (int i = 0; i < sz; i++) {
    int v = g[u][i];
    int cur = up[u];
    if (i) cur = max(cur, pref[i - 1]);
    if (i + 1 < sz) cur = max(cur, suf[i + 1]);
    up[v] = cur + 1;
  }
  for (auto v: g[u]) {
    dfs2(v);
  }
}
int mx_d[N];
int32_t main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  int n; cin >> n >> m;
  for (int i = 1; i < n; i++) {
    int u, v; cin >> u >> v;
    g[u].push_back(v);
    g[v].push_back(u);
  }
  dfs(1);
  dfs2(1);
  for (int u = 1; u <= n; u++) {
    vector<int> vec;
    if (u != 1) vec.push_back(up[u]);
    for (auto v: g[u]) {
      vec.push_back(dp[v] + 1);
    }
    sort(vec.rbegin(), vec.rend());
    mx_d[u] = vec[0];
    if (vec.size() > 1) {
      mx_d[u] += vec[1];
    }
    mx_d[u] += 1;
  }
  for (int i = 1; i <= n; i++) {
    cnt[mx_d[i]]++;
    DIAMETER = max(DIAMETER, mx_d[i]);
  }

  init();

  int last_prime = 0;
  for (int i = 2; i <= DIAMETER; i++) {
    if (spf[i] == i) last_prime = i;
    if (cnt[i]) {
      int k = id[last_prime];
      if (!v.empty() and v.back().first == k) {
        v.back().second += cnt[i];
      } else {
        v.push_back({k, cnt[i]});
      }
    }
  }

  if (DIAMETER > 2 * SQRT(m)) solve_large();
  else solve_small();
  return 0;
}

Rate the Problem Amazing problem: 

    


14



 Good problem: 

    


1



 Average problem: 

    


1



 Bad problem: 

    


12



 Didn't solve: 

    


14



 

TutorialWe can observe that this kind of path is imporatnt â€” when we are in (ğ‘¥,ğ‘¥)(x,x), we only perform one of the following two kind of moves:Move 1 (ğ‘¥,ğ‘¥)â†’(ğ‘¥,ğ‘¥+1)â†’(ğ‘¥+1,ğ‘¥+1)(x,x)â†’(x,x+1)â†’(x+1,x+1)This move transforms [â€¦,ğ‘ğ‘¥,ğ‘ğ‘¥+1,â€¦][â€¦,ax,ax+1,â€¦] into [â€¦,ğ‘ğ‘¥+1,ğ‘ğ‘¥,â€¦][â€¦,ax+1,ax,â€¦].Move 2 (ğ‘¥,ğ‘¥)â†’(ğ‘¥,ğ‘¥+1)â†’(ğ‘¥,ğ‘¥+2)â†’(ğ‘¥+1,ğ‘¥+2)â†’(ğ‘¥+2,ğ‘¥+2)(x,x)â†’(x,x+1)â†’(x,x+2)â†’(x+1,x+2)â†’(x+2,x+2)This move transforms [â€¦,ğ‘ğ‘¥,ğ‘ğ‘¥+1,ğ‘ğ‘¥+2,â€¦][â€¦,ax,ax+1,ax+2,â€¦] into [â€¦,ğ‘ğ‘¥+2,ğ‘ğ‘¥+1,ğ‘ğ‘¥,â€¦][â€¦,ax+2,ax+1,ax,â€¦].Summary of the path:Note the arrays before and after the path as ğ‘a and ğ‘â€²aâ€², respectively. We can see ğ‘â€²ğ‘›=ğ‘1anâ€²=a1, and [ğ‘â€²1,â€¦,ğ‘â€²ğ‘›âˆ’1][a1â€²,â€¦,anâˆ’1â€²] can be obtained from [ğ‘2,â€¦,ğ‘ğ‘›][a2,â€¦,an] through the following transformation:  Swap any two adjacent numbers of [ğ‘2,â€¦,ğ‘ğ‘›][a2,â€¦,an], but each number can be swapped at most once. This inspires us to use Odd-Even Sort algorithm.Steps to Achieve the Sorted Array:Step 11: Initialize ğ‘1=ğ‘šğ‘›a1=mn:  If ğ‘1â‰ ğ‘šğ‘›a1â‰ mn, where ğ‘šğ‘›mn is the minimum of the array, use the following path: (1,1)â†’(1,ğ‘1)â†’(ğ‘1,ğ‘1)â†’(ğ‘1,ğ‘›)â†’(ğ‘›,ğ‘›)(1,1)â†’(1,p1)â†’(p1,p1)â†’(p1,n)â†’(n,n)This sequence ensures that ğ‘1=ğ‘šğ‘›a1=mn.Then, repeat steps 22 and 33 until the array is sorted.Step 22: Perform Odd-Even Sorting:  Perform an  Odd-Even Sort (a round of comparison) using the key path above on the subarray ğ‘2,â€¦,ğ‘ğ‘›a2,â€¦,an.Step 33: Maintain the orderliness of [ğ‘2,â€¦,ğ‘ğ‘›][a2,â€¦,an] while repeatedly making ğ‘1=ğ‘šğ‘›a1=mn:  After step 22, we want ğ‘šğ‘›mn back to the head of the array. To achieve this, perform the following operations: (1,1)â†’(1,ğ‘›)â†’(ğ‘›,ğ‘›)(1,1)â†’(1,n)â†’(n,n)This sequence transforms the array as follows: [ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›(ğ‘ğ‘›=ğ‘šğ‘›)]â†’[ğ‘â€²1,ğ‘â€²2,â€¦,ğ‘â€²ğ‘›]=[ğ‘ğ‘›,ğ‘ğ‘›âˆ’1,ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›âˆ’2][a1,a2,â€¦,an(an=mn)]â†’[a1â€²,a2â€²,â€¦,anâ€²]=[an,anâˆ’1,a1,a2,â€¦,anâˆ’2]When this is performed after an odd-even sort, it ensures that:  ğ‘šğ‘›mn is back to the head of the array. The subarray ğ‘1,â€¦,ğ‘ğ‘›âˆ’1a1,â€¦,anâˆ’1 has been cyclically shifted. Handling Continuous Cyclic Shifts in Odd-Even Sort:  Even Length (ğ‘›âˆ’1nâˆ’1 is even):  Cyclic shifting does not affect the odd-even sort. You can continue applying the sort as usual. Odd Length (ğ‘›âˆ’1nâˆ’1 is odd):  A small modification is needed. Specifically, First compare (ğ‘3,ğ‘4),(ğ‘5,ğ‘6),â€¦(a3,a4),(a5,a6),â€¦ instead of (ğ‘2,ğ‘3),(ğ‘4,ğ‘5),â€¦(a2,a3),(a4,a5),â€¦ This adjustment ensures that the odd-even sort operates correctly despite the continuous cyclic shifts. Overall, we obtained a sorted array using 2ğ‘›2n walks.

Code#include <map>
#include <set>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <bitset>
using namespace std;
typedef double db;
typedef long long ll;
typedef unsigned long long ull;
const int N=2010;
int T,n,mn,tot;
int a[N];
vector<int> X[N],Y[N];

void path1(int num) //(1,1)->(1,2)->(2,2)->(2,3)->(3,3)->...
{
	for(int i=1;i<=n;i++)
	{
		X[num].push_back(i),Y[num].push_back(i);
		if(i!=n)
		{
			X[num].push_back(i),Y[num].push_back(i+1);
			swap(a[i],a[i+1]);
		}
	}
}

void path2(int num) //(1,1)->(1,n)->(n,n)
{
	for(int i=1;i<=n;i++)
	{
		X[num].push_back(1),Y[num].push_back(i);
		swap(a[1],a[i]);
	}
	for(int i=2;i<=n;i++)
	{
		X[num].push_back(i),Y[num].push_back(n);
		swap(a[i],a[n]);
	}
}

void walk1(int j)
{
	X[tot].push_back(j-1),Y[tot].push_back(j);
	X[tot].push_back(j-1),Y[tot].push_back(j+1);
    X[tot].push_back(j),Y[tot].push_back(j+1);
	X[tot].push_back(j+1),Y[tot].push_back(j+1);
    swap(a[j-1],a[j+1]);
}

void walk2(int j)
{
	X[tot].push_back(j-1),Y[tot].push_back(j);
	X[tot].push_back(j),Y[tot].push_back(j);
	X[tot].push_back(j),Y[tot].push_back(j+1);
	X[tot].push_back(j+1),Y[tot].push_back(j+1);
	swap(a[j-1],a[j]);
	swap(a[j],a[j+1]);
}

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",&a[i]);
		mn=n;tot=0;
		for(int i=1;i<=n;i++)   mn=min(mn,a[i]);
		for(int i=1;i<=3*n;i++) X[i].clear(),Y[i].clear();
		int p1;
		for(int i=1;i<=n;i++) if(a[i]==mn) p1=i;
		if(p1!=1)
		{
		    tot++;
		    for(int i=1;i<=p1;i++) X[tot].push_back(1),Y[tot].push_back(i),swap(a[1],a[i]);
		    for(int i=2;i<=p1;i++) X[tot].push_back(i),Y[tot].push_back(p1),swap(a[i],a[p1]);
		    for(int i=p1+1;i<=n;i++) X[tot].push_back(p1),Y[tot].push_back(i),swap(a[p1],a[i]);
		    for(int i=p1+1;i<=n;i++) X[tot].push_back(i),Y[tot].push_back(n),swap(a[i],a[n]);
		}
		for(int i=2;i<=n;i++)
		{
			tot++;
			X[tot].push_back(1),Y[tot].push_back(1);
			if(n&1)
			{
				if(i&1)
				{
					for(int j=2;j<=n;j+=2)
					{
						if(j+1==i) walk2(j);
						else if(a[j]>a[j+1]) walk1(j);
						else walk2(j);
					}
				}
				else
				{
					for(int j=2;j<=n;j+=2)
					{
						if(a[j]>a[j+1]) walk1(j);
						else walk2(j);
					}
				}
			}
			else
			{
				if(i&1)
				{
					for(int j=2;j<=n;j+=2)
					{
						if(j==i-1)
						{
							X[tot].push_back(j-1),Y[tot].push_back(j);
							X[tot].push_back(j),Y[tot].push_back(j);
							swap(a[j-1],a[j]);
							j--;
						}
						else if(a[j]>a[j+1]) walk1(j);
						else walk2(j);
					}
				}
				else
				{
					for(int j=2;j<=n;j+=2)
					{
						if(j==i)
						{
							X[tot].push_back(j-1),Y[tot].push_back(j);
							X[tot].push_back(j),Y[tot].push_back(j);
							swap(a[j-1],a[j]);
							j--;
						}
						else if(a[j]>a[j+1]) walk1(j);
						else walk2(j);
					}
				}
			}
			path2(++tot);
		}
		printf("%d\n",tot);
		for(int i=1;i<=tot;i++)
		{
			for(int j=1;j<2*n-1;j++)
			{
			    if(X[i][j]==X[i][j-1]) printf("R");
			    else printf("D");
			}
			printf("\n");
		}

	}

	return 0;
}

Rate the Problem Amazing problem: 

    


13



 Good problem: 

    


0



 Average problem: 

    


1



 Bad problem: 

    


4



 Didn't solve: 

    


14



 

TutorialFirst, read the editorial of the easy version. We can see that the bottleneck lies in the fact that after every round of odd-even sorting, we need to perform a walk operation to ensure that ğ‘1=ğ‘šğ‘›a1=mn.The following method can break through this bottleneck: for simplicity, let's assume ğ‘›n is even. Define the numbers smaller than or equal to ğ‘›2n2 as ğ‘†S, and the numbers bigger than ğ‘›2n2 as ğµB. If we have ğ‘=[ğ‘†,â€¦,ğ‘†,ğµ,â€¦,ğµ]a=[S,â€¦,S,B,â€¦,B], we can repeatedly perform key path operations to get the following sequence:  [ğ‘†,â€¦,ğ‘†,ğµ,â€¦,ğµ]â†’[ğ‘†,â€¦,ğ‘†,ğµ,â€¦,ğµ,ğ‘†]â†’[ğ‘†,â€¦,ğ‘†,ğµ,â€¦,ğµ,ğ‘†,ğ‘†]â†’â€¦â†’[ğµ,â€¦,ğµ,ğ‘†,â€¦,ğ‘†][S,â€¦,S,B,â€¦,B]â†’[S,â€¦,S,B,â€¦,B,S]â†’[S,â€¦,S,B,â€¦,B,S,S]â†’â€¦â†’[B,â€¦,B,S,â€¦,S]  In this process, we only perform odd-even sorting for the subarray [ğµ,â€¦,ğµ][B,â€¦,B]. [ğµ,â€¦,ğµ,ğ‘†,â€¦,ğ‘†]â†’[ğµ,â€¦,ğµ,ğ‘†,â€¦,ğ‘†,ğµ]â†’[ğµ,â€¦,ğµ,ğ‘†,â€¦,ğµ,ğµ]â†’â€¦â†’[ğ‘†,â€¦,ğ‘†,ğµ,â€¦,ğµ][B,â€¦,B,S,â€¦,S]â†’[B,â€¦,B,S,â€¦,S,B]â†’[B,â€¦,B,S,â€¦,B,B]â†’â€¦â†’[S,â€¦,S,B,â€¦,B]  In this process, we only perform odd-even sorting for the subarray [ğ‘†,â€¦,ğ‘†][S,â€¦,S]. After that, the array is sorted.Finally, the only remaining problem is how to arrange ğ‘=[ğ‘†,â€¦,ğ‘†,ğµ,â€¦,ğµ]a=[S,â€¦,S,B,â€¦,B].Assume we have ğ‘˜k positions ğ‘1,ğ‘2,â€¦,ğ‘ğ‘˜p1,p2,â€¦,pk such that 1<ğ‘1<ğ‘2<â€¦<ğ‘ğ‘˜â‰¤ğ‘›1<p1<p2<â€¦<pkâ‰¤n. Consider what the following operations are doing:(1,1)â†’(1,ğ‘1)â†’(2,ğ‘1)â†’(2,ğ‘2)â†’(3,ğ‘2)â†’â€¦â†’(ğ‘˜,ğ‘ğ‘˜)(1,1)â†’(1,p1)â†’(2,p1)â†’(2,p2)â†’(3,p2)â†’â€¦â†’(k,pk)If we ignore the other numbersï¼Œthese operations correspond to:swap(ğ‘1,ğ‘ğ‘1),swap(ğ‘2,ğ‘ğ‘2),â€¦swap(a1,ap1),swap(a2,ap2),â€¦Then, we can take any path from (ğ‘˜,ğ‘ğ‘˜)(k,pk) to (ğ‘›,ğ‘›)(n,n).At first, we perform one operation to set ğ‘1=ğ‘›a1=n, then choose ğ‘›2n2 positions ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›2p1,p2,â€¦,pn2 to obtain ğ‘=[ğ‘†,â€¦,ğ‘†,ğµ,â€¦,ğµ]a=[S,â€¦,S,B,â€¦,B].For ğ‘›n being odd, we need two additional operations for some little adjustments.Overall, we obtained a sorted array using ğ‘›+4n+4 walks.

Code#include <map>
#include <set>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <bitset>
using namespace std;
typedef double db;
typedef long long ll;
typedef unsigned long long ull;
const int N=2010;
int T,n,tot;
int a[N];
vector<int> X[N],Y[N];

void path1(int num)  //(1,1)->(1,2)->(2,2)->(2,3)->(3,3)->...
{
	for(int i=1;i<=n;i++)
	{
		X[num].push_back(i),Y[num].push_back(i);
		if(i!=n)
		{
			X[num].push_back(i),Y[num].push_back(i+1);
			swap(a[i],a[i+1]);
		}
	}
}

void path2(int num) //(1,1)->(1,n)->(n,n)
{
	for(int i=1;i<=n;i++)
	{
		X[num].push_back(1),Y[num].push_back(i);
		swap(a[1],a[i]);
	}
	for(int i=2;i<=n;i++)
	{
		X[num].push_back(i),Y[num].push_back(n);
		swap(a[i],a[n]);
	}
}

void path3(int num,vector<int> p) //swap(1,p[0]),(2,p[1]),... note p[0]!=1
{
	for(int i=1;i<=p[0];i++)
	{
		X[num].push_back(1),Y[num].push_back(i);
		swap(a[1],a[i]);
	}
	for(int i=1;i<p.size();i++)
	{
		for(int j=p[i-1];j<=p[i];j++)
		{
			X[num].push_back(i+1),Y[num].push_back(j);
		    swap(a[i+1],a[j]);
		}
	}
	int x=p.size(),y=p.back();
	while(x!=n)
	{
	    x++;
	    X[num].push_back(x),Y[num].push_back(y);
		swap(a[x],a[y]);
	}
	while(y!=n)
	{
	    y++;
	    X[num].push_back(x),Y[num].push_back(y);
		swap(a[x],a[y]);
	}
}

void walk1(int j)
{
	X[tot].push_back(j-1),Y[tot].push_back(j);
	X[tot].push_back(j-1),Y[tot].push_back(j+1);
    X[tot].push_back(j),Y[tot].push_back(j+1);
	X[tot].push_back(j+1),Y[tot].push_back(j+1);
    swap(a[j-1],a[j+1]);
}

void walk2(int j)
{
	X[tot].push_back(j-1),Y[tot].push_back(j);
	X[tot].push_back(j),Y[tot].push_back(j);
	X[tot].push_back(j),Y[tot].push_back(j+1);
	X[tot].push_back(j+1),Y[tot].push_back(j+1);
	swap(a[j-1],a[j]);
	swap(a[j],a[j+1]);
}

void walk3(int j)
{
	X[tot].push_back(j-1),Y[tot].push_back(j);
	X[tot].push_back(j),Y[tot].push_back(j);
	swap(a[j-1],a[j]);
}

void init()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	tot=0;
	for(int i=1;i<=3*n;i++) X[i].clear(),Y[i].clear();
	vector<pair<int,int> > pr;
	for(int i=1;i<=n;i++) pr.push_back(make_pair(a[i],i));
	sort(pr.begin(),pr.end());
	for(int i=1;i<=n;i++) a[pr[i-1].second]=i;
}

void step1()
{
	int p1,pn;
	vector<int> p;
	for(int i=1;i<=n;i++) if(a[i]==1) p1=i;
	if(p1!=1)
	{
        p.push_back(p1);
        path3(++tot,p);
	}
	if(n==2) return ;
	tot++;
	X[tot].push_back(1),Y[tot].push_back(1);
	for(int j=2;j<=n;j+=2)
	{
	    if(j+1>n) walk3(j);
	    else if(a[j]==n) walk1(j);
		else walk2(j);
	}
	p1=n;
	for(int i=1;i<=n;i++) if(a[i]==n) pn=i;
    p.clear();
    p.push_back(pn);p.push_back(p1);
    path3(++tot,p);
    p.clear();
    for(int i=1;i<=n;i++) if(a[i]<=(n+1)/2) p.push_back(i);
    path3(++tot,p);
}

void step2()
{
	int head;
	if(n&1)
	{
	    for(int t=1;t<=2;t++)
		{
            head=n/2+2;
            for(int i=1;i<=n/2+(t==1);i++)
            {
                tot++;
                X[tot].push_back(1),Y[tot].push_back(1);
                for(int j=2;j<=n;j++)
                {
                    if(!(head<=j&&j<=head+n/2-1)) walk3(j);
                    else if(j==head&&(head&1)) walk3(j);
                    else
                    {
                        if(!(head<=j+1&&j+1<=head+n/2-1)) walk3(j);
                        else if(a[j]>a[j+1]) walk1(j),j++;
                        else walk2(j),j++;
                    }
                }
                head--;
            }
		}
	}
	else
	{
		for(int t=1;t<=2;t++)
		{
            head=n/2+1;
            for(int i=1;i<=n/2;i++)
            {
                tot++;
                X[tot].push_back(1),Y[tot].push_back(1);
                for(int j=2;j<=n;j++)
                {
                    if(!(head<=j&&j<=head+n/2-1)) walk3(j);
                    else if(j==head&&(head&1)) walk3(j);
                    else
                    {
                        if(!(head<=j+1&&j+1<=head+n/2-1)) walk3(j);
                        else if(a[j]>a[j+1]) walk1(j),j++;
                        else walk2(j),j++;
                    }
                }
                head--;
            }
		}
	}
}

void output()
{
	printf("%d\n",tot);
	for(int i=1;i<=tot;i++)
	{
		for(int j=1;j<2*n-1;j++)
		{
		    if(X[i][j]==X[i][j-1]) printf("R");
		    else printf("D");
		}
		printf("\n");
	}
}

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		init();
		step1();
		step2();
		output();
	}

	return 0;
}


Rate the Problem Amazing problem: 

    


12



 Good problem: 

    


1



 Average problem: 

    


0



 Bad problem: 

    


4



 Didn't solve: 

    


20



 

Spoiler// this is code

int main() {
fastio();
int tc;cin>>tc;

while(tc--){
 int n,m;cin>>n>>m;
 vector<int> a(m);
 for(int i=0;i<m;i++)cin>>a[i];

 sort(a.begin(),a.end(),greater<int>());
 vector<int> fa(n+1);
 vector<int> t(n+1);int flag=1;
 for(int i=1;i<=n;i++){
    if(i==1){fa[i]=a[0];t[i]=0;}
    else{
        //find all factors of this
        vector<int> f;
        f.push_back(1);
        for(int x=2;x*x<=i;x++){
            if(i%x==0){
                f.push_back(x);
                if(x*x!=i){
                    fa.push_back(i/x);
                }
            }
        }

        int mx=0;
        for(auto it:f){
            mx=max(mx,t[it]);
        }

    mx++;
    if(mx>=m){
        flag=0;break;
    }
    else{
        fa[i]=a[mx];
        t[i]=mx;
    }
    }
 }
 if(!flag)cout<<-1<<endl;
 else{
    for(int i=1;i<=n;i++)cout<<fa[i]<<" ";
    cout<<endl;
 }
  }
}

