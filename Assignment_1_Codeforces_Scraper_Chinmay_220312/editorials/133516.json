{
    "url": "https://codeforces.com/blog/entry/133516",
    "title": "Refact.ai Match 1 (Codeforces Round 985) Editorial",
    "tags": [],
    "content": "Thank you all for participating in the round!We apologize for the wrong checker in problem E at the beginning of the contest, as well as the weak tests in problem B. To be honest, all the hacked submissions have similar logic and codes in B, which made me suspicious. Anyway, we are sorry for the inconvenience! >_< Rating Predictions     A B C D E F G H I     Error_Yuan 800 1200 1600 2100 2300 2600 3000 3400 3500   sszcdjr 800 1100 1600 2000 2300 2600 2900 3300 3500   wyrqwq 800 1000 1400 2200 2300 2600 3000 3500 3500   Otomachi_Una 800 1000 1600 2200 2400 2600 3200 3500 3500   dXqwq 900 1100 1700 2200 2400 2600 3200 3500 3500   Kubic 800 1000 1600 2400 2200 2800 3000 3500 3300   wsc2008qwq 800 1100 1600 1900 2200 2700 3100       chromate00 800 1000 1600 1900             rui_er 800 1000 1500 1800 2200 2500 3000       abc864197532 800 1100 1600 2200 2300 2500 2900             A B C D E F G H I     Average 810  1060  1580  2090  2289 2611  3033  3450  3467    Actual 800  1100  1700  1900  2100  2500  3000  3500  3400 (Thank you, rainboy)    2029A - SetAuthor: Otomachi_UnaFirst Blood: Benq at 00:00:51 HintGreedy from small to large. SolutionWe can delete the numbers from small to large. Thus, previously removed numbers will not affect future choices (if \ud835\udc65<\ud835\udc66x<y, then \ud835\udc65x cannot be a multiple of \ud835\udc66y). So an integer \ud835\udc65x (\ud835\udc59\u2264\ud835\udc65\u2264\ud835\udc5fl\u2264x\u2264r) can be removed if and only if \ud835\udc58\u22c5\ud835\udc65\u2264\ud835\udc5fk\u22c5x\u2264r, that is, \ud835\udc65\u2264\u230a\ud835\udc5f\ud835\udc58\u230bx\u2264\u230ark\u230b. The answer is max(\u230a\ud835\udc5f\ud835\udc58\u230b\u2212\ud835\udc59+1,0)max(\u230ark\u230b\u2212l+1,0).Time complexity: \ue23b(1)O(1) per test case. Code (C++)#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n \nconst int _N = 1e5 + 5;\n \nint T;\n \nvoid solve() {\n\tint l, r, k; cin >> l >> r >> k;\n\tcout << max(r / k - l + 1, 0) << endl;\n\treturn;\n}\n \nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n} Code (Python 3)for _ in range(int(input())):\n    l, r, k = map(int, input().split())\n    print(max(r // k - l + 1, 0)) Rate the Problem Amazing problem: \n\n\n\n\n35\n\n\n\n\n\n Good problem: \n\n    \n\n\n147\n\n\n\n Average problem: \n\n    \n\n\n119\n\n\n\n Bad problem: \n\n    \n\n\n11\n\n\n\n Didn't solve: \n\n    \n\n\n18\n\n\n\n 2029B - ReplacementAuthor: wyrqwqFirst Blood: Benq at 00:02:30 Hint(\ud835\udff6\ud835\udff701 or \ud835\udff7\ud835\udff610 exists) \u27fa\u27fa (both \ud835\udff60 and \ud835\udff71 exist). SolutionEach time we do an operation, if \ud835\udc60s consists only of \ud835\udff60 or \ud835\udff71, we surely cannot find any valid indices. Otherwise, we can always perform the operation successfully. In the \ud835\udc56i-th operation, if \ud835\udc61\ud835\udc56=\ud835\udff6ti=0, we actually decrease the number of \ud835\udff71-s by 11, and vice versa. Thus, we only need to maintain the number of \ud835\udff60-s and \ud835\udff71-s in \ud835\udc60s. If any of them falls to 00 before the last operation, the answer is NO, otherwise, the answer is YES.Time complexity: \ue23b(\ud835\udc5b)O(n) per test case. Code (C++)#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\n\nusing namespace std;\nusing ll = long long;\n\nconst int _N = 1e5 + 5;\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s, t; cin >> s >> t;\n\tint cnt0 = count(all(s), '0'), cnt1 = n - cnt0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (cnt0 == 0 || cnt1 == 0) {\n\t\t\tcout << \"NO\" << '\\n';\n\t\t\treturn;\n\t\t}\n\t\tif (t[i] == '1') cnt0--;\n\t\telse cnt1--;\n\t}\n\tcout << \"YES\" << '\\n';\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n} Code (Python 3)for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    one = s.count(\"1\")\n    zero = s.count(\"0\")\n    ans = \"YES\"\n    for ti in input():\n        if one == 0 or zero == 0:\n            ans = \"NO\"\n            break\n        one -= 1\n        zero -= 1\n        if ti == \"1\":\n            one += 1\n        else:\n            zero += 1\n    print(ans) Rate the Problem Amazing problem: \n\n    \n\n\n64\n\n\n\n Good problem: \n\n    \n\n\n217\n\n\n\n Average problem: \n\n    \n\n\n26\n\n\n\n Bad problem: \n\n    \n\n\n46\n\n\n\n Didn't solve: \n\n    \n\n\n21\n\n\n\n 2029C - New RatingAuthor: Error_YuanFirst Blood: ksun48 at 00:05:34 Solution 1 (with hints)Hint 1Binary search. Hint 2Do something backward. SolutionFirst, do binary search on the answer. Suppose we're checking whether the answer can be \u2265\ud835\udc58\u2265k now.Let \ud835\udc53\ud835\udc56fi be the current rating after participating in the 11-st to the \ud835\udc56i-th contest (without skipping).Let \ud835\udc54\ud835\udc56gi be the minimum rating before the \ud835\udc56i-th contest to make sure that the final rating is \u2265\ud835\udc58\u2265k (without skipping).\ud835\udc53\ud835\udc56fi-s can be calculated easily by simulating the process in the statement. For \ud835\udc54\ud835\udc56gi-s, it can be shown that  \ud835\udc54\ud835\udc56={\ud835\udc54\ud835\udc56+1\u22121,\ud835\udc54\ud835\udc56+1+1,\ud835\udc4e\ud835\udc56\u2265\ud835\udc54\ud835\udc56+1\ud835\udc4e\ud835\udc56<\ud835\udc54\ud835\udc56+1gi={gi+1\u22121,ai\u2265gi+1gi+1+1,ai<gi+1where \ud835\udc54\ud835\udc5b+1=\ud835\udc58gn+1=k.Then, we should check if there exists an interval [\ud835\udc59,\ud835\udc5f][l,r] (1\u2264\ud835\udc59\u2264\ud835\udc5f\u2264\ud835\udc5b1\u2264l\u2264r\u2264n), such that \ud835\udc53\ud835\udc59\u22121\u2265\ud835\udc54\ud835\udc5f+1fl\u22121\u2265gr+1. If so, we can choose to skip [\ud835\udc59,\ud835\udc5f][l,r] and get a rating of \u2265\ud835\udc58\u2265k. Otherwise, it is impossible to make the rating \u2265\ud835\udc58\u2265k.We can enumerate on \ud835\udc5fr and use a prefix max to check whether valid \ud835\udc59l exists.Time complexity: \ue23b(\ud835\udc5blog\ud835\udc5b)O(nlog\u2061n) per test case. Solution 2 (with hints)Hint 1Consider DP. Hint 2There are only three possible states for each contest: before, in, or after the skipped interval. SolutionConsider \ud835\udc51\ud835\udc5d\ud835\udc56,0/1/2=dpi,0/1/2= the maximum rating after the \ud835\udc56i-th contest, where the \ud835\udc56i-th contest is before/in/after the skipped interval.Let \ud835\udc53(\ud835\udc4e,\ud835\udc65)=f(a,x)= the result rating when current rating is \ud835\udc4ea and the performance rating is \ud835\udc65x, then \u23a7\u23a9\u23a8\u23aa\u23aa\ud835\udc51\ud835\udc5d\ud835\udc56,0=\ud835\udc53(\ud835\udc51\ud835\udc5d\ud835\udc56\u22121,0,\ud835\udc4e\ud835\udc56),\ud835\udc51\ud835\udc5d\ud835\udc56,1=max(\ud835\udc51\ud835\udc5d\ud835\udc56\u22121,1,\ud835\udc51\ud835\udc5d\ud835\udc56\u22121,0),\ud835\udc51\ud835\udc5d\ud835\udc56,2=max(\ud835\udc53(\ud835\udc51\ud835\udc5d\ud835\udc56\u22121,1,\ud835\udc4e\ud835\udc56),\ud835\udc53(\ud835\udc51\ud835\udc5d\ud835\udc56\u22121,2,\ud835\udc4e\ud835\udc56)).{dpi,0=f(dpi\u22121,0,ai),dpi,1=max(dpi\u22121,1,dpi\u22121,0),dpi,2=max(f(dpi\u22121,1,ai),f(dpi\u22121,2,ai)).And the final answer is max(\ud835\udc51\ud835\udc5d\ud835\udc5b,1,\ud835\udc51\ud835\udc5d\ud835\udc5b,2)max(dpn,1,dpn,2).Time complexity: \ue23b(\ud835\udc5b)O(n) per test case. Code (Solution 1, C++)#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int _N = 1e5 + 5;\n\nint T;\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> a(n + 1);\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tvector<int> pre(n + 1);\n\tint curf = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (curf < a[i]) curf++;\n\t\telse if (curf > a[i]) curf--;\n\t\tpre[i] = max(pre[i - 1], curf);\n\t}\n\tauto check = [&](int k) {\n\t\tint curg = k;\n\t\tfor (int i = n; i >= 1; i--) {\n\t\t\tif (pre[i - 1] >= curg) return true;\n\t\t\tif (a[i] < curg) curg++;\n\t\t\telse curg--;\n\t\t}\n\t\treturn false;\n\t};\n\tint L = 0, R = n + 1;\n\twhile (L < R) {\n\t\tint mid = (L + R + 1) >> 1;\n\t\tif (check(mid)) L = mid;\n\t\telse R = mid - 1;\n\t}\n\tcout << L << '\\n';\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n} Code (Solution 2, Python 3)for _ in range(int(input())):\n    n = int(input())\n    \n    def f(a, x):\n        return a + (a < x) - (a > x)\n    \n    dp = [0, -n, -n]\n    for x in map(int, input().split()):\n        dp[2] = max(f(dp[1], x), f(dp[2], x))\n        dp[1] = max(dp[1], dp[0])\n        dp[0] = f(dp[0], x)\n\n    print(max(dp[1], dp[2])) Rate the Problem Amazing problem: \n\n    \n\n\n365\n\n\n\n Good problem: \n\n    \n\n\n89\n\n\n\n Average problem: \n\n    \n\n\n20\n\n\n\n Bad problem: \n\n    \n\n\n34\n\n\n\n Didn't solve: \n\n    \n\n\n59\n\n\n\n 2029D - Cool GraphAuthor: Error_YuanFirst Blood: ksun48 at 00:13:24There are many different approaches to this problem. Only the easiest one (at least I think so) is shared here. Hint 1Try to make the graph into a forest first. Hint 2(\ud835\udc51\ud835\udc52\ud835\udc54\ud835\udc56\u22641degi\u22641 for every \ud835\udc56i) \u27f9\u27f9 (The graph is a forest). SolutionLet \ud835\udc51\ud835\udc56di be the degree of vertex \ud835\udc56i. First, we keep doing the following until it is impossible:  Choose a vertex \ud835\udc62u with \ud835\udc51\ud835\udc62\u22652du\u22652, then find any two vertices \ud835\udc63,\ud835\udc64v,w adjacent to \ud835\udc62u. Perform the operation on (\ud835\udc62,\ud835\udc63,\ud835\udc64)(u,v,w). Since each operation decreases the number of edges by at least 11, at most \ud835\udc5am operations will be performed. After these operations, \ud835\udc51\ud835\udc56\u22641di\u22641 holds for every \ud835\udc56i. Thus, the resulting graph consists only of components with size \u22642\u22642.If there are no edges, the graph is already cool, and we don't need to do any more operations.Otherwise, let's pick an arbitrary edge (\ud835\udc62,\ud835\udc63)(u,v) as the base of the final tree, and then merge everything else to it.For a component with size =1=1 (i.e. it is a single vertex \ud835\udc64w), perform the operation on (\ud835\udc62,\ud835\udc63,\ud835\udc64)(u,v,w), and set (\ud835\udc62,\ud835\udc63)\u2190(\ud835\udc62,\ud835\udc64)(u,v)\u2190(u,w).For a component with size =2=2 (i.e. it is an edge connecting \ud835\udc4ea and \ud835\udc4fb), perform the operation on (\ud835\udc62,\ud835\udc4e,\ud835\udc4f)(u,a,b).It is clear that the graph is transformed into a tree now.The total number of operations won't exceed \ud835\udc5b+\ud835\udc5a\u22642\u22c5max(\ud835\udc5b,\ud835\udc5a)n+m\u22642\u22c5max(n,m).In the author's solution, we used some data structures to maintain the edges, thus, the time complexity is \ue23b(\ud835\udc5b+\ud835\udc5alog\ud835\udc5a)O(n+mlog\u2061m) per test case. Code (C++)#include <bits/stdc++.h>\nusing namespace std;\n#ifdef DEBUG\n#include \"debug.hpp\"\n#else\n#define debug(...) (void)0\n#endif\n\nusing i64 = int64_t;\nconstexpr bool test = false;\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  int t;\n  cin >> t;\n  for (int ti = 0; ti < t; ti += 1) {\n    int n, m;\n    cin >> n >> m;\n    vector<set<int>> adj(n + 1);\n    for (int i = 0, u, v; i < m; i += 1) {\n      cin >> u >> v;\n      adj[u].insert(v);\n      adj[v].insert(u);\n    }\n    vector<tuple<int, int, int>> ans;\n    for (int i = 1; i <= n; i += 1) {\n      while (adj[i].size() >= 2) {\n        int u = *adj[i].begin();\n        adj[i].erase(adj[i].begin());\n        int v = *adj[i].begin();\n        adj[i].erase(adj[i].begin());\n        adj[u].erase(i);\n        adj[v].erase(i);\n        ans.emplace_back(i, u, v);\n        if (adj[u].contains(v)) {\n          adj[u].erase(v);\n          adj[v].erase(u);\n        } else {\n          adj[u].insert(v);\n          adj[v].insert(u);\n        }\n      }\n    }\n    vector<int> s;\n    vector<pair<int, int>> p;\n    for (int i = 1; i <= n; i += 1) {\n      if (adj[i].size() == 0) {\n        s.push_back(i);\n      } else if (*adj[i].begin() > i) {\n        p.emplace_back(i, *adj[i].begin());\n      }\n    }\n    if (not p.empty()) {\n      auto [x, y] = p.back();\n      p.pop_back();\n      for (int u : s) {\n        ans.emplace_back(x, y, u);\n        tie(x, y) = pair(x, u);\n      }\n      for (auto [u, v] : p) {\n        ans.emplace_back(y, u, v);\n      }\n    }\n    println(\"{}\", ans.size());\n    for (auto [x, y, z] : ans) println(\"{} {} {}\", x, y, z);\n  }\n} Rate the Problem Amazing problem: \n\n    \n\n\n211\n\n\n\n Good problem: \n\n    \n\n\n50\n\n\n\n Average problem: \n\n    \n\n\n15\n\n\n\n Bad problem: \n\n    \n\n\n29\n\n\n\n Didn't solve: \n\n    \n\n\n24\n\n\n\n 2029E - Common GeneratorAuthor: Error_Yuan, wyrqwqFirst Blood: ksun48 at 00:23:50 Hint 122 is powerful. Hint 2Consider primes. Hint 3How did you prove that 22 can generate every integer except odd primes? Can you generalize it? SolutionIn this problem, we do not take the integer 11 into consideration.Claim 1. 22 can generate every integer except odd primes.Proof. For a certain non-prime \ud835\udc65x, let mind(\ud835\udc65)mind\u2061(x) be the minimum divisor of \ud835\udc65x. Then \ud835\udc65\u2212mind(\ud835\udc65)x\u2212mind\u2061(x) must be an even number, which is \u22652\u22652. So \ud835\udc65\u2212mind(\ud835\udc65)x\u2212mind\u2061(x) can be generated by 22, and \ud835\udc65x can be generated by \ud835\udc65\u2212mind(\ud835\udc65)x\u2212mind\u2061(x). Thus, 22 is a generator of \ud835\udc65x.Claim 2. Primes can only be generated by themselves.According to the above two claims, we can first check if there exist primes in the array \ud835\udc4ea. If not, then 22 is a common generator. Otherwise, let the prime be \ud835\udc5dp, the only possible generator should be \ud835\udc5dp itself. So we only need to check whether \ud835\udc5dp is a generator of the rest integers.For an even integer \ud835\udc65x, it is easy to see that, \ud835\udc5dp is a generator of \ud835\udc65x if and only if \ud835\udc65\u22652\u22c5\ud835\udc5dx\u22652\u22c5p. Claim 3. For a prime \ud835\udc5dp and an odd integer \ud835\udc65x, \ud835\udc5dp is a generator of \ud835\udc65x if and only if \ud835\udc65\u2212mind(\ud835\udc65)\u22652\u22c5\ud835\udc5dx\u2212mind\u2061(x)\u22652\u22c5p.Proof. First, \ud835\udc65\u2212mind(\ud835\udc65)x\u2212mind\u2061(x) is the largest integer other than \ud835\udc65x itself that can generate \ud835\udc65x. Moreover, only even numbers \u22652\u22c5\ud835\udc5d\u22652\u22c5p can be generated by \ud835\udc5dp (\ud835\udc65\u2212mind(\ud835\udc65)x\u2212mind\u2061(x) is even). That ends the proof.Thus, we have found a good way to check if a certain number can be generated from \ud835\udc5dp. We can use the linear sieve to pre-calculate all the mind(\ud835\udc56)mind\u2061(i)-s.Time complexity: \ue23b(\u2211\ud835\udc5b+\ud835\udc49)O(\u2211n+V), where \ud835\udc49=max\ud835\udc4e\ud835\udc56V=maxai.Some other solutions with worse time complexity can also pass, such as \ue23b(\ud835\udc49log\ud835\udc49)O(Vlog\u2061V) and \ue23b(\ud835\udc61\ud835\udc49\u203e\u203e\u221a)O(tV). Code (C++)#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int _N = 4e5 + 5;\n\nint vis[_N], pr[_N], cnt = 0;\n\nvoid init(int n) {\n\tvis[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (!vis[i]) {\n\t\t\tpr[++cnt] = i;\n\t\t}\n\t\tfor (int j = 1; j <= cnt && i * pr[j] <= n; j++) {\n\t\t\tvis[i * pr[j]] = pr[j];\n\t\t\tif (i % pr[j] == 0) continue;\n\t\t}\n\t}\n}\n\nint T;\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> a(n + 1);\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[a[i]]) p = a[i];\n\t}\n\tif (!p) {\n\t\tcout << 2 << '\\n';\n\t\treturn;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i] == p) continue;\n\t\tif (vis[a[i]] == 0) {\n\t\t\tcout << -1 << '\\n';\n\t\t\treturn;\n\t\t}\n\t\tif (a[i] & 1) {\n\t\t\tif (a[i] - vis[a[i]] < 2 * p) {\n\t\t\t\tcout << -1 << '\\n';\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (a[i] < 2 * p) {\n\t\t\t\tcout << -1 << '\\n';\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << p << '\\n';\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tinit(400000);\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n} Rate the Problem Amazing problem: \n\n    \n\n\n136\n\n\n\n Good problem: \n\n    \n\n\n70\n\n\n\n Average problem: \n\n    \n\n\n18\n\n\n\n Bad problem: \n\n    \n\n\n22\n\n\n\n Didn't solve: \n\n    \n\n\n16\n\n\n\n 2029F - Palindrome EverywhereAuthor: sszcdjrFirst Blood: taeyeon_ss at 00:16:50 Hint 1If there are both consecutive \ud835\ude81R-s and \ud835\ude71B-s, does the condition hold for all (\ud835\udc56,\ud835\udc57)(i,j)? Why?  Hint 2Suppose that there are only consecutive \ud835\ude81R-s, check the parity of the number of \ud835\ude81R-s in each consecutive segment of \ud835\ude81R-s. Hint 3If for each consecutive segment of \ud835\ude81R-s, the parity of the number of \ud835\ude81R-s is odd, does the condition hold for all (\ud835\udc56,\ud835\udc57)(i,j)? Why?  Hint 4If for at least two of the consecutive segments of \ud835\ude81R-s, the parity of the number of \ud835\ude81R-s is even, does the condition hold for all (\ud835\udc56,\ud835\udc57)(i,j)? Why?  Hint 5Is this the necessary and sufficient condition? Why? Hint 6Don't forget some trivial cases like \ud835\ude81\ud835\ude81\ud835\ude81...\ud835\ude81\ud835\ude71RRR...RB and \ud835\ude81\ud835\ude81\ud835\ude81...\ud835\ude81RRR...R. SolutionFor each \ud835\udc58>\ud835\udc5bk>n or \ud835\udc58\u22640k\u22640, let \ud835\udc50\ud835\udc58ck be \ud835\udc50\ud835\udc58mod\ud835\udc5bckmodn.Lemma 1: If there are both consecutive \ud835\ude81R-s and \ud835\ude71B-s, the answer is NO.Proof 1: Suppose that \ud835\udc50\ud835\udc56\u22121=\ud835\udc50\ud835\udc56=\ud835\ude81ci\u22121=ci=R and \ud835\udc50\ud835\udc57\u22121=\ud835\udc50\ud835\udc57=\ud835\ude71cj\u22121=cj=B, it's obvious that there doesn't exist a palindrome route between \ud835\udc56i and \ud835\udc57j.Imagine there are two persons on vertex \ud835\udc56i and \ud835\udc57j. They want to meet each other (they are on the same vertex or adjacent vertex) and can only travel through an edge of the same color.Lemma 2: Suppose that there are only consecutive \ud835\ude81R-s, if for each consecutive segment of \ud835\ude81R-s, the parity of the number of \ud835\ude81R-s is odd, the answer is NO.Proof 2: Suppose that \ud835\udc50\ud835\udc56=\ud835\udc50\ud835\udc57=\ud835\ude71ci=cj=B, \ud835\udc56\u2262\ud835\udc57(mod\ud835\udc5b)i\u2262j(modn) and \ud835\udc50\ud835\udc56+1=\ud835\udc50\ud835\udc56+2=\u22ef=\ud835\udc50\ud835\udc57\u22121=\ud835\ude81ci+1=ci+2=\u22ef=cj\u22121=R. The two persons on \ud835\udc56i and \ud835\udc57j have to \"cross\" \ud835\ude71B simultaneously. As for each consecutive segment of \ud835\ude81R-s, the parity of the number of \ud835\ude81R-s is odd, they can only get to the same side of their current consecutive segment of \ud835\ude81R-s. After \"crossing\" \ud835\ude71B, they will still be on different consecutive segments of \ud835\ude81R-s separated by exactly one \ud835\ude71B and can only get to the same side. Thus, they will never meet.Lemma 3: Suppose that there are only consecutive \ud835\ude81R-s, if, for at least two of the consecutive segments of \ud835\ude81R-s, the parity of the number of \ud835\ude81R-s is even, the answer is NO.Proof 3: Suppose that \ud835\udc50\ud835\udc56=\ud835\udc50\ud835\udc57=\ud835\ude71ci=cj=B, \ud835\udc56\u2262\ud835\udc57(mod\ud835\udc5b)i\u2262j(modn) and vertex \ud835\udc56i and \ud835\udc57j are both in a consecutive segment of \ud835\ude81R-s with even number of \ud835\ude81R-s. Let the starting point of two persons be \ud835\udc56i and \ud835\udc57\u22121j\u22121 and they won't be able to \"cross\" and \ud835\ude71B. Thus, they will never meet.The only case left is that there is exactly one consecutive segment of \ud835\ude81R-s with an even number of \ud835\ude81R-s.Lemma 4: Suppose that there are only consecutive \ud835\ude81R-s, if, for exactly one of the consecutive segments of \ud835\ude81R-s, the parity of the number of \ud835\ude81R-s is even, the answer is YES.Proof 4: Let the starting point of the two persons be \ud835\udc56,\ud835\udc57i,j. Consider the following cases:Case 1: If vertex \ud835\udc56i and \ud835\udc57j are in the same consecutive segment of \ud835\ude81R-s, the two persons can meet each other by traveling through the \ud835\ude81R-s between them.Case 2: If vertex \ud835\udc56i and \ud835\udc57j are in the different consecutive segment of \ud835\ude81R-s and there are odd numbers of \ud835\ude81R-s in both segments, the two person may cross \ud835\ude71B-s in the way talked about in Proof 2. However, when one of them reaches a consecutive segment with an even number of \ud835\ude81R-s, the only thing they can do is let the one in an even segment cross the whole segment and \"cross\" the next \ud835\ude71B in the front, while letting the other one traveling back and forth and \"cross\" the \ud835\ude71B he just \"crossed\". Thus, unlike the situation in Proof 2, we successfully changed the side they can both get to and thus they will be able to meet each other as they are traveling toward each other and there are only odd segments between them.Case 3: If vertex \ud835\udc56i and \ud835\udc57j are in the different consecutive segment of \ud835\ude81R-s and there are an odd number of \ud835\ude81R-s in exactly one of the segments, we can let both of them be in one side of there segments and change the situation to the one we've discussed about in Case 2 (when one of them reached a consecutive segment with even number of \ud835\ude81R-s).As a result, the answer is YES if:  At least \ud835\udc5b\u22121n\u22121 of \ud835\udc501,\ud835\udc502,\u2026,\ud835\udc50\ud835\udc5bc1,c2,\u2026,cn are the same (Hint 6), or Suppose that there are only consecutive \ud835\ude81R-s, there's exactly one of the consecutive segments of \ud835\ude81R-s such that the parity of the number of \ud835\ude81R-s is even. And we can judge them in \ue23b(\ud835\udc5b)O(n) time complexity. Code (C++)#include <bits/stdc++.h>\nusing namespace std;\nvoid solve(){\n\tint n; cin>>n;\n\tstring s; cin>>s;\n\tint visr=0,visb=0,ok=0; \n\tfor(int i=0;i<n;i++){\n\t\tif(s[i]==s[(i+1)%n]){\n\t\t\tif(s[i]=='R') visr=1;\n\t\t\telse visb=1;\n\t\t\tok++;\n\t\t}\n\t}\n\tif(visr&visb){\n\t\tcout<<\"NO\\n\";\n\t\treturn ;\n\t}\n\tif(ok==n){\n\t\tcout<<\"YES\\n\";\n\t\treturn ;\n\t}\n\tif(visb) for(int i=0;i<n;i++) s[i]='R'+'B'-s[i];\n\tint st=0;\n\tfor(int i=0;i<n;i++) if(s[i]=='B') st=(i+1)%n;\n\tvector<int> vc;\n\tint ntot=0,cnt=0;\n\tfor(int i=0,j=st;i<n;i++,j=(j+1)%n){\n\t\tif(s[j]=='B') vc.push_back(ntot),cnt+=(ntot&1)^1,ntot=0;\n\t\telse ntot++;\n\t}\n\tif(vc.size()==1||cnt==1){\n\t\tcout<<\"YES\\n\";\n\t\treturn ;\n\t}\n\tcout<<\"NO\\n\";\n\treturn ;\n}\nsigned main(){\n\tint t; cin>>t;\n\twhile(t--) solve();\n\treturn 0;\n} Bonus 1Count the number of strings of length \ud835\udc5bn satisfying the condition. Bonus 2Solve the problem for \ud835\udc50\ud835\udc56\u2208{\ud835\ude70,\ud835\ude71,\u2026,\ud835\ude89}ci\u2208{A,B,\u2026,Z}, and solve the counting version. Rate the Problem Amazing problem: \n\n    \n\n\n29\n\n\n\n Good problem: \n\n    \n\n\n41\n\n\n\n Average problem: \n\n    \n\n\n11\n\n\n\n Bad problem: \n\n    \n\n\n46\n\n\n\n Didn't solve: \n\n    \n\n\n21\n\n\n\n 2029G - Balanced ProblemAuthor: wyrqwq, Error_YuanFirst Blood: taeyeon_ss at 00:56:22This problem has two approaches. The first one is the authors' solution, and the second one was found during testing. Solution 1 (with hints)Hint 1The array \ud835\udc4ea is constructed with the operations. How can we use this property? Hint 2If we want to make all \ud835\udc4e\ud835\udc56=\ud835\udc65ai=x, what is the minimum value of \ud835\udc65x? Use the property mentioned in Hint 1. Hint 3(For the subproblem in Hint 2), try to find an algorithm related to the positions of \ud835\ude7b/\ud835\ude81L/R-s directly. Hint 4(For the subproblem in Hint 2), the conclusion is that, the minimum \ud835\udc65x equals # of\u00a0\ud835\ude7b-s+# of\u00a0\ud835\ude81-s\u2212# of adjacent\u00a0\ud835\ude7b\ud835\ude81-s# of\u00a0L-s+# of\u00a0R-s\u2212# of adjacent\u00a0LR-s. Think why. Hint 5Go for DP. SolutionRead the hints first.Then, note that there are only \ue23b(\ud835\udc49)O(V) useful positions: If (after the initial operations) \ud835\udc4e\ud835\udc56>\ud835\udc49ai>V or \ud835\udc4e\ud835\udc56=\ud835\udc4e\ud835\udc56\u22121ai=ai\u22121, we can simply ignore \ud835\udc4e\ud835\udc56ai, or merge \ud835\udc50\ud835\udc56ci into \ud835\udc50\ud835\udc56\u22121ci\u22121.Now let \ud835\udc51\ud835\udc5d(\ud835\udc56,\ud835\udc60)dp(i,s) denote the answer when we consider the prefix of length \ud835\udc56i, and we have \"saved\" \ud835\udc60s pairs of \ud835\ude7b\ud835\ude81LR.Then, \ud835\udc51\ud835\udc5d(\ud835\udc56,\ud835\udc60)=max\ud835\udc57<\ud835\udc56\ud835\udc51\ud835\udc5d(\ud835\udc57,\ud835\udc60\u2212|cntL(\ud835\udc57,\ud835\udc56\u22121)\u2212cntR(\ud835\udc57+1,\ud835\udc56)|)+\ud835\udc50\ud835\udc56dp(i,s)=maxj<idp(j,s\u2212|cntL(j,i\u22121)\u2212cntR(j+1,i)|)+ciWrite cntLcntL and cntRcntR as prefix sums: \ud835\udc51\ud835\udc5d(\ud835\udc56,\ud835\udc60)=max\ud835\udc57<\ud835\udc56\ud835\udc51\ud835\udc5d(\ud835\udc57,\ud835\udc60\u2212|preL(\ud835\udc56\u22121)\u2212preR(\ud835\udc56)+preR(\ud835\udc57)\u2212preL(\ud835\udc57\u22121)|)+\ud835\udc50\ud835\udc56dp(i,s)=maxj<idp(j,s\u2212|preL(i\u22121)\u2212preR(i)+preR(j)\u2212preL(j\u22121)|)+ciDo casework on the sign of the things inside the absabs, and you can maintain both cases with 1D Fenwick trees.Thus, you solved the problem in \ue23b(\ud835\udc492log\ud835\udc49)O(V2log\u2061V). Solution 2 (with hints)Hint 1Solve the problem for a single \ud835\udc63v first. Hint 2Don't think too much, just go straight for a DP solution. Hint 3Does your time complexity in DP contain \ud835\udc5bn or \ud835\udc5am? In fact, both \ud835\udc5bn and \ud835\udc5am are useless. There are only \ue23b(\ud835\udc49)O(V) useful positions. Hint 4Use some data structures to optimize your DP. Even \ue23b(\ud835\udc632log2\ud835\udc63)O(v2log2\u2061v) is acceptable. Hint 5Here is the final step: take a look at your DP carefully. Can you change the definition of states a little, so that it can get the answer for each 1\u2264\ud835\udc63\u2264\ud835\udc491\u2264v\u2264V? SolutionFirst, note that there are only \ue23b(\ud835\udc49)O(V) useful positions: If (after the initial operations) \ud835\udc4e\ud835\udc56>\ud835\udc49ai>V or \ud835\udc4e\ud835\udc56=\ud835\udc4e\ud835\udc56\u22121ai=ai\u22121, we can simply ignore \ud835\udc4e\ud835\udc56ai, or merge \ud835\udc50\ud835\udc56ci into \ud835\udc50\ud835\udc56\u22121ci\u22121.Now, let's solve the problem for a single \ud835\udc63v.Denote \ud835\udc51\ud835\udc5d(\ud835\udc56,\ud835\udc57,\ud835\udc58)dp(i,j,k) as the maximum answer when considering the prefix of length \ud835\udc56i, and there are \ud835\udc57j prefix additions covering \ud835\udc56i, \ud835\udc58k suffix additions covering \ud835\udc56i.Enumerate on \ud835\udc56i, and it is easy to show that the state changes if and only if \ud835\udc57+\ud835\udc58+\ud835\udc4e\ud835\udc56=\ud835\udc63j+k+ai=v, and \ud835\udc51\ud835\udc5d(\ud835\udc56,\ud835\udc57,\ud835\udc58)=max\ud835\udc5d\u2264\ud835\udc57,\ud835\udc5e\u2265\ud835\udc58\ud835\udc51\ud835\udc5d(\ud835\udc56\u22121,\ud835\udc5d,\ud835\udc5e)+\ud835\udc50\ud835\udc56dp(i,j,k)=maxp\u2264j,q\u2265kdp(i\u22121,p,q)+ciYou can use a 2D Fenwick tree to get the 2D prefix max. Thus, you solved the single \ud835\udc63v case in \ue23b(\ud835\udc632log2\ud835\udc63)O(v2log2\u2061v).In fact, we can process the DP in \ue23b(\ud835\udc632log\ud835\udc63)O(v2log\u2061v) by further optimization:  \ud835\udc51\ud835\udc5d(\ud835\udc56,\ud835\udc57,\ud835\udc58)=max\ud835\udc5d\u2264\ud835\udc56\u22121,\ud835\udc5e\u2265\ud835\udc57,\ud835\udc63\u2212\ud835\udc4e\ud835\udc5d\u2212\ud835\udc5e\u2264\ud835\udc58\ud835\udc51\ud835\udc5d(\ud835\udc5d,\ud835\udc5e,\ud835\udc63\u2212\ud835\udc4e\ud835\udc5d\u2212\ud835\udc5e)+\ud835\udc50\ud835\udc56dp(i,j,k)=maxp\u2264i\u22121,q\u2265j,v\u2212ap\u2212q\u2264kdp(p,q,v\u2212ap\u2212q)+ciThis only requires \ud835\udc4e\ud835\udc5d+\ud835\udc5e\u2265\ud835\udc4e\ud835\udc56+\ud835\udc57ap+q\u2265ai+j when \ud835\udc4e\ud835\udc5d\u2264\ud835\udc4e\ud835\udc56ap\u2264ai, and \ud835\udc5e\u2264\ud835\udc57q\u2264j when \ud835\udc4e\ud835\udc5d\u2265\ud835\udc4e\ud835\udc56ap\u2265ai. So you can use 1D Fenwick trees to process the dp in \ue23b(\ud835\udc632log\ud835\udc63)O(v2log\u2061v).Now, let's go for the whole solution.Let's modify the DP state a bit: now \ud835\udc51\ud835\udc5d(\ud835\udc56,\ud835\udc57,\ud835\udc58)dp(i,j,k) is the state when using \ud835\udc63\u2212\ud835\udc58v\u2212k suffix operations (note that \ud835\udc63v is not a constant here). The transformation is similar.Then the answer for \ud835\udc63=\ud835\udc56v=i will be max\ud835\udc51\ud835\udc5d(\u2217,\u2217,\ud835\udc56)maxdp(\u2217,\u2217,i). Code (Solution 1, C++)#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = double;\n\nconst int _N = 4105;\nconst ld inf = 1e15;\n\nint T;\n\nstruct fenwick {\n\tll c[_N]; int N;\n\tint lowbit(int x) { return x & (-x); }\n\tvoid init(int n) {\n\t\tN = n;\n\t\tfor (int i = 1; i <= N; i++) c[i] = -1e18;\n\t}\n\tvoid update(int x, ll v) {\n\t\t// assert(x != 0);\n\t\twhile (x < N) {\n\t\t\tc[x] = max(c[x], v);\n\t\t\tx += lowbit(x);\n\t\t}\n\t}\n\tll getmx(int x) {\n\t\t// assert(x != 0);\n\t\tll res = -1e18;\n\t\twhile (x > 0) {\n\t\t\tres = max(res, c[x]);\n\t\t\tx -= lowbit(x);\n\t\t}\n\t\treturn res;\n\t}\n} pre[4105], suf[4105];\n\nvoid solve() {\n\tint n, o, m, k; cin >> n >> o >> m;\n\tk = 0;\n\tvector<ll> a(n + 3), c(n + 3), d(n + 3), L(n + 3), R(n + 3), L2(n + 3), R2(n + 3);\n\tfor (int i = 1; i <= n; i++) cin >> c[i];\n\tfor (int i = 1; i <= o; i++) {\n\t\tchar op; int x; cin >> op >> x;\n\t\tif (op == 'L') L[x]++;\n\t\telse R[x]++;\n\t}\n\tvector<int> tL(n + 3), tR(n + 3);\n\tfor (int i = 1; i <= n; i++) tR[i] = tR[i - 1] + R[i];\n\tfor (int i = n; i >= 1; i--) tL[i] = tL[i + 1] + L[i];\n\tint q = 0, curL = 0, curR = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = tL[i] + tR[i];\n\t\tif (a[i] <= m + k) {\n\t\t    if (a[i] == a[i - 1] && L[i] == 0 && R[i] == 0) {\n\t\t        if (q == 0) q++;\n\t\t        d[q] += c[i];\n\t\t        continue;\n\t\t    }\n\t\t\tq++;\n\t\t\tL2[q] += L[i];\n\t\t\tR2[q] += R[i] + curR;\n\t\t\tL2[q - 1] += curL;\n\t\t\td[q] += c[i];\n\t\t\tcurL = curR = 0;\n\t\t} else {\n\t\t\tcurL += L[i];\n\t\t\tcurR += R[i];\n\t\t}\n\t}\n\tL2[0] = 0; L2[q] += curL;\n\tfor (int i = 1; i <= q; i++) L2[i] += L2[i - 1], R2[i] += R2[i - 1];\n    m += k;\n    vector<ll> dp(2 * m + 2, -1e18);\n\tfor (int i = 0; i <= 2 * m; i++) {\n\t\tpre[i].init(2 * m + 2);\n\t\tsuf[i].init(2 * m + 2);\n\t}\n\tvector<ll> ans(m + 1);\n\tfor (int i = 1; i <= q; i++) {\n        dp.resize(2 * m + 2, -1e18);\n\t\tdp[L2[i - 1]] = d[i];\n\t\tfor (int s = 0; s <= m; s++) {\n\t\t\tll res1 = pre[s - L2[i - 1] + m].getmx(R2[i] - L2[i - 1] + m + 1);\n\t\t\tll res2 = suf[s - R2[i] + m].getmx(m + 1 - R2[i] + L2[i - 1]);\n\t\t\tdp[s] = max({ dp[s], res1 + d[i], res2 + d[i] });\n\t\t\tif (L2[q] + R2[i] - s >= 0 && L2[q] + R2[i] - s <= m) ans[L2[q] + R2[i] - s] = max(ans[L2[q] + R2[i] - s], dp[s]);\n\t\t}\n\t\tfor (int s = 0; s <= m; s++) {\n\t\t\tif (dp[s] <= -1e12) continue;\n\t\t\tpre[s - L2[i - 1] + m].update(R2[i] - L2[i - 1] + m + 1, dp[s]);\n\t\t\tsuf[s - R2[i] + m].update(m + 1 - R2[i] + L2[i - 1], dp[s]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tans[i] = max(ans[i - 1], ans[i]);\n\t\tcout << ans[i] << \" \\n\"[i == m];\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n} Code (Solution 2, C++)#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define pii pair<int, int>\n#define all(a) a.begin(), a.end()\nconst int mod = 1e9 + 7, N = 5005;\n\nvoid solve() {\n    int n, m, V;\n    cin >> n >> m >> V;\n    vector <int> c(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> c[i];\n    }\n    vector <int> pre(n + 1);\n    for (int i = 0; i < m; ++i) {\n        char x; int v; cin >> x >> v, --v;\n        if (x == 'L') {\n            pre[0]++, pre[v + 1]--;\n        } else {\n            pre[v]++;\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        pre[i + 1] += pre[i];\n    }\n    vector <..."
}