{
    "url": "https://codeforces.com/blog/entry/136908",
    "title": "\u0420\u0430\u0437\u0431\u043e\u0440 Codeforces Round 990 (Div. 2 + Div. 1)",
    "tags": [],
    "content": "Div2AAlyona is happy when there are no unfinished layers \u2014 that is, in front of her is a perfect square with odd side length. Since the order of pieces is fixed, it is enough to keep track of the total current size \ud835\udc60s of the puzzle, and after each day check, if the \ud835\udc60s is a perfect square of an odd number. The easiest way to do that is to create an additional array containing 12,32,53,...,99212,32,53,...,992, and check after each day, whether \ud835\udc60s is in this array. CodeNT = int(input())\n\nsqs = set()\nk = 1\nwhile k * k <= 100 * 1000:\n\tsqs.add(k * k)\n\tk += 2\n\nfor T in range(NT):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tanswer = 0\n\tcursum = 0\n\tfor t in a:\n\t\tcursum += t\n\t\tif cursum in sqs:\n\t\t\tanswer += 1\n\tprint(answer)\nDiv2BFind the character which appears the lowest number of times \u2014 if tied, take the earlier character in the alphabet. Find the character which appears the highest number of times \u2014 if tied, take the later character in the alphabet. Then, replace any of the lowest-occurrence characters with the highest-occurrence character. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0)->sync_with_stdio(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        vector<int> occ(26);\n        for (int i=0; i<n; i++)\n            occ[s[i] - 'a'] += 1;\n        pair<pair<int,char>,int> low, high;\n        low = high = {{occ[s[0] - 'a'], s[0]}, 0};\n        for (int i=1; i<n; i++) {\n            low = min(low, {{occ[s[i] - 'a'], s[i]}, i});\n            high = max(high, {{occ[s[i] - 'a'], s[i]}, i});\n        }\n        s[low.second] = s[high.second];\n        cout << s << \"\\n\";\n    }\n  return 0;\n}Div2CWe can divide the columns in the matrix into three different groups:  the columns where we go through the top cell; the columns where we go through the bottom cell; the columns where we go through both cells. There should be exactly one column in the 33-rd group \u2014 this will be the column where we shift from the top row to the bottom row. However, all other columns can be redistributed between groups 11 and 22 as we want: if we want to put a column into the 11-st group, we put it before the column where we go down; otherwise, we put it after the column where we go down. So, we can get any distribution of columns between the 11-st and the 22-nd group.Now let's consider the contribution of each column to the answer. Columns from the 11-st group add \ud835\udc4e1,\ud835\udc56a1,i to the answer, columns from the 22-nd group add \ud835\udc4e2,\ud835\udc56a2,i, the column from the 33-rd group adds both of these values. So, we can iterate on the index of the column where we go down, take \ud835\udc4e1,\ud835\udc56+\ud835\udc4e2,\ud835\udc56a1,i+a2,i for it, and take max(\ud835\udc4e1,\ud835\udc57,\ud835\udc4e2,\ud835\udc57)max(a1,j,a2,j) for every other column. This works in \ud835\udc42(\ud835\udc5b2)O(n2), and under the constraints of the problem, it is enough. However, it is possible to solve the problem in \ud835\udc42(\ud835\udc5b)O(n). To do so, calculate the sum of max(\ud835\udc4e1,\ud835\udc57,\ud835\udc4e2,\ud835\udc57)max(a1,j,a2,j) over all columns. Then, if we pick the \ud835\udc56i-th column as the column where we go down, the answer be equal to this sum, plus min(\ud835\udc4e1,\ud835\udc56,\ud835\udc4e2,\ud835\udc56)min(a1,i,a2,i), since this will be the only column where we visit both cells. Codefor _ in range(int(input())):\n    n = int(input())\n    a = []\n    for i in range(2):\n        a.append(list(map(int, input().split())))\n    best = [max(a[0][i], a[1][i]) for i in range(n)]\n    full = [a[0][i] + a[1][i] for i in range(n)]\n    sum_best = sum(best)\n    ans = -10 ** 19\n    for i in range(n):\n        ans = max(ans, sum_best + full[i] - best[i])\n    print(ans)Div2DThe first idea is to notice, that each element is moved to the back at most once. Indeed, if we fix a subset of elements that we ever move to the back, we can perform the operation once on each of them in any order we like, and that becomes their final order with the smallest possible increase. The optimal order is, of course, the increasing order. The question is how to select this subset of elements to move to the back.Since we need the lexicographically smallest array, we're looking for some greedy approach that chooses the smallest possible element on the next position one by one, left to right.  What's the smallest number our resulting array can start with? Of course, the minimum. That means, all the elements in front of the minimum have to be moved to the back and be increased by one. What's the smallest number we can have on the second place, given that we have the minimum in the first positions? Either the smallest element to the right of the minimum, or the smallest element among those already moved to the back. ... Analysing this approach, we see that as we go left to right, we keep picking elements from the suffix minima sequence, and keep growing the set of elements we have to move to the right to ''extract'' this sequence from the initial array. At one point, the next smallest element comes not from the suffix minima sequence, but from the pile of integers we move to the right. At this point, all the remaining elements have to be moved to the right once (that is, increased by 11), and then listed in sorted order.So, the answer is always several first elements of the suffix minima sequence, starting from the global minimum, and then all other elements, increased by 11 and sorted in increased order. To find the point where we switch from the suffix minima sequence to the moved elements, it is convenient to precomute the minima, and keep a set of those elements we already move to the right.This solution runs in \ud835\udc42(\ud835\udc5blog\ud835\udc5b)O(nlog\u2061n), along with many other. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid solve()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tvector<int> front(n);\n\tint frontfront = n;\n\tint frontback = n;\n\tmultiset<int> back;\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tif (frontfront >= frontback || a[i] <= front[frontfront]) front[--frontfront] = a[i];\n\t\telse back.insert(a[i] + 1);\n\t\twhile (frontfront < frontback && !back.empty() && front[frontback - 1] > *back.begin())\n\t\t{\n\t\t\tback.insert(front[frontback - 1] + 1);\n\t\t\tfrontback--;\n\t\t}\n\t}\n\tvector<int> answer;\n\tfor (int i = frontfront; i < frontback; i++) answer.pb(front[i]);\n\tfor (auto t : back) answer.pb(t);\n\tfor (auto t : answer) printf(\"%d \", t);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n    int NT = 1;\n    scanf(\"%d\", &NT);\n    for (int T = 1; T <= NT; T++)\n    {\n        solve();\n    }\n    return 0;\n}\nDiv1CFirst, we will use the idea of binary search on the answer. Let's assume we are currently checking if we can achieve the answer \ud835\udc58k.We will iterate over all the necessary coordinates of the vertical lines. To do this, we note that it makes sense to iterate only over those where the lines coincide in the Y-coordinate with at least one of the points. It is obvious that in this case, the necessary vertical lines will be on the order of \ud835\udc42(\ud835\udc5b)O(n).During the iteration over the vertical line, we will maintain two segment trees for the sum: one for the left half of the plane and the other for the right. \ud835\udc61\ud835\udc66ty in each of the segment trees will represent how many points have a Y-coordinate of \ud835\udc66y in the corresponding half of the plane. In each of the segment trees, we will check if it is possible to divide the half-plane into two parts by a line parallel to the x-axis, so that there are at least \ud835\udc58k points in both parts; and if this is possible, we will find the set of suitable lines \u2014 it will obviously be some segment [\ud835\udc66\ud835\udc59,\ud835\udc66\ud835\udc5f][yl,yr]. If the intersection of the resulting segments in both segment trees is not empty, then we have found the answer. This can be done by descending the tree in \ud835\udc42(log\ud835\udc5b)O(log\u2061n) time.Thus, the total time complexity of the described solution is \ud835\udc42(\ud835\udc5blog2\ud835\udc5b)O(nlog2\u2061n). Code#include <math.h>\n#include <unordered_set>\n#include <unordered_map>\n#include <map>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <array>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string_view>\n#include <functional>\n#include <sstream>\n#include <numeric>\n#include <cmath>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <iomanip>\n \nusing namespace std;\n \nusing i64 = long long;\nusing ui32 = unsigned int;\nusing ui64 = unsigned long long;\n \n#define all(a) (a).begin(), (a).end()\n \n \nstruct Tree;\n \nTree* NewNode();\n \nstruct Count {\n    int left = 0;\n    int right = 0;\n    void Add(int delta) {\n        left += delta;\n        if (delta < 0) {\n            right -= delta;\n        }\n    }\n    void operator += (const Count& c) {\n        left += c.left;\n        right += c.right;\n    }\n \n    int GetMin() {\n        return min(left, right);\n    }\n};\n \nstruct Tree {\n        Count count;\n        Tree* left = nullptr;\n        Tree* right = nullptr;\n \n        void Add(int l, int r, int p, int delta = 1) {\n            count.Add(delta);\n            if (r - l == 1) {\n                return;\n            }\n            int mid = (l + r) / 2;\n            if (p < mid) {\n                if (left == nullptr) {\n                    left = NewNode();\n                }\n                left->Add(l, mid, p, delta);\n            } else {\n                if (right == nullptr) {\n                    right = NewNode();\n                }\n                right->Add(mid, r, p, delta);\n            }\n        } \n \n        Count LeftCount() {\n            if (left) {\n                return left->count;\n            }\n            return {};\n        }\n        Count RightCount() {\n            if (right) {\n                return right->count;\n            }\n            return {};\n        }\n \n        void Remove(int l, int r, int p) {\n            Add(l, r, p, -1);\n        }\n};\n \nTree nodes[7000000];\n \nTree* NewNode() {\n    static Tree* nextNode = nodes;\n    return nextNode++;\n}\n \n \nstruct Solver {\n    struct Point {\n        int x, y;\n        bool operator < (const Point& p) const {\n            return x < p.x;\n        }\n    };\n \n    int max = 0;\n    int bx = 0;\n    int by = 0;\n \n    bool FindBest(int l, int r, Tree* node, const Count& left = {}, const Count& right = {}) {\n        if (node == nullptr) {\n            return false;\n        }\n        int mid = (l + r) / 2;\n        Count newLeft = node->LeftCount();\n        Count newRight = node->RightCount();\n        newLeft += left;\n        newRight += right;\n        int mn = min(newLeft.GetMin(), newRight.GetMin());\n        bool updated = false;\n        if (mn > max) {\n            max = mn;\n            by = mid;\n            updated = true;\n        }\n        if (mn == newLeft.GetMin()) {\n            if (FindBest(mid, r, node->right, newLeft, right)) {\n                return true;\n            }\n        } else {\n            if (FindBest(l, mid, node->left, left, newRight)) {\n                return true;\n            }\n        }\n        return updated;\n    }\n \n    void Solve(istream& cin, ostream& cout) {\n        int n;\n        cin >> n;\n        vector<Point> a(n);\n        int t9 = 1000000001;\n        #ifdef pperm\n            t9 = 100;\n        #endif\n        Tree* tree = NewNode();\n        for (Point& p : a) {\n            cin >> p.x >> p.y;\n            tree->Add(-t9, t9, p.y);\n        }\n        sort(all(a));\n        for (int i = 0; i < n;) {\n            int j = i + 1;\n            while (j < n && a[j].x == a[i].x) {\n                ++j;\n            }\n            if (FindBest(-t9, t9, tree)) {\n                bx = a[i].x;\n            }\n            for (;i < j; ++i) {\n                tree->Remove(-t9, t9, a[i].y);\n \n            }\n        }\n        cout << max << '\\n' << bx << ' ' << by << endl;\n    }\n};\n \nint main(int argc, char* args[]) {\n#ifdef pperm\n    ifstream cin(\"/home/pperm86/My/Codeforces/input.txt\");\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n#ifndef pperm\n    srand(time(0));\n#endif\n    int T = 1;\n    cin >> T;\n    for (int iTest = 1; iTest <= T; ++iTest) {\n\t\tSolver solver{};\n        solver.Solve(cin, cout);\n    }\n#ifdef pperm\n    cout << clock() / static_cast<double>(CLOCKS_PER_SEC) << endl;\n#endif\n    return 0;\n}Div1DWe will compress the graph into strongly connected components. Inside a component, each runner can move between any pair of vertices and thus visit all. We will now solve the problem for a directed acyclic graph.We will check for the existence of an answer. Suppose all runners already know the winning plan, and we will try to send them out so that each vertex is visited at least once. To do this, it is necessary to decompose the graph into paths such that:  each vertex belongs to at least one path; no more than \ud835\udc4e[\ud835\udc56]a[i] paths start at each vertex (where \ud835\udc4e[\ud835\udc56]a[i] is the number of runners initially located at the vertex); paths may intersect. Take the source \ud835\udc60s and the sink \ud835\udc61t, and now a path can be represented as a sequence \ud835\udc60s, \ud835\udc621u1, ..., \ud835\udc62\ud835\udc58uk, \ud835\udc61t.We will divide \ud835\udc62u into \ud835\udc62\ud835\udc56\ud835\udc5buin and \ud835\udc62\ud835\udc5c\ud835\udc62\ud835\udc61uout and will consider that a vertex \ud835\udc62u belongs to least one transition from \ud835\udc62\ud835\udc56\ud835\udc5buin to \ud835\udc62\ud835\udc5c\ud835\udc62\ud835\udc61uout. We will draw the following edges:  from \ud835\udc60s to \ud835\udc62\ud835\udc56\ud835\udc5buin with capacity \ud835\udc50\ud835\udc4e\ud835\udc5d=\ud835\udc4e[\ud835\udc62]cap=a[u]; from \ud835\udc62\ud835\udc56\ud835\udc5buin to \ud835\udc62\ud835\udc5c\ud835\udc62\ud835\udc61uout with \ud835\udc50\ud835\udc4e\ud835\udc5d=\ud835\udc56\ud835\udc5b\ud835\udc53cap=inf and the condition of flow through the edge \ud835\udc53\u22651f\u22651; from \ud835\udc62\ud835\udc5c\ud835\udc62\ud835\udc61uout to \ud835\udc61t with \ud835\udc50\ud835\udc4e\ud835\udc5d=\ud835\udc56\ud835\udc5b\ud835\udc53cap=inf; from \ud835\udc62\ud835\udc5c\ud835\udc62\ud835\udc61uout to \ud835\udc63\ud835\udc56\ud835\udc5bvin with \ud835\udc50\ud835\udc4e\ud835\udc5d=\ud835\udc56\ud835\udc5b\ud835\udc53cap=inf for all edges (u, v) in the original graph.  This is equivalent to finding a flow with constraints in this graph.To do this, we will create a dummy source \ud835\udc60\u2032s\u2032 and sink \ud835\udc61\u2032t\u2032, and now for each edge (\ud835\udc62\ud835\udc56\ud835\udc5b,\ud835\udc62\ud835\udc5c\ud835\udc62\ud835\udc61)(uin,uout) with flow through it 1\u2264\ud835\udc53\u2264\ud835\udc56\ud835\udc5b\ud835\udc531\u2264f\u2264inf, we will make the following replacements by drawing edges:  from \ud835\udc62\ud835\udc56\ud835\udc5buin to \ud835\udc62\ud835\udc5c\ud835\udc62\ud835\udc61uout with \ud835\udc50\ud835\udc4e\ud835\udc5d=\ud835\udc56\ud835\udc5b\ud835\udc53\u22121cap=inf\u22121; from \ud835\udc60\u2032s\u2032 to \ud835\udc62\ud835\udc5c\ud835\udc62\ud835\udc61uout with \ud835\udc50\ud835\udc4e\ud835\udc5d=1cap=1; from \ud835\udc62\ud835\udc56\ud835\udc5buin to \ud835\udc61\u2032t\u2032 with \ud835\udc50\ud835\udc4e\ud835\udc5d=1cap=1; from \ud835\udc61t to \ud835\udc60s with \ud835\udc50\ud835\udc4e\ud835\udc5d=\ud835\udc56\ud835\udc5b\ud835\udc53cap=inf. Finding a flow that satisfies the constraints is equivalent to finding the maximum flow from \ud835\udc60\u2032s\u2032 to \ud835\udc61\u2032t\u2032, and if it equals the number of vertices, then the answer exists; otherwise, we can output \u22121\u22121 at this step.Now we minimize the number of runners who initially know the plan. Note that:  it makes no sense for runners to move until they know the plan; it makes no sense to pass the plan to more than one runner from one city. We try to take this into account when constructing. Instead of adding edges from the source to \ud835\udc62\ud835\udc56\ud835\udc5buin, we will do the following:  create a vertex \ud835\udc62\ud835\udc50\ud835\udc5b\ud835\udc61ucnt to control the number of runners and draw edges: from \ud835\udc60s to \ud835\udc62\ud835\udc50\ud835\udc5b\ud835\udc61ucnt with \ud835\udc50\ud835\udc4e\ud835\udc5d=\ud835\udc4e[\ud835\udc62]cap=a[u]; from \ud835\udc62\ud835\udc50\ud835\udc5b\ud835\udc61ucnt to \ud835\udc62\ud835\udc5c\ud835\udc62\ud835\udc61uout with \ud835\udc50\ud835\udc4e\ud835\udc5d=\ud835\udc4e[\ud835\udc62]cap=a[u]; from \ud835\udc62\ud835\udc50\ud835\udc5b\ud835\udc61ucnt to \ud835\udc62\ud835\udc56\ud835\udc5buin with \ud835\udc50\ud835\udc4e\ud835\udc5d=1cap=1, \ud835\udc50\ud835\udc5c\ud835\udc60\ud835\udc61=1cost=1. assign zero cost to all other edges.  This is equivalent to ensuring that all \ud835\udc4e[\ud835\udc56]a[i] runners learn the plan, but if no one comes to our city, we will personally tell exactly one runner from this number, paying \ud835\udc50\ud835\udc5c\ud835\udc60\ud835\udc61=1cost=1 for that person.The answer to the problem is the minimum cost of the maximum flow from \ud835\udc60\u2032s\u2032 to \ud835\udc61\u2032t\u2032 with this graph construction. The proof follows from the graph construction.MCMF can be considered as \ud835\udc42(\ud835\udc5b2\ud835\udc5a2)O(n2m2) or \ud835\udc42(\ud835\udc5b3\ud835\udc5a)O(n3m) for any graphs, but it is worth noting that the flow value \ud835\udc53f is limited to \ud835\udc5bn, and we have a solution in \ud835\udc42(\ud835\udc53\ud835\udc5b\ud835\udc5a)O(fnm) using Ford-Bellman or \ud835\udc42(\ud835\udc53\ud835\udc5alog\ud835\udc5b)O(fmlog\u2061n) using Dijkstra's algorithm with potentials.Interestingly, we note that as a result, we obtained 3\ud835\udc5b3n vertices and \ud835\udc5a+7\ud835\udc5bm+7n edges. With careful implementation, MCMF fits well within TL. Code#define _CRT_SECURE_NO_WARNINGS\n\n#include<iostream>\n#include<fstream>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<array>\n#include<unordered_set>\n#include<unordered_map>\n#include<cstring>\n#include<string>\n#include<memory>\n#include<iomanip>\n#include<cassert>\n#include<cmath>\n#include<random>\n#include<algorithm>\n#include<chrono>\n\n#pragma GCC optimize(\"O3,unroll-loops\")\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\n\n#define int long long\n#define ld long double\n#define endl '\\n'\n\nusing namespace std;\n\n\nconstexpr int N = 500;\nvector<int> g[N], gr[N], gcmp[N];\nint a[N], acmp[N], used[N], color[N], cur_color = 0;\nvector<int> order, cmp;\n\nvoid dfs1(int u) {\n\tfor (int v : g[u]) {\n\t\tif (used[v] == 0) {\n\t\t\tused[v] = 1;\n\t\t\tdfs1(v);\n\t\t}\n\t}\n\torder.push_back(u);\n}\n\nvoid dfs2(int u) {\n\tfor (int v : gr[u]) {\n\t\tif (used[v] == 0) {\n\t\t\tused[v] = 1;\n\t\t\tdfs2(v);\n\t\t}\n\t}\n\tcolor[u] = cur_color;\n}\n\ninline array<int, 3> getInd(int u) {\n\treturn { 3 * u, 3 * u + 1, 3 * u + 2 };\n}\n\nconstexpr int INF = 0x3f3f3f3f;\n\nstruct MCMF {\n\tstruct rib {\n\t\tint b, u, c, f;\n\t\tsize_t back;\n\t};\n\n\tMCMF(int size) : n(size), g_mcmf(size) {};\n\n\tint n;\n\tvector<vector<rib>> g_mcmf;\n\n\tvoid rebuild(int sz) {\n\t\tn = sz, g_mcmf.clear(); g_mcmf.resize(sz);\n\t}\n\n\tvoid add_rib(int a, int b, int u, int c) {\n\t\trib r1 = { b, u, c, 0, g_mcmf[b].size() };\n\t\trib r2 = { a, 0, -c, 0, g_mcmf[a].size() };\n\t\tg_mcmf[a].push_back(r1);\n\t\tg_mcmf[b].push_back(r2);\n\t}\n\n\tpair<int, int> get_flow(int s, int t, int maxflow = INF) {\n\t\tint flow = 0, cost = 0;\n\t\twhile (flow < maxflow) {\n\t\t\tvector<int> id(n, 0);\n\t\t\tvector<int> d(n, INF);\n\t\t\tvector<int> q(n);\n\t\t\tvector<int> p(n);\n\t\t\tvector<size_t> p_rib(n);\n\t\t\tint qh = 0, qt = 0;\n\t\t\tq[qt++] = s;\n\t\t\td[s] = 0;\n\t\t\twhile (qh != qt) {\n\t\t\t\tint v = q[qh++];\n\t\t\t\tid[v] = 2;\n\t\t\t\tif (qh == n)  qh = 0;\n\t\t\t\tfor (size_t i = 0; i < g_mcmf[v].size(); ++i) {\n\t\t\t\t\trib& r = g_mcmf[v][i];\n\t\t\t\t\tif (r.f < r.u && d[v] + r.c < d[r.b]) {\n\t\t\t\t\t\td[r.b] = d[v] + r.c;\n\t\t\t\t\t\tif (id[r.b] == 0) {\n\t\t\t\t\t\t\tq[qt++] = r.b;\n\t\t\t\t\t\t\tif (qt == n)  qt = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (id[r.b] == 2) {\n\t\t\t\t\t\t\tif (--qh == -1)  qh = n - 1;\n\t\t\t\t\t\t\tq[qh] = r.b;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tid[r.b] = 1;\n\t\t\t\t\t\tp[r.b] = v;\n\t\t\t\t\t\tp_rib[r.b] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d[t] == INF)  break;\n\t\t\tint addflow = maxflow - flow;\n\t\t\tfor (int v = t; v != s; v = p[v]) {\n\t\t\t\tint pv = p[v];  size_t pr = p_rib[v];\n\t\t\t\taddflow = min(addflow, g_mcmf[pv][pr].u - g_mcmf[pv][pr].f);\n\t\t\t}\n\t\t\tfor (int v = t; v != s; v = p[v]) {\n\t\t\t\tint pv = p[v];  size_t pr = p_rib[v], r = g_mcmf[pv][pr].back;\n\t\t\t\tg_mcmf[pv][pr].f += addflow;\n\t\t\t\tg_mcmf[v][r].f -= addflow;\n\t\t\t\tcost += g_mcmf[pv][pr].c * addflow;\n\t\t\t}\n\t\t\tflow += addflow;\n\t\t}\n\t\treturn { flow, cost };\n\t}\n};\n\nvoid solve() {\n\t\n\tfor (int i =0 ; i < N; i++)\n\t{\n\t\tg[i] = {};\n\t\tgr[i] = {};\n\t\tgcmp[i] = {};\n\t}\n\tmemset(a, 0, sizeof a);\n\tmemset(acmp, 0, sizeof acmp);\n\tmemset(used, 0, sizeof used);\n\tmemset(color, 0, sizeof color);\n\tcur_color = 0;\n\torder = {};\n\tcmp = {};\n\t\n\tint n, m; cin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tg[i].clear();\n\t\tgr[i].clear();\n\t}\n\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v; cin >> u >> v; u--, v--;\n\t\tg[u].push_back(v);\n\t\tgr[v].push_back(u);\n\t}\n\n\torder.clear();\n\tmemset(used, 0, sizeof(used[0]) * n);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i] == 0) {\n\t\t\tused[i] = 1;\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\n\tmemset(used, 0, sizeof(used[0]) * n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint u = order[n - i - 1];\n\t\tif (used[u] == 0) {\n\t\t\tused[u] = 1;\n\t\t\tdfs2(u);\n\t\t\tcur_color++;\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) cout << color[i] << \" \"; cout << endl;\n\n\tmemset(acmp, 0, sizeof(acmp[0]) * cur_color);\n\tfor (int i = 0; i < n; i++) {\n\t\tacmp[color[i]] += a[i];\n\t\tfor (int v : g[i]) {\n\t\t\tif (color[i] != color[v]) {\n\t\t\t\tgcmp[color[i]].push_back(color[v]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < cur_color; i++) {\n\t\tauto& e = gcmp[i];\n\t\tsort(e.begin(), e.end());\n\t\te.erase(unique(e.begin(), e.end()), e.end());\n\n\t\t// cout << i << \" \" << acmp[i] << \": \";\n\t\t// for (int v : e) cout << v << \" \"; cout << endl;\n\t}\n\n\tint s = 3 * cur_color, t = s + 1, so = t + 1, to = so + 1;\n\tMCMF gg(to + 1);\n\n\tfor (int i = 0; i < cur_color; i++) {\n\t\tauto [uin, uout, ucnt] = getInd(i);\n\t\tgg.add_rib(s, ucnt, acmp[i], 0);\n\t\tgg.add_rib(ucnt, uin, 1, 1);\n\t\tgg.add_rib(ucnt, uout, INF, 0);\n\n\t\tgg.add_rib(uin, uout, INF, 0);\n\t\tgg.add_rib(uout, t, INF, 0);\n\n\t\tgg.add_rib(so, uout, 1, 0);\n\t\tgg.add_rib(uin, to, 1, 0);\n\t}\n\n\tgg.add_rib(t, s, INF, 0);\n\n\tfor (int i = 0; i < cur_color; i++) {\n\t\tauto [uin, uout, ucnt] = getInd(i);\n\t\tfor (int v : gcmp[i]) {\n\t\t\tauto [vin, vout, vcnt] = getInd(v);\n\t\t\tgg.add_rib(uout, vin, INF, 0);\n\t\t}\n\t}\n\n\tauto [flow, cost] = gg.get_flow(so, to);\n\t// cout << flow << \" \" << cost << endl;\n\n\tif (flow < cur_color) {\n\t\tcout << -1 << endl;\n\t\treturn;\n\t}\n\n\tcout << cost << endl;\n}\n\nsigned main() {\n\t// freopen(\"input.txt\", \"r\", stdin);\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\n\tint q; cin >> q; while (q--)\n\tsolve();\n}\nDiv1E1+E2For convenience, we will call groups that include certain cities.The key condition is that each specialization can correspond to no more than one task. Thus, cities from different groups must have \"practically sorted\" strength values as the group order increases.Let [\ud835\udc59\ud835\udc56,\ud835\udc5f\ud835\udc56][li,ri] denote the segment that includes all the strengths of the cities in group \ud835\udc56i, where \ud835\udc5f\ud835\udc56ri is the maximum strength of a city from this group, and \ud835\udc59\ud835\udc56li is the minimum. If \ud835\udc59\ud835\udc56\u2264\ud835\udc5f\ud835\udc56+2li\u2264ri+2, it is impossible to build a contest, as there must be at least a difference of 2 tasks between the cities corresponding to \ud835\udc59\ud835\udc56li and \ud835\udc5f\ud835\udc56+2ri+2, but they can differ by at most 1 task in specialization. After this, the problem reduces to considering two neighboring groups and subsequently checking the task difficulties for compliance with the linear conditions of each group.Let's consider two cases:  If \ud835\udc59\ud835\udc56\u2265\ud835\udc5f\ud835\udc56+1li\u2265ri+1, it is sufficient to add a few tasks (specifically, just 2) of difficulty from the segment [\ud835\udc5f\ud835\udc56+1+1,\ud835\udc59\ud835\udc56][ri+1+1,li] to maintain order. Otherwise, each city in the \ud835\udc56i-th group that lies in the intersection must solve a task with its specialization. In this case, no task can be in the segment [\ud835\udc59\ud835\udc56+1,\ud835\udc5f\ud835\udc56+1][li+1,ri+1], as the city with the highest strength in group \ud835\udc56+1i+1 will solve at least as many tasks as the weakest city in group \ud835\udc56i, which we cannot allow. To maintain order with the other groups, it is sufficient to add 2 tasks of difficulty \ud835\udc5f\ud835\udc56+1+1ri+1+1 (unlike the first case, due to the fact that \ud835\udc59\ud835\udc56\u2264\ud835\udc5f\ud835\udc56+2li\u2264ri+2 cannot occur, we can immediately determine the appropriate task difficulty, but they can be arranged using the same algorithm as for the first case). It can be noted that when adding pairs of tasks, they need to choose an unused specification (since we are not using it in principle, but otherwise it may cause collisions).We conclude that we need to arrange tasks with a specified specification that a city from the intersection of groups can solve, meaning its difficulty must not exceed the wisdom of that city, and also arrange 2 tasks of certain difficulties to maintain order between groups. These difficulties arise from possible intersections with other groups when using \ud835\udc5f\ud835\udc56+1+1ri+1+1 as the task difficulty and possible specification collisions of cities, which may allow a city from a weaker group to solve a task that we did not intend for it, thus violating the strictness conditions between groups.Most problems cannot arise when \ud835\udc5a=2m=2, so what has been said above is already a solution (without minor adjustments) to the simple version of the problem.First, we will solve how to choose the difficulty for tasks with a specific specification. To do this, we will prohibit using the task specification corresponding to cities that form the second case (i.e., from the \ud835\udc56+1i+1-th group) with difficulty [\ud835\udc59\ud835\udc56,\ud835\udc4f\ud835\udc57][li,bj], where j is the number of such a city. Also, as mentioned, we cannot have a task from the segment [\ud835\udc59\ud835\udc56+1,\ud835\udc5f\ud835\udc56+1][li+1,ri+1] regardless of the type. To determine the difficulty, it is sufficient to set it to the maximum possible (equal to wisdom) and then gradually decrease it until we reach an allowed difficulty.To resolve the problem from the first case, we will place barriers with 2 tasks of difficulty equal to the strength of a certain city wherever possible.If there exists an answer for the given configuration, we will guarantee to construct it this way, using no more than 3\u22c5\ud835\udc5b3\u22c5n tasks. After all calculations, we need to check whether the contest we constructed meets the problem's conditions and output -1 otherwise. Code/**\n *    author:  tourist\n *    created: 01.12.2024 18:36:51\n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n), b(n), c(n);\n    set<int> s;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i] >> b[i] >> c[i];\n      s.insert(c[i]);\n    }\n    vector<vector<int>> vs(m);\n    for (int i = 0; i < m; i++) {\n      int foo;\n      cin >> foo;\n      vs[i].resize(foo);\n      for (int j = 0; j < foo; j++) {\n        cin >> vs[i][j];\n        --vs[i][j];\n      }\n    }\n    const int inf = int(1.01e9);\n    vector<int> min_a(m, in..."
}