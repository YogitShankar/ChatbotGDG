{
    "url": "https://codeforces.com/problemset/problem/2029/G",
    "title": "G. Balanced Problem",
    "tags": [
        "data structures",
        "dp",
        "*3000"
    ],
    "content": "G. Balanced Problemtime limit per test3 secondsmemory limit per test1024 megabytesinputstandard inputoutputstandard outputThere is an array \ud835\udc4ea consisting of \ud835\udc5bn integers. Initially, all elements of \ud835\udc4ea are equal to 00.Kevin can perform several operations on the array. Each operation is one of the following two types: Prefix addition\u00a0\u2014 Kevin first selects an index \ud835\udc65x (1\u2264\ud835\udc65\u2264\ud835\udc5b1\u2264x\u2264n), and then for each 1\u2264\ud835\udc57\u2264\ud835\udc651\u2264j\u2264x, increases \ud835\udc4e\ud835\udc57aj by 11;  Suffix addition\u00a0\u2014 Kevin first selects an index \ud835\udc65x (1\u2264\ud835\udc65\u2264\ud835\udc5b1\u2264x\u2264n), and then for each \ud835\udc65\u2264\ud835\udc57\u2264\ud835\udc5bx\u2264j\u2264n, increases \ud835\udc4e\ud835\udc57aj by 11.In the country of KDOI, people think that the integer \ud835\udc63v is balanced. Thus, Iris gives Kevin an array \ud835\udc50c consisting of \ud835\udc5bn integers and defines the beauty of the array \ud835\udc4ea as follows: Initially, set \ud835\udc4f=0b=0;  For each 1\u2264\ud835\udc56\u2264\ud835\udc5b1\u2264i\u2264n, if \ud835\udc4e\ud835\udc56=\ud835\udc63ai=v, add \ud835\udc50\ud835\udc56ci to \ud835\udc4fb;  The beauty of \ud835\udc4ea is the final value of \ud835\udc4fb.Kevin wants to maximize the beauty of \ud835\udc4ea after all the operations. However, he had already performed \ud835\udc5am operations when he was sleepy. Now, he can perform an arbitrary number (possibly zero) of new operations.You have to help Kevin find the maximum possible beauty if he optimally performs the new operations.However, to make sure that you are not just rolling the dice, Kevin gives you an integer \ud835\udc49V, and you need to solve the problem for each 1\u2264\ud835\udc63\u2264\ud835\udc491\u2264v\u2264V.InputEach test contains multiple test cases. The first line of the input contains a single integer \ud835\udc61t (1\u2264\ud835\udc61\u226410001\u2264t\u22641000)\u00a0\u2014 the number of test cases. The description of test cases follows.The first line of each test case contains three integers \ud835\udc5bn, \ud835\udc5am, and \ud835\udc49V (1\u2264\ud835\udc5b,\ud835\udc5a\u22642\u22c51051\u2264n,m\u22642\u22c5105, 1\u2264\ud835\udc49\u226420001\u2264V\u22642000)\u00a0\u2014 the length of the array \ud835\udc4ea, the number of initial operations, and the number that Kevin gives you.The second line contains \ud835\udc5bn integers \ud835\udc501,\ud835\udc502,\u2026,\ud835\udc50\ud835\udc5bc1,c2,\u2026,cn (1\u2264\ud835\udc50\ud835\udc56\u22641091\u2264ci\u2264109)\u00a0\u2014 the elements in the array \ud835\udc50c.Then \ud835\udc5am lines follow, the \ud835\udc56i-th line containing a character \ud835\udc5c\ud835\udc5dop and an integer \ud835\udc65x (\ud835\udc5c\ud835\udc5d=\ud835\ude7bop=L or \ud835\ude81R, 1\u2264\ud835\udc65\u2264\ud835\udc5b1\u2264x\u2264n)\u00a0\u2014 the type of the \ud835\udc56i-th operation and the selected index.  If \ud835\udc5c\ud835\udc5d=\ud835\ude7bop=L, this operation is a prefix addition on index \ud835\udc65x;  If \ud835\udc5c\ud835\udc5d=\ud835\ude81op=R, this operation is a suffix addition on index \ud835\udc65x. It is guaranteed that:  the sum of \ud835\udc5bn over all test cases does not exceed 2\u22c51052\u22c5105;  the sum of \ud835\udc5am over all test cases does not exceed 2\u22c51052\u22c5105;  the sum of \ud835\udc492V2 over all test cases does not exceed 4\u22c51064\u22c5106. OutputFor each test case, output \ud835\udc49V integers in a single line, the \ud835\udc56i-th integer denoting the maximum possible beauty after Kevin performs some new operations when \ud835\udc63=\ud835\udc56v=i.ExampleInputCopy53 3 21 2 4L 3R 3L 13 3 25 1 4L 3R 3L 15 4 51 1 1 1 1L 3R 2L 5L 410 12 910 9 8 7 6 5 4 3 2 1L 2L 4R 4R 4L 6R 8L 3L 2R 1R 10L 8L 11 1 41000000000L 1OutputCopy2 6\n1 9\n0 1 3 5 5\n0 0 0 6 25 32 35 44 51\n1000000000 1000000000 1000000000 1000000000\nNoteIn the first test case, the array \ud835\udc4ea changes as follows for the initial operations: [0,0,0]\u2212\u2192\u2212\ud835\ude7b\u00a03[1,1,1]\u2212\u2192\u2212\ud835\ude81\u00a03[1,1,2]\u2212\u2192\u2212\ud835\ude7b\u00a01[2,1,2][0,0,0]\u2192L\u00a03[1,1,1]\u2192R\u00a03[1,1,2]\u2192L\u00a01[2,1,2].  For \ud835\udc63=1v=1, it is optimal to not perform any new operations, and the beauty is \ud835\udc4f=\ud835\udc502=2b=c2=2;  For \ud835\udc63=2v=2, it is optimal to perform a prefix addition operation on index 22. After that, \ud835\udc4ea becomes [3,2,2][3,2,2], and the beauty is \ud835\udc4f=\ud835\udc502+\ud835\udc503=6b=c2+c3=6. In the second test case, for both \ud835\udc63=1v=1 and \ud835\udc63=2v=2, it is optimal to not perform any new operations...."
}